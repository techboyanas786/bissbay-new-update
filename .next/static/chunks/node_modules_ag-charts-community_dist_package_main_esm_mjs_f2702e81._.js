(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/ag-charts-community/dist/package/main.esm.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AG_CHARTS_LOCALE_EN_US",
    ()=>AG_CHARTS_LOCALE_EN_US,
    "AgCharts",
    ()=>AgCharts,
    "AgChartsCommunityModule",
    ()=>AgChartsCommunityModule,
    "AgErrorBarSupportedSeriesTypes",
    ()=>AgErrorBarSupportedSeriesTypes,
    "AgTooltipAnchorToType",
    ()=>AgTooltipAnchorToType,
    "AgTooltipPlacementType",
    ()=>AgTooltipPlacementType,
    "VERSION",
    ()=>VERSION,
    "_ModuleSupport",
    ()=>module_support_exports,
    "_Scene",
    ()=>integrated_charts_scene_exports,
    "_Theme",
    ()=>integrated_charts_theme_exports,
    "_Util",
    ()=>integrated_charts_util_exports,
    "_Widget",
    ()=>exports_exports,
    "setupCommunityModules",
    ()=>registerInbuiltModules,
    "time",
    ()=>time2
]);
// packages/ag-charts-community/src/api/agCharts.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ag-charts-core/dist/package/main.esm.mjs [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __decorateClass = (decorators, target, key, kind)=>{
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for(var i = decorators.length - 1, decorator; i >= 0; i--)if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result) __defProp(target, key, result);
    return result;
};
;
;
;
var BaseModuleInstance = class {
    destroy() {
        this.cleanup.flush();
    }
    constructor(){
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
    }
};
var ModuleRegistry = class {
    register() {
        for(var _len = arguments.length, modules = new Array(_len), _key = 0; _key < _len; _key++){
            modules[_key] = arguments[_key];
        }
        for (const module of modules){
            this.registerDependencies(module);
            const otherModule = this.modules.find((other)=>module.type === other.type && ("optionsKey" in module && "optionsKey" in other ? module.optionsKey === other.optionsKey : true) && module.identifier === other.identifier);
            if (otherModule) {
                if (module.packageType === "enterprise" && otherModule.packageType === "community") {
                    const index = this.modules.indexOf(otherModule);
                    this.modules.splice(index, 1, module);
                    if ("optionsKey" in module) {
                        this.modulesByOptionKey.set(module.optionsKey, module);
                    }
                }
            } else {
                this.modules.push(module);
                if ("optionsKey" in module) {
                    this.modulesByOptionKey.set(module.optionsKey, module);
                }
            }
        }
    }
    hasEnterpriseModules() {
        return this.modules.some((m)=>m.packageType === "enterprise");
    }
    *byType() {
        for(var _len = arguments.length, types = new Array(_len), _key = 0; _key < _len; _key++){
            types[_key] = arguments[_key];
        }
        const yielded = /* @__PURE__ */ new Set();
        const modulesByType = this.modules.filter((module)=>types.includes(module.type));
        const calculateDependencies = (module)=>{
            const deps = this.dependencies.get(module);
            var _deps_flatMap_concat;
            return (_deps_flatMap_concat = deps === null || deps === void 0 ? void 0 : deps.flatMap(calculateDependencies).concat(deps)) !== null && _deps_flatMap_concat !== void 0 ? _deps_flatMap_concat : [];
        };
        const unresolvable = [];
        for (const module of modulesByType){
            const uniqueKey = "optionsKey" in module ? module.optionsKey : module.contextKey;
            if (yielded.has(uniqueKey)) continue;
            for (const dependency of calculateDependencies(uniqueKey)){
                if (yielded.has(dependency)) continue;
                const dependencyModule = this.modulesByOptionKey.get(dependency);
                if (!dependencyModule) {
                    unresolvable.push(dependency);
                    continue;
                }
                if (!types.includes(dependencyModule.type)) continue;
                yield dependencyModule;
                yielded.add(dependency);
            }
            yield module;
            yielded.add(uniqueKey);
        }
        if (unresolvable.length > 0) {
            throw new Error("Could not resolve module dependencies: ".concat(unresolvable));
        }
    }
    registerDependencies(module) {
        if (module.dependencies == null || module.dependencies.length === 0) return;
        const uniqueKey = "optionsKey" in module ? module.optionsKey : module.contextKey;
        this.dependencies.set(uniqueKey, module.dependencies);
    }
    constructor(){
        this.modules = [];
        this.dependencies = /* @__PURE__ */ new Map();
        this.modulesByOptionKey = /* @__PURE__ */ new Map();
    }
};
var moduleRegistry = new ModuleRegistry();
;
// packages/ag-charts-community/src/util/interpolating.ts
var interpolate = Symbol("interpolate");
var isInterpolating = (x)=>x[interpolate] != null;
// packages/ag-charts-community/src/util/nearest.ts
function nearestSquared(x, y, objects) {
    let maxDistanceSquared = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Infinity;
    const result = {
        nearest: void 0,
        distanceSquared: maxDistanceSquared
    };
    for (const obj of objects){
        const thisDistance = obj.distanceSquared(x, y);
        if (thisDistance === 0) {
            return {
                nearest: obj,
                distanceSquared: 0
            };
        } else if (thisDistance < result.distanceSquared) {
            result.nearest = obj;
            result.distanceSquared = thisDistance;
        }
    }
    return result;
}
function nearestSquaredInContainer(x, y, container) {
    let maxDistanceSquared = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Infinity;
    var _container_transformPoint;
    var _container_transformPoint1;
    const { x: tx = x, y: ty = y } = (_container_transformPoint1 = (_container_transformPoint = container.transformPoint) === null || _container_transformPoint === void 0 ? void 0 : _container_transformPoint.call(container, x, y)) !== null && _container_transformPoint1 !== void 0 ? _container_transformPoint1 : {};
    const result = {
        nearest: void 0,
        distanceSquared: maxDistanceSquared
    };
    for (const child of container.children){
        const { nearest, distanceSquared: distanceSquared2 } = child.nearestSquared(tx, ty, result.distanceSquared);
        if (distanceSquared2 === 0) {
            return {
                nearest,
                distanceSquared: distanceSquared2
            };
        } else if (distanceSquared2 < result.distanceSquared) {
            result.nearest = nearest;
            result.distanceSquared = distanceSquared2;
        }
    }
    return result;
}
// packages/ag-charts-community/src/scene/bbox.ts
var _BBox = class _BBox {
    static fromDOMRect(param) {
        let { x, y, width: width2, height: height2 } = param;
        return new _BBox(x, y, width2, height2);
    }
    static merge(boxes) {
        let left = Infinity;
        let top = Infinity;
        let right = -Infinity;
        let bottom = -Infinity;
        for (const box of boxes){
            if (box.x < left) {
                left = box.x;
            }
            if (box.y < top) {
                top = box.y;
            }
            if (box.x + box.width > right) {
                right = box.x + box.width;
            }
            if (box.y + box.height > bottom) {
                bottom = box.y + box.height;
            }
        }
        return new _BBox(left, top, right - left, bottom - top);
    }
    static nearestBox(x, y, boxes) {
        return nearestSquared(x, y, boxes);
    }
    toDOMRect() {
        return {
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            top: this.y,
            left: this.x,
            right: this.x + this.width,
            bottom: this.y + this.height,
            toJSON () {
                return {};
            }
        };
    }
    clone() {
        const { x, y, width: width2, height: height2 } = this;
        return new _BBox(x, y, width2, height2);
    }
    equals(other) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boxesEqual"])(this, other);
    }
    containsPoint(x, y) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boxContains"])(this, x, y);
    }
    intersection(other) {
        if (!this.collidesBBox(other)) return;
        const newX1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(other.x, this.x, other.x + other.width);
        const newY1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(other.y, this.y, other.y + other.height);
        const newX2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(other.x, this.x + this.width, other.x + other.width);
        const newY2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(other.y, this.y + this.height, other.y + other.height);
        return new _BBox(newX1, newY1, newX2 - newX1, newY2 - newY1);
    }
    collidesBBox(other) {
        return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;
    }
    computeCenter() {
        return {
            x: this.x + this.width / 2,
            y: this.y + this.height / 2
        };
    }
    isFinite() {
        return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);
    }
    distanceSquared(x, y) {
        if (this.containsPoint(x, y)) {
            return 0;
        }
        const dx = x - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(this.x, x, this.x + this.width);
        const dy = y - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(this.y, y, this.y + this.height);
        return dx * dx + dy * dy;
    }
    shrink(amount, position) {
        if (typeof amount === "number") {
            this.applyMargin(amount, position);
        } else {
            for (const key of Object.keys(amount)){
                const value = amount[key];
                if (typeof value === "number") {
                    this.applyMargin(value, key);
                }
            }
        }
        if (this.width < 0) {
            this.width = 0;
        }
        if (this.height < 0) {
            this.height = 0;
        }
        return this;
    }
    grow(amount, position) {
        if (typeof amount === "number") {
            this.applyMargin(-amount, position);
        } else {
            for (const key of Object.keys(amount)){
                const value = amount[key];
                if (typeof value === "number") {
                    this.applyMargin(-value, key);
                }
            }
        }
        return this;
    }
    applyMargin(value, position) {
        switch(position){
            case "top":
                this.y += value;
            case "bottom":
                this.height -= value;
                break;
            case "left":
                this.x += value;
            case "right":
                this.width -= value;
                break;
            case "vertical":
                this.y += value;
                this.height -= value * 2;
                break;
            case "horizontal":
                this.x += value;
                this.width -= value * 2;
                break;
            case void 0:
                this.x += value;
                this.y += value;
                this.width -= value * 2;
                this.height -= value * 2;
                break;
        }
    }
    translate(x, y) {
        this.x += x;
        this.y += y;
        return this;
    }
    [interpolate](other, d) {
        return new _BBox(this.x * (1 - d) + other.x * d, this.y * (1 - d) + other.y * d, this.width * (1 - d) + other.width * d, this.height * (1 - d) + other.height * d);
    }
    constructor(x, y, width2, height2){
        this.x = x;
        this.y = y;
        this.width = width2;
        this.height = height2;
    }
};
_BBox.zero = Object.freeze(new _BBox(0, 0, 0, 0));
_BBox.NaN = Object.freeze(new _BBox(NaN, NaN, NaN, NaN));
var BBox = _BBox;
;
;
var LONG_TIME_PERIOD_THRESHOLD = 2e3;
var timeOfLastLog = Date.now();
var logTimeGap = ()=>{
    const timeSinceLastLog = Date.now() - timeOfLastLog;
    if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {
        const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].log("**** ".concat(prettyDuration, "s since last log message ****"));
    }
    timeOfLastLog = Date.now();
};
var Debug = {
    create () {
        for(var _len = arguments.length, debugSelectors = new Array(_len), _key = 0; _key < _len; _key++){
            debugSelectors[_key] = arguments[_key];
        }
        const resultFn = function() {
            for(var _len = arguments.length, logContent = new Array(_len), _key = 0; _key < _len; _key++){
                logContent[_key] = arguments[_key];
            }
            if (Debug.check(...debugSelectors)) {
                if (typeof logContent[0] === "function") {
                    logContent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])(logContent[0]());
                }
                logTimeGap();
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].log(...logContent);
            }
        };
        return Object.assign(resultFn, {
            check: ()=>Debug.check(...debugSelectors),
            group: (name, cb)=>{
                if (Debug.check(...debugSelectors)) {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].logGroup(name, cb);
                }
                return cb();
            }
        });
    },
    check () {
        for(var _len = arguments.length, debugSelectors = new Array(_len), _key = 0; _key < _len; _key++){
            debugSelectors[_key] = arguments[_key];
        }
        if (debugSelectors.length === 0) {
            debugSelectors.push(true);
        }
        const chartDebug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])("agChartsDebug"));
        return chartDebug.some((selector)=>debugSelectors.includes(selector));
    },
    inDevelopmentMode (fn) {
        if (Debug.check("dev")) {
            return fn();
        }
    }
};
// packages/ag-charts-community/src/scene/canvas/canvasUtil.ts
function clearContext(param) {
    let { context, pixelRatio, width: width2, height: height2 } = param;
    context.save();
    try {
        context.resetTransform();
        context.clearRect(0, 0, Math.ceil(width2 * pixelRatio), Math.ceil(height2 * pixelRatio));
    } finally{
        context.restore();
    }
}
function debugContext(ctx) {
    if (Debug.check("canvas")) {
        const save = ctx.save.bind(ctx);
        const restore = ctx.restore.bind(ctx);
        let depth = 0;
        Object.assign(ctx, {
            save () {
                save();
                depth++;
            },
            restore () {
                if (depth === 0) {
                    throw new Error("AG Charts - Unable to restore() past depth 0");
                }
                restore();
                depth--;
            },
            verifyDepthZero () {
                if (depth !== 0) {
                    throw new Error("AG Charts - Save/restore depth is non-zero: ".concat(depth));
                }
            }
        });
    }
}
// packages/ag-charts-community/src/scene/canvas/hdpiOffscreenCanvas.ts
function canvasDimensions(width2, height2, pixelRatio) {
    return [
        Math.floor(width2 * pixelRatio),
        Math.floor(height2 * pixelRatio)
    ];
}
var HdpiOffscreenCanvas = class {
    drawImage(context) {
        let dx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, dy = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        return context.drawImage(this.canvas, dx, dy);
    }
    transferToImageBitmap() {
        return this.canvas.transferToImageBitmap();
    }
    resize(width2, height2, pixelRatio) {
        if (!(width2 > 0 && height2 > 0)) return;
        const { canvas, context } = this;
        if (width2 !== this.width || height2 !== this.height || pixelRatio !== this.pixelRatio) {
            const [canvasWidth, canvasHeight] = canvasDimensions(width2, height2, pixelRatio);
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }
        context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        this.width = width2;
        this.height = height2;
        this.pixelRatio = pixelRatio;
    }
    clear() {
        clearContext(this);
    }
    destroy() {
        this.canvas.width = 0;
        this.canvas.height = 0;
        this.context.clearRect(0, 0, 0, 0);
        this.canvas = null;
        this.context = null;
        Object.freeze(this);
    }
    constructor(options){
        const { width: width2, height: height2, pixelRatio, willReadFrequently = false } = options;
        this.width = width2;
        this.height = height2;
        this.pixelRatio = pixelRatio;
        const [canvasWidth, canvasHeight] = canvasDimensions(width2, height2, pixelRatio);
        this.canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
        this.context = this.canvas.getContext("2d", {
            willReadFrequently
        });
        this.context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        debugContext(this.context);
    }
};
;
;
// packages/ag-charts-community/src/util/decorator.ts
var BREAK_TRANSFORM_CHAIN = Symbol("BREAK");
var CONFIG_KEY = "__decorator_config";
var ACCESSORS_KEY = "__decorator_accessors";
function addFakeTransformToInstanceProperty(target, propertyKeyOrSymbol) {
    initialiseConfig(target, propertyKeyOrSymbol).optional = true;
}
function initialiseConfig(target, propertyKeyOrSymbol) {
    if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {
        Object.defineProperty(target, CONFIG_KEY, {
            value: {}
        });
    }
    if (Object.getOwnPropertyDescriptor(target, ACCESSORS_KEY) == null) {
        var _Object_getPrototypeOf;
        const parentAccessors = (_Object_getPrototypeOf = Object.getPrototypeOf(target)) === null || _Object_getPrototypeOf === void 0 ? void 0 : _Object_getPrototypeOf[ACCESSORS_KEY];
        var _parentAccessors_slice;
        const accessors = (_parentAccessors_slice = parentAccessors === null || parentAccessors === void 0 ? void 0 : parentAccessors.slice()) !== null && _parentAccessors_slice !== void 0 ? _parentAccessors_slice : [];
        Object.defineProperty(target, ACCESSORS_KEY, {
            value: accessors
        });
    }
    const config = target[CONFIG_KEY];
    const propertyKey = propertyKeyOrSymbol.toString();
    if (config[propertyKey] != null) {
        return config[propertyKey];
    }
    config[propertyKey] = {
        setters: [],
        getters: [],
        observers: []
    };
    const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);
    let prevGet = descriptor === null || descriptor === void 0 ? void 0 : descriptor.get;
    let prevSet = descriptor === null || descriptor === void 0 ? void 0 : descriptor.set;
    if (prevGet == null || prevSet == null) {
        const accessors = target[ACCESSORS_KEY];
        let index = accessors.indexOf(propertyKeyOrSymbol);
        if (index === -1) {
            index = accessors.push(propertyKeyOrSymbol) - 1;
        }
        prevGet !== null && prevGet !== void 0 ? prevGet : prevGet = function() {
            let accessorValues = this.__accessors;
            if (accessorValues == null) {
                accessorValues = accessors.slice().fill(void 0);
                Object.defineProperty(this, "__accessors", {
                    value: accessorValues
                });
            }
            return accessorValues[index];
        };
        prevSet !== null && prevSet !== void 0 ? prevSet : prevSet = function(value) {
            let accessorValues = this.__accessors;
            if (accessorValues == null) {
                accessorValues = accessors.slice().fill(void 0);
                Object.defineProperty(this, "__accessors", {
                    value: accessorValues
                });
            }
            accessorValues[index] = value;
        };
    }
    const getter = function() {
        let value = prevGet.call(this);
        for (const transformFn of config[propertyKey].getters){
            value = transformFn(this, propertyKeyOrSymbol, value);
            if (value === BREAK_TRANSFORM_CHAIN) {
                return;
            }
        }
        return value;
    };
    const setter = function(value) {
        const { setters, observers } = config[propertyKey];
        let oldValue;
        if (setters.some((f)=>f.length > 2)) {
            oldValue = prevGet.call(this);
        }
        for (const transformFn of setters){
            value = transformFn(this, propertyKeyOrSymbol, value, oldValue);
            if (value === BREAK_TRANSFORM_CHAIN) {
                return;
            }
        }
        prevSet.call(this, value);
        for (const observerFn of observers){
            observerFn(this, value, oldValue);
        }
    };
    Object.defineProperty(target, propertyKeyOrSymbol, {
        set: setter,
        get: getter,
        enumerable: true,
        configurable: false
    });
    return config[propertyKey];
}
function addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {
    return (target, propertyKeyOrSymbol)=>{
        const config = initialiseConfig(target, propertyKeyOrSymbol);
        config.setters.push(setTransform);
        if (getTransform) {
            config.getters.unshift(getTransform);
        }
        if (configMetadata) {
            Object.assign(config, configMetadata);
        }
    };
}
function addObserverToInstanceProperty(setObserver) {
    return (target, propertyKeyOrSymbol)=>{
        initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);
    };
}
function isDecoratedObject(target) {
    return typeof target !== "undefined" && CONFIG_KEY in target;
}
function listDecoratedProperties(target) {
    const targets = /* @__PURE__ */ new Set();
    while(isDecoratedObject(target)){
        targets.add(target === null || target === void 0 ? void 0 : target[CONFIG_KEY]);
        target = Object.getPrototypeOf(target);
    }
    return Array.from(targets).flatMap((configMap)=>Object.keys(configMap));
}
function extractDecoratedProperties(target) {
    return listDecoratedProperties(target).reduce((result, key)=>{
        var _target_key;
        result[String(key)] = (_target_key = target[key]) !== null && _target_key !== void 0 ? _target_key : null;
        return result;
    }, {});
}
// packages/ag-charts-community/src/util/object.ts
function objectsEqual(a, b) {
    if (Array.isArray(a)) {
        if (!Array.isArray(b)) return false;
        if (a.length !== b.length) return false;
        return a.every((av, i)=>objectsEqual(av, b[i]));
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(a)) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(b)) return false;
        return objectsEqualWith(a, b, objectsEqual);
    }
    return a === b;
}
function objectsEqualWith(a, b, cmp2) {
    if (Object.is(a, b)) return true;
    for (const key of Object.keys(b)){
        if (!(key in a)) return false;
    }
    for (const key of Object.keys(a)){
        if (!(key in b)) return false;
        if (!cmp2(a[key], b[key])) return false;
    }
    return true;
}
function mergeDefaults() {
    for(var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++){
        sources[_key] = arguments[_key];
    }
    const target = {};
    for (const source of sources){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(source)) continue;
        const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);
        for (const key of keys){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(target[key]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(source[key])) {
                target[key] = mergeDefaults(target[key], source[key]);
            } else {
                var _target_key;
                (_target_key = target[key]) !== null && _target_key !== void 0 ? _target_key : target[key] = source[key];
            }
        }
    }
    return target;
}
function merge() {
    for(var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++){
        sources[_key] = arguments[_key];
    }
    const target = {};
    for (const source of sources){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(source)) continue;
        const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);
        for (const key of keys){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(target[key]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(source[key])) {
                target[key] = merge(target[key], source[key]);
            } else if (!(key in target)) {
                var _target_key;
                (_target_key = target[key]) !== null && _target_key !== void 0 ? _target_key : target[key] = source[key];
            }
        }
    }
    return target;
}
function mergeArrayDefaults(dataArray) {
    for(var _len = arguments.length, itemDefaults = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        itemDefaults[_key - 1] = arguments[_key];
    }
    if (itemDefaults && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(dataArray)) {
        return dataArray.map((item)=>mergeDefaults(item, ...itemDefaults));
    }
    return dataArray;
}
function mapValues(object4, mapper) {
    const result = {};
    for (const [key, value] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entries"])(object4)){
        result[key] = mapper(value, key, object4);
    }
    return result;
}
function without(object4, keys) {
    const clone2 = {
        ...object4
    };
    for (const key of keys){
        delete clone2[key];
    }
    return clone2;
}
function pick(object4, keys) {
    if (object4 == null) return;
    const picked = {};
    for (const key of keys){
        if (Object.hasOwn(object4, key)) {
            picked[key] = object4[key];
        }
    }
    return picked;
}
function getPath(object4, path) {
    const pathArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(path) ? path : path.split(".");
    return pathArray.reduce((value, pathKey)=>value[pathKey], object4);
}
var SKIP_JS_BUILTINS = /* @__PURE__ */ new Set([
    "__proto__",
    "constructor",
    "prototype"
]);
function setPath(object4, path, newValue) {
    const pathArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(path) ? path.slice() : path.split(".");
    const lastKey = pathArray.pop();
    if (pathArray.some((p)=>SKIP_JS_BUILTINS.has(p))) return;
    const lastObject = pathArray.reduce((value, pathKey)=>value[pathKey], object4);
    lastObject[lastKey] = newValue;
    return lastObject[lastKey];
}
function partialAssign(keysToCopy, target, source) {
    if (source === void 0) {
        return target;
    }
    for (const key of keysToCopy){
        const value = source[key];
        if (value !== void 0) {
            target[key] = value;
        }
    }
    return target;
}
function deepFreeze(obj) {
    if (obj == null || typeof obj !== "object" || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(obj)) {
        return obj;
    }
    Object.freeze(obj);
    Object.getOwnPropertyNames(obj).forEach((prop)=>{
        const value = obj[prop];
        if (value !== null && (typeof value === "object" || typeof value === "function") && !Object.isFrozen(value)) {
            deepFreeze(value);
        }
    });
    return obj;
}
function isObjectWithProperty(obj, key) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(obj) && key in obj;
}
function isObjectWithStringProperty(obj, key) {
    return isObjectWithProperty(obj, key) && typeof obj[key] === "string";
}
;
var TRIPLE_EQ = (lhs, rhs)=>lhs === rhs;
function SceneChangeDetection(opts) {
    return function(target, key) {
        const privateKey = "__".concat(key);
        if (target[key]) return;
        prepareGetSet(target, key, privateKey, opts);
    };
}
function SceneRefChangeDetection(opts) {
    return SceneChangeDetection(opts);
}
function SceneObjectChangeDetection(opts) {
    return SceneChangeDetection(opts);
}
function SceneArrayChangeDetection(opts) {
    const baseOpts = opts !== null && opts !== void 0 ? opts : {};
    baseOpts.equals = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraysEqual"];
    return SceneChangeDetection(opts);
}
function prepareGetSet(target, key, privateKey, opts) {
    const { changeCb, convertor, checkDirtyOnAssignment = false } = opts !== null && opts !== void 0 ? opts : {};
    const requiredOpts = {
        changeCb,
        checkDirtyOnAssignment,
        convertor
    };
    const setter = buildCheckDirtyChain(privateKey, buildChangeCallbackChain(buildConvertorChain(buildSetter(privateKey, requiredOpts), requiredOpts), requiredOpts), requiredOpts);
    const getter = function() {
        return this[privateKey];
    };
    Object.defineProperty(target, key, {
        set: setter,
        get: getter,
        enumerable: true,
        configurable: true
    });
}
function buildConvertorChain(setterFn, opts) {
    const { convertor } = opts;
    if (convertor) {
        return function(value) {
            setterFn.call(this, convertor(value));
        };
    }
    return setterFn;
}
var NO_CHANGE = Symbol("no-change");
function buildChangeCallbackChain(setterFn, opts) {
    const { changeCb } = opts;
    if (changeCb) {
        return function(value) {
            const change = setterFn.call(this, value);
            if (change !== NO_CHANGE) {
                changeCb.call(this, this);
            }
            return change;
        };
    }
    return setterFn;
}
function buildCheckDirtyChain(privateKey, setterFn, opts) {
    const { checkDirtyOnAssignment } = opts;
    if (checkDirtyOnAssignment) {
        return function(value) {
            const change = setterFn.call(this, value);
            if ((value === null || value === void 0 ? void 0 : value._dirty) === true) {
                this.markDirty(privateKey);
            }
            return change;
        };
    }
    return setterFn;
}
function buildSetter(privateKey, opts) {
    const { equals = TRIPLE_EQ } = opts;
    return function(value) {
        const oldValue = this[privateKey];
        if (!equals(value, oldValue)) {
            this[privateKey] = value;
            this.onChangeDetection(privateKey);
            return value;
        }
        return NO_CHANGE;
    };
}
// packages/ag-charts-community/src/scene/zIndex.ts
var cmp = (a, b)=>Math.sign(a - b);
function compareZIndex(a, b) {
    if (typeof a === "number" && typeof b === "number") {
        return cmp(a, b);
    }
    const aArray = typeof a === "number" ? [
        a
    ] : a;
    const bArray = typeof b === "number" ? [
        b
    ] : b;
    const length2 = Math.min(aArray.length, bArray.length);
    for(let i = 0; i < length2; i += 1){
        const diff2 = cmp(aArray[i], bArray[i]);
        if (diff2 !== 0) return diff2;
    }
    return cmp(aArray.length, bArray.length);
}
// packages/ag-charts-community/src/scene/node.ts
var PointerEvents = /* @__PURE__ */ ((PointerEvents2)=>{
    PointerEvents2[PointerEvents2["All"] = 0] = "All";
    PointerEvents2[PointerEvents2["None"] = 1] = "None";
    return PointerEvents2;
})(PointerEvents || {});
var MAX_ERROR_COUNT = 5;
var _Node = class _Node {
    static toSVG(node, width2, height2) {
        var _svg_defs, _svg_defs1;
        const svg = node === null || node === void 0 ? void 0 : node.toSVG();
        if (svg == null || !svg.elements.length && !((_svg_defs = svg.defs) === null || _svg_defs === void 0 ? void 0 : _svg_defs.length)) return;
        const root = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("svg");
        root.setAttribute("width", String(width2));
        root.setAttribute("height", String(height2));
        root.setAttribute("viewBox", "0 0 ".concat(width2, " ").concat(height2));
        root.setAttribute("overflow", "visible");
        if ((_svg_defs1 = svg.defs) === null || _svg_defs1 === void 0 ? void 0 : _svg_defs1.length) {
            const defs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("defs");
            defs.append(...svg.defs);
            root.append(defs);
        }
        root.append(...svg.elements);
        return root.outerHTML;
    }
    static *extractBBoxes(nodes, skipInvisible) {
        for (const n of nodes){
            if (!skipInvisible || n.visible && !n.transitionOut) {
                const bbox = n.getBBox();
                if (bbox) yield bbox;
            }
        }
    }
    /**
   * Some arbitrary data bound to the node.
   */ get datum() {
        return this._datum;
    }
    set datum(datum) {
        if (this._datum !== datum) {
            this._previousDatum = this._datum;
            this._datum = datum;
        }
    }
    get previousDatum() {
        return this._previousDatum;
    }
    get layerManager() {
        var _this_scene;
        return (_this_scene = this.scene) === null || _this_scene === void 0 ? void 0 : _this_scene.layersManager;
    }
    get imageLoader() {
        var _this_scene;
        return (_this_scene = this.scene) === null || _this_scene === void 0 ? void 0 : _this_scene.imageLoader;
    }
    closestDatum() {
        for (const { datum } of this.traverseUp(true)){
            if (datum != null) {
                return datum;
            }
        }
    }
    /** Perform any pre-rendering initialization. */ preRender(_renderCtx) {
        let thisComplexity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        this.childNodeCounts.groups = 0;
        this.childNodeCounts.nonGroups = 1;
        this.childNodeCounts.complexity = thisComplexity;
        this.childNodeCounts.thisComplexity = thisComplexity;
        if (this.batchLevel > 0 || this.batchDirty) {
            throw new Error("AG Charts - illegal rendering state; batched update in progress");
        }
        return this.childNodeCounts;
    }
    /** Guaranteed isolated render - if there is any failure, the Cavans2D context is returned to its prior state. */ isolatedRender(renderCtx) {
        renderCtx.ctx.save();
        try {
            this.render(renderCtx);
        } catch (e) {
            var _e_errorCount;
            const errorCount = (_e_errorCount = e.errorCount) !== null && _e_errorCount !== void 0 ? _e_errorCount : 1;
            if (errorCount >= MAX_ERROR_COUNT) {
                e.errorCount = errorCount;
                throw e;
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Error during rendering", e, e.stack);
        } finally{
            renderCtx.ctx.restore();
        }
    }
    render(renderCtx) {
        const { stats } = renderCtx;
        this.debugDirtyProperties();
        if (renderCtx.debugNodeSearch) {
            var _this_name;
            const idOrName = (_this_name = this.name) !== null && _this_name !== void 0 ? _this_name : this.id;
            if (renderCtx.debugNodeSearch.some((v)=>typeof v === "string" ? v === idOrName : v.test(idOrName))) {
                var _this_name1;
                renderCtx.debugNodes[(_this_name1 = this.name) !== null && _this_name1 !== void 0 ? _this_name1 : this.id] = this;
            }
        }
        if (stats) {
            stats.nodesRendered++;
            stats.opsPerformed += this.childNodeCounts.thisComplexity;
        }
    }
    setScene(scene) {
        this.scene = scene;
    }
    *traverseUp(includeSelf) {
        let node = this;
        if (includeSelf) {
            yield node;
        }
        while(node = node.parentNode){
            yield node;
        }
    }
    /**
   * Checks if the node is the root (has no parent).
   */ isRoot() {
        return !this.parentNode;
    }
    removeChild(node) {
        var _node_name, _this_name;
        throw new Error("AG Charts - internal error, unknown child node ".concat((_node_name = node.name) !== null && _node_name !== void 0 ? _node_name : node.id, " in $").concat((_this_name = this.name) !== null && _this_name !== void 0 ? _this_name : this.id));
    }
    remove() {
        var _this_parentNode;
        (_this_parentNode = this.parentNode) === null || _this_parentNode === void 0 ? void 0 : _this_parentNode.removeChild(this);
    }
    destroy() {
        var _this_parentNode;
        (_this_parentNode = this.parentNode) === null || _this_parentNode === void 0 ? void 0 : _this_parentNode.removeChild(this);
    }
    batchedUpdate(fn) {
        this.batchLevel++;
        fn();
        this.batchLevel--;
        if (this.batchLevel === 0 && this.batchDirty) {
            this.markDirty();
            this.batchDirty = false;
        }
    }
    setProperties(styles) {
        this.batchLevel++;
        Object.assign(this, styles);
        this.batchLevel--;
        if (this.batchLevel === 0 && this.batchDirty) {
            this.markDirty();
            this.batchDirty = false;
        }
        return this;
    }
    containsPoint(_x, _y) {
        return false;
    }
    pickNode(x, y) {
        if (this.containsPoint(x, y)) {
            return this;
        }
    }
    pickNodes(x, y) {
        let into = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        if (this.containsPoint(x, y)) {
            into.push(this);
        }
        return into;
    }
    getBBox() {
        var _this_cachedBBox;
        (_this_cachedBBox = this.cachedBBox) !== null && _this_cachedBBox !== void 0 ? _this_cachedBBox : this.cachedBBox = Object.freeze(this.computeBBox());
        return this.cachedBBox;
    }
    computeBBox() {
        return;
    }
    onChangeDetection(property) {
        this.markDirty(property);
    }
    markDirtyChildrenOrder() {
        this.cachedBBox = void 0;
    }
    markDirty(property) {
        var _this_parentNode;
        if (this.batchLevel > 0) {
            this.batchDirty = true;
            return;
        }
        if (property != null && this._debugDirtyProperties) {
            this.markDebugProperties(property);
        }
        this.cachedBBox = void 0;
        (_this_parentNode = this.parentNode) === null || _this_parentNode === void 0 ? void 0 : _this_parentNode.markDirty();
    }
    markDebugProperties(property) {
        var _this__debugDirtyProperties, _stack, _this__debugDirtyProperties1;
        var _this__debugDirtyProperties_get;
        const sources = (_this__debugDirtyProperties_get = (_this__debugDirtyProperties = this._debugDirtyProperties) === null || _this__debugDirtyProperties === void 0 ? void 0 : _this__debugDirtyProperties.get(property)) !== null && _this__debugDirtyProperties_get !== void 0 ? _this__debugDirtyProperties_get : [];
        var _stack_split_filter;
        const caller = (_stack_split_filter = (_stack = new Error().stack) === null || _stack === void 0 ? void 0 : _stack.split("\n").filter((line)=>{
            return line !== "Error" && !line.includes(".markDebugProperties") && !line.includes(".markDirty") && !line.includes("Object.assign ") && !line.includes("".concat(this.constructor.name, "."));
        })) !== null && _stack_split_filter !== void 0 ? _stack_split_filter : "unknown";
        sources.push(caller[0].replace(" at ", "").trim());
        (_this__debugDirtyProperties1 = this._debugDirtyProperties) === null || _this__debugDirtyProperties1 === void 0 ? void 0 : _this__debugDirtyProperties1.set(property, sources);
    }
    debugDirtyProperties() {
        if (this._debugDirtyProperties == null) return;
        if (!this._debugDirtyProperties.has("__first__")) {
            this._debugDirtyProperties.forEach((sources, property)=>{
                if (sources.length > 1) {
                    console.groupCollapsed("Property changed multiple times before render: ".concat(this.constructor.name, ".").concat(property, " (").concat(sources.length, "x)"));
                    sources.forEach((source)=>console.log(source));
                    console.groupEnd();
                }
            });
        }
        this._debugDirtyProperties.clear();
    }
    onZIndexChange() {
        var _this_parentNode;
        (_this_parentNode = this.parentNode) === null || _this_parentNode === void 0 ? void 0 : _this_parentNode.markDirtyChildrenOrder();
    }
    toSVG() {
        return;
    }
    constructor(options){
        /** Unique number to allow creation order to be easily determined. */ this.serialNumber = _Node._nextSerialNumber++;
        this.childNodeCounts = {
            groups: 0,
            nonGroups: 0,
            thisComplexity: 0,
            complexity: 0
        };
        /** Unique node ID in the form `ClassName-NaturalNumber`. */ this.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createId"])(this);
        this.name = void 0;
        this.transitionOut = void 0;
        this.pointerEvents = 0 /* All */ ;
        this._datum = void 0;
        this._previousDatum = void 0;
        this.scene = void 0;
        this._debugDirtyProperties = void 0;
        this.parentNode = void 0;
        this.cachedBBox = void 0;
        /**
     * To simplify the type system (especially in Selections) we don't have the `Parent` node
     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.
     * But we still need to distinguish regular leaf nodes from container leafs somehow.
     */ this.isContainerNode = false;
        this.visible = true;
        this.zIndex = 0;
        this.batchLevel = 0;
        this.batchDirty = false;
        this.name = options === null || options === void 0 ? void 0 : options.name;
        var _options_tag;
        this.tag = (_options_tag = options === null || options === void 0 ? void 0 : options.tag) !== null && _options_tag !== void 0 ? _options_tag : NaN;
        var _options_zIndex;
        this.zIndex = (_options_zIndex = options === null || options === void 0 ? void 0 : options.zIndex) !== null && _options_zIndex !== void 0 ? _options_zIndex : 0;
        this.scene = options === null || options === void 0 ? void 0 : options.scene;
        var _options_debugDirty;
        if ((_options_debugDirty = options === null || options === void 0 ? void 0 : options.debugDirty) !== null && _options_debugDirty !== void 0 ? _options_debugDirty : _Node._debugEnabled) {
            this._debugDirtyProperties = /* @__PURE__ */ new Map([
                [
                    "__first__",
                    []
                ]
            ]);
        }
    }
};
_Node._nextSerialNumber = 0;
// eslint-disable-next-line sonarjs/public-static-readonly
_Node._debugEnabled = false;
__decorateClass([
    SceneChangeDetection()
], _Node.prototype, "visible", 2);
__decorateClass([
    SceneObjectChangeDetection({
        equals: objectsEqual,
        changeCb: (target)=>target.onZIndexChange()
    })
], _Node.prototype, "zIndex", 2);
var Node2 = _Node;
;
;
// packages/ag-charts-community/src/util/angle.ts
var twoPi = Math.PI * 2;
var halfPi = Math.PI / 2;
function normalizeAngle360(radians) {
    radians %= twoPi;
    radians += twoPi;
    radians %= twoPi;
    return radians;
}
function normalizeAngle360Inclusive(radians) {
    radians %= twoPi;
    radians += twoPi;
    if (radians !== twoPi) {
        radians %= twoPi;
    }
    return radians;
}
function normalizeAngle180(radians) {
    radians %= twoPi;
    if (radians < -Math.PI) {
        radians += twoPi;
    } else if (radians >= Math.PI) {
        radians -= twoPi;
    }
    return radians;
}
function isBetweenAngles(targetAngle, startAngle, endAngle) {
    const t = normalizeAngle360(targetAngle);
    const a0 = normalizeAngle360(startAngle);
    const a1 = normalizeAngle360(endAngle);
    if (a0 < a1) {
        return a0 <= t && t <= a1;
    } else if (a0 > a1) {
        return a0 <= t || t <= a1;
    } else {
        return startAngle !== endAngle;
    }
}
function toRadians(degrees) {
    return degrees / 180 * Math.PI;
}
function toDegrees(radians) {
    return radians / Math.PI * 180;
}
function angleBetween(angle0, angle1) {
    angle0 = normalizeAngle360(angle0);
    angle1 = normalizeAngle360(angle1);
    return angle1 - angle0 + (angle0 > angle1 ? twoPi : 0);
}
function getAngleRatioRadians(angle2) {
    const normalizedAngle = normalizeAngle360(angle2);
    if (normalizedAngle <= halfPi) {
        return normalizedAngle / halfPi;
    } else if (normalizedAngle <= Math.PI) {
        return (Math.PI - normalizedAngle) / halfPi;
    } else if (normalizedAngle <= 1.5 * Math.PI) {
        return (normalizedAngle - Math.PI) / halfPi;
    } else {
        return (twoPi - normalizedAngle) / halfPi;
    }
}
function angularPadding(hPadding, vPadding, angle2) {
    const angleRatio = getAngleRatioRadians(angle2);
    return hPadding * angleRatio + vPadding * Math.abs(1 - angleRatio);
}
function normalizeAngle360FromDegrees(degrees) {
    return degrees ? normalizeAngle360(toRadians(degrees)) : 0;
}
;
;
;
var lerp = (x, y, t)=>x * (1 - t) + y * t;
var srgbToLinear = (value)=>{
    const sign = value < 0 ? -1 : 1;
    const abs = Math.abs(value);
    if (abs <= 0.04045) return value / 12.92;
    return sign * ((abs + 0.055) / 1.055) ** 2.4;
};
var srgbFromLinear = (value)=>{
    const sign = value < 0 ? -1 : 1;
    const abs = Math.abs(value);
    if (abs > 31308e-7) {
        return sign * (1.055 * abs ** (1 / 2.4) - 0.055);
    }
    return 12.92 * value;
};
var _Color = class _Color {
    /**
   * A color string can be in one of the following formats to be valid:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   */ static validColorString(str) {
        if (str.indexOf("#") >= 0) {
            return !!_Color.parseHex(str);
        }
        if (str.indexOf("rgb") >= 0) {
            return !!_Color.stringToRgba(str);
        }
        return _Color.nameToHex.has(str.toLowerCase());
    }
    /**
   * The given string can be in one of the following formats:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   * @param str
   */ static fromString(str) {
        if (str.indexOf("#") >= 0) {
            return _Color.fromHexString(str);
        }
        const hex = _Color.nameToHex.get(str.toLowerCase());
        if (hex) {
            return _Color.fromHexString(hex);
        }
        if (str.indexOf("rgb") >= 0) {
            return _Color.fromRgbaString(str);
        }
        throw new Error("Invalid color string: '".concat(str, "'"));
    }
    // See https://drafts.csswg.org/css-color/#hex-notation
    static parseHex(input) {
        input = input.replace(/ /g, "").slice(1);
        let parts;
        switch(input.length){
            case 6:
            case 8:
                parts = [];
                for(let i = 0; i < input.length; i += 2){
                    parts.push(parseInt("".concat(input[i]).concat(input[i + 1]), 16));
                }
                break;
            case 3:
            case 4:
                parts = input.split("").map((p)=>parseInt(p, 16)).map((p)=>p + p * 16);
                break;
        }
        if ((parts === null || parts === void 0 ? void 0 : parts.length) >= 3 && parts.every((p)=>p >= 0)) {
            if (parts.length === 3) {
                parts.push(255);
            }
            return parts;
        }
    }
    static fromHexString(str) {
        const values = _Color.parseHex(str);
        if (values) {
            const [r, g, b, a] = values;
            return new _Color(r / 255, g / 255, b / 255, a / 255);
        }
        throw new Error("Malformed hexadecimal color string: '".concat(str, "'"));
    }
    static stringToRgba(str) {
        let po = -1;
        let pc = -1;
        for(let i = 0; i < str.length; i++){
            const c = str[i];
            if (po === -1 && c === "(") {
                po = i;
            } else if (c === ")") {
                pc = i;
                break;
            }
        }
        if (po === -1 || pc === -1) return;
        const contents = str.substring(po + 1, pc);
        const parts = contents.split(",");
        const rgba = [];
        for(let i = 0; i < parts.length; i++){
            const part = parts[i];
            let value = parseFloat(part);
            if (!Number.isFinite(value)) {
                return;
            }
            if (part.indexOf("%") >= 0) {
                value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, value, 100);
                value /= 100;
            } else if (i === 3) {
                value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, value, 1);
            } else {
                value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, value, 255);
                value /= 255;
            }
            rgba.push(value);
        }
        return rgba;
    }
    static fromRgbaString(str) {
        const rgba = _Color.stringToRgba(str);
        if (rgba) {
            if (rgba.length === 3) {
                return new _Color(rgba[0], rgba[1], rgba[2]);
            } else if (rgba.length === 4) {
                return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);
            }
        }
        throw new Error("Malformed rgb/rgba color string: '".concat(str, "'"));
    }
    static fromArray(arr) {
        if (arr.length === 4) {
            return new _Color(arr[0], arr[1], arr[2], arr[3]);
        }
        if (arr.length === 3) {
            return new _Color(arr[0], arr[1], arr[2]);
        }
        throw new Error("The given array should contain 3 or 4 color components (numbers).");
    }
    static fromHSB(h, s, b) {
        let alpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
        const rgb = _Color.HSBtoRGB(h, s, b);
        return new _Color(rgb[0], rgb[1], rgb[2], alpha);
    }
    static fromHSL(h, s, l) {
        let alpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
        const rgb = _Color.HSLtoRGB(h, s, l);
        return new _Color(rgb[0], rgb[1], rgb[2], alpha);
    }
    static fromOKLCH(l, c, h) {
        let alpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
        const rgb = _Color.OKLCHtoRGB(l, c, h);
        return new _Color(rgb[0], rgb[1], rgb[2], alpha);
    }
    static padHex(str) {
        return str.length === 1 ? "0" + str : str;
    }
    toHexString() {
        let hex = "#" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));
        if (this.a < 1) {
            hex += _Color.padHex(Math.round(this.a * 255).toString(16));
        }
        return hex;
    }
    toRgbaString() {
        let fractionDigits = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
        const components = [
            Math.round(this.r * 255),
            Math.round(this.g * 255),
            Math.round(this.b * 255)
        ];
        const k = Math.pow(10, fractionDigits);
        if (this.a !== 1) {
            components.push(Math.round(this.a * k) / k);
            return "rgba(".concat(components.join(", "), ")");
        }
        return "rgb(".concat(components.join(", "), ")");
    }
    toString() {
        if (this.a === 1) {
            return this.toHexString();
        }
        return this.toRgbaString();
    }
    toHSB() {
        return _Color.RGBtoHSB(this.r, this.g, this.b);
    }
    static RGBtoOKLCH(r, g, b) {
        const LSRGB0 = srgbToLinear(r);
        const LSRGB1 = srgbToLinear(g);
        const LSRGB2 = srgbToLinear(b);
        const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);
        const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);
        const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);
        const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;
        const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;
        const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;
        const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;
        const OKLCH0 = OKLAB0;
        const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);
        const OKLCH2 = hue >= 0 ? hue : hue + 360;
        return [
            OKLCH0,
            OKLCH1,
            OKLCH2
        ];
    }
    static OKLCHtoRGB(l, c, h) {
        const OKLAB0 = l;
        const OKLAB1 = c * Math.cos(h * Math.PI / 180);
        const OKLAB2 = c * Math.sin(h * Math.PI / 180);
        const LMS0 = (OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2) ** 3;
        const LMS1 = (OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2) ** 3;
        const LMS2 = (OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2) ** 3;
        const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;
        const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;
        const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;
        const SRGB0 = srgbFromLinear(LSRGB0);
        const SRGB1 = srgbFromLinear(LSRGB1);
        const SRGB2 = srgbFromLinear(LSRGB2);
        return [
            SRGB0,
            SRGB1,
            SRGB2
        ];
    }
    static RGBtoHSL(r, g, b) {
        const min = Math.min(r, g, b);
        const max = Math.max(r, g, b);
        const l = (max + min) / 2;
        let h;
        let s;
        if (max === min) {
            h = 0;
            s = 0;
        } else {
            const delta3 = max - min;
            s = l > 0.5 ? delta3 / (2 - max - min) : delta3 / (max + min);
            if (max === r) {
                h = (g - b) / delta3 + (g < b ? 6 : 0);
            } else if (max === g) {
                h = (b - r) / delta3 + 2;
            } else {
                h = (r - g) / delta3 + 4;
            }
            h *= 360 / 6;
        }
        return [
            h,
            s,
            l
        ];
    }
    static HSLtoRGB(h, s, l) {
        h = (h % 360 + 360) % 360;
        if (s === 0) {
            return [
                l,
                l,
                l
            ];
        }
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        function hueToRgb(t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }
        const r = hueToRgb(h / 360 + 1 / 3);
        const g = hueToRgb(h / 360);
        const b = hueToRgb(h / 360 - 1 / 3);
        return [
            r,
            g,
            b
        ];
    }
    /**
   * Converts the given RGB triple to an array of HSB (HSV) components.
   */ static RGBtoHSB(r, g, b) {
        const min = Math.min(r, g, b);
        const max = Math.max(r, g, b);
        const S = max === 0 ? 0 : (max - min) / max;
        let H = 0;
        if (min !== max) {
            const delta3 = max - min;
            const rc = (max - r) / delta3;
            const gc = (max - g) / delta3;
            const bc = (max - b) / delta3;
            if (r === max) {
                H = bc - gc;
            } else if (g === max) {
                H = 2 + rc - bc;
            } else {
                H = 4 + gc - rc;
            }
            H /= 6;
            if (H < 0) {
                H = H + 1;
            }
        }
        return [
            H * 360,
            S,
            max
        ];
    }
    /**
   * Converts the given HSB (HSV) triple to an array of RGB components.
   */ static HSBtoRGB(H, S, B) {
        H = (H % 360 + 360) % 360 / 360;
        let r = 0;
        let g = 0;
        let b = 0;
        if (S === 0) {
            r = g = b = B;
        } else {
            const h = (H - Math.floor(H)) * 6;
            const f = h - Math.floor(h);
            const p = B * (1 - S);
            const q = B * (1 - S * f);
            const t = B * (1 - S * (1 - f));
            switch(h >> 0){
                case 0:
                    r = B;
                    g = t;
                    b = p;
                    break;
                case 1:
                    r = q;
                    g = B;
                    b = p;
                    break;
                case 2:
                    r = p;
                    g = B;
                    b = t;
                    break;
                case 3:
                    r = p;
                    g = q;
                    b = B;
                    break;
                case 4:
                    r = t;
                    g = p;
                    b = B;
                    break;
                case 5:
                    r = B;
                    g = p;
                    b = q;
                    break;
            }
        }
        return [
            r,
            g,
            b
        ];
    }
    static mix(c0, c1, t) {
        return new _Color(lerp(c0.r, c1.r, t), lerp(c0.g, c1.g, t), lerp(c0.b, c1.b, t), lerp(c0.a, c1.a, t));
    }
    static lighten(c, t) {
        const oklch = _Color.RGBtoOKLCH(c.r, c.g, c.b);
        return _Color.fromOKLCH((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, oklch[0] + t, 1), oklch[1], oklch[2]);
    }
    static darken(c, t) {
        const oklch = _Color.RGBtoOKLCH(c.r, c.g, c.b);
        return _Color.fromOKLCH((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, oklch[0] - t, 1), oklch[1], oklch[2]);
    }
    static interpolate(colors, count) {
        const step = 1 / (colors.length - 1);
        const oklchColors = colors.map((c)=>_Color.RGBtoOKLCH(c.r, c.g, c.b));
        return Array.from({
            length: count
        }, (_, i)=>{
            const t = i / (count - 1);
            const index = colors.length <= 2 ? 0 : Math.min(Math.floor(t * (colors.length - 1)), colors.length - 2);
            const q = (t - index * step) / step;
            const c0 = oklchColors[index];
            const c1 = oklchColors[index + 1];
            return _Color.fromOKLCH(lerp(c0[0], c1[0], q), lerp(c0[1], c1[1], q), lerp(c0[2], c1[2], q));
        });
    }
    /**
   * Every color component should be in the [0, 1] range.
   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.
   * So, when animating colors, if the source or target color components are already near
   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color
   * component value to end up outside of that range mid-animation. For this reason the constructor
   * performs range checking/constraining.
   * @param r Red component.
   * @param g Green component.
   * @param b Blue component.
   * @param a Alpha (opacity) component.
   */ constructor(r, g, b, a = 1){
        this.r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, r || 0, 1);
        this.g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, g || 0, 1);
        this.b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, b || 0, 1);
        this.a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, a || 0, 1);
    }
};
/**
 * CSS Color Module Level 4:
 * https://drafts.csswg.org/css-color/#named-colors
 */ _Color.nameToHex = /* @__PURE__ */ new Map([
    [
        "aliceblue",
        "#F0F8FF"
    ],
    [
        "antiquewhite",
        "#FAEBD7"
    ],
    [
        "aqua",
        "#00FFFF"
    ],
    [
        "aquamarine",
        "#7FFFD4"
    ],
    [
        "azure",
        "#F0FFFF"
    ],
    [
        "beige",
        "#F5F5DC"
    ],
    [
        "bisque",
        "#FFE4C4"
    ],
    [
        "black",
        "#000000"
    ],
    [
        "blanchedalmond",
        "#FFEBCD"
    ],
    [
        "blue",
        "#0000FF"
    ],
    [
        "blueviolet",
        "#8A2BE2"
    ],
    [
        "brown",
        "#A52A2A"
    ],
    [
        "burlywood",
        "#DEB887"
    ],
    [
        "cadetblue",
        "#5F9EA0"
    ],
    [
        "chartreuse",
        "#7FFF00"
    ],
    [
        "chocolate",
        "#D2691E"
    ],
    [
        "coral",
        "#FF7F50"
    ],
    [
        "cornflowerblue",
        "#6495ED"
    ],
    [
        "cornsilk",
        "#FFF8DC"
    ],
    [
        "crimson",
        "#DC143C"
    ],
    [
        "cyan",
        "#00FFFF"
    ],
    [
        "darkblue",
        "#00008B"
    ],
    [
        "darkcyan",
        "#008B8B"
    ],
    [
        "darkgoldenrod",
        "#B8860B"
    ],
    [
        "darkgray",
        "#A9A9A9"
    ],
    [
        "darkgreen",
        "#006400"
    ],
    [
        "darkgrey",
        "#A9A9A9"
    ],
    [
        "darkkhaki",
        "#BDB76B"
    ],
    [
        "darkmagenta",
        "#8B008B"
    ],
    [
        "darkolivegreen",
        "#556B2F"
    ],
    [
        "darkorange",
        "#FF8C00"
    ],
    [
        "darkorchid",
        "#9932CC"
    ],
    [
        "darkred",
        "#8B0000"
    ],
    [
        "darksalmon",
        "#E9967A"
    ],
    [
        "darkseagreen",
        "#8FBC8F"
    ],
    [
        "darkslateblue",
        "#483D8B"
    ],
    [
        "darkslategray",
        "#2F4F4F"
    ],
    [
        "darkslategrey",
        "#2F4F4F"
    ],
    [
        "darkturquoise",
        "#00CED1"
    ],
    [
        "darkviolet",
        "#9400D3"
    ],
    [
        "deeppink",
        "#FF1493"
    ],
    [
        "deepskyblue",
        "#00BFFF"
    ],
    [
        "dimgray",
        "#696969"
    ],
    [
        "dimgrey",
        "#696969"
    ],
    [
        "dodgerblue",
        "#1E90FF"
    ],
    [
        "firebrick",
        "#B22222"
    ],
    [
        "floralwhite",
        "#FFFAF0"
    ],
    [
        "forestgreen",
        "#228B22"
    ],
    [
        "fuchsia",
        "#FF00FF"
    ],
    [
        "gainsboro",
        "#DCDCDC"
    ],
    [
        "ghostwhite",
        "#F8F8FF"
    ],
    [
        "gold",
        "#FFD700"
    ],
    [
        "goldenrod",
        "#DAA520"
    ],
    [
        "gray",
        "#808080"
    ],
    [
        "green",
        "#008000"
    ],
    [
        "greenyellow",
        "#ADFF2F"
    ],
    [
        "grey",
        "#808080"
    ],
    [
        "honeydew",
        "#F0FFF0"
    ],
    [
        "hotpink",
        "#FF69B4"
    ],
    [
        "indianred",
        "#CD5C5C"
    ],
    [
        "indigo",
        "#4B0082"
    ],
    [
        "ivory",
        "#FFFFF0"
    ],
    [
        "khaki",
        "#F0E68C"
    ],
    [
        "lavender",
        "#E6E6FA"
    ],
    [
        "lavenderblush",
        "#FFF0F5"
    ],
    [
        "lawngreen",
        "#7CFC00"
    ],
    [
        "lemonchiffon",
        "#FFFACD"
    ],
    [
        "lightblue",
        "#ADD8E6"
    ],
    [
        "lightcoral",
        "#F08080"
    ],
    [
        "lightcyan",
        "#E0FFFF"
    ],
    [
        "lightgoldenrodyellow",
        "#FAFAD2"
    ],
    [
        "lightgray",
        "#D3D3D3"
    ],
    [
        "lightgreen",
        "#90EE90"
    ],
    [
        "lightgrey",
        "#D3D3D3"
    ],
    [
        "lightpink",
        "#FFB6C1"
    ],
    [
        "lightsalmon",
        "#FFA07A"
    ],
    [
        "lightseagreen",
        "#20B2AA"
    ],
    [
        "lightskyblue",
        "#87CEFA"
    ],
    [
        "lightslategray",
        "#778899"
    ],
    [
        "lightslategrey",
        "#778899"
    ],
    [
        "lightsteelblue",
        "#B0C4DE"
    ],
    [
        "lightyellow",
        "#FFFFE0"
    ],
    [
        "lime",
        "#00FF00"
    ],
    [
        "limegreen",
        "#32CD32"
    ],
    [
        "linen",
        "#FAF0E6"
    ],
    [
        "magenta",
        "#FF00FF"
    ],
    [
        "maroon",
        "#800000"
    ],
    [
        "mediumaquamarine",
        "#66CDAA"
    ],
    [
        "mediumblue",
        "#0000CD"
    ],
    [
        "mediumorchid",
        "#BA55D3"
    ],
    [
        "mediumpurple",
        "#9370DB"
    ],
    [
        "mediumseagreen",
        "#3CB371"
    ],
    [
        "mediumslateblue",
        "#7B68EE"
    ],
    [
        "mediumspringgreen",
        "#00FA9A"
    ],
    [
        "mediumturquoise",
        "#48D1CC"
    ],
    [
        "mediumvioletred",
        "#C71585"
    ],
    [
        "midnightblue",
        "#191970"
    ],
    [
        "mintcream",
        "#F5FFFA"
    ],
    [
        "mistyrose",
        "#FFE4E1"
    ],
    [
        "moccasin",
        "#FFE4B5"
    ],
    [
        "navajowhite",
        "#FFDEAD"
    ],
    [
        "navy",
        "#000080"
    ],
    [
        "oldlace",
        "#FDF5E6"
    ],
    [
        "olive",
        "#808000"
    ],
    [
        "olivedrab",
        "#6B8E23"
    ],
    [
        "orange",
        "#FFA500"
    ],
    [
        "orangered",
        "#FF4500"
    ],
    [
        "orchid",
        "#DA70D6"
    ],
    [
        "palegoldenrod",
        "#EEE8AA"
    ],
    [
        "palegreen",
        "#98FB98"
    ],
    [
        "paleturquoise",
        "#AFEEEE"
    ],
    [
        "palevioletred",
        "#DB7093"
    ],
    [
        "papayawhip",
        "#FFEFD5"
    ],
    [
        "peachpuff",
        "#FFDAB9"
    ],
    [
        "peru",
        "#CD853F"
    ],
    [
        "pink",
        "#FFC0CB"
    ],
    [
        "plum",
        "#DDA0DD"
    ],
    [
        "powderblue",
        "#B0E0E6"
    ],
    [
        "purple",
        "#800080"
    ],
    [
        "rebeccapurple",
        "#663399"
    ],
    [
        "red",
        "#FF0000"
    ],
    [
        "rosybrown",
        "#BC8F8F"
    ],
    [
        "royalblue",
        "#4169E1"
    ],
    [
        "saddlebrown",
        "#8B4513"
    ],
    [
        "salmon",
        "#FA8072"
    ],
    [
        "sandybrown",
        "#F4A460"
    ],
    [
        "seagreen",
        "#2E8B57"
    ],
    [
        "seashell",
        "#FFF5EE"
    ],
    [
        "sienna",
        "#A0522D"
    ],
    [
        "silver",
        "#C0C0C0"
    ],
    [
        "skyblue",
        "#87CEEB"
    ],
    [
        "slateblue",
        "#6A5ACD"
    ],
    [
        "slategray",
        "#708090"
    ],
    [
        "slategrey",
        "#708090"
    ],
    [
        "snow",
        "#FFFAFA"
    ],
    [
        "springgreen",
        "#00FF7F"
    ],
    [
        "steelblue",
        "#4682B4"
    ],
    [
        "tan",
        "#D2B48C"
    ],
    [
        "teal",
        "#008080"
    ],
    [
        "thistle",
        "#D8BFD8"
    ],
    [
        "tomato",
        "#FF6347"
    ],
    [
        "transparent",
        "#00000000"
    ],
    [
        "turquoise",
        "#40E0D0"
    ],
    [
        "violet",
        "#EE82EE"
    ],
    [
        "wheat",
        "#F5DEB3"
    ],
    [
        "white",
        "#FFFFFF"
    ],
    [
        "whitesmoke",
        "#F5F5F5"
    ],
    [
        "yellow",
        "#FFFF00"
    ],
    [
        "yellowgreen",
        "#9ACD32"
    ]
]);
var Color = _Color;
// packages/ag-charts-community/src/scale/scale.ts
var ScaleAlignment = /* @__PURE__ */ ((ScaleAlignment2)=>{
    ScaleAlignment2[ScaleAlignment2["Leading"] = 0] = "Leading";
    ScaleAlignment2[ScaleAlignment2["Trailing"] = 1] = "Trailing";
    ScaleAlignment2[ScaleAlignment2["Interpolate"] = 2] = "Interpolate";
    return ScaleAlignment2;
})(ScaleAlignment || {});
// packages/ag-charts-community/src/scale/abstractScale.ts
var AbstractScale = class {
    ticks(_ticks, _domain, _visibleRange) {
        return void 0;
    }
    niceDomain(_ticks) {
        let domain = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.domain;
        return domain;
    }
    get bandwidth() {
        return void 0;
    }
    get step() {
        return void 0;
    }
    get inset() {
        return void 0;
    }
};
// packages/ag-charts-community/src/scale/invalidating.ts
var Invalidating = (target, propertyKey)=>{
    const mappedProperty = Symbol(String(propertyKey));
    target[mappedProperty] = void 0;
    Object.defineProperty(target, propertyKey, {
        get () {
            return this[mappedProperty];
        },
        set (newValue) {
            const oldValue = this[mappedProperty];
            if (oldValue !== newValue) {
                this[mappedProperty] = newValue;
                this.invalid = true;
            }
        },
        enumerable: true,
        configurable: false
    });
};
// packages/ag-charts-community/src/scale/colorScale.ts
var convertColorStringToOklcha = (v)=>{
    const color11 = Color.fromString(v);
    const [l, c, h] = Color.RGBtoOKLCH(color11.r, color11.g, color11.b);
    return {
        l,
        c,
        h,
        a: color11.a
    };
};
var delta = 1e-6;
var isAchromatic = (x)=>x.c < delta || x.l < delta || x.l > 1 - delta;
var interpolateOklch = (x, y, d)=>{
    d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, d, 1);
    let h;
    if (isAchromatic(x)) {
        h = y.h;
    } else if (isAchromatic(y)) {
        h = x.h;
    } else {
        const xH = x.h;
        let yH = y.h;
        const deltaH = y.h - x.h;
        if (deltaH > 180) {
            yH -= 360;
        } else if (deltaH < -180) {
            yH += 360;
        }
        h = xH * (1 - d) + yH * d;
    }
    const c = x.c * (1 - d) + y.c * d;
    const l = x.l * (1 - d) + y.l * d;
    const a = x.a * (1 - d) + y.a * d;
    return Color.fromOKLCH(l, c, h, a);
};
var ColorScale = class extends AbstractScale {
    update() {
        const { domain, range: range3 } = this;
        if (domain.length < 2) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("`colorDomain` should have at least 2 values.");
            if (domain.length === 0) {
                domain.push(0, 1);
            } else if (domain.length === 1) {
                domain.push(domain[0] + 1);
            }
        }
        for(let i = 1; i < domain.length; i++){
            const a = domain[i - 1];
            const b = domain[i];
            if (a > b) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("`colorDomain` values should be supplied in ascending order.");
                domain.sort((a2, b2)=>a2 - b2);
                break;
            }
        }
        if (range3.length < domain.length) {
            for(let i = range3.length; i < domain.length; i++){
                range3.push(range3.length > 0 ? range3[0] : "black");
            }
        }
        this.parsedRange = this.range.map(convertColorStringToOklcha);
    }
    normalizeDomains() {
        for(var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++){
            domains[_key] = arguments[_key];
        }
        return {
            domain: domains.flat(),
            animatable: true
        };
    }
    toDomain() {
        return;
    }
    convert(x) {
        this.refresh();
        const { domain, range: range3, parsedRange } = this;
        const d0 = domain[0];
        const d1 = domain.at(-1);
        const r0 = range3[0];
        const r1 = range3[range3.length - 1];
        if (x <= d0) {
            return r0;
        }
        if (x >= d1) {
            return r1;
        }
        let index;
        let q;
        if (domain.length === 2) {
            const t = (x - d0) / (d1 - d0);
            const step = 1 / (range3.length - 1);
            index = range3.length <= 2 ? 0 : Math.min(Math.floor(t * (range3.length - 1)), range3.length - 2);
            q = (t - index * step) / step;
        } else {
            for(index = 0; index < domain.length - 2; index++){
                if (x < domain[index + 1]) {
                    break;
                }
            }
            const a = domain[index];
            const b = domain[index + 1];
            q = (x - a) / (b - a);
        }
        const c0 = parsedRange[index];
        const c1 = parsedRange[index + 1];
        return interpolateOklch(c0, c1, q).toRgbaString();
    }
    invert() {
        return;
    }
    refresh() {
        if (!this.invalid) return;
        this.invalid = false;
        this.update();
        if (this.invalid) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Expected update to not invalidate scale");
        }
    }
    constructor(){
        super(...arguments);
        this.type = "color";
        this.defaultTickCount = 0;
        this.invalid = true;
        this.domain = [
            0,
            1
        ];
        this.range = [
            "red",
            "blue"
        ];
        this.parsedRange = this.range.map(convertColorStringToOklcha);
    }
};
__decorateClass([
    Invalidating
], ColorScale.prototype, "domain", 2);
__decorateClass([
    Invalidating
], ColorScale.prototype, "range", 2);
// packages/ag-charts-community/src/scene/gradient/gradient.ts
var Gradient = class {
    createGradient(ctx, shapeBbox, params) {
        var _this_bbox;
        const bbox = (_this_bbox = this.bbox) !== null && _this_bbox !== void 0 ? _this_bbox : shapeBbox;
        if (!bbox.isFinite()) {
            return;
        }
        if (this._cache != null && this._cache.ctx === ctx && this._cache.bbox.equals(bbox)) {
            return this._cache.gradient;
        }
        const { stops, colorSpace } = this;
        if (stops.length === 0) return;
        if (stops.length === 1) return stops[0].color;
        let gradient2 = this.createCanvasGradient(ctx, bbox, params);
        if (gradient2 == null) return;
        const isOkLch = colorSpace === "oklch";
        const step = 0.05;
        let c0 = stops[0];
        gradient2.addColorStop(c0.stop, c0.color);
        for(let i = 1; i < stops.length; i += 1){
            const c1 = stops[i];
            if (isOkLch) {
                const scale2 = new ColorScale();
                scale2.domain = [
                    c0.stop,
                    c1.stop
                ];
                scale2.range = [
                    c0.color,
                    c1.color
                ];
                for(let stop = c0.stop + step; stop < c1.stop; stop += step){
                    gradient2.addColorStop(stop, scale2.convert(stop));
                }
            }
            gradient2.addColorStop(c1.stop, c1.color);
            c0 = c1;
        }
        if ("createPattern" in gradient2) {
            gradient2 = gradient2.createPattern();
        }
        this._cache = {
            ctx,
            bbox,
            gradient: gradient2
        };
        return gradient2;
    }
    toSvg(shapeBbox) {
        var _this_bbox;
        const bbox = (_this_bbox = this.bbox) !== null && _this_bbox !== void 0 ? _this_bbox : shapeBbox;
        const gradient2 = this.createSvgGradient(bbox);
        this.stops.forEach((param)=>{
            let { stop: offset, color: color11 } = param;
            const stop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("stop");
            stop.setAttribute("offset", "".concat(offset));
            stop.setAttribute("stop-color", "".concat(color11));
            gradient2.appendChild(stop);
        });
        return gradient2;
    }
    constructor(colorSpace, stops = [], bbox){
        this.colorSpace = colorSpace;
        this.stops = stops;
        this.bbox = bbox;
        this._cache = void 0;
    }
};
// packages/ag-charts-community/src/scene/gradient/conicGradient.ts
var ConicGradient = class extends Gradient {
    createCanvasGradient(ctx, bbox, params) {
        const angleOffset = -90;
        const { angle: angle2 } = this;
        const radians = normalizeAngle360FromDegrees(angle2 + angleOffset);
        var _params_centerX;
        const cx = (_params_centerX = params === null || params === void 0 ? void 0 : params.centerX) !== null && _params_centerX !== void 0 ? _params_centerX : bbox.x + bbox.width * 0.5;
        var _params_centerY;
        const cy = (_params_centerY = params === null || params === void 0 ? void 0 : params.centerY) !== null && _params_centerY !== void 0 ? _params_centerY : bbox.y + bbox.height * 0.5;
        return ctx.createConicGradient(radians, cx, cy);
    }
    createSvgGradient(_bbox) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("linearGradient");
    }
    constructor(colorSpace, stops, angle2 = 0, bbox){
        super(colorSpace, stops, bbox);
        this.angle = angle2;
    }
};
;
var LinearGradient = class extends Gradient {
    getGradientPoints(bbox) {
        const angleOffset = 90;
        const { angle: angle2 } = this;
        const radians = normalizeAngle360FromDegrees(angle2 + angleOffset);
        const cos = Math.cos(radians);
        const sin = Math.sin(radians);
        const w = bbox.width;
        const h = bbox.height;
        const cx = bbox.x + w * 0.5;
        const cy = bbox.y + h * 0.5;
        const diagonal = Math.sqrt(h * h + w * w) / 2;
        const diagonalAngle = Math.atan2(h, w);
        let quarteredAngle;
        if (radians < Math.PI / 2) {
            quarteredAngle = radians;
        } else if (radians < Math.PI) {
            quarteredAngle = Math.PI - radians;
        } else if (radians < 1.5 * Math.PI) {
            quarteredAngle = radians - Math.PI;
        } else {
            quarteredAngle = 2 * Math.PI - radians;
        }
        const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));
        return {
            x0: cx + cos * l,
            y0: cy + sin * l,
            x1: cx - cos * l,
            y1: cy - sin * l
        };
    }
    createCanvasGradient(ctx, bbox) {
        const { x0, y0, x1, y1 } = this.getGradientPoints(bbox);
        if (isNaN(x0) || isNaN(y0) || isNaN(x1) || isNaN(y1)) {
            return void 0;
        }
        return ctx.createLinearGradient(x0, y0, x1, y1);
    }
    createSvgGradient(bbox) {
        const { x0, y0, x1, y1 } = this.getGradientPoints(bbox);
        const gradient2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("linearGradient");
        gradient2.setAttribute("x1", String(x0));
        gradient2.setAttribute("y1", String(y0));
        gradient2.setAttribute("x2", String(x1));
        gradient2.setAttribute("y2", String(y1));
        gradient2.setAttribute("gradientUnits", "userSpaceOnUse");
        return gradient2;
    }
    constructor(colorSpace, stops, angle2 = 0, bbox){
        super(colorSpace, stops, bbox);
        this.angle = angle2;
    }
};
;
var RadialGradient = class extends Gradient {
    createCanvasGradient(ctx, bbox, params) {
        var _params_centerX;
        const cx = (_params_centerX = params === null || params === void 0 ? void 0 : params.centerX) !== null && _params_centerX !== void 0 ? _params_centerX : bbox.x + bbox.width * 0.5;
        var _params_centerY;
        const cy = (_params_centerY = params === null || params === void 0 ? void 0 : params.centerY) !== null && _params_centerY !== void 0 ? _params_centerY : bbox.y + bbox.height * 0.5;
        var _params_innerRadius;
        const innerRadius = (_params_innerRadius = params === null || params === void 0 ? void 0 : params.innerRadius) !== null && _params_innerRadius !== void 0 ? _params_innerRadius : 0;
        var _params_outerRadius;
        const outerRadius = (_params_outerRadius = params === null || params === void 0 ? void 0 : params.outerRadius) !== null && _params_outerRadius !== void 0 ? _params_outerRadius : Math.hypot(bbox.width * 0.5, bbox.height * 0.5) / Math.SQRT2;
        return ctx.createRadialGradient(cx, cy, innerRadius, cx, cy, outerRadius);
    }
    createSvgGradient(bbox) {
        const cx = bbox.x + bbox.width * 0.5;
        const cy = bbox.y + bbox.height * 0.5;
        const gradient2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("radialGradient");
        gradient2.setAttribute("cx", String(cx));
        gradient2.setAttribute("cy", String(cy));
        gradient2.setAttribute("r", String(Math.hypot(bbox.width * 0.5, bbox.height * 0.5) / Math.SQRT2));
        gradient2.setAttribute("gradientUnits", "userSpaceOnUse");
        return gradient2;
    }
    constructor(colorSpace, stops, bbox){
        super(colorSpace, stops, bbox);
    }
};
;
;
var Property = addFakeTransformToInstanceProperty;
var BaseProperties = class {
    handleUnknownProperties(_unknownKeys, _properties) {}
    set(properties) {
        const { className = this.constructor.name } = this.constructor;
        if (properties == null) {
            this.clear();
            return this;
        }
        if (typeof properties !== "object") {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("unable to set ".concat(className, " - expecting a properties object"));
            return this;
        }
        const keys = new Set(Object.keys(properties));
        for (const propertyKey of listDecoratedProperties(this)){
            if (keys.has(propertyKey)) {
                const value = properties[propertyKey];
                const self = this;
                if (isProperties(self[propertyKey])) {
                    if (self[propertyKey] instanceof PropertiesArray) {
                        const array6 = self[propertyKey].reset(value);
                        if (array6 == null) {
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("unable to set [".concat(String(propertyKey), "] - expecting a properties array"));
                        } else {
                            self[propertyKey] = array6;
                        }
                    } else {
                        self[propertyKey].set(value);
                    }
                } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value)) {
                    var _self_propertyKey;
                    self[propertyKey] = merge(value, (_self_propertyKey = self[propertyKey]) !== null && _self_propertyKey !== void 0 ? _self_propertyKey : {});
                } else {
                    self[propertyKey] = value;
                }
                keys.delete(propertyKey);
            }
        }
        this.handleUnknownProperties(keys, properties);
        for (const unknownKey of keys){
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("unable to set [".concat(String(unknownKey), "] in ").concat(className, " - property is unknown"));
        }
        return this;
    }
    clear() {
        for (const propertyKey of listDecoratedProperties(this)){
            const currentValue = this[propertyKey];
            if (isProperties(currentValue)) {
                currentValue.clear();
            } else {
                this[propertyKey] = void 0;
            }
        }
        return this;
    }
    toJson() {
        return listDecoratedProperties(this).reduce((object4, propertyKey)=>{
            const propertyValue = this[propertyKey];
            object4[String(propertyKey)] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;
            return object4;
        }, {});
    }
};
var PropertiesArray = class _PropertiesArray extends Array {
    set(properties) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(properties)) {
            this.length = properties.length;
            for(let i = 0; i < properties.length; i++){
                this[i] = this.itemFactory(properties[i]);
            }
        }
        return this;
    }
    reset(properties) {
        if (Array.isArray(properties)) {
            return new _PropertiesArray(this.itemFactory, ...properties);
        }
    }
    toJson() {
        return this.map((value)=>{
            var _value_toJson;
            var _value_toJson1;
            return (_value_toJson1 = value === null || value === void 0 ? void 0 : (_value_toJson = value.toJson) === null || _value_toJson === void 0 ? void 0 : _value_toJson.call(value)) !== null && _value_toJson1 !== void 0 ? _value_toJson1 : value;
        });
    }
    constructor(itemFactory, ...properties){
        super(properties.length);
        const isConstructor = (value2)=>{
            var _value2_prototype_constructor, _value2_prototype;
            return Boolean(value2 === null || value2 === void 0 ? void 0 : (_value2_prototype = value2.prototype) === null || _value2_prototype === void 0 ? void 0 : (_value2_prototype_constructor = _value2_prototype.constructor) === null || _value2_prototype_constructor === void 0 ? void 0 : _value2_prototype_constructor.name);
        };
        const value = isConstructor(itemFactory) ? (params)=>new itemFactory().set(params) : itemFactory;
        Object.defineProperty(this, "itemFactory", {
            value,
            enumerable: false,
            configurable: false
        });
        this.set(properties);
    }
};
function isProperties(value) {
    return value instanceof BaseProperties || value instanceof PropertiesArray;
}
// packages/ag-charts-community/src/scene/gradient/stops.ts
var StopProperties = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.color = "black";
    }
};
__decorateClass([
    Property
], StopProperties.prototype, "stop", 2);
__decorateClass([
    Property
], StopProperties.prototype, "color", 2);
function stopsAreAscending(fills) {
    let currentStop;
    for (const fill of fills){
        if ((fill === null || fill === void 0 ? void 0 : fill.stop) == null) continue;
        if (currentStop != null && fill.stop < currentStop) {
            return false;
        }
        currentStop = fill.stop;
    }
    return true;
}
function discreteColorStops(colorStops) {
    return colorStops.flatMap((colorStop, i)=>{
        var _colorStops_at;
        const { stop } = colorStop;
        const nextColor = (_colorStops_at = colorStops.at(i + 1)) === null || _colorStops_at === void 0 ? void 0 : _colorStops_at.color;
        return nextColor != null ? [
            colorStop,
            {
                stop,
                color: nextColor
            }
        ] : [
            colorStop
        ];
    });
}
function getDefaultColorStops(defaultColorStops, fillMode) {
    const stopOffset = fillMode === "discrete" ? 1 : 0;
    const colorStops = defaultColorStops.map((color11, index, param)=>{
        let { length: length2 } = param;
        return {
            stop: (index + stopOffset) / (length2 - 1 + stopOffset),
            color: color11
        };
    });
    return fillMode === "discrete" ? discreteColorStops(colorStops) : colorStops;
}
function getColorStops(baseFills, defaultColorStops, domain) {
    let fillMode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "continuous";
    var _fills_find;
    const fills = baseFills.map((fill)=>typeof fill === "string" ? {
            color: fill
        } : fill);
    if (fills.length === 0) {
        return getDefaultColorStops(defaultColorStops, fillMode);
    } else if (!stopsAreAscending(fills)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("[fills] must have the stops defined in ascending order");
        return [];
    }
    const d0 = Math.min(...domain);
    const d1 = Math.max(...domain);
    const isDiscrete = fillMode === "discrete";
    const stops = new Float64Array(fills.length);
    let previousDefinedStopIndex = 0;
    let nextDefinedStopIndex = -1;
    for(let i = 0; i < fills.length; i += 1){
        const colorStop = fills[i];
        if (i >= nextDefinedStopIndex) {
            nextDefinedStopIndex = fills.length - 1;
            for(let j = i + 1; j < fills.length; j += 1){
                var _fills_j;
                if (((_fills_j = fills[j]) === null || _fills_j === void 0 ? void 0 : _fills_j.stop) != null) {
                    nextDefinedStopIndex = j;
                    break;
                }
            }
        }
        let stop = colorStop === null || colorStop === void 0 ? void 0 : colorStop.stop;
        if (stop == null) {
            var _fills_previousDefinedStopIndex, _fills_nextDefinedStopIndex;
            const stop0 = (_fills_previousDefinedStopIndex = fills[previousDefinedStopIndex]) === null || _fills_previousDefinedStopIndex === void 0 ? void 0 : _fills_previousDefinedStopIndex.stop;
            const stop1 = (_fills_nextDefinedStopIndex = fills[nextDefinedStopIndex]) === null || _fills_nextDefinedStopIndex === void 0 ? void 0 : _fills_nextDefinedStopIndex.stop;
            const value0 = stop0 !== null && stop0 !== void 0 ? stop0 : d0;
            const value1 = stop1 !== null && stop1 !== void 0 ? stop1 : d1;
            const stopOffset = isDiscrete && stop0 == null ? 1 : 0;
            stop = value0 + (value1 - value0) * (i - previousDefinedStopIndex + stopOffset) / (nextDefinedStopIndex - previousDefinedStopIndex + stopOffset);
        } else {
            previousDefinedStopIndex = i;
        }
        stops[i] = Math.max(0, Math.min(1, (stop - d0) / (d1 - d0)));
    }
    let lastDefinedColor = (_fills_find = fills.find((c)=>c.color != null)) === null || _fills_find === void 0 ? void 0 : _fills_find.color;
    let colorScale;
    const colorStops = fills.map((fill, i)=>{
        let color11 = fill === null || fill === void 0 ? void 0 : fill.color;
        const stop = stops[i];
        if (color11 != null) {
            lastDefinedColor = color11;
        } else if (lastDefinedColor != null) {
            color11 = lastDefinedColor;
        } else {
            if (colorScale == null) {
                colorScale = new ColorScale();
                colorScale.domain = [
                    0,
                    1
                ];
                colorScale.range = defaultColorStops;
            }
            color11 = colorScale.convert(stop);
        }
        return {
            stop,
            color: color11
        };
    });
    return fillMode === "discrete" ? discreteColorStops(colorStops) : colorStops;
}
;
var Image2 = class {
    createCanvasImage(ctx, image, width2, height2) {
        if (!image) return null;
        const [renderedWidth, renderedHeight] = this.getSize(image.width, image.height, width2, height2);
        if (renderedWidth < 1 || renderedHeight < 1) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Image fill is too small to render, ignoring.");
            return null;
        }
        return ctx.createPattern(image, this.repeat);
    }
    getSize(imageWidth, imageHeight, width2, height2) {
        const { fit } = this;
        let dw = imageWidth;
        let dh = imageHeight;
        let scale2 = 1;
        const shapeAspectRatio = width2 / height2;
        const imageAspectRatio = imageWidth / imageHeight;
        if (fit === "stretch" || imageWidth === 0 || imageHeight === 0) {
            dw = width2;
            dh = height2;
        } else if (fit === "contain") {
            scale2 = imageAspectRatio > shapeAspectRatio ? width2 / imageWidth : height2 / imageHeight;
        } else if (fit === "cover") {
            scale2 = imageAspectRatio > shapeAspectRatio ? height2 / imageHeight : width2 / imageWidth;
        }
        return [
            Math.max(1, dw * scale2),
            Math.max(1, dh * scale2)
        ];
    }
    setImageTransform(pattern, bbox) {
        var _this_imageLoader;
        if (typeof pattern === "string") return;
        const { url, rotation, width: width2, height: height2 } = this;
        const image = (_this_imageLoader = this.imageLoader) === null || _this_imageLoader === void 0 ? void 0 : _this_imageLoader.loadImage(url);
        if (!image) {
            return;
        }
        const angle2 = normalizeAngle360FromDegrees(rotation);
        const cos = Math.cos(angle2);
        const sin = Math.sin(angle2);
        const [renderedWidth, renderedHeight] = this.getSize(image.width, image.height, width2 !== null && width2 !== void 0 ? width2 : bbox.width, height2 !== null && height2 !== void 0 ? height2 : bbox.height);
        const widthScale = renderedWidth / image.width;
        const heightScale = renderedHeight / image.height;
        const bboxCenterX = bbox.x + bbox.width / 2;
        const bboxCenterY = bbox.y + bbox.height / 2;
        const rotatedW = cos * renderedWidth - sin * renderedHeight;
        const rotatedH = sin * renderedWidth + cos * renderedHeight;
        const shapeCenterX = rotatedW / 2;
        const shapeCenterY = rotatedH / 2;
        pattern === null || pattern === void 0 ? void 0 : pattern.setTransform(new DOMMatrix([
            cos * widthScale,
            sin * heightScale,
            -sin * widthScale,
            cos * heightScale,
            bboxCenterX - shapeCenterX,
            bboxCenterY - shapeCenterY
        ]));
    }
    createPattern(ctx, shapeWidth, shapeHeight, node) {
        var _this_imageLoader;
        var _this_width;
        const width2 = (_this_width = this.width) !== null && _this_width !== void 0 ? _this_width : shapeWidth;
        var _this_height;
        const height2 = (_this_height = this.height) !== null && _this_height !== void 0 ? _this_height : shapeHeight;
        const cache = this._cache;
        if (cache != null && cache.ctx === ctx && cache.width === width2 && cache.height === height2) {
            return cache.pattern;
        }
        const image = (_this_imageLoader = this.imageLoader) === null || _this_imageLoader === void 0 ? void 0 : _this_imageLoader.loadImage(this.url, node);
        const pattern = this.createCanvasImage(ctx, image, width2, height2);
        if (pattern == null) return;
        this._cache = {
            ctx,
            pattern,
            width: width2,
            height: height2
        };
        return pattern;
    }
    toSvg(bbox, pixelRatio) {
        const { url, rotation, backgroundFill, backgroundFillOpacity } = this;
        const { x, y, width: width2, height: height2 } = bbox;
        const pattern = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("pattern");
        pattern.setAttribute("viewBox", "0 0 ".concat(width2, " ").concat(height2));
        pattern.setAttribute("x", String(x));
        pattern.setAttribute("y", String(y));
        pattern.setAttribute("width", String(width2));
        pattern.setAttribute("height", String(height2));
        pattern.setAttribute("patternUnits", "userSpaceOnUse");
        const rect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("rect");
        rect.setAttribute("x", "0");
        rect.setAttribute("y", "0");
        rect.setAttribute("width", String(width2));
        rect.setAttribute("height", String(height2));
        rect.setAttribute("fill", backgroundFill);
        rect.setAttribute("fill-opacity", String(backgroundFillOpacity));
        pattern.appendChild(rect);
        const image = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("image");
        image.setAttribute("href", url);
        image.setAttribute("x", "0");
        image.setAttribute("y", "0");
        image.setAttribute("width", String(width2));
        image.setAttribute("height", String(height2));
        image.setAttribute("preserveAspectRatio", "none");
        image.setAttribute("transform", "scale(".concat(1 / pixelRatio, ") rotate(").concat(rotation, ", ").concat(width2 / 2, ", ").concat(height2 / 2, ")"));
        pattern.appendChild(image);
        return pattern;
    }
    constructor(imageLoader, imageOptions){
        this.imageLoader = imageLoader;
        this._cache = void 0;
        this.url = imageOptions.url;
        var _imageOptions_backgroundFill;
        this.backgroundFill = (_imageOptions_backgroundFill = imageOptions.backgroundFill) !== null && _imageOptions_backgroundFill !== void 0 ? _imageOptions_backgroundFill : "black";
        var _imageOptions_backgroundFillOpacity;
        this.backgroundFillOpacity = (_imageOptions_backgroundFillOpacity = imageOptions.backgroundFillOpacity) !== null && _imageOptions_backgroundFillOpacity !== void 0 ? _imageOptions_backgroundFillOpacity : 1;
        var _imageOptions_repeat;
        this.repeat = (_imageOptions_repeat = imageOptions.repeat) !== null && _imageOptions_repeat !== void 0 ? _imageOptions_repeat : "no-repeat";
        this.width = imageOptions.width;
        this.height = imageOptions.height;
        var _imageOptions_fit;
        this.fit = (_imageOptions_fit = imageOptions.fit) !== null && _imageOptions_fit !== void 0 ? _imageOptions_fit : "stretch";
        var _imageOptions_rotation;
        this.rotation = (_imageOptions_rotation = imageOptions.rotation) !== null && _imageOptions_rotation !== void 0 ? _imageOptions_rotation : 0;
    }
};
;
// packages/ag-charts-community/src/util/distance.ts
function pointsDistanceSquared(x1, y1, x2, y2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return dx * dx + dy * dy;
}
function lineDistanceSquared(x, y, x1, y1, x2, y2, best) {
    if (x1 === x2 && y1 === y2) {
        return Math.min(best, pointsDistanceSquared(x, y, x1, y1));
    }
    const dx = x2 - x1;
    const dy = y2 - y1;
    const t = Math.max(0, Math.min(1, ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)));
    const ix = x1 + t * dx;
    const iy = y1 + t * dy;
    return Math.min(best, pointsDistanceSquared(x, y, ix, iy));
}
;
var commandEx = /^[\t\n\f\r ]*([achlmqstvz])[\t\n\f\r ]*/i;
var coordinateEx = /^[+-]?((\d*\.\d+)|(\d+\.)|(\d+))(e[+-]?\d+)?/i;
var commaEx = /[\t\n\f\r ]*,?[\t\n\f\r ]*/;
var flagEx = /^[01]/;
var pathParams = {
    z: [],
    h: [
        coordinateEx
    ],
    v: [
        coordinateEx
    ],
    m: [
        coordinateEx,
        coordinateEx
    ],
    l: [
        coordinateEx,
        coordinateEx
    ],
    t: [
        coordinateEx,
        coordinateEx
    ],
    s: [
        coordinateEx,
        coordinateEx,
        coordinateEx,
        coordinateEx
    ],
    q: [
        coordinateEx,
        coordinateEx,
        coordinateEx,
        coordinateEx
    ],
    c: [
        coordinateEx,
        coordinateEx,
        coordinateEx,
        coordinateEx,
        coordinateEx,
        coordinateEx
    ],
    a: [
        coordinateEx,
        coordinateEx,
        coordinateEx,
        flagEx,
        flagEx,
        coordinateEx,
        coordinateEx
    ]
};
function parseSvg(d) {
    if (!d) return;
    const segments = [];
    let i = 0;
    let currentCommand;
    while(i < d.length){
        const commandMatch = commandEx.exec(d.slice(i));
        let command;
        if (commandMatch == null) {
            if (!currentCommand) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Invalid SVG path, error at index ".concat(i, ": Missing command."));
                return;
            }
            command = currentCommand;
        } else {
            command = commandMatch[1];
            i += commandMatch[0].length;
        }
        const segment = parseSegment(command, d, i);
        if (!segment) return;
        i = segment[0];
        currentCommand = command;
        segments.push(segment[1]);
    }
    return segments;
}
function parseSegment(command, d, index) {
    const params = pathParams[command.toLocaleLowerCase()];
    const pathSeg = {
        command,
        params: []
    };
    for (const regex of params){
        const segment = d.slice(index);
        const match = regex.exec(segment);
        if (match != null) {
            pathSeg.params.push(parseFloat(match[0]));
            index += match[0].length;
            const next = commaEx.exec(segment.slice(match[0].length));
            if (next != null) {
                index += next[0].length;
            }
        } else if (pathSeg.params.length === 1) {
            return [
                index,
                pathSeg
            ];
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Invalid SVG path, error at index ".concat(index, ": No path segment parameters for command [").concat(command, "]"));
            return;
        }
    }
    return [
        index,
        pathSeg
    ];
}
// packages/ag-charts-community/src/scene/polyRoots.ts
function linearRoot(a, b) {
    const t = -b / a;
    return a !== 0 && t >= 0 && t <= 1 ? [
        t
    ] : [];
}
function quadraticRoots(a, b, c) {
    let delta3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1e-6;
    if (Math.abs(a) < delta3) {
        return linearRoot(b, c);
    }
    const D = b * b - 4 * a * c;
    const roots = [];
    if (Math.abs(D) < delta3) {
        const t = -b / (2 * a);
        if (t >= 0 && t <= 1) {
            roots.push(t);
        }
    } else if (D > 0) {
        const rD = Math.sqrt(D);
        const t1 = (-b - rD) / (2 * a);
        const t2 = (-b + rD) / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
            roots.push(t1);
        }
        if (t2 >= 0 && t2 <= 1) {
            roots.push(t2);
        }
    }
    return roots;
}
function cubicRoots(a, b, c, d) {
    let delta3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1e-6;
    if (Math.abs(a) < delta3) {
        return quadraticRoots(b, c, d, delta3);
    }
    const A = b / a;
    const B = c / a;
    const C2 = d / a;
    const Q = (3 * B - A * A) / 9;
    const R = (9 * A * B - 27 * C2 - 2 * A * A * A) / 54;
    const D = Q * Q * Q + R * R;
    const third = 1 / 3;
    const roots = [];
    if (D >= 0) {
        const rD = Math.sqrt(D);
        const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);
        const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);
        const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);
        const t = -third * A + (S + T);
        if (t >= 0 && t <= 1) {
            roots.push(t);
        }
        if (Math.abs(Im) < delta3) {
            const t2 = -third * A - (S + T) / 2;
            if (t2 >= 0 && t2 <= 1) {
                roots.push(t2);
            }
        }
    } else {
        const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));
        const thirdA = third * A;
        const twoSqrtQ = 2 * Math.sqrt(-Q);
        const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;
        const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;
        const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;
        if (t1 >= 0 && t1 <= 1) {
            roots.push(t1);
        }
        if (t2 >= 0 && t2 <= 1) {
            roots.push(t2);
        }
        if (t3 >= 0 && t3 <= 1) {
            roots.push(t3);
        }
    }
    return roots;
}
// packages/ag-charts-community/src/scene/intersection.ts
function segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
    const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);
    if (d === 0) {
        return 0;
    }
    const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;
    const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;
    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
        return 1;
    }
    return 0;
}
function cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {
    let intersections = 0;
    const A = y1 - y2;
    const B = x2 - x1;
    const C2 = x1 * (y2 - y1) - y1 * (x2 - x1);
    const bx = bezierCoefficients(px1, px2, px3, px4);
    const by = bezierCoefficients(py1, py2, py3, py4);
    const a = A * bx[0] + B * by[0];
    const b = A * bx[1] + B * by[1];
    const c = A * bx[2] + B * by[2];
    const d = A * bx[3] + B * by[3] + C2;
    const roots = cubicRoots(a, b, c, d);
    for (const t of roots){
        const tt = t * t;
        const ttt = t * tt;
        const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];
        const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];
        let s;
        if (x1 === x2) {
            s = (y - y1) / (y2 - y1);
        } else {
            s = (x - x1) / (x2 - x1);
        }
        if (s >= 0 && s <= 1) {
            intersections++;
        }
    }
    return intersections;
}
function bezierCoefficients(P1, P2, P3, P4) {
    return [
        // Bzier expressed as matrix operations:
        //                 |-1  3 -3  1| |P1|
        //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|
        //                 |-3  3  0  0| |P3|
        //                 | 1  0  0  0| |P4|
        -P1 + 3 * P2 - 3 * P3 + P4,
        3 * P1 - 6 * P2 + 3 * P3,
        -3 * P1 + 3 * P2,
        P1
    ];
}
;
function evaluateBezier(p0, p1, p2, p3, t) {
    return (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;
}
function solveBezier(p0, p1, p2, p3, value) {
    if (value <= Math.min(p0, p3)) {
        return p0 < p3 ? 0 : 1;
    } else if (value >= Math.max(p0, p3)) {
        return p0 < p3 ? 1 : 0;
    }
    let t0 = 0;
    let t1 = 1;
    let t = NaN;
    for(let i = 0; i < 12; i += 1){
        t = (t0 + t1) / 2;
        const curveValue = evaluateBezier(p0, p1, p2, p3, t);
        if (curveValue < value) {
            t0 = t;
        } else {
            t1 = t;
        }
    }
    return t;
}
function splitBezier2D(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t) {
    const x01 = (1 - t) * p0x + t * p1x;
    const y01 = (1 - t) * p0y + t * p1y;
    const x12 = (1 - t) * p1x + t * p2x;
    const y12 = (1 - t) * p1y + t * p2y;
    const x23 = (1 - t) * p2x + t * p3x;
    const y23 = (1 - t) * p2y + t * p3y;
    const x012 = (1 - t) * x01 + t * x12;
    const y012 = (1 - t) * y01 + t * y12;
    const x123 = (1 - t) * x12 + t * x23;
    const y123 = (1 - t) * y12 + t * y23;
    const x0123 = (1 - t) * x012 + t * x123;
    const y0123 = (1 - t) * y012 + t * y123;
    return [
        [
            {
                x: p0x,
                y: p0y
            },
            {
                x: x01,
                y: y01
            },
            {
                x: x012,
                y: y012
            },
            {
                x: x0123,
                y: y0123
            }
        ],
        [
            {
                x: x0123,
                y: y0123
            },
            {
                x: x123,
                y: y123
            },
            {
                x: x23,
                y: y23
            },
            {
                x: p3x,
                y: p3y
            }
        ]
    ];
}
function calculateDerivativeExtrema(p0, p1, p2, p3) {
    const a = -p0 + 3 * p1 - 3 * p2 + p3;
    const b = 2 * (p0 - 2 * p1 + p2);
    const c = -p0 + p1;
    if (a === 0) {
        if (b !== 0) {
            const t = -c / b;
            if (t > 0 && t < 1) {
                return [
                    t
                ];
            }
        }
        return [];
    }
    const discriminant = b * b - 4 * a * c;
    if (discriminant >= 0) {
        const sqrtDiscriminant = Math.sqrt(discriminant);
        const t1 = (-b + sqrtDiscriminant) / (2 * a);
        const t2 = (-b - sqrtDiscriminant) / (2 * a);
        return [
            t1,
            t2
        ].filter((t)=>t > 0 && t < 1);
    }
    return [];
}
function bezier2DExtrema(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y) {
    const tx = calculateDerivativeExtrema(cp0x, cp1x, cp2x, cp3x);
    const ty = calculateDerivativeExtrema(cp0y, cp1y, cp2y, cp3y);
    return [
        ...tx,
        ...ty
    ];
}
function bezierCandidate(points, x, y) {
    const midX = evaluateBezier(points[0].x, points[1].x, points[2].x, points[3].x, 0.5);
    const midY = evaluateBezier(points[0].y, points[1].y, points[2].y, points[3].y, 0.5);
    const distance2 = Math.hypot(midX - x, midY - y);
    const minDistance = Math.min(Math.hypot(points[0].x - x, points[0].y - y), Math.hypot(points[1].x - x, points[1].y - y), Math.hypot(points[2].x - x, points[2].y - y), Math.hypot(points[3].x - x, points[3].y - y));
    return {
        points,
        distance: distance2,
        minDistance
    };
}
function bezier2DDistance(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, x, y) {
    let precision = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : 1;
    const points0 = [
        {
            x: cp0x,
            y: cp0y
        },
        {
            x: cp1x,
            y: cp1y
        },
        {
            x: cp2x,
            y: cp2y
        },
        {
            x: cp3x,
            y: cp3y
        }
    ];
    let queue = {
        value: bezierCandidate(points0, x, y),
        next: null
    };
    let bestResult;
    while(queue != null){
        const { points, distance: distance2, minDistance } = queue.value;
        queue = queue.next;
        if (bestResult == null || distance2 < bestResult.distance) {
            bestResult = {
                distance: distance2,
                minDistance
            };
        }
        if (bestResult != null && bestResult.distance - minDistance <= precision) {
            continue;
        }
        const [leftPoints, rightPoints] = splitBezier2D(points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y, 0.5);
        const newCandidates = [
            bezierCandidate(leftPoints, x, y),
            bezierCandidate(rightPoints, x, y)
        ].sort(bezierCandidateCmp);
        queue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insertListItemsSorted"])(queue, newCandidates, bezierCandidateCmp);
    }
    var _bestResult_distance;
    return (_bestResult_distance = bestResult === null || bestResult === void 0 ? void 0 : bestResult.distance) !== null && _bestResult_distance !== void 0 ? _bestResult_distance : Infinity;
}
var bezierCandidateCmp = (a, b)=>b.minDistance - a.minDistance;
// packages/ag-charts-community/src/scene/extendedPath2D.ts
var ExtendedPath2D = class {
    isEmpty() {
        return this.commands.length === 0;
    }
    isDirty() {
        return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();
    }
    getPath2D() {
        return this.path2d;
    }
    moveTo(x, y) {
        this.openedPath = true;
        this.sx = x;
        this.sy = y;
        this.cx = x;
        this.cy = y;
        this.path2d.moveTo(x, y);
        this.commands.push(0 /* Move */ );
        this.params.push(x, y);
    }
    lineTo(x, y) {
        if (this.openedPath) {
            this.cx = x;
            this.cy = y;
            this.path2d.lineTo(x, y);
            this.commands.push(1 /* Line */ );
            this.params.push(x, y);
        } else {
            this.moveTo(x, y);
        }
    }
    cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {
        if (!this.openedPath) {
            this.moveTo(cx1, cy1);
        }
        this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);
        this.commands.push(2 /* Curve */ );
        this.params.push(cx1, cy1, cx2, cy2, x, y);
    }
    closePath() {
        if (this.openedPath) {
            this.cx = this.sx;
            this.cy = this.sy;
            this.sx = NaN;
            this.sy = NaN;
            this.path2d.closePath();
            this.commands.push(3 /* ClosePath */ );
            this.openedPath = false;
            this.closedPath = true;
        }
    }
    rect(x, y, width2, height2) {
        this.moveTo(x, y);
        this.lineTo(x + width2, y);
        this.lineTo(x + width2, y + height2);
        this.lineTo(x, y + height2);
        this.closePath();
    }
    roundRect(x, y, width2, height2, radii) {
        radii = Math.min(radii, width2 / 2, height2 / 2);
        this.moveTo(x, y + radii);
        this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);
        this.lineTo(x + radii, y);
        this.lineTo(x + width2 - radii, y);
        this.arc(x + width2 - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);
        this.lineTo(x + width2, y + radii);
        this.lineTo(x + width2, y + height2 - radii);
        this.arc(x + width2 - radii, y + height2 - radii, radii, 0, Math.PI / 2);
        this.lineTo(x + width2 - radii, y + height2);
        this.lineTo(x + radii, y + height2);
        this.arc(x + +radii, y + height2 - radii, radii, Math.PI / 2, Math.PI);
        this.lineTo(x, y + height2 - radii);
        this.closePath();
    }
    ellipse(cx, cy, rx, ry, rotation, sAngle, eAngle) {
        let counterClockwise = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
        const r = rx;
        const scaleY = ry / rx;
        const mxx = Math.cos(rotation);
        const myx = Math.sin(rotation);
        const mxy = -scaleY * myx;
        const myy = scaleY * mxx;
        const x0 = r * Math.cos(sAngle);
        const y0 = r * Math.sin(sAngle);
        const sx = cx + mxx * x0 + mxy * y0;
        const sy = cy + myx * x0 + myy * y0;
        const distanceSquared2 = (sx - this.cx) ** 2 + (sy - this.cy) ** 2;
        if (!this.openedPath) {
            this.moveTo(sx, sy);
        } else if (distanceSquared2 > 1e-6) {
            this.lineTo(sx, sy);
        }
        let sweep = counterClockwise ? -normalizeAngle360(sAngle - eAngle) : normalizeAngle360(eAngle - sAngle);
        if (Math.abs(Math.abs(eAngle - sAngle) - 2 * Math.PI) < 1e-6 && sweep < 2 * Math.PI) {
            sweep += 2 * Math.PI * (counterClockwise ? -1 : 1);
        }
        const arcSections = Math.max(Math.ceil(Math.abs(sweep) / (Math.PI / 2)), 1);
        const step = sweep / arcSections;
        const h = 4 / 3 * Math.tan(step / 4);
        for(let i = 0; i < arcSections; i += 1){
            const a0 = sAngle + step * (i + 0);
            const a1 = sAngle + step * (i + 1);
            const rSinStart = r * Math.sin(a0);
            const rCosStart = r * Math.cos(a0);
            const rSinEnd = r * Math.sin(a1);
            const rCosEnd = r * Math.cos(a1);
            const cp1x = rCosStart - h * rSinStart;
            const cp1y = rSinStart + h * rCosStart;
            const cp2x = rCosEnd + h * rSinEnd;
            const cp2y = rSinEnd - h * rCosEnd;
            const cp3x = rCosEnd;
            const cp3y = rSinEnd;
            this.cubicCurveTo(cx + mxx * cp1x + mxy * cp1y, cy + myx * cp1x + myy * cp1y, cx + mxx * cp2x + mxy * cp2y, cy + myx * cp2x + myy * cp2y, cx + mxx * cp3x + mxy * cp3y, cy + myx * cp3x + myy * cp3y);
        }
    }
    arc(x, y, r, sAngle, eAngle, counterClockwise) {
        this.ellipse(x, y, r, r, 0, sAngle, eAngle, counterClockwise);
    }
    appendSvg(svg) {
        const parts = parseSvg(svg);
        if (parts == null) return false;
        let sx = 0;
        let sy = 0;
        let cx;
        let cy;
        let cpx = 0;
        let cpy = 0;
        for (const { command, params } of parts){
            cx !== null && cx !== void 0 ? cx : cx = params[0];
            cy !== null && cy !== void 0 ? cy : cy = params[1];
            const relative = command === command.toLowerCase();
            const dx = relative ? cx : 0;
            const dy = relative ? cy : 0;
            switch(command.toLowerCase()){
                case "m":
                    this.moveTo(dx + params[0], dy + params[1]);
                    cx = dx + params[0];
                    cy = dy + params[1];
                    sx = cx;
                    sy = cy;
                    break;
                case "c":
                    this.cubicCurveTo(dx + params[0], dy + params[1], dx + params[2], dy + params[3], dx + params[4], dy + params[5]);
                    cpx = dx + params[2];
                    cpy = dy + params[3];
                    cx = dx + params[4];
                    cy = dy + params[5];
                    break;
                case "s":
                    this.cubicCurveTo(cx + cx - cpx, cy + cy - cpy, dx + params[0], dy + params[1], dx + params[2], dy + params[3]);
                    cpx = dx + params[0];
                    cpy = dy + params[1];
                    cx = dx + params[2];
                    cy = dy + params[3];
                    break;
                case "q":
                    this.cubicCurveTo((dx + 2 * params[0]) / 3, (dy + 2 * params[1]) / 3, (2 * params[0] + params[2]) / 3, (2 * params[1] + params[3]) / 3, params[2], params[3]);
                    cpx = params[0];
                    cpy = params[1];
                    cx = params[2];
                    cy = params[3];
                    break;
                case "t":
                    this.cubicCurveTo((cx + 2 * (cx + cx - cpx)) / 3, (cy + 2 * (cy + cy - cpy)) / 3, (2 * (cx + cx - cpx) + params[0]) / 3, (2 * (cy + cy - cpy) + params[1]) / 3, params[0], params[1]);
                    cpx = cx + cx - cpx;
                    cpy = cy + cy - cpy;
                    cx = params[0];
                    cy = params[1];
                    break;
                case "a":
                    this.svgEllipse(cx, cy, params[0], params[1], params[2] * Math.PI / 180, params[3], params[4], dx + params[5], dy + params[6]);
                    cx = dx + params[5];
                    cy = dy + params[6];
                    break;
                case "h":
                    this.lineTo(dx + params[0], cy);
                    cx = dx + params[0];
                    break;
                case "l":
                    this.lineTo(dx + params[0], dy + params[1]);
                    cx = dx + params[0];
                    cy = dy + params[1];
                    break;
                case "v":
                    this.lineTo(cx, dy + params[0]);
                    cy = dy + params[0];
                    break;
                case "z":
                    this.closePath();
                    cx = sx;
                    cy = sy;
                    break;
                default:
                    throw new Error("Could not translate command '".concat(command, "' with '").concat(params.join(" "), "'"));
            }
        }
        return true;
    }
    svgEllipse(x1, y1, rx, ry, rotation, fA, fS, x2, y2) {
        rx = Math.abs(rx);
        ry = Math.abs(ry);
        const dx = (x1 - x2) / 2;
        const dy = (y1 - y2) / 2;
        const sin = Math.sin(rotation);
        const cos = Math.cos(rotation);
        const rotX = cos * dx + sin * dy;
        const rotY = -sin * dx + cos * dy;
        const normX = rotX / rx;
        const normY = rotY / ry;
        let scale2 = normX * normX + normY * normY;
        let cx = (x1 + x2) / 2;
        let cy = (y1 + y2) / 2;
        let cpx = 0;
        let cpy = 0;
        if (scale2 >= 1) {
            scale2 = Math.sqrt(scale2);
            rx *= scale2;
            ry *= scale2;
        } else {
            scale2 = Math.sqrt(1 / scale2 - 1);
            if (fA === fS) scale2 = -scale2;
            cpx = scale2 * rx * normY;
            cpy = -scale2 * ry * normX;
            cx += cos * cpx - sin * cpy;
            cy += sin * cpx + cos * cpy;
        }
        const sAngle = Math.atan2((rotY - cpy) / ry, (rotX - cpx) / rx);
        const deltaTheta = Math.atan2((-rotY - cpy) / ry, (-rotX - cpx) / rx) - sAngle;
        const eAngle = sAngle + deltaTheta;
        const counterClockwise = !!(1 - fS);
        this.ellipse(cx, cy, rx, ry, rotation, sAngle, eAngle, counterClockwise);
    }
    clear(trackChanges) {
        if (trackChanges) {
            this.previousCommands = this.commands;
            this.previousParams = this.params;
            this.previousClosedPath = this.closedPath;
        }
        this.path2d = new Path2D();
        this.openedPath = false;
        this.closedPath = false;
        this.commands = [];
        this.params = [];
    }
    isPointInPath(x, y) {
        const commands = this.commands;
        const params = this.params;
        const cn = commands.length;
        const ox = -1e4;
        const oy = -1e4;
        let sx = NaN;
        let sy = NaN;
        let px = 0;
        let py = 0;
        let intersectionCount = 0;
        for(let ci = 0, pi = 0; ci < cn; ci++){
            switch(commands[ci]){
                case 0 /* Move */ :
                    intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);
                    px = params[pi++];
                    sx = px;
                    py = params[pi++];
                    sy = py;
                    break;
                case 1 /* Line */ :
                    intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);
                    px = params[pi - 2];
                    py = params[pi - 1];
                    break;
                case 2 /* Curve */ :
                    intersectionCount += cubicSegmentIntersections(px, py, params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], ox, oy, x, y);
                    px = params[pi - 2];
                    py = params[pi - 1];
                    break;
                case 3 /* ClosePath */ :
                    intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);
                    break;
            }
        }
        return intersectionCount % 2 === 1;
    }
    distanceSquared(x, y) {
        let best = Infinity;
        const commands = this.commands;
        const params = this.params;
        const cn = commands.length;
        let sx = NaN;
        let sy = NaN;
        let cx = 0;
        let cy = 0;
        for(let ci = 0, pi = 0; ci < cn; ci++){
            switch(commands[ci]){
                case 0 /* Move */ :
                    cx = sx = params[pi++];
                    cy = sy = params[pi++];
                    break;
                case 1 /* Line */ :
                    {
                        const x0 = cx;
                        const y0 = cy;
                        cx = params[pi++];
                        cy = params[pi++];
                        best = lineDistanceSquared(x, y, x0, y0, cx, cy, best);
                        break;
                    }
                case 2 /* Curve */ :
                    const cp0x = cx;
                    const cp0y = cy;
                    const cp1x = params[pi++];
                    const cp1y = params[pi++];
                    const cp2x = params[pi++];
                    const cp2y = params[pi++];
                    cx = params[pi++];
                    cy = params[pi++];
                    best = bezier2DDistance(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cx, cy, x, y) ** 2;
                    break;
                case 3 /* ClosePath */ :
                    best = lineDistanceSquared(x, y, cx, cy, sx, sy, best);
                    break;
            }
        }
        return best;
    }
    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
    toSVG() {
        let transform = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (x, y)=>({
                x,
                y
            });
        const buffer = [];
        const { commands, params } = this;
        const addCommand = (command, count)=>{
            buffer.push(command);
            for(let i = 0; i < count; i += 2){
                const { x, y } = transform(params[pi++], params[pi++]);
                buffer.push(x, y);
            }
        };
        let pi = 0;
        for (const command of commands){
            switch(command){
                case 0 /* Move */ :
                    addCommand("M", 2);
                    break;
                case 1 /* Line */ :
                    addCommand("L", 2);
                    break;
                case 2 /* Curve */ :
                    addCommand("C", 6);
                    break;
                case 3 /* ClosePath */ :
                    addCommand("Z", 0);
                    break;
            }
        }
        return buffer.join(" ");
    }
    computeBBox() {
        const { commands, params } = this;
        let [top, left, right, bot] = [
            Infinity,
            Infinity,
            -Infinity,
            -Infinity
        ];
        let [cx, cy] = [
            NaN,
            NaN
        ];
        let [sx, sy] = [
            NaN,
            NaN
        ];
        const joinPoint = (x, y)=>{
            top = Math.min(y, top);
            left = Math.min(x, left);
            right = Math.max(x, right);
            bot = Math.max(y, bot);
            cx = x;
            cy = y;
        };
        let pi = 0;
        for (const command of commands){
            switch(command){
                case 0 /* Move */ :
                    joinPoint(params[pi++], params[pi++]);
                    sx = cx;
                    sy = cy;
                    break;
                case 1 /* Line */ :
                    joinPoint(params[pi++], params[pi++]);
                    break;
                case 2 /* Curve */ :
                    {
                        const cp0x = cx;
                        const cp0y = cy;
                        const cp1x = params[pi++];
                        const cp1y = params[pi++];
                        const cp2x = params[pi++];
                        const cp2y = params[pi++];
                        const cp3x = params[pi++];
                        const cp3y = params[pi++];
                        const ts = bezier2DExtrema(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y);
                        ts.forEach((t)=>{
                            const px = evaluateBezier(cp0x, cp1x, cp2x, cp3x, t);
                            const py = evaluateBezier(cp0y, cp1y, cp2y, cp3y, t);
                            joinPoint(px, py);
                        });
                        joinPoint(cp3x, cp3y);
                        break;
                    }
                case 3 /* ClosePath */ :
                    joinPoint(sx, sy);
                    sx = NaN;
                    sy = NaN;
                    break;
            }
        }
        return new BBox(left, top, right - left, bot - top);
    }
    constructor(){
        // The methods of this class will likely be called many times per animation frame,
        // and any allocation can trigger a GC cycle during animation, so we attempt
        // to minimize the number of allocations.
        this.path2d = new Path2D();
        this.previousCommands = [];
        this.previousParams = [];
        this.previousClosedPath = false;
        this.commands = [];
        this.params = [];
        this.cx = NaN;
        this.cy = NaN;
        this.sx = NaN;
        this.sy = NaN;
        this.openedPath = false;
        this.closedPath = false;
    }
};
// packages/ag-charts-community/src/scene/util/pixel.ts
function align(pixelRatio, start2, length2) {
    const alignedStart = Math.round(start2 * pixelRatio) / pixelRatio;
    if (length2 == null) {
        return alignedStart;
    } else if (length2 === 0) {
        return 0;
    } else if (length2 < 1) {
        return Math.ceil(length2 * pixelRatio) / pixelRatio;
    }
    return Math.round((length2 + start2) * pixelRatio) / pixelRatio - alignedStart;
}
function alignBefore(pixelRatio, start2) {
    return Math.floor(start2 * pixelRatio) / pixelRatio;
}
// packages/ag-charts-community/src/scene/pattern/patterns.ts
function drawPatternUnitPolygon(path, params, moves) {
    const { width: width2, height: height2, padding: padding2, strokeWidth } = params;
    const x0 = width2 / 2;
    const y0 = height2 / 2;
    const w = Math.max(1, width2 - padding2 - strokeWidth / 2);
    const h = Math.max(1, height2 - padding2 - strokeWidth / 2);
    let didMove = false;
    for (const [dx, dy] of moves){
        const x = x0 + (dx - 0.5) * w;
        const y = y0 + (dy - 0.5) * h;
        if (didMove) {
            path.lineTo(x, y);
        } else {
            path.moveTo(x, y);
        }
        didMove = true;
    }
    path.closePath();
}
var PATTERNS = {
    circles (path, param) {
        let { width: width2, strokeWidth, padding: padding2 } = param;
        const c = width2 / 2;
        const r = Math.max(1, c - padding2 - strokeWidth / 2);
        path.arc(c, c, r, 0, Math.PI * 2);
    },
    squares (path, param) {
        let { width: width2, height: height2, pixelRatio, padding: padding2, strokeWidth } = param;
        const offset = padding2 + strokeWidth / 2;
        path.moveTo(align(pixelRatio, offset), align(pixelRatio, offset));
        path.lineTo(align(pixelRatio, width2 - offset), align(pixelRatio, offset));
        path.lineTo(align(pixelRatio, width2 - offset), align(pixelRatio, height2 - offset));
        path.lineTo(align(pixelRatio, offset), align(pixelRatio, height2 - offset));
        path.closePath();
    },
    triangles (path, params) {
        drawPatternUnitPolygon(path, params, [
            [
                0.5,
                0
            ],
            [
                1,
                1
            ],
            [
                0,
                1
            ]
        ]);
    },
    diamonds (path, params) {
        drawPatternUnitPolygon(path, params, [
            [
                0.5,
                0
            ],
            [
                1,
                0.5
            ],
            [
                0.5,
                1
            ],
            [
                0,
                0.5
            ]
        ]);
    },
    stars (path, param) {
        let { width: width2, height: height2, padding: padding2 } = param;
        const spikes = 5;
        const outerRadius = Math.max(1, (width2 - padding2) / 2);
        const innerRadius = outerRadius / 2;
        const rotation = Math.PI / 2;
        for(let i = 0; i < spikes * 2; i++){
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle2 = i * Math.PI / spikes - rotation;
            const xCoordinate = width2 / 2 + Math.cos(angle2) * radius;
            const yCoordinate = height2 / 2 + Math.sin(angle2) * radius;
            path.lineTo(xCoordinate, yCoordinate);
        }
        path.closePath();
    },
    hearts (path, param) {
        let { width: width2, height: height2, padding: padding2 } = param;
        const r = Math.max(1, width2 / 4 - padding2 / 2);
        const x = width2 / 2;
        const y = height2 / 2 + r / 2;
        path.arc(x - r, y - r, r, toRadians(130), toRadians(330));
        path.arc(x + r, y - r, r, toRadians(220), toRadians(50));
        path.lineTo(x, y + r);
        path.closePath();
    },
    crosses (path, params) {
        drawPatternUnitPolygon(path, params, [
            [
                0.25,
                0
            ],
            [
                0.5,
                0.25
            ],
            [
                0.75,
                0
            ],
            [
                1,
                0.25
            ],
            [
                0.75,
                0.5
            ],
            [
                1,
                0.75
            ],
            [
                0.75,
                1
            ],
            [
                0.5,
                0.75
            ],
            [
                0.25,
                1
            ],
            [
                0,
                0.75
            ],
            [
                0.25,
                0.5
            ],
            [
                0,
                0.25
            ]
        ]);
    },
    "vertical-lines" (path, param) {
        let { width: width2, height: height2, pixelRatio, strokeWidth } = param;
        const x = align(pixelRatio, width2 / 2) - strokeWidth % 2 / 2;
        path.moveTo(x, 0);
        path.lineTo(x, height2);
    },
    "horizontal-lines" (path, param) {
        let { width: width2, height: height2, pixelRatio, strokeWidth } = param;
        const y = align(pixelRatio, height2 / 2) - strokeWidth % 2 / 2;
        path.moveTo(0, y);
        path.lineTo(width2, y);
    },
    "forward-slanted-lines" (path, param) {
        let { width: width2, height: height2, strokeWidth } = param;
        const angle2 = Math.atan2(height2, width2);
        const insetX = strokeWidth * Math.cos(angle2);
        const insetY = strokeWidth * Math.sin(angle2);
        path.moveTo(-insetX, insetY);
        path.lineTo(insetX, -insetY);
        path.moveTo(-insetX, height2 + insetY);
        path.lineTo(width2 + insetX, -insetY);
        path.moveTo(width2 - insetX, height2 + insetY);
        path.lineTo(width2 + insetX, height2 - insetY);
    },
    "backward-slanted-lines" (path, param) {
        let { width: width2, height: height2, strokeWidth } = param;
        const angle2 = Math.atan2(height2, width2);
        const insetX = strokeWidth * Math.cos(angle2);
        const insetY = strokeWidth * Math.sin(angle2);
        path.moveTo(width2 - insetX, -insetY);
        path.lineTo(width2 + insetX, insetY);
        path.moveTo(-insetX, -insetY);
        path.lineTo(width2 + insetX, height2 + insetY);
        path.moveTo(-insetX, height2 - insetY);
        path.lineTo(insetX, height2 + insetY);
    }
};
// packages/ag-charts-community/src/scene/pattern/pattern.ts
var Pattern = class {
    getPath(pixelRatio) {
        const { pattern, width: width2, height: height2, padding: padding2, strokeWidth, path: svgPath } = this;
        const path = new ExtendedPath2D();
        let renderPattern = PATTERNS[pattern] != null;
        if (svgPath) {
            renderPattern && (renderPattern = !path.appendSvg(svgPath));
        }
        if (renderPattern) {
            PATTERNS[pattern](path, {
                width: width2,
                height: height2,
                pixelRatio,
                strokeWidth,
                padding: padding2
            });
        }
        return path;
    }
    renderStroke(path2d, ctx) {
        const { stroke: stroke2, strokeWidth, strokeOpacity } = this;
        if (!strokeWidth) return;
        ctx.strokeStyle = stroke2;
        ctx.lineWidth = strokeWidth;
        ctx.globalAlpha = strokeOpacity;
        ctx.stroke(path2d);
    }
    renderFill(path2d, ctx) {
        const { fill, fillOpacity } = this;
        if (fill === "none") {
            return;
        }
        ctx.fillStyle = fill;
        ctx.globalAlpha = fillOpacity;
        ctx.fill(path2d);
    }
    createCanvasPattern(ctx, pixelRatio) {
        const { width: width2, height: height2, scale: scale2, backgroundFill, backgroundFillOpacity } = this;
        if (width2 * scale2 < 1 || height2 * scale2 < 1) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Pattern fill is too small to render, ignoring.");
            return null;
        }
        const offscreenPattern = new HdpiOffscreenCanvas({
            width: width2,
            height: height2,
            pixelRatio: pixelRatio * scale2
        });
        const offscreenPatternCtx = offscreenPattern.context;
        if (backgroundFill !== "none") {
            offscreenPatternCtx.fillStyle = backgroundFill;
            offscreenPatternCtx.globalAlpha = backgroundFillOpacity;
            offscreenPatternCtx.fillRect(0, 0, width2, height2);
        }
        const path2d = this.getPath(pixelRatio).getPath2D();
        this.renderFill(path2d, offscreenPatternCtx);
        this.renderStroke(path2d, offscreenPatternCtx);
        const pattern = ctx.createPattern(offscreenPattern.canvas, "repeat");
        this.setPatternTransform(pattern, pixelRatio);
        offscreenPattern.destroy();
        return pattern;
    }
    setPatternTransform(pattern, pixelRatio) {
        let tx = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ty = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (pattern == null) return;
        const angle2 = normalizeAngle360FromDegrees(this.rotation);
        const scale2 = 1 / pixelRatio;
        const cos = Math.cos(angle2) * scale2;
        const sin = Math.sin(angle2) * scale2;
        pattern.setTransform(new DOMMatrix([
            cos,
            sin,
            -sin,
            cos,
            tx,
            ty
        ]));
    }
    createPattern(ctx, pixelRatio) {
        if (this._cache != null && this._cache.ctx === ctx && this._cache.pixelRatio === pixelRatio) {
            return this._cache.pattern;
        }
        const pattern = this.createCanvasPattern(ctx, pixelRatio);
        if (pattern == null) return;
        this._cache = {
            ctx,
            pattern,
            pixelRatio
        };
        return pattern;
    }
    toSvg() {
        const { width: width2, height: height2, fill, fillOpacity, backgroundFill, backgroundFillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, rotation, scale: scale2 } = this;
        const pattern = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("pattern");
        pattern.setAttribute("viewBox", "0 0 ".concat(width2, " ").concat(height2));
        pattern.setAttribute("width", String(width2));
        pattern.setAttribute("height", String(height2));
        pattern.setAttribute("patternUnits", "userSpaceOnUse");
        const rect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("rect");
        rect.setAttribute("x", "0");
        rect.setAttribute("y", "0");
        rect.setAttribute("width", String(width2));
        rect.setAttribute("height", String(height2));
        rect.setAttribute("fill", backgroundFill);
        rect.setAttribute("fill-opacity", String(backgroundFillOpacity));
        pattern.appendChild(rect);
        const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("path");
        path.setAttribute("fill", fill);
        path.setAttribute("fill-opacity", String(fillOpacity));
        path.setAttribute("stroke-opacity", String(strokeOpacity));
        path.setAttribute("stroke", stroke2);
        path.setAttribute("stroke-width", String(strokeWidth));
        path.setAttribute("transform", "rotate(".concat(rotation, ") scale(").concat(scale2, ")"));
        path.setAttribute("d", this.getPath(1).toSVG());
        pattern.appendChild(path);
        return pattern;
    }
    constructor(patternOptions){
        this._cache = void 0;
        var _patternOptions_width;
        this.width = Math.max((_patternOptions_width = patternOptions === null || patternOptions === void 0 ? void 0 : patternOptions.width) !== null && _patternOptions_width !== void 0 ? _patternOptions_width : 10, 1);
        var _patternOptions_height;
        this.height = Math.max((_patternOptions_height = patternOptions === null || patternOptions === void 0 ? void 0 : patternOptions.height) !== null && _patternOptions_height !== void 0 ? _patternOptions_height : 10, 1);
        var _patternOptions_fill;
        this.fill = (_patternOptions_fill = patternOptions.fill) !== null && _patternOptions_fill !== void 0 ? _patternOptions_fill : "none";
        var _patternOptions_fillOpacity;
        this.fillOpacity = (_patternOptions_fillOpacity = patternOptions.fillOpacity) !== null && _patternOptions_fillOpacity !== void 0 ? _patternOptions_fillOpacity : 1;
        var _patternOptions_backgroundFill;
        this.backgroundFill = (_patternOptions_backgroundFill = patternOptions.backgroundFill) !== null && _patternOptions_backgroundFill !== void 0 ? _patternOptions_backgroundFill : "none";
        var _patternOptions_backgroundFillOpacity;
        this.backgroundFillOpacity = (_patternOptions_backgroundFillOpacity = patternOptions.backgroundFillOpacity) !== null && _patternOptions_backgroundFillOpacity !== void 0 ? _patternOptions_backgroundFillOpacity : 1;
        var _patternOptions_stroke;
        this.stroke = (_patternOptions_stroke = patternOptions.stroke) !== null && _patternOptions_stroke !== void 0 ? _patternOptions_stroke : "black";
        var _patternOptions_strokeOpacity;
        this.strokeOpacity = (_patternOptions_strokeOpacity = patternOptions.strokeOpacity) !== null && _patternOptions_strokeOpacity !== void 0 ? _patternOptions_strokeOpacity : 1;
        var _patternOptions_strokeWidth;
        this.strokeWidth = (_patternOptions_strokeWidth = patternOptions.strokeWidth) !== null && _patternOptions_strokeWidth !== void 0 ? _patternOptions_strokeWidth : 1;
        var _patternOptions_padding;
        this.padding = (_patternOptions_padding = patternOptions.padding) !== null && _patternOptions_padding !== void 0 ? _patternOptions_padding : 1;
        var _patternOptions_pattern;
        this.pattern = (_patternOptions_pattern = patternOptions.pattern) !== null && _patternOptions_pattern !== void 0 ? _patternOptions_pattern : "forward-slanted-lines";
        var _patternOptions_rotation;
        this.rotation = (_patternOptions_rotation = patternOptions.rotation) !== null && _patternOptions_rotation !== void 0 ? _patternOptions_rotation : 0;
        var _patternOptions_scale;
        this.scale = (_patternOptions_scale = patternOptions.scale) !== null && _patternOptions_scale !== void 0 ? _patternOptions_scale : 1;
        this.path = patternOptions.path;
    }
};
;
function isGradientFill(fill) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(fill) && fill.type == "gradient";
}
function isStringFillArray(fills) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(fills) && fills.every((fill)=>typeof fill === "string");
}
function isPatternFill(fill) {
    return fill !== null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(fill) && fill.type == "pattern";
}
function isImageFill(fill) {
    return fill !== null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(fill) && fill.type == "image";
}
function isGradientOrPatternFill(fill) {
    return isGradientFill(fill) || isPatternFill(fill);
}
// packages/ag-charts-community/src/scene/shape/svgUtils.ts
function setSvgFontAttributes(element2, options) {
    const { fontStyle, fontWeight, fontSize, fontFamily } = options;
    if (fontStyle) element2.setAttribute("font-style", fontStyle);
    if (fontWeight) element2.setAttribute("font-weight", String(fontWeight));
    if (fontSize != null) element2.setAttribute("font-size", String(fontSize));
    if (fontFamily) element2.setAttribute("font-family", fontFamily);
}
function setSvgStrokeAttributes(element2, options) {
    const { stroke: stroke2, strokeWidth, strokeOpacity } = options;
    if (stroke2) element2.setAttribute("stroke", stroke2);
    if (strokeWidth != null) element2.setAttribute("stroke-width", String(strokeWidth));
    if (strokeOpacity != null) element2.setAttribute("stroke-opacity", String(strokeOpacity));
}
function setSvgLineDashAttributes(element2, options) {
    const { lineDash, lineDashOffset } = options;
    if (lineDash === null || lineDash === void 0 ? void 0 : lineDash.some((d)=>d !== 0)) {
        const lineDashArray = lineDash.length % 2 === 1 ? [
            ...lineDash,
            ...lineDash
        ] : lineDash;
        element2.setAttribute("stroke-dasharray", lineDashArray.join(" "));
        if (lineDashOffset != null) element2.setAttribute("stroke-dashoffset", String(lineDashOffset));
    }
}
// packages/ag-charts-community/src/scene/shape/shape.ts
var Shape = class extends Node2 {
    getGradient(fill) {
        if (isGradientFill(fill)) return this.createGradient(fill);
    }
    createGradient(fill) {
        const { colorSpace = "rgb", gradient: gradient2 = "linear", colorStops, rotation = 0, reverse = false } = fill;
        if (colorStops == null) return;
        let stops = getColorStops(colorStops, [
            "black"
        ], [
            0,
            1
        ]);
        if (reverse) {
            stops = stops.map((s)=>({
                    color: s.color,
                    stop: 1 - s.stop
                })).reverse();
        }
        switch(gradient2){
            case "linear":
                return new LinearGradient(colorSpace, stops, rotation);
            case "radial":
                return new RadialGradient(colorSpace, stops);
            case "conic":
                return new ConicGradient(colorSpace, stops, rotation);
        }
    }
    getPattern(fill) {
        if (isPatternFill(fill)) return this.createPattern(fill);
    }
    createPattern(fill) {
        return new Pattern(fill);
    }
    getImage(fill) {
        if (isImageFill(fill)) return this.createImage(fill);
    }
    createImage(fill) {
        return new Image2(this.imageLoader, fill);
    }
    onFillChange() {
        if (typeof this.fill === "object") {
            var _this__cachedFill;
            if (objectsEqual((_this__cachedFill = this._cachedFill) !== null && _this__cachedFill !== void 0 ? _this__cachedFill : {}, this.fill)) {
                return;
            }
        }
        this.fillGradient = this.getGradient(this.fill);
        this.fillPattern = this.getPattern(this.fill);
        this.fillImage = this.getImage(this.fill);
        this._cachedFill = this.fill;
    }
    onStrokeChange() {
        this.strokeGradient = this.getGradient(this.stroke);
    }
    /**
   * Returns a device-pixel aligned coordinate (or length if length is supplied).
   *
   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle
   * of a device pixel.
   */ align(start2, length2) {
        var _this_layerManager_canvas, _this_layerManager;
        var _this_layerManager_canvas_pixelRatio;
        return align((_this_layerManager_canvas_pixelRatio = (_this_layerManager = this.layerManager) === null || _this_layerManager === void 0 ? void 0 : (_this_layerManager_canvas = _this_layerManager.canvas) === null || _this_layerManager_canvas === void 0 ? void 0 : _this_layerManager_canvas.pixelRatio) !== null && _this_layerManager_canvas_pixelRatio !== void 0 ? _this_layerManager_canvas_pixelRatio : 1, start2, length2);
    }
    markDirty(property) {
        super.markDirty(property);
        this.cachedDefaultGradientFillBBox = void 0;
    }
    fillStroke(ctx, path) {
        this.renderFill(ctx, path);
        this.renderStroke(ctx, path);
    }
    renderFill(ctx, path) {
        const { fill, fillOpacity, fillImage } = this;
        if (fill != null && fill !== "none" && fillOpacity > 0) {
            const { globalAlpha } = ctx;
            if (fillImage) {
                ctx.globalAlpha = fillImage.backgroundFillOpacity;
                ctx.fillStyle = fillImage.backgroundFill;
                this.executeFill(ctx, path);
                ctx.globalAlpha = globalAlpha;
            }
            this.applyFillAndAlpha(ctx);
            this.applyShadow(ctx);
            this.executeFill(ctx, path);
            ctx.globalAlpha = globalAlpha;
            ctx.shadowColor = "rgba(0, 0, 0, 0)";
        }
    }
    executeFill(ctx, path) {
        if (path) {
            ctx.fill(path);
        } else {
            ctx.fill();
        }
    }
    applyFillAndAlpha(ctx) {
        const { fill, fillGradient, fillPattern, fillImage, fillOpacity = 1, opacity = 1 } = this;
        ctx.globalAlpha *= opacity * fillOpacity;
        if (fillGradient) {
            var _this_getDefaultGradientFillBBox;
            const { fillBBox = (_this_getDefaultGradientFillBBox = this.getDefaultGradientFillBBox()) !== null && _this_getDefaultGradientFillBBox !== void 0 ? _this_getDefaultGradientFillBBox : this.getBBox(), fillParams } = this;
            var _fillGradient_createGradient;
            ctx.fillStyle = (_fillGradient_createGradient = fillGradient.createGradient(ctx, fillBBox, fillParams)) !== null && _fillGradient_createGradient !== void 0 ? _fillGradient_createGradient : "black";
        } else if (fillPattern) {
            var _this_layerManager_canvas, _this_layerManager;
            const { x, y } = this.getBBox();
            var _this_layerManager_canvas_pixelRatio;
            const pixelRatio = (_this_layerManager_canvas_pixelRatio = (_this_layerManager = this.layerManager) === null || _this_layerManager === void 0 ? void 0 : (_this_layerManager_canvas = _this_layerManager.canvas) === null || _this_layerManager_canvas === void 0 ? void 0 : _this_layerManager_canvas.pixelRatio) !== null && _this_layerManager_canvas_pixelRatio !== void 0 ? _this_layerManager_canvas_pixelRatio : 1;
            const pattern = fillPattern.createPattern(ctx, pixelRatio);
            fillPattern.setPatternTransform(pattern, pixelRatio, x, y);
            if (pattern) {
                ctx.fillStyle = pattern;
            } else {
                ctx.fillStyle = fillPattern.fill;
                ctx.globalAlpha *= fillPattern.fillOpacity;
            }
        } else if (fillImage) {
            const bbox = this.getBBox();
            const image = fillImage.createPattern(ctx, bbox.width, bbox.height, this);
            fillImage.setImageTransform(image, bbox);
            ctx.fillStyle = image !== null && image !== void 0 ? image : "transparent";
        } else {
            ctx.fillStyle = typeof fill === "string" ? fill : "black";
        }
    }
    applyStrokeAndAlpha(ctx) {
        const { stroke: stroke2, strokeOpacity = 1, strokeGradient, opacity = 1 } = this;
        var _strokeGradient_createGradient, _ref;
        ctx.strokeStyle = (_ref = (_strokeGradient_createGradient = strokeGradient === null || strokeGradient === void 0 ? void 0 : strokeGradient.createGradient(ctx, this.getBBox())) !== null && _strokeGradient_createGradient !== void 0 ? _strokeGradient_createGradient : typeof stroke2 === "string" ? stroke2 : void 0) !== null && _ref !== void 0 ? _ref : "black";
        ctx.globalAlpha *= opacity * strokeOpacity;
    }
    applyShadow(ctx) {
        var _this_layerManager;
        var _this_layerManager_canvas_pixelRatio;
        const pixelRatio = (_this_layerManager_canvas_pixelRatio = (_this_layerManager = this.layerManager) === null || _this_layerManager === void 0 ? void 0 : _this_layerManager.canvas.pixelRatio) !== null && _this_layerManager_canvas_pixelRatio !== void 0 ? _this_layerManager_canvas_pixelRatio : 1;
        const fillShadow = this.fillShadow;
        if (fillShadow === null || fillShadow === void 0 ? void 0 : fillShadow.enabled) {
            ctx.shadowColor = fillShadow.color;
            ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
            ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
            ctx.shadowBlur = fillShadow.blur * pixelRatio;
        }
    }
    renderStroke(ctx, path) {
        const { stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin, miterLimit } = this;
        if (stroke2 != null && stroke2 !== "none" && strokeWidth > 0 && strokeOpacity > 0) {
            const { globalAlpha } = ctx;
            this.applyStrokeAndAlpha(ctx);
            ctx.lineWidth = strokeWidth;
            if (lineDash) {
                ctx.setLineDash(lineDash);
            }
            if (lineDashOffset) {
                ctx.lineDashOffset = lineDashOffset;
            }
            if (lineCap) {
                ctx.lineCap = lineCap;
            }
            if (lineJoin) {
                ctx.lineJoin = lineJoin;
            }
            if (miterLimit != null) {
                ctx.miterLimit = miterLimit;
            }
            this.executeStroke(ctx, path);
            ctx.globalAlpha = globalAlpha;
        }
    }
    executeStroke(ctx, path) {
        if (path) {
            ctx.stroke(path);
        } else {
            ctx.stroke();
        }
    }
    getDefaultGradientFillBBox() {
        var _this_cachedDefaultGradientFillBBox;
        (_this_cachedDefaultGradientFillBBox = this.cachedDefaultGradientFillBBox) !== null && _this_cachedDefaultGradientFillBBox !== void 0 ? _this_cachedDefaultGradientFillBBox : this.cachedDefaultGradientFillBBox = Object.freeze(this.computeDefaultGradientFillBBox());
        return this.cachedDefaultGradientFillBBox;
    }
    computeDefaultGradientFillBBox() {
        return;
    }
    containsPoint(x, y) {
        return this.isPointInPath(x, y);
    }
    applySvgFillAttributes(element2, defs) {
        const { fill, fillOpacity } = this;
        if (typeof fill === "string") {
            element2.setAttribute("fill", fill);
        } else if (isGradientFill(fill) && this.fillGradient) {
            defs !== null && defs !== void 0 ? defs : defs = [];
            var _this_fillBBox;
            const gradient2 = this.fillGradient.toSvg((_this_fillBBox = this.fillBBox) !== null && _this_fillBBox !== void 0 ? _this_fillBBox : this.getBBox());
            const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generateUUID"])();
            gradient2.setAttribute("id", id);
            defs.push(gradient2);
            element2.setAttribute("fill", "url(#".concat(id, ")"));
        } else if (isPatternFill(fill) && this.fillPattern) {
            defs !== null && defs !== void 0 ? defs : defs = [];
            const pattern = this.fillPattern.toSvg();
            const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generateUUID"])();
            pattern.setAttribute("id", id);
            defs.push(pattern);
            element2.setAttribute("fill", "url(#".concat(id, ")"));
        } else if (isImageFill(fill) && this.fillImage) {
            var _this_layerManager_canvas, _this_layerManager;
            defs !== null && defs !== void 0 ? defs : defs = [];
            var _this_layerManager_canvas_pixelRatio;
            const pixelRatio = (_this_layerManager_canvas_pixelRatio = (_this_layerManager = this.layerManager) === null || _this_layerManager === void 0 ? void 0 : (_this_layerManager_canvas = _this_layerManager.canvas) === null || _this_layerManager_canvas === void 0 ? void 0 : _this_layerManager_canvas.pixelRatio) !== null && _this_layerManager_canvas_pixelRatio !== void 0 ? _this_layerManager_canvas_pixelRatio : 1;
            const pattern = this.fillImage.toSvg(this.getBBox(), pixelRatio);
            const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generateUUID"])();
            pattern.setAttribute("id", id);
            defs.push(pattern);
            element2.setAttribute("fill", "url(#".concat(id, ")"));
        } else {
            element2.setAttribute("fill", "none");
        }
        element2.setAttribute("fill-opacity", String(fillOpacity));
        return defs;
    }
    applySvgStrokeAttributes(element2) {
        const { stroke: stroke2, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this;
        setSvgStrokeAttributes(element2, {
            stroke: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(stroke2) ? stroke2 : void 0,
            strokeOpacity,
            strokeWidth
        });
        setSvgLineDashAttributes(element2, {
            lineDash,
            lineDashOffset
        });
    }
    constructor(){
        super(...arguments);
        this.fillOpacity = 1;
        this.strokeOpacity = 1;
        this.fill = "black";
        this.strokeWidth = 0;
        this.lineDashOffset = 0;
        this.opacity = 1;
    }
};
__decorateClass([
    SceneChangeDetection()
], Shape.prototype, "fillOpacity", 2);
__decorateClass([
    SceneChangeDetection()
], Shape.prototype, "strokeOpacity", 2);
__decorateClass([
    SceneObjectChangeDetection({
        equals: objectsEqual,
        changeCb: (s)=>s.onFillChange()
    })
], Shape.prototype, "fill", 2);
__decorateClass([
    SceneObjectChangeDetection({
        equals: objectsEqual,
        changeCb: (s)=>s.onStrokeChange()
    })
], Shape.prototype, "stroke", 2);
__decorateClass([
    SceneChangeDetection()
], Shape.prototype, "strokeWidth", 2);
__decorateClass([
    SceneArrayChangeDetection()
], Shape.prototype, "lineDash", 2);
__decorateClass([
    SceneChangeDetection()
], Shape.prototype, "lineDashOffset", 2);
__decorateClass([
    SceneChangeDetection()
], Shape.prototype, "lineCap", 2);
__decorateClass([
    SceneChangeDetection()
], Shape.prototype, "lineJoin", 2);
__decorateClass([
    SceneChangeDetection()
], Shape.prototype, "miterLimit", 2);
__decorateClass([
    SceneChangeDetection({
        convertor: (v)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, v !== null && v !== void 0 ? v : 1, 1)
    })
], Shape.prototype, "opacity", 2);
__decorateClass([
    SceneObjectChangeDetection({
        equals: TRIPLE_EQ,
        checkDirtyOnAssignment: true
    })
], Shape.prototype, "fillShadow", 2);
__decorateClass([
    SceneObjectChangeDetection({
        equals: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boxesEqual"],
        changeCb: (s)=>s.onFillChange()
    })
], Shape.prototype, "fillBBox", 2);
__decorateClass([
    SceneObjectChangeDetection({
        equals: objectsEqual,
        changeCb: (s)=>s.onFillChange()
    })
], Shape.prototype, "fillParams", 2);
;
;
var IDENTITY_MATRIX_ELEMENTS = [
    1,
    0,
    0,
    1,
    0,
    0
];
var Matrix = class _Matrix {
    get e() {
        return [
            ...this.elements
        ];
    }
    setElements(elements) {
        const e = this.elements;
        e[0] = elements[0];
        e[1] = elements[1];
        e[2] = elements[2];
        e[3] = elements[3];
        e[4] = elements[4];
        e[5] = elements[5];
        return this;
    }
    get identity() {
        const e = this.elements;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberEqual"])(e[0], 1) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberEqual"])(e[1], 0) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberEqual"])(e[2], 0) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberEqual"])(e[3], 1) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberEqual"])(e[4], 0) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberEqual"])(e[5], 0);
    }
    /**
   * Performs the AxB matrix multiplication and saves the result
   * to `C`, if given, or to `A` otherwise.
   */ AxB(A, B, C2) {
        const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];
        C2 = C2 !== null && C2 !== void 0 ? C2 : A;
        C2[0] = a;
        C2[1] = b;
        C2[2] = c;
        C2[3] = d;
        C2[4] = e;
        C2[5] = f;
    }
    /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns the current matrix.
   * @param other
   */ multiplySelf(other) {
        this.AxB(this.elements, other.elements);
        return this;
    }
    /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns a new matrix.
   * @param other
   */ multiply(other) {
        const elements = new Array(6);
        if (other instanceof _Matrix) {
            this.AxB(this.elements, other.elements, elements);
        } else {
            this.AxB(this.elements, [
                other.a,
                other.b,
                other.c,
                other.d,
                other.e,
                other.f
            ], elements);
        }
        return new _Matrix(elements);
    }
    preMultiplySelf(other) {
        this.AxB(other.elements, this.elements, this.elements);
        return this;
    }
    /**
   * Returns the inverse of this matrix as a new matrix.
   */ inverse() {
        const el = this.elements;
        let a = el[0], b = el[1], c = el[2], d = el[3];
        const e = el[4], f = el[5];
        const rD = 1 / (a * d - b * c);
        a *= rD;
        b *= rD;
        c *= rD;
        d *= rD;
        return new _Matrix([
            d,
            -b,
            -c,
            a,
            c * f - d * e,
            b * e - a * f
        ]);
    }
    invertSelf() {
        const el = this.elements;
        let a = el[0], b = el[1], c = el[2], d = el[3];
        const e = el[4], f = el[5];
        const rD = 1 / (a * d - b * c);
        a *= rD;
        b *= rD;
        c *= rD;
        d *= rD;
        el[0] = d;
        el[1] = -b;
        el[2] = -c;
        el[3] = a;
        el[4] = c * f - d * e;
        el[5] = b * e - a * f;
        return this;
    }
    transformPoint(x, y) {
        const e = this.elements;
        return {
            x: x * e[0] + y * e[2] + e[4],
            y: x * e[1] + y * e[3] + e[5]
        };
    }
    transformBBox(bbox, target) {
        const el = this.elements;
        const xx = el[0];
        const xy = el[1];
        const yx = el[2];
        const yy = el[3];
        const h_w = bbox.width * 0.5;
        const h_h = bbox.height * 0.5;
        const cx = bbox.x + h_w;
        const cy = bbox.y + h_h;
        const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);
        const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);
        target !== null && target !== void 0 ? target : target = new BBox(0, 0, 0, 0);
        target.x = cx * xx + cy * yx + el[4] - w;
        target.y = cx * xy + cy * yy + el[5] - h;
        target.width = w + w;
        target.height = h + h;
        return target;
    }
    toContext(ctx) {
        if (this.identity) {
            return;
        }
        const e = this.elements;
        ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);
    }
    static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {
        const sx = scalingX;
        const sy = scalingY;
        let scx;
        let scy;
        if (sx === 1 && sy === 1) {
            scx = 0;
            scy = 0;
        } else {
            var _opts_scalingCenterX;
            scx = (_opts_scalingCenterX = opts === null || opts === void 0 ? void 0 : opts.scalingCenterX) !== null && _opts_scalingCenterX !== void 0 ? _opts_scalingCenterX : 0;
            var _opts_scalingCenterY;
            scy = (_opts_scalingCenterY = opts === null || opts === void 0 ? void 0 : opts.scalingCenterY) !== null && _opts_scalingCenterY !== void 0 ? _opts_scalingCenterY : 0;
        }
        const r = rotation;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        let rcx;
        let rcy;
        if (r === 0) {
            rcx = 0;
            rcy = 0;
        } else {
            var _opts_rotationCenterX;
            rcx = (_opts_rotationCenterX = opts === null || opts === void 0 ? void 0 : opts.rotationCenterX) !== null && _opts_rotationCenterX !== void 0 ? _opts_rotationCenterX : 0;
            var _opts_rotationCenterY;
            rcy = (_opts_rotationCenterY = opts === null || opts === void 0 ? void 0 : opts.rotationCenterY) !== null && _opts_rotationCenterY !== void 0 ? _opts_rotationCenterY : 0;
        }
        const tx = translationX;
        const ty = translationY;
        const tx4 = scx * (1 - sx) - rcx;
        const ty4 = scy * (1 - sy) - rcy;
        matrix.setElements([
            cos * sx,
            sin * sx,
            -sin * sy,
            cos * sy,
            cos * tx4 - sin * ty4 + rcx + tx,
            sin * tx4 + cos * ty4 + rcy + ty
        ]);
        return matrix;
    }
    constructor(elements = IDENTITY_MATRIX_ELEMENTS){
        this.elements = [
            ...elements
        ];
    }
};
// packages/ag-charts-community/src/scene/transformable.ts
function isMatrixTransform(node) {
    return isMatrixTransformType(node.constructor);
}
var MATRIX_TRANSFORM_TYPE = Symbol("isMatrixTransform");
function isMatrixTransformType(cstr) {
    return cstr[MATRIX_TRANSFORM_TYPE] === true;
}
function MatrixTransform(Parent) {
    var _a, _b;
    const ParentNode = Parent;
    if (isMatrixTransformType(Parent)) {
        return Parent;
    }
    const TRANSFORM_MATRIX = Symbol("matrix_combined_transform");
    class MatrixTransformInternal extends ParentNode {
        onChangeDetection(property) {
            super.onChangeDetection(property);
            this._dirtyTransform = true;
            if (this.batchLevel > 0) {
                return;
            }
            this.markDirty("transform");
        }
        updateMatrix(_matrix) {}
        computeTransformMatrix() {
            if (!this._dirtyTransform) return;
            this[TRANSFORM_MATRIX].setElements(IDENTITY_MATRIX_ELEMENTS);
            this.updateMatrix(this[TRANSFORM_MATRIX]);
            this._dirtyTransform = false;
        }
        toParent(bbox) {
            this.computeTransformMatrix();
            if (this[TRANSFORM_MATRIX].identity) return bbox.clone();
            return this[TRANSFORM_MATRIX].transformBBox(bbox);
        }
        toParentPoint(x, y) {
            this.computeTransformMatrix();
            if (this[TRANSFORM_MATRIX].identity) return {
                x,
                y
            };
            return this[TRANSFORM_MATRIX].transformPoint(x, y);
        }
        fromParent(bbox) {
            this.computeTransformMatrix();
            if (this[TRANSFORM_MATRIX].identity) return bbox.clone();
            return this[TRANSFORM_MATRIX].inverse().transformBBox(bbox);
        }
        fromParentPoint(x, y) {
            this.computeTransformMatrix();
            if (this[TRANSFORM_MATRIX].identity) return {
                x,
                y
            };
            return this[TRANSFORM_MATRIX].inverse().transformPoint(x, y);
        }
        computeBBox() {
            const bbox = super.computeBBox();
            if (!bbox) return bbox;
            return this.toParent(bbox);
        }
        computeBBoxWithoutTransforms() {
            return super.computeBBox();
        }
        pickNode(x, y) {
            ({ x, y } = this.fromParentPoint(x, y));
            return super.pickNode(x, y);
        }
        pickNodes(x, y, into) {
            ({ x, y } = this.fromParentPoint(x, y));
            return super.pickNodes(x, y, into);
        }
        render(renderCtx) {
            this.computeTransformMatrix();
            const { ctx } = renderCtx;
            const matrix = this[TRANSFORM_MATRIX];
            let performRestore = false;
            try {
                if (!matrix.identity) {
                    ctx.save();
                    performRestore = true;
                    matrix.toContext(ctx);
                }
                super.render(renderCtx);
            } finally{
                if (performRestore) {
                    ctx.restore();
                }
            }
        }
        toSVG() {
            this.computeTransformMatrix();
            const svg = super.toSVG();
            const matrix = this[TRANSFORM_MATRIX];
            if (matrix.identity || svg == null) return svg;
            const g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("g");
            g.append(...svg.elements);
            const [a, b, c, d, e, f] = matrix.e;
            g.setAttribute("transform", "matrix(".concat(a, " ").concat(b, " ").concat(c, " ").concat(d, " ").concat(e, " ").concat(f, ")"));
            return {
                elements: [
                    g
                ],
                defs: svg.defs
            };
        }
        constructor(){
            super(...arguments);
            this[_b] = new Matrix();
            this._dirtyTransform = true;
        }
    }
    _a = MATRIX_TRANSFORM_TYPE, _b = TRANSFORM_MATRIX;
    MatrixTransformInternal[_a] = true;
    return MatrixTransformInternal;
}
function Rotatable(Parent) {
    var _a;
    const ParentNode = Parent;
    const ROTATABLE_MATRIX = Symbol("matrix_rotation");
    class RotatableInternal extends MatrixTransform(ParentNode) {
        updateMatrix(matrix) {
            super.updateMatrix(matrix);
            const { rotation, rotationCenterX, rotationCenterY } = this;
            if (rotation === 0) return;
            Matrix.updateTransformMatrix(this[ROTATABLE_MATRIX], 1, 1, rotation, 0, 0, {
                rotationCenterX,
                rotationCenterY
            });
            matrix.multiplySelf(this[ROTATABLE_MATRIX]);
        }
        constructor(){
            super(...arguments);
            this[_a] = new Matrix();
            this.rotationCenterX = 0;
            this.rotationCenterY = 0;
            this.rotation = 0;
        }
    }
    _a = ROTATABLE_MATRIX;
    __decorateClass([
        SceneChangeDetection()
    ], RotatableInternal.prototype, "rotationCenterX", 2);
    __decorateClass([
        SceneChangeDetection()
    ], RotatableInternal.prototype, "rotationCenterY", 2);
    __decorateClass([
        SceneChangeDetection()
    ], RotatableInternal.prototype, "rotation", 2);
    return RotatableInternal;
}
function Scalable(Parent) {
    var _a;
    const ParentNode = Parent;
    const SCALABLE_MATRIX = Symbol("matrix_scale");
    class ScalableInternal extends MatrixTransform(ParentNode) {
        updateMatrix(matrix) {
            super.updateMatrix(matrix);
            const { scalingX, scalingY, scalingCenterX, scalingCenterY } = this;
            if (scalingX === 1 && scalingY === 1) return;
            Matrix.updateTransformMatrix(this[SCALABLE_MATRIX], scalingX, scalingY, 0, 0, 0, {
                scalingCenterX,
                scalingCenterY
            });
            matrix.multiplySelf(this[SCALABLE_MATRIX]);
        }
        constructor(){
            super(...arguments);
            this[_a] = new Matrix();
            this.scalingX = 1;
            this.scalingY = 1;
            this.scalingCenterX = 0;
            this.scalingCenterY = 0;
        }
    }
    _a = SCALABLE_MATRIX;
    __decorateClass([
        SceneChangeDetection()
    ], ScalableInternal.prototype, "scalingX", 2);
    __decorateClass([
        SceneChangeDetection()
    ], ScalableInternal.prototype, "scalingY", 2);
    __decorateClass([
        SceneChangeDetection()
    ], ScalableInternal.prototype, "scalingCenterX", 2);
    __decorateClass([
        SceneChangeDetection()
    ], ScalableInternal.prototype, "scalingCenterY", 2);
    return ScalableInternal;
}
function Translatable(Parent) {
    var _a;
    const ParentNode = Parent;
    const TRANSLATABLE_MATRIX = Symbol("matrix_translation");
    class TranslatableInternal extends MatrixTransform(ParentNode) {
        updateMatrix(matrix) {
            super.updateMatrix(matrix);
            const { translationX, translationY } = this;
            if (translationX === 0 && translationY === 0) return;
            Matrix.updateTransformMatrix(this[TRANSLATABLE_MATRIX], 1, 1, 0, translationX, translationY);
            matrix.multiplySelf(this[TRANSLATABLE_MATRIX]);
        }
        constructor(){
            super(...arguments);
            this[_a] = new Matrix();
            this.translationX = 0;
            this.translationY = 0;
        }
    }
    _a = TRANSLATABLE_MATRIX;
    __decorateClass([
        SceneChangeDetection()
    ], TranslatableInternal.prototype, "translationX", 2);
    __decorateClass([
        SceneChangeDetection()
    ], TranslatableInternal.prototype, "translationY", 2);
    return TranslatableInternal;
}
var Transformable = class {
    /**
   * Converts a BBox from canvas coordinate space into the coordinate space of the given Node.
   */ static fromCanvas(node, bbox) {
        const parents = [];
        for (const parent of node.traverseUp()){
            if (isMatrixTransform(parent)) {
                parents.unshift(parent);
            }
        }
        for (const parent of parents){
            bbox = parent.fromParent(bbox);
        }
        if (isMatrixTransform(node)) {
            bbox = node.fromParent(bbox);
        }
        return bbox;
    }
    /**
   * Converts a Nodes BBox (or an arbitrary BBox if supplied) from local Node coordinate space
   * into the Canvas coordinate space.
   */ static toCanvas(node, bbox) {
        if (bbox == null) {
            bbox = node.getBBox();
        } else if (isMatrixTransform(node)) {
            bbox = node.toParent(bbox);
        }
        for (const parent of node.traverseUp()){
            if (isMatrixTransform(parent)) {
                bbox = parent.toParent(bbox);
            }
        }
        return bbox;
    }
    /**
   * Converts a point from canvas coordinate space into the coordinate space of the given Node.
   */ static fromCanvasPoint(node, x, y) {
        const parents = [];
        for (const parent of node.traverseUp()){
            if (isMatrixTransform(parent)) {
                parents.unshift(parent);
            }
        }
        for (const parent of parents){
            ({ x, y } = parent.fromParentPoint(x, y));
        }
        if (isMatrixTransform(node)) {
            ({ x, y } = node.fromParentPoint(x, y));
        }
        return {
            x,
            y
        };
    }
    /**
   * Converts a point from a Nodes local coordinate space into the Canvas coordinate space.
   */ static toCanvasPoint(node, x, y) {
        if (isMatrixTransform(node)) {
            ({ x, y } = node.toParentPoint(x, y));
        }
        for (const parent of node.traverseUp()){
            if (isMatrixTransform(parent)) {
                ({ x, y } = parent.toParentPoint(x, y));
            }
        }
        return {
            x,
            y
        };
    }
};
// packages/ag-charts-community/src/scene/group.ts
var sharedOffscreenCanvas;
var _Group = class _Group extends Node2 {
    static is(value) {
        return value instanceof _Group;
    }
    static computeChildrenBBox(nodes) {
        let skipInvisible = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return BBox.merge(Node2.extractBBoxes(nodes, skipInvisible));
    }
    static compareChildren(a, b) {
        return compareZIndex(a.zIndex, b.zIndex) || a.serialNumber - b.serialNumber;
    }
    // We consider a group to be boundless, thus any point belongs to it.
    containsPoint(_x, _y) {
        return true;
    }
    computeBBox() {
        return _Group.computeChildrenBBox(this.children());
    }
    computeSafeClippingBBox(pixelRatio) {
        const bbox = this.computeBBox();
        if ((bbox === null || bbox === void 0 ? void 0 : bbox.isFinite()) !== true) return;
        let strokeWidth = 0;
        const strokeMiterAmount = 4;
        for (const child of this.descendants()){
            if (child instanceof Shape) {
                strokeWidth = Math.max(strokeWidth, child.strokeWidth);
            }
        }
        const padding2 = Math.max(// Account for anti-aliasing artefacts
        1, // Account for strokes (incl. miters) - this may not be the best place to include this
        strokeWidth / 2 * strokeMiterAmount);
        const { x: originX, y: originY } = Transformable.toCanvasPoint(this, 0, 0);
        const x = alignBefore(pixelRatio, originX + bbox.x - padding2) - originX;
        const y = alignBefore(pixelRatio, originY + bbox.y - padding2) - originY;
        const width2 = Math.ceil(bbox.x + bbox.width - x + padding2);
        const height2 = Math.ceil(bbox.y + bbox.height - y + padding2);
        return new BBox(x, y, width2, height2);
    }
    prepareSharedCanvas(width2, height2, pixelRatio) {
        if (sharedOffscreenCanvas == null || sharedOffscreenCanvas.pixelRatio !== pixelRatio) {
            sharedOffscreenCanvas = new HdpiOffscreenCanvas({
                width: width2,
                height: height2,
                pixelRatio
            });
        } else {
            sharedOffscreenCanvas.resize(width2, height2, pixelRatio);
        }
        return sharedOffscreenCanvas;
    }
    setScene(scene) {
        super.setScene(scene);
        if (this.layer) {
            var _this_scene;
            (_this_scene = this.scene) === null || _this_scene === void 0 ? void 0 : _this_scene.layersManager.removeLayer(this.layer);
            this.layer = void 0;
        }
        for (const child of this.children()){
            child.setScene(scene);
        }
    }
    markDirty(property) {
        this.dirty = true;
        super.markDirty(property);
    }
    markDirtyChildrenOrder() {
        super.markDirtyChildrenOrder();
        this.dirtyZIndex = true;
        this.markDirty();
    }
    /**
   * Appends one or more new node instances to this parent.
   * If one needs to:
   * - move a child to the end of the list of children
   * - move a child from one parent to another (including parents in other scenes)
   * one should use the {@link insertBefore} method instead.
   * @param nodes A node or nodes to append.
   */ append(nodes) {
        for (const node of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toIterable"])(nodes)){
            var _node_parentNode;
            (_node_parentNode = node.parentNode) === null || _node_parentNode === void 0 ? void 0 : _node_parentNode.removeChild(node);
            this.childNodes.add(node);
            node.parentNode = this;
            node.setScene(this.scene);
        }
        this.markDirtyChildrenOrder();
        this.markDirty();
    }
    appendChild(node) {
        this.append(node);
        return node;
    }
    removeChild(node) {
        var _this_childNodes;
        if (!((_this_childNodes = this.childNodes) === null || _this_childNodes === void 0 ? void 0 : _this_childNodes.delete(node))) {
            var _node_name, _this_name;
            throw new Error("AG Charts - internal error, unknown child node ".concat((_node_name = node.name) !== null && _node_name !== void 0 ? _node_name : node.id, " in $").concat((_this_name = this.name) !== null && _this_name !== void 0 ? _this_name : this.id));
        }
        node.parentNode = void 0;
        node.setScene();
        this.markDirtyChildrenOrder();
        this.markDirty();
    }
    clear() {
        var _this_childNodes;
        for (const child of this.children()){
            delete child.parentNode;
            child.setScene();
        }
        (_this_childNodes = this.childNodes) === null || _this_childNodes === void 0 ? void 0 : _this_childNodes.clear();
        this.markDirty();
    }
    /**
   * Hit testing method.
   * Recursively checks if the given point is inside this node or any of its children.
   * Returns the first matching node or `undefined`.
   * Nodes that render later (show on top) are hit tested first.
   */ pickNode(x, y) {
        if (!this.visible || this.pointerEvents === 1 /* None */  || !this.containsPoint(x, y)) {
            return;
        }
        if (this.childNodes != null && this.childNodes.size !== 0) {
            const children = [
                ...this.children()
            ];
            for(let i = children.length - 1; i >= 0; i--){
                const child = children[i];
                const hit = child.pickNode(x, y);
                if (hit != null) {
                    return hit;
                }
            }
        } else if (!this.isContainerNode) {
            return this;
        }
    }
    pickNodes(x, y) {
        let into = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        if (!this.visible || this.pointerEvents === 1 /* None */  || !this.containsPoint(x, y)) {
            return into;
        }
        if (!this.isContainerNode) {
            into.push(this);
        }
        for (const child of this.children()){
            child.pickNodes(x, y, into);
        }
        return into;
    }
    isDirty(renderCtx) {
        const { width: width2, height: height2, devicePixelRatio } = renderCtx;
        const { dirty, layer } = this;
        const layerResized = layer != null && (this._lastWidth !== width2 || this._lastHeight !== height2);
        const pixelRatioChanged = this._lastDevicePixelRatio !== devicePixelRatio;
        this._lastWidth = width2;
        this._lastHeight = height2;
        this._lastDevicePixelRatio = devicePixelRatio;
        return dirty || layerResized || pixelRatioChanged;
    }
    preRender(renderCtx) {
        let counts;
        if (this.dirty) {
            counts = super.preRender(renderCtx, 0);
            for (const child of this.children()){
                const childCounts = child.preRender(renderCtx);
                counts.groups += childCounts.groups;
                counts.nonGroups += childCounts.nonGroups;
                counts.complexity += childCounts.complexity;
            }
            counts.groups += 1;
            counts.nonGroups -= 1;
        } else {
            counts = this.childNodeCounts;
        }
        if (this.renderToOffscreenCanvas && !this.optimizeForInfrequentRedraws && counts.nonGroups > 0 && this.getVisibility()) {
            var _this_layerManager;
            var _this_layer;
            (_this_layer = this.layer) !== null && _this_layer !== void 0 ? _this_layer : this.layer = (_this_layerManager = this.layerManager) === null || _this_layerManager === void 0 ? void 0 : _this_layerManager.addLayer({
                name: this.name
            });
        } else if (this.layer != null) {
            var _this_layerManager1;
            (_this_layerManager1 = this.layerManager) === null || _this_layerManager1 === void 0 ? void 0 : _this_layerManager1.removeLayer(this.layer);
            this.layer = void 0;
        }
        return counts;
    }
    render(renderCtx) {
        const { layer, renderToOffscreenCanvas } = this;
        const childRenderCtx = {
            ...renderCtx
        };
        const dirty = this.isDirty(renderCtx);
        this.dirty = false;
        if (!renderToOffscreenCanvas) {
            this.renderInContext(childRenderCtx);
            super.render(childRenderCtx);
            return;
        }
        const { ctx, stats, devicePixelRatio: pixelRatio } = renderCtx;
        let { image } = this;
        if (dirty) {
            var _this = this;
            image === null || image === void 0 ? void 0 : image.bitmap.close();
            image = void 0;
            const bbox = layer ? void 0 : this.computeSafeClippingBBox(pixelRatio);
            const renderOffscreen = function(offscreenCanvas) {
                for(var _len = arguments.length, transform = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    transform[_key - 1] = arguments[_key];
                }
                const offscreenCtx = offscreenCanvas.context;
                childRenderCtx.ctx = offscreenCtx;
                offscreenCanvas.clear();
                offscreenCtx.save();
                try {
                    offscreenCtx.setTransform(...transform);
                    offscreenCtx.globalAlpha = 1;
                    _this.renderInContext(childRenderCtx);
                } finally{
                    var _offscreenCtx_verifyDepthZero;
                    offscreenCtx.restore();
                    (_offscreenCtx_verifyDepthZero = offscreenCtx.verifyDepthZero) === null || _offscreenCtx_verifyDepthZero === void 0 ? void 0 : _offscreenCtx_verifyDepthZero.call(offscreenCtx);
                }
            };
            if (layer) {
                renderOffscreen(layer, ctx.getTransform());
            } else if (bbox) {
                const { x, y, width: width2, height: height2 } = bbox;
                const canvas = this.prepareSharedCanvas(width2, height2, pixelRatio);
                renderOffscreen(canvas, pixelRatio, 0, 0, pixelRatio, -x * pixelRatio, -y * pixelRatio);
                image = {
                    bitmap: canvas.transferToImageBitmap(),
                    x,
                    y,
                    width: width2,
                    height: height2
                };
            }
            this.image = image;
            if (stats) stats.layersRendered++;
        } else if (stats) {
            stats.layersSkipped++;
        }
        const { globalAlpha } = ctx;
        ctx.globalAlpha = globalAlpha * this.opacity;
        if (layer) {
            ctx.save();
            try {
                ctx.resetTransform();
                layer.drawImage(ctx);
            } finally{
                ctx.restore();
            }
        } else if (image) {
            const { bitmap, x, y, width: width2, height: height2 } = image;
            ctx.drawImage(bitmap, 0, 0, width2 * pixelRatio, height2 * pixelRatio, x, y, width2, height2);
        }
        ctx.globalAlpha = globalAlpha;
        super.render(childRenderCtx);
    }
    applyClip(ctx, clipRect) {
        const { x, y, width: width2, height: height2 } = clipRect;
        ctx.beginPath();
        ctx.rect(x, y, width2, height2);
        ctx.clip();
    }
    renderInContext(childRenderCtx) {
        const { ctx, stats } = childRenderCtx;
        if (this.dirtyZIndex) {
            this.sortChildren(_Group.compareChildren);
            this.dirtyZIndex = false;
        }
        ctx.save();
        try {
            ctx.globalAlpha *= this.opacity;
            if (this.clipRect != null) {
                this.applyClip(ctx, this.clipRect);
                childRenderCtx.clipBBox = Transformable.toCanvas(this, this.clipRect);
            }
            for (const child of this.children()){
                if (!child.visible) {
                    if (stats) {
                        stats.nodesSkipped += child.childNodeCounts.nonGroups + child.childNodeCounts.groups;
                        stats.opsSkipped += child.childNodeCounts.complexity;
                    }
                    continue;
                }
                child.isolatedRender(childRenderCtx);
            }
        } finally{
            ctx.restore();
        }
    }
    sortChildren(compareFn) {
        if (!this.childNodes) return;
        const sortedChildren = [
            ...this.childNodes
        ].sort(compareFn);
        this.childNodes.clear();
        for (const child of sortedChildren){
            this.childNodes.add(child);
        }
    }
    *children() {
        yield* this.childNodes;
    }
    *excludeChildren(exclude) {
        for (const child of this.children()){
            if (exclude.instance && !(child instanceof exclude.instance) || exclude.name && child.name !== exclude.name) {
                yield child;
            }
        }
    }
    *descendants() {
        for (const child of this.children()){
            yield child;
            if (child instanceof _Group) {
                yield* child.descendants();
            }
        }
    }
    /**
   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and
   * sets this group's clipRect to the transformed bbox.
   * @param bbox clipRect bbox in the canvas coordinate space.
   */ setClipRect(bbox) {
        this.clipRect = bbox ? Transformable.fromCanvas(this, bbox) : void 0;
    }
    /**
   * Set the clip rect within the canvas coordinate space.
   * @param bbox clipRect bbox in the canvas coordinate space.
   */ setClipRectCanvasSpace(bbox) {
        this.clipRect = bbox;
    }
    getVisibility() {
        for (const node of this.traverseUp(true)){
            if (!node.visible) {
                return false;
            }
        }
        return true;
    }
    toSVG() {
        if (!this.visible) return;
        const defs = [];
        const elements = [];
        for (const child of this.children()){
            const svg = child.toSVG();
            if (svg != null) {
                elements.push(...svg.elements);
                if (svg.defs != null) {
                    defs.push(...svg.defs);
                }
            }
        }
        return {
            elements,
            defs
        };
    }
    // optimizeForInfrequentRedraws: true
    constructor(opts){
        super(opts);
        this.childNodes = /* @__PURE__ */ new Set();
        this.dirty = false;
        this.dirtyZIndex = false;
        this.clipRect = void 0;
        this.opacity = 1;
        this.renderToOffscreenCanvas = false;
        this.optimizeForInfrequentRedraws = false;
        // Used when renderToOffscreenCanvas: true
        this.layer = void 0;
        // optimizeForInfrequentRedraws: false
        this.image = void 0;
        this._lastWidth = NaN;
        this._lastHeight = NaN;
        this._lastDevicePixelRatio = NaN;
        this.isContainerNode = true;
        this.renderToOffscreenCanvas = (opts === null || opts === void 0 ? void 0 : opts.renderToOffscreenCanvas) === true;
    }
};
_Group.className = "Group";
__decorateClass([
    SceneChangeDetection({
        convertor: (v)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, v, 1)
    })
], _Group.prototype, "opacity", 2);
var Group = _Group;
var ScalableGroup = class extends Scalable(Group) {
};
var RotatableGroup = class extends Rotatable(Group) {
};
var TranslatableGroup = class extends Translatable(Group) {
};
var TransformableGroup = class extends Rotatable(Translatable(Group)) {
};
;
function needsContext(caller, _params) {
    return "context" in caller;
}
function maybeSetContext(caller, params) {
    if (caller != null && needsContext(caller, params)) {
        if (params[0] != null && typeof params[0] === "object" && params[0].context === void 0) {
            params[0].context = caller.context;
            return true;
        }
    }
    return false;
}
function callWithContext(callers, fn) {
    for(var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
        params[_key - 2] = arguments[_key];
    }
    if (Array.isArray(callers)) {
        for (const caller of callers){
            if (maybeSetContext(caller, params)) {
                break;
            }
        }
    } else {
        maybeSetContext(callers, params);
    }
    return fn(...params);
}
var CallbackCache = class {
    call(callers, fn) {
        for(var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
            params[_key - 2] = arguments[_key];
        }
        let serialisedParams;
        let paramCache = this.cache.get(fn);
        try {
            serialisedParams = JSON.stringify(params);
        } catch (e) {
            return this.invoke(callers, fn, paramCache, void 0, ...params);
        }
        if (paramCache == null) {
            paramCache = /* @__PURE__ */ new Map();
            this.cache.set(fn, paramCache);
        }
        if (!paramCache.has(serialisedParams)) {
            return this.invoke(callers, fn, paramCache, serialisedParams, ...params);
        }
        return paramCache.get(serialisedParams);
    }
    invoke(callers, fn, paramCache, serialisedParams) {
        for(var _len = arguments.length, params = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){
            params[_key - 4] = arguments[_key];
        }
        try {
            const result = callWithContext(callers, fn, ...params);
            if (paramCache && serialisedParams != null) {
                paramCache.set(serialisedParams, result);
            }
            return result;
        } catch (e) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("User callback errored, ignoring", e);
            return;
        }
    }
    invalidateCache() {
        this.cache = /* @__PURE__ */ new WeakMap();
    }
    constructor(){
        this.cache = /* @__PURE__ */ new WeakMap();
    }
};
;
function setElementBBox(element2, bbox) {
    if (!element2) return;
    const { x, y, width: width2, height: height2 } = normalizeBounds(bbox);
    setPixelValue(element2.style, "width", width2);
    setPixelValue(element2.style, "height", height2);
    setPixelValue(element2.style, "left", x);
    setPixelValue(element2.style, "top", y);
}
function getElementBBox(element2) {
    const width2 = parseFloat(element2.style.width) || element2.offsetWidth;
    const height2 = parseFloat(element2.style.height) || element2.offsetHeight;
    const x = parseFloat(element2.style.left) || element2.offsetLeft;
    const y = parseFloat(element2.style.top) || element2.offsetTop;
    return {
        x,
        y,
        width: width2,
        height: height2
    };
}
function focusCursorAtEnd(element2) {
    var _element2_lastChild;
    element2.focus({
        preventScroll: true
    });
    if (((_element2_lastChild = element2.lastChild) === null || _element2_lastChild === void 0 ? void 0 : _element2_lastChild.textContent) == null) return;
    const range3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])().createRange();
    range3.setStart(element2.lastChild, element2.lastChild.textContent.length);
    range3.setEnd(element2.lastChild, element2.lastChild.textContent.length);
    const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])().getSelection();
    selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
    selection === null || selection === void 0 ? void 0 : selection.addRange(range3);
}
function isInputPending() {
    const navigator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])("navigator");
    if ("scheduling" in navigator) {
        const scheduling = navigator.scheduling;
        if ("isInputPending" in scheduling) {
            return scheduling.isInputPending({
                includeContinuous: true
            });
        }
    }
    return false;
}
function getIconClassNames(icon) {
    return "ag-charts-icon ag-charts-icon-".concat(icon);
}
function normalizeBounds(bbox) {
    let { x, y, width: width2, height: height2 } = bbox;
    if ((width2 == null || width2 > 0) && (height2 == null || height2 > 0)) {
        return bbox;
    }
    if (x != null && width2 != null && width2 < 0) {
        width2 = -width2;
        x = x - width2;
    }
    if (y != null && height2 != null && height2 < 0) {
        height2 = -height2;
        y = y - height2;
    }
    return {
        x,
        y,
        width: width2,
        height: height2
    };
}
function setPixelValue(style, key, value) {
    if (value == null) {
        style.removeProperty(key);
    } else {
        style.setProperty(key, "".concat(value, "px"));
    }
}
;
var CLASS_INSTANCE_TYPE = "class-instance";
function jsonDiff(source, target, shallow) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(target)) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(source) || source.length !== target.length || target.some((v, i)=>jsonDiff(source[i], v, shallow) != null)) {
            return target;
        }
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(target)) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(source)) {
            return target;
        }
        const result = {};
        const allKeys = /* @__PURE__ */ new Set([
            ...Object.keys(source),
            ...Object.keys(target)
        ]);
        for (const key of allKeys){
            if (source[key] === target[key]) {
                continue;
            } else if (shallow === null || shallow === void 0 ? void 0 : shallow.has(key)) {
                result[key] = target[key];
            } else if (typeof source[key] === typeof target[key]) {
                const diff2 = jsonDiff(source[key], target[key], shallow);
                if (diff2 !== null) {
                    result[key] = diff2;
                }
            } else {
                result[key] = target[key];
            }
        }
        return Object.keys(result).length ? result : null;
    } else if (source !== target) {
        return target;
    }
    return null;
}
function jsonPropertyCompare(source, target) {
    for (const key of Object.keys(source)){
        if (source[key] === (target === null || target === void 0 ? void 0 : target[key])) continue;
        return false;
    }
    return true;
}
function deepClone(source, opts) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(source)) {
        return cloneArray(source, opts);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(source)) {
        return clonePlainObject(source, opts);
    }
    if (source instanceof Map) {
        return new Map(deepClone(Array.from(source)));
    }
    return shallowClone(source);
}
function cloneArray(source, opts) {
    const result = [];
    const seen = opts === null || opts === void 0 ? void 0 : opts.seen;
    for (const item of source){
        if (typeof item === "object" && (seen === null || seen === void 0 ? void 0 : seen.includes(item))) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("cycle detected in array", item);
            continue;
        }
        seen === null || seen === void 0 ? void 0 : seen.push(item);
        result.push(deepClone(item, opts));
        seen === null || seen === void 0 ? void 0 : seen.pop();
    }
    return result;
}
function clonePlainObject(source, opts) {
    const target = {};
    for (const key of Object.keys(source)){
        var _opts_assign, _opts_shallow;
        if (opts === null || opts === void 0 ? void 0 : (_opts_assign = opts.assign) === null || _opts_assign === void 0 ? void 0 : _opts_assign.has(key)) {
            target[key] = source[key];
        } else if (opts === null || opts === void 0 ? void 0 : (_opts_shallow = opts.shallow) === null || _opts_shallow === void 0 ? void 0 : _opts_shallow.has(key)) {
            target[key] = shallowClone(source[key]);
        } else {
            target[key] = deepClone(source[key], opts);
        }
    }
    return target;
}
function shallowClone(source) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(source)) {
        return source.slice(0);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(source)) {
        return {
            ...source
        };
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDate"])(source)) {
        return new Date(source);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isRegExp"])(source)) {
        return new RegExp(source.source, source.flags);
    }
    return source;
}
function jsonWalk(json, visit, skip, parallelJson, ctx, acc) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(json)) {
        acc = visit(json, parallelJson, ctx, acc);
        let index = 0;
        for (const node of json){
            acc = jsonWalk(node, visit, skip, parallelJson === null || parallelJson === void 0 ? void 0 : parallelJson[index], ctx, acc);
            index++;
        }
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(json)) {
        acc = visit(json, parallelJson, ctx, acc);
        for (const key of Object.keys(json)){
            if (skip === null || skip === void 0 ? void 0 : skip.has(key)) {
                continue;
            }
            const value = json[key];
            acc = jsonWalk(value, visit, skip, parallelJson === null || parallelJson === void 0 ? void 0 : parallelJson[key], ctx, acc);
        }
    }
    return acc;
}
function jsonApply(target, source) {
    let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const { path, matcherPath = path === null || path === void 0 ? void 0 : path.replace(/(\[[0-9+]+])/i, "[]"), skip = [] } = params;
    if (target == null) {
        throw new Error("AG Charts - target is uninitialised: ".concat(path !== null && path !== void 0 ? path : "<root>"));
    }
    if (source == null) {
        return target;
    }
    if (isProperties(target)) {
        return target.set(source);
    }
    const targetAny = target;
    const targetType = classify(target);
    for (const property of Object.keys(source)){
        if (SKIP_JS_BUILTINS.has(property)) continue;
        const propertyMatcherPath = "".concat(matcherPath ? matcherPath + "." : "").concat(property);
        if (skip.includes(propertyMatcherPath)) continue;
        const newValue = source[property];
        const propertyPath = "".concat(path ? path + "." : "").concat(property);
        const targetClass = targetAny.constructor;
        const currentValue = targetAny[property];
        try {
            const currentValueType = classify(currentValue);
            const newValueType = classify(newValue);
            if (targetType === CLASS_INSTANCE_TYPE && !(property in target || property === "context")) {
                if (newValue === void 0) continue;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("unable to set [".concat(propertyPath, "] in ").concat(targetClass === null || targetClass === void 0 ? void 0 : targetClass.name, " - property is unknown"));
                continue;
            }
            if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== "object")) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("unable to set [".concat(propertyPath, "] in ").concat(targetClass === null || targetClass === void 0 ? void 0 : targetClass.name, " - can't apply type of [").concat(newValueType, "], allowed types are: [").concat(currentValueType, "]"));
                continue;
            }
            if (isProperties(currentValue)) {
                if (newValue === void 0) {
                    currentValue.clear();
                } else {
                    currentValue.set(newValue);
                }
            } else if (newValueType === "object" && property !== "context") {
                if (!(property in targetAny)) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("unable to set [".concat(propertyPath, "] in ").concat(targetClass === null || targetClass === void 0 ? void 0 : targetClass.name, " - property is unknown"));
                    continue;
                }
                if (currentValue == null) {
                    targetAny[property] = newValue;
                } else {
                    jsonApply(currentValue, newValue, {
                        ...params,
                        path: propertyPath,
                        matcherPath: propertyMatcherPath
                    });
                }
            } else {
                targetAny[property] = newValue;
            }
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("unable to set [".concat(propertyPath, "] in [").concat(targetClass === null || targetClass === void 0 ? void 0 : targetClass.name, "]; nested error is: ").concat(error.message));
        }
    }
    return target;
}
function classify(value) {
    if (value == null) {
        return null;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHtmlElement"])(value) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDate"])(value)) {
        return "primitive";
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(value)) {
        return "array";
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(value)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value) ? "object" : CLASS_INSTANCE_TYPE;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(value)) {
        return "function";
    }
    return "primitive";
}
;
var Mutex = class {
    acquire(cb) {
        return new Promise((resolve)=>{
            this.acquireQueue.push([
                cb,
                resolve
            ]);
            if (this.available) {
                this.dispatchNext().catch((e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].errorOnce(e));
            }
        });
    }
    async acquireImmediately(cb) {
        if (!this.available) {
            return false;
        }
        await this.acquire(cb);
        return true;
    }
    async waitForClearAcquireQueue() {
        return this.acquire(()=>Promise.resolve(void 0));
    }
    async dispatchNext() {
        this.available = false;
        var _this_acquireQueue_shift;
        let [next, done] = (_this_acquireQueue_shift = this.acquireQueue.shift()) !== null && _this_acquireQueue_shift !== void 0 ? _this_acquireQueue_shift : [];
        while(next){
            try {
                await next();
                done === null || done === void 0 ? void 0 : done();
            } catch (error) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].error("mutex callback error", error);
                done === null || done === void 0 ? void 0 : done();
            }
            var _this_acquireQueue_shift1;
            [next, done] = (_this_acquireQueue_shift1 = this.acquireQueue.shift()) !== null && _this_acquireQueue_shift1 !== void 0 ? _this_acquireQueue_shift1 : [];
        }
        this.available = true;
    }
    constructor(){
        this.available = true;
        this.acquireQueue = [];
    }
};
// packages/ag-charts-community/src/util/observable.ts
var Observable = class {
    addEventListener(eventType, listener) {
        if (typeof listener !== "function") {
            throw new Error("AG Charts - listener must be a Function");
        }
        const eventTypeListeners = this.eventListeners.get(eventType);
        if (eventTypeListeners) {
            eventTypeListeners.add(listener);
        } else {
            this.eventListeners.set(eventType, /* @__PURE__ */ new Set([
                listener
            ]));
        }
    }
    removeEventListener(type, listener) {
        const listeners = this.eventListeners.get(type);
        if (listeners == null) return;
        listeners.delete(listener);
        if (listeners.size === 0) {
            this.eventListeners.delete(type);
        }
    }
    hasEventListener(type) {
        return this.eventListeners.has(type);
    }
    clearEventListeners() {
        this.eventListeners.clear();
    }
    fireEvent(event) {
        var _this_eventListeners_get;
        (_this_eventListeners_get = this.eventListeners.get(event.type)) === null || _this_eventListeners_get === void 0 ? void 0 : _this_eventListeners_get.forEach((listener)=>listener(event));
    }
    constructor(){
        this.eventListeners = /* @__PURE__ */ new Map();
    }
};
// packages/ag-charts-community/src/util/padding.ts
var Padding = class extends BaseProperties {
    constructor(top = 0, right = top, bottom = top, left = right){
        super();
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        this.left = left;
    }
};
__decorateClass([
    Property
], Padding.prototype, "top", 2);
__decorateClass([
    Property
], Padding.prototype, "right", 2);
__decorateClass([
    Property
], Padding.prototype, "bottom", 2);
__decorateClass([
    Property
], Padding.prototype, "left", 2);
;
function ProxyProperty(proxyPath, configMetadata) {
    const pathArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(proxyPath) ? proxyPath : proxyPath.split(".");
    if (pathArray.length === 1) {
        const [property] = pathArray;
        return addTransformToInstanceProperty((target, _, value)=>target[property] = value, (target)=>target[property], configMetadata);
    }
    return addTransformToInstanceProperty((target, _, value)=>setPath(target, pathArray, value), (target)=>getPath(target, pathArray), configMetadata);
}
function ProxyOnWrite(proxyProperty) {
    return addTransformToInstanceProperty((target, _, value)=>target[proxyProperty] = value);
}
function ProxyPropertyOnWrite(childName, childProperty) {
    return addTransformToInstanceProperty((target, key, value)=>target[childName][childProperty !== null && childProperty !== void 0 ? childProperty : key] = value);
}
function ActionOnSet(opts) {
    const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;
    return addTransformToInstanceProperty((target, _, newValue, oldValue)=>{
        if (newValue !== oldValue) {
            if (oldValue !== void 0) {
                oldValueFn === null || oldValueFn === void 0 ? void 0 : oldValueFn.call(target, oldValue);
            }
            if (newValue !== void 0) {
                newValueFn === null || newValueFn === void 0 ? void 0 : newValueFn.call(target, newValue);
            }
            changeValueFn === null || changeValueFn === void 0 ? void 0 : changeValueFn.call(target, newValue, oldValue);
        }
        return newValue;
    });
}
function ObserveChanges(observerFn) {
    return addObserverToInstanceProperty(observerFn);
}
;
function debouncedAnimationFrame(cb) {
    return buildScheduler((innerCb, _delayMs)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])().requestAnimationFrame(innerCb), cb);
}
function debouncedCallback(cb) {
    return buildScheduler(function(innerCb) {
        let delayMs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        if (delayMs === 0) {
            queueMicrotask(innerCb);
        } else {
            setTimeout(innerCb, delayMs);
        }
    }, cb);
}
function buildScheduler(scheduleFn, cb) {
    let scheduleCount = 0;
    let promiseRunning = false;
    let awaitingPromise;
    let awaitingDone;
    const busy = ()=>{
        return promiseRunning;
    };
    const done = ()=>{
        promiseRunning = false;
        awaitingDone === null || awaitingDone === void 0 ? void 0 : awaitingDone();
        awaitingDone = void 0;
        awaitingPromise = void 0;
        if (scheduleCount > 0) {
            scheduleFn(scheduleCb);
        }
    };
    const scheduleCb = ()=>{
        const count = scheduleCount;
        scheduleCount = 0;
        promiseRunning = true;
        const maybePromise = cb({
            count
        });
        if (!maybePromise) {
            done();
            return;
        }
        maybePromise.then(done, done);
    };
    return {
        schedule (delayMs) {
            if (scheduleCount === 0 && !busy()) {
                scheduleFn(scheduleCb, delayMs);
            }
            scheduleCount++;
        },
        async await () {
            if (!busy()) {
                return;
            }
            awaitingPromise !== null && awaitingPromise !== void 0 ? awaitingPromise : awaitingPromise = new Promise((resolve)=>{
                awaitingDone = resolve;
            });
            while(busy()){
                await awaitingPromise;
            }
        }
    };
}
;
// packages/ag-charts-community/src/widget/widgetEvents.ts
var WIDGET_HTML_EVENTS = [
    "blur",
    "change",
    "contextmenu",
    "focus",
    "keydown",
    "keyup",
    "click",
    "dblclick",
    "mouseenter",
    "mousemove",
    "mouseleave",
    "wheel",
    "touchstart",
    "touchmove",
    "touchend",
    "touchcancel"
];
function allocMouseEvent(type, sourceEvent, current) {
    const { offsetX, offsetY, clientX, clientY } = sourceEvent;
    const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current, sourceEvent);
    return {
        type,
        device: "mouse",
        offsetX,
        offsetY,
        clientX,
        clientY,
        currentX,
        currentY,
        sourceEvent
    };
}
function allocTouchEvent(type, sourceEvent, _current) {
    return {
        type,
        sourceEvent
    };
}
var WidgetAllocators = {
    blur: (sourceEvent)=>{
        return {
            type: "blur",
            sourceEvent
        };
    },
    change: (sourceEvent)=>{
        return {
            type: "change",
            sourceEvent
        };
    },
    contextmenu: (sourceEvent, current)=>{
        return allocMouseEvent("contextmenu", sourceEvent, current);
    },
    focus: (sourceEvent)=>{
        return {
            type: "focus",
            sourceEvent
        };
    },
    keydown: (sourceEvent)=>{
        return {
            type: "keydown",
            sourceEvent
        };
    },
    keyup: (sourceEvent)=>{
        return {
            type: "keyup",
            sourceEvent
        };
    },
    click: (sourceEvent, current)=>{
        return allocMouseEvent("click", sourceEvent, current);
    },
    dblclick: (sourceEvent, current)=>{
        return allocMouseEvent("dblclick", sourceEvent, current);
    },
    mouseenter: (sourceEvent, current)=>{
        return allocMouseEvent("mouseenter", sourceEvent, current);
    },
    mousemove: (sourceEvent, current)=>{
        return allocMouseEvent("mousemove", sourceEvent, current);
    },
    mouseleave: (sourceEvent, current)=>{
        return allocMouseEvent("mouseleave", sourceEvent, current);
    },
    wheel: (sourceEvent)=>{
        const { offsetX, offsetY, clientX, clientY } = sourceEvent;
        const factor = sourceEvent.deltaMode === 0 ? 0.01 : 1;
        const deltaX = sourceEvent.deltaX * factor;
        const deltaY = sourceEvent.deltaY * factor;
        return {
            type: "wheel",
            offsetX,
            offsetY,
            clientX,
            clientY,
            deltaX,
            deltaY,
            sourceEvent
        };
    },
    touchstart: (sourceEvent, current)=>{
        return allocTouchEvent("touchstart", sourceEvent, current);
    },
    touchmove: (sourceEvent, current)=>{
        return allocTouchEvent("touchmove", sourceEvent, current);
    },
    touchend: (sourceEvent, current)=>{
        return allocTouchEvent("touchend", sourceEvent, current);
    },
    touchcancel: (sourceEvent, current)=>{
        return allocTouchEvent("touchcancel", sourceEvent, current);
    }
};
var WidgetEventUtil = class {
    static alloc(type, sourceEvent, current) {
        return WidgetAllocators[type](sourceEvent, current);
    }
    static isHTMLEvent(type) {
        const htmlTypes = WIDGET_HTML_EVENTS;
        return htmlTypes.includes(type);
    }
    static calcCurrentXY(current, event) {
        const currentRect = current.getBoundingClientRect();
        return {
            currentX: event.clientX - currentRect.x,
            currentY: event.clientY - currentRect.y
        };
    }
};
;
var WidgetListenerHTML = class {
    initSourceHandler(type, handler) {
        var _this_sourceListeners;
        (_this_sourceListeners = this.sourceListeners) !== null && _this_sourceListeners !== void 0 ? _this_sourceListeners : this.sourceListeners = {};
        this.sourceListeners[type] = handler;
    }
    lazyGetWidgetListeners(type, target) {
        var _a;
        var _this_sourceListeners;
        if (!(type in ((_this_sourceListeners = this.sourceListeners) !== null && _this_sourceListeners !== void 0 ? _this_sourceListeners : {}))) {
            const sourceHandler = (sourceEvent)=>{
                const widgetEvent = WidgetEventUtil.alloc(type, sourceEvent, target.getElement());
                this.dispatch(type, target, widgetEvent);
            };
            const opts = {};
            if (type.startsWith("touch")) opts.passive = false;
            this.initSourceHandler(type, sourceHandler);
            target.getElement().addEventListener(type, sourceHandler, opts);
        }
        var _this_widgetListeners;
        (_this_widgetListeners = this.widgetListeners) !== null && _this_widgetListeners !== void 0 ? _this_widgetListeners : this.widgetListeners = {};
        var _type;
        (_type = (_a = this.widgetListeners)[type]) !== null && _type !== void 0 ? _type : _a[type] = [];
        return this.widgetListeners[type];
    }
    add(type, target, handler) {
        const listeners = this.lazyGetWidgetListeners(type, target);
        listeners.push(handler);
    }
    remove(type, target, handler) {
        const listeners = this.lazyGetWidgetListeners(type, target);
        const index = listeners.indexOf(handler);
        if (index > -1) listeners.splice(index, 1);
    }
    destroy(target) {
        this.widgetListeners = void 0;
        if (this.sourceListeners) {
            for (const [key, sourceHandler] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entries"])(this.sourceListeners)){
                target.getElement().removeEventListener(key, sourceHandler);
            }
            this.sourceListeners = void 0;
        }
    }
    dispatch(type, target, event) {
        var _this_widgetListeners;
        var _this_widgetListeners_type;
        for (const widgetListener of (_this_widgetListeners_type = (_this_widgetListeners = this.widgetListeners) === null || _this_widgetListeners === void 0 ? void 0 : _this_widgetListeners[type]) !== null && _this_widgetListeners_type !== void 0 ? _this_widgetListeners_type : []){
            widgetListener(event, target);
        }
    }
    constructor(){
        this.widgetListeners = {};
        this.sourceListeners = {};
    }
};
;
;
var MouseDragger = class {
    destroy() {
        this.cleanup.flush();
        this.glob.globalMouseDragCallbacks = void 0;
        this.self.mouseDragger = void 0;
    }
    constructor(glob, self, myCallbacks, downEvent){
        this.glob = glob;
        this.self = self;
        this.window = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])();
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.mousegeneral = (generalEvent)=>{
            generalEvent.stopPropagation();
            generalEvent.stopImmediatePropagation();
        };
        this.mousemove = (moveEvent)=>{
            var _this_glob_globalMouseDragCallbacks;
            moveEvent.stopPropagation();
            moveEvent.stopImmediatePropagation();
            (_this_glob_globalMouseDragCallbacks = this.glob.globalMouseDragCallbacks) === null || _this_glob_globalMouseDragCallbacks === void 0 ? void 0 : _this_glob_globalMouseDragCallbacks.mousemove(moveEvent);
        };
        this.mouseup = (upEvent)=>{
            if (upEvent.button === 0) {
                var _this_glob_globalMouseDragCallbacks;
                upEvent.stopPropagation();
                upEvent.stopImmediatePropagation();
                (_this_glob_globalMouseDragCallbacks = this.glob.globalMouseDragCallbacks) === null || _this_glob_globalMouseDragCallbacks === void 0 ? void 0 : _this_glob_globalMouseDragCallbacks.mouseup(upEvent);
                this.destroy();
            }
        };
        const { window: window2, mousegeneral, mousemove, mouseup } = this;
        this.cleanup.register((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(window2, "mousedown", mousegeneral, {
            capture: true
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(window2, "mouseenter", mousegeneral, {
            capture: true
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(window2, "mouseleave", mousegeneral, {
            capture: true
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(window2, "mouseout", mousegeneral, {
            capture: true
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(window2, "mouseover", mousegeneral, {
            capture: true
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(window2, "mousemove", mousemove, {
            capture: true
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(window2, "mouseup", mouseup, {
            capture: true
        }));
        self.mouseDragger = this;
        glob.globalMouseDragCallbacks = myCallbacks;
        glob.globalMouseDragCallbacks.mousedown(downEvent);
        downEvent.stopPropagation();
        downEvent.stopImmediatePropagation();
    }
};
function startMouseDrag(glob, self, myCallbacks, downEvent) {
    if (glob.globalMouseDragCallbacks != null) return void 0;
    return new MouseDragger(glob, self, myCallbacks, downEvent);
}
;
var LONG_TAP_DURATION_MS = 500;
var LONG_TAP_INTERRUPT_MIN_TOUCHMOVE_PXPX = 100;
function deltaClientSquared(a, b) {
    const dx = a.clientX - b.clientX;
    const dy = a.clientY - b.clientY;
    return dx * dx + dy * dy;
}
var gIsInLongTap = false;
var TouchDragger = class {
    destroy() {
        clearTimeout(this.longtapTimer);
        this.cleanup.flush();
        this.glob.globalTouchDragCallbacks = void 0;
        this.self.touchDragger = void 0;
    }
    findInitialFinger() {
        for(var _len = arguments.length, touchLists = new Array(_len), _key = 0; _key < _len; _key++){
            touchLists[_key] = arguments[_key];
        }
        const touches = touchLists.map((touchList)=>Array.from(touchList)).flat();
        return Array.from(touches).find((v)=>v.identifier === this.initialTouch.identifier);
    }
    constructor(glob, self, myCallbacks, initialTouch, target){
        this.glob = glob;
        this.self = self;
        this.initialTouch = initialTouch;
        this.target = target;
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.longTapInterrupted = false;
        this.longtap = ()=>{
            const { target, initialTouch } = this;
            if (!this.longTapInterrupted) {
                const cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
                target.dispatchEvent(new TouchEvent("touchcancel", {
                    touches: [
                        initialTouch
                    ],
                    bubbles: true
                }));
                gIsInLongTap = true;
                const longTapMove = (e)=>e.preventDefault();
                const longTapEnd = (e)=>{
                    gIsInLongTap = false;
                    e.preventDefault();
                    cleanup.flush();
                };
                cleanup.register((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(target, "touchmove", longTapMove, {
                    passive: false
                }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(target, "touchend", longTapEnd, {
                    passive: false
                }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(target, "touchcancel", longTapEnd, {
                    passive: false
                }));
                const { clientX, clientY } = initialTouch;
                const contextMenuEvent = new PointerEvent("contextmenu", {
                    bubbles: true,
                    cancelable: true,
                    view: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(),
                    clientX,
                    clientY,
                    pointerType: "touch"
                });
                target.dispatchEvent(contextMenuEvent);
            }
        };
        this.touchmove = (moveEvent)=>{
            const { glob, self, initialTouch } = this;
            const touch = this.findInitialFinger(moveEvent.targetTouches);
            if (touch != null) {
                this.longTapInterrupted = this.longTapInterrupted || deltaClientSquared(initialTouch, touch) > LONG_TAP_INTERRUPT_MIN_TOUCHMOVE_PXPX;
                if (self.dragTouchEnabled) {
                    var _glob_globalTouchDragCallbacks;
                    (_glob_globalTouchDragCallbacks = glob.globalTouchDragCallbacks) === null || _glob_globalTouchDragCallbacks === void 0 ? void 0 : _glob_globalTouchDragCallbacks.touchmove(moveEvent, touch);
                }
            }
        };
        this.touchend = (endEvent)=>{
            this.longTapInterrupted = true;
            const touch = this.findInitialFinger(endEvent.changedTouches, endEvent.touches);
            if (touch != null) {
                var _this_glob_globalTouchDragCallbacks;
                (_this_glob_globalTouchDragCallbacks = this.glob.globalTouchDragCallbacks) === null || _this_glob_globalTouchDragCallbacks === void 0 ? void 0 : _this_glob_globalTouchDragCallbacks.touchend(endEvent, touch);
            }
            this.destroy();
        };
        this.longtapTimer = setTimeout(this.longtap, LONG_TAP_DURATION_MS);
        const { touchmove, touchend } = this;
        this.cleanup.register((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(target, "touchmove", touchmove, {
            passive: false
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(target, "touchstart", touchend, {
            passive: false
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(target, "touchend", touchend, {
            passive: false
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(target, "touchcancel", touchend, {
            passive: false
        }));
        self.touchDragger = this;
        glob.globalTouchDragCallbacks = myCallbacks;
    }
};
function startOneFingerTouch(glob, self, myCallbacks, initialTouch, target) {
    if (glob.globalTouchDragCallbacks != null || gIsInLongTap) return void 0;
    return new TouchDragger(glob, self, myCallbacks, initialTouch, target);
}
// packages/ag-charts-community/src/widget/widgetListenerInternal.ts
function makeMouseDrag(current, type, origin3, sourceEvent) {
    const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current.getElement(), sourceEvent);
    const originDeltaX = sourceEvent.pageX - origin3.pageX;
    const originDeltaY = sourceEvent.pageY - origin3.pageY;
    return {
        type,
        device: "mouse",
        offsetX: origin3.offsetX + originDeltaX,
        offsetY: origin3.offsetY + originDeltaY,
        clientX: sourceEvent.clientX,
        clientY: sourceEvent.clientY,
        currentX,
        currentY,
        originDeltaX,
        originDeltaY,
        sourceEvent
    };
}
function getTouchOffsets(current, param) {
    let { pageX, pageY } = param;
    const { x, y } = current.getElement().getBoundingClientRect();
    return {
        offsetX: pageX - x,
        offsetY: pageY - y
    };
}
function makeTouchDrag(current, type, origin3, sourceEvent, touch) {
    const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current.getElement(), touch);
    const originDeltaX = touch.pageX - origin3.pageX;
    const originDeltaY = touch.pageY - origin3.pageY;
    return {
        type,
        device: "touch",
        offsetX: origin3.offsetX + originDeltaX,
        offsetY: origin3.offsetY + originDeltaY,
        clientX: touch.clientX,
        clientY: touch.clientY,
        currentX,
        currentY,
        originDeltaX,
        originDeltaY,
        sourceEvent
    };
}
var GlobalCallbacks = {};
var WidgetListenerInternal = class {
    destroy() {
        var _this_dragTriggerRemover, _this, _this_listeners, _this_mouseDragger, _this_touchDragger;
        (_this_dragTriggerRemover = (_this = this).dragTriggerRemover) === null || _this_dragTriggerRemover === void 0 ? void 0 : _this_dragTriggerRemover.call(_this);
        this.dragTriggerRemover = void 0;
        (_this_listeners = this.listeners) === null || _this_listeners === void 0 ? void 0 : _this_listeners.clear();
        (_this_mouseDragger = this.mouseDragger) === null || _this_mouseDragger === void 0 ? void 0 : _this_mouseDragger.destroy();
        (_this_touchDragger = this.touchDragger) === null || _this_touchDragger === void 0 ? void 0 : _this_touchDragger.destroy();
    }
    getListenerSet(type) {
        var _this_listeners;
        (_this_listeners = this.listeners) !== null && _this_listeners !== void 0 ? _this_listeners : this.listeners = /* @__PURE__ */ new Map();
        let result = this.listeners.get(type);
        if (result === void 0) {
            result = /* @__PURE__ */ new Set();
            this.listeners.set(type, result);
        }
        return result;
    }
    add(type, target, handler) {
        this.getListenerSet(type).add(handler);
        switch(type){
            case "drag-start":
            case "drag-move":
            case "drag-end":
                {
                    this.registerDragTrigger(target);
                    break;
                }
        }
    }
    remove(type, _target, handler) {
        this.getListenerSet(type).delete(handler);
    }
    registerDragTrigger(target) {
        if (this.dragTriggerRemover == null) {
            const element2 = target.getElement();
            const cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
            cleanup.register((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(element2, "mousedown", (event)=>this.triggerMouseDrag(target, event)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(element2, "touchstart", (event)=>this.triggerTouchDrag(target, event), {
                passive: false
            }));
            this.dragTriggerRemover = ()=>cleanup.flush();
        }
    }
    triggerMouseDrag(current, downEvent) {
        if (downEvent.button === 0) {
            this.startMouseDrag(current, downEvent);
        }
    }
    startMouseDrag(current, initialDownEvent) {
        const origin3 = {
            pageX: NaN,
            pageY: NaN,
            offsetX: NaN,
            offsetY: NaN
        };
        partialAssign([
            "pageX",
            "pageY",
            "offsetX",
            "offsetY"
        ], origin3, initialDownEvent);
        const dragCallbacks = {
            mousedown: (downEvent)=>{
                const dragStartEvent = makeMouseDrag(current, "drag-start", origin3, downEvent);
                this.dispatch("drag-start", current, dragStartEvent);
            },
            mousemove: (moveEvent)=>{
                const dragMoveEvent = makeMouseDrag(current, "drag-move", origin3, moveEvent);
                this.dispatch("drag-move", current, dragMoveEvent);
            },
            mouseup: (upEvent)=>{
                const dragEndEvent = makeMouseDrag(current, "drag-end", origin3, upEvent);
                this.dispatch("drag-end", current, dragEndEvent);
                this.endDrag(current, dragEndEvent);
            }
        };
        this.mouseDragger = startMouseDrag(GlobalCallbacks, this, dragCallbacks, initialDownEvent);
    }
    endDrag(target, param) {
        let { sourceEvent, clientX, clientY } = param;
        const elem = target.getElement();
        const rect = elem.getBoundingClientRect();
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boxContains"])(rect, clientX, clientY)) {
            var _sourceEvent_target;
            elem.dispatchEvent(new MouseEvent("mouseleave", sourceEvent));
            (_sourceEvent_target = sourceEvent.target) === null || _sourceEvent_target === void 0 ? void 0 : _sourceEvent_target.dispatchEvent(new MouseEvent("mouseenter", sourceEvent));
        }
    }
    triggerTouchDrag(current, startEvent) {
        const touch = startEvent.targetTouches[0];
        if (startEvent.targetTouches.length === 1 && touch != null) {
            this.startOneFingerTouch(current, startEvent, touch);
        }
    }
    startOneFingerTouch(current, initialEvent, initialTouch) {
        const origin3 = {
            pageX: NaN,
            pageY: NaN,
            ...getTouchOffsets(current, initialTouch)
        };
        partialAssign([
            "pageX",
            "pageY"
        ], origin3, initialTouch);
        const dragCallbacks = {
            touchmove: (moveEvent, touch)=>{
                const dragMoveEvent = makeTouchDrag(current, "drag-move", origin3, moveEvent, touch);
                this.dispatch("drag-move", current, dragMoveEvent);
            },
            touchend: (cancelEvent, touch)=>{
                const dragMoveEvent = makeTouchDrag(current, "drag-end", origin3, cancelEvent, touch);
                this.dispatch("drag-end", current, dragMoveEvent);
            }
        };
        const target = current.getElement();
        this.touchDragger = startOneFingerTouch(GlobalCallbacks, this, dragCallbacks, initialTouch, target);
        const dragStartEvent = makeTouchDrag(current, "drag-start", origin3, initialEvent, initialTouch);
        this.dispatch("drag-start", current, dragStartEvent);
    }
    dispatch(type, current, event) {
        for (const handler of this.getListenerSet(type)){
            handler(event, current);
        }
        this.dispatchCallback(type, event);
    }
    constructor(dispatchCallback){
        this.dispatchCallback = dispatchCallback;
        this.dragTouchEnabled = true;
    }
};
// packages/ag-charts-community/src/widget/widget.ts
var WidgetBounds = class {
    setBounds(bounds) {
        var _this_elemContainer;
        setElementBBox((_this_elemContainer = this.elemContainer) !== null && _this_elemContainer !== void 0 ? _this_elemContainer : this.elem, bounds);
    }
    getBounds() {
        var _this_elemContainer;
        return getElementBBox((_this_elemContainer = this.elemContainer) !== null && _this_elemContainer !== void 0 ? _this_elemContainer : this.elem);
    }
    static setElementContainer(widget, elemContainer) {
        const currentBounds = widget.getBounds();
        setElementBBox(elemContainer, currentBounds);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setElementStyles"])(widget.elem, {
            width: "100%",
            height: "100%"
        });
        widget.elem.remove();
        widget.elemContainer = elemContainer;
        widget.elemContainer.replaceChildren(widget.elem);
    }
    constructor(elem){
        this.elem = elem;
    }
};
var Widget = class extends WidgetBounds {
    set id(elementId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "id", elementId);
    }
    get id() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttribute"])(this.elem, "id");
    }
    getElement() {
        return this.elem;
    }
    getBoundingClientRect() {
        return this.elem.getBoundingClientRect();
    }
    get clientWidth() {
        return this.elem.clientWidth;
    }
    get clientHeight() {
        return this.elem.clientHeight;
    }
    destroy() {
        var _this_destroyListener, _this, _this_parent, _this_internalListener, _this_htmlListener;
        (_this_destroyListener = (_this = this).destroyListener) === null || _this_destroyListener === void 0 ? void 0 : _this_destroyListener.call(_this);
        this.destroyListener = void 0;
        (_this_parent = this.parent) === null || _this_parent === void 0 ? void 0 : _this_parent.removeChild(this);
        this.children.forEach((child)=>{
            child.parent = void 0;
            child.destroy();
        });
        this.children.length = 0;
        this.destructor();
        this.remove();
        (_this_internalListener = this.internalListener) === null || _this_internalListener === void 0 ? void 0 : _this_internalListener.destroy();
        (_this_htmlListener = this.htmlListener) === null || _this_htmlListener === void 0 ? void 0 : _this_htmlListener.destroy(this);
    }
    remove() {
        var _this_elemContainer;
        this.elem.remove();
        (_this_elemContainer = this.elemContainer) === null || _this_elemContainer === void 0 ? void 0 : _this_elemContainer.remove();
    }
    setHidden(hidden) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setElementStyle"])(this.elem, "display", hidden ? "none" : void 0);
    }
    isHidden() {
        var _getWindow6_getComputedStyle, _getWindow6;
        return ((_getWindow6 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])()) === null || _getWindow6 === void 0 ? void 0 : (_getWindow6_getComputedStyle = _getWindow6.getComputedStyle) === null || _getWindow6_getComputedStyle === void 0 ? void 0 : _getWindow6_getComputedStyle.call(_getWindow6, this.elem).display) === "none";
    }
    setCursor(cursor) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setElementStyle"])(this.elem, "cursor", cursor);
    }
    setTextContent(textContent) {
        this.elem.textContent = textContent !== null && textContent !== void 0 ? textContent : null;
    }
    setAriaDescribedBy(ariaDescribedBy) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "aria-describedby", ariaDescribedBy);
    }
    setAriaHidden(ariaHidden) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "aria-hidden", ariaHidden);
    }
    setAriaLabel(ariaLabel) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "aria-label", ariaLabel);
    }
    setAriaExpanded(ariaExpanded) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "aria-expanded", ariaExpanded);
    }
    setAriaControls(ariaControls) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "aria-controls", ariaControls);
    }
    setAriaHasPopup(ariaHasPopup) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "aria-haspopup", ariaHasPopup);
    }
    setInnerHTML(html) {
        this.elem.innerHTML = html;
    }
    setPointerEvents(pointerEvents) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setElementStyle"])(this.elem, "pointer-events", pointerEvents);
    }
    isDisabled() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttribute"])(this.elem, "aria-disabled", false);
    }
    hasPopup() {
        const ariaHasPopup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttribute"])(this.elem, "aria-haspopup");
        return ariaHasPopup !== void 0 && ariaHasPopup !== "false";
    }
    parseFloat(s) {
        return s === "" ? 0 : parseFloat(s);
    }
    cssLeft() {
        return this.parseFloat(this.elem.style.left);
    }
    cssTop() {
        return this.parseFloat(this.elem.style.top);
    }
    cssWidth() {
        return this.parseFloat(this.elem.style.width);
    }
    cssHeight() {
        return this.parseFloat(this.elem.style.height);
    }
    focus(opts) {
        this.elem.focus(opts);
    }
    setFocusOverride(focus) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "data-focus-override", focus);
    }
    setPreventsDefault(preventDefault) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "data-preventdefault", preventDefault);
    }
    setTabIndex(tabIndex) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "tabindex", tabIndex);
    }
    addChild(child) {
        this.addChildToDOM(child, this.getBefore(child));
        this.children.push(child);
        child.index = this.children.length - 1;
        child.parent = this;
        this.onChildAdded(child);
    }
    removeChild(child) {
        const i = this.children.findIndex((value)=>value === child);
        this.children.splice(i, 1);
        this.removeChildFromDOM(child);
        this.onChildRemoved(child);
    }
    moveChild(child, domIndex) {
        if (child.domIndex === domIndex) return;
        child.domIndex = domIndex;
        this.removeChildFromDOM(child);
        this.addChildToDOM(child, this.getBefore(child));
    }
    addClass() {
        for(var _len = arguments.length, tokens = new Array(_len), _key = 0; _key < _len; _key++){
            tokens[_key] = arguments[_key];
        }
        this.elem.classList.add(...tokens);
    }
    removeClass() {
        for(var _len = arguments.length, tokens = new Array(_len), _key = 0; _key < _len; _key++){
            tokens[_key] = arguments[_key];
        }
        this.elem.classList.remove(...tokens);
    }
    toggleClass(token, force) {
        this.elem.classList.toggle(token, force);
    }
    appendOrInsert(child, before) {
        if (before) {
            before.getElement().insertAdjacentElement("beforebegin", child);
        } else {
            this.elem.appendChild(child);
        }
    }
    addChildToDOM(child, before) {
        this.appendOrInsert(child.getElement(), before);
    }
    removeChildFromDOM(child) {
        this.elem.removeChild(child.getElement());
    }
    onChildAdded(_child) {}
    onChildRemoved(_child) {}
    getBefore(param) {
        let { domIndex } = param;
        if (domIndex === void 0) return void 0;
        return this.children.filter((child)=>child.domIndex !== void 0 && child.domIndex > domIndex).reduce((prev, curr)=>!prev || curr.domIndex < prev.domIndex ? curr : prev, void 0);
    }
    addListener(type, listener) {
        if (WidgetEventUtil.isHTMLEvent(type)) {
            var _this_htmlListener;
            (_this_htmlListener = this.htmlListener) !== null && _this_htmlListener !== void 0 ? _this_htmlListener : this.htmlListener = new WidgetListenerHTML();
            this.htmlListener.add(type, this, listener);
        } else {
            var _this_internalListener;
            (_this_internalListener = this.internalListener) !== null && _this_internalListener !== void 0 ? _this_internalListener : this.internalListener = new WidgetListenerInternal(this.onDispatch.bind(this));
            this.internalListener.add(type, this, listener);
        }
        return ()=>this.removeListener(type, listener);
    }
    removeListener(type, listener) {
        if (WidgetEventUtil.isHTMLEvent(type)) {
            var _this_htmlListener;
            (_this_htmlListener = this.htmlListener) === null || _this_htmlListener === void 0 ? void 0 : _this_htmlListener.remove(type, this, listener);
        } else if (this.htmlListener != null) {
            var _this_internalListener;
            (_this_internalListener = this.internalListener) === null || _this_internalListener === void 0 ? void 0 : _this_internalListener.remove(type, this, listener);
        }
    }
    setDragTouchEnabled(dragTouchEnabled) {
        var _this_internalListener;
        (_this_internalListener = this.internalListener) !== null && _this_internalListener !== void 0 ? _this_internalListener : this.internalListener = new WidgetListenerInternal(this.onDispatch.bind(this));
        this.internalListener.dragTouchEnabled = dragTouchEnabled;
    }
    onDispatch(type, event) {
        var _event_sourceEvent;
        if (!((_event_sourceEvent = event.sourceEvent) === null || _event_sourceEvent === void 0 ? void 0 : _event_sourceEvent.bubbles)) return;
        let { parent } = this;
        while(parent != null){
            const { internalListener } = parent;
            if (internalListener != null) {
                const parentEvent = {
                    ...event,
                    ...WidgetEventUtil.calcCurrentXY(parent.getElement(), event)
                };
                internalListener.dispatch(type, parent, parentEvent);
            }
            parent = parent.parent;
        }
    }
    static addWindowEvent(_type, listener) {
        const pagehideHandler = (event)=>{
            if (event.persisted) {
                return;
            }
            listener();
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(), "pagehide", pagehideHandler);
    }
    constructor(){
        super(...arguments);
        this.index = NaN;
        this.children = [];
    }
};
;
;
// packages/ag-charts-community/src/util/canvas.util.ts
function createCanvasContext() {
    let width2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, height2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return new OffscreenCanvas(width2, height2).getContext("2d");
}
// packages/ag-charts-community/src/util/lruCache.ts
var LRUCache = class {
    get(key) {
        if (!this.store.has(key)) return void 0;
        const hit = this.store.get(key);
        this.store.delete(key);
        this.store.set(key, hit);
        return hit;
    }
    has(key) {
        return this.store.has(key);
    }
    set(key, value) {
        this.store.set(key, value);
        if (this.store.size > this.maxCacheSize) {
            const iterator = this.store.keys();
            let evictCount = this.store.size - this.maxCacheSize;
            while(evictCount > 0){
                const evictKeyIterator = iterator.next();
                if (!evictKeyIterator.done) {
                    this.store.delete(evictKeyIterator.value);
                }
                evictCount--;
            }
        }
        return value;
    }
    clear() {
        this.store.clear();
    }
    constructor(maxCacheSize = 5){
        this.maxCacheSize = maxCacheSize;
        this.store = /* @__PURE__ */ new Map();
    }
};
// packages/ag-charts-community/src/util/textMeasurer.ts
var CachedTextMeasurerPool = class {
    // Measures the dimensions of the provided text, handling multiline if needed.
    static measureText(text, options) {
        const textMeasurer = this.getMeasurer(options);
        return textMeasurer.measureText(text);
    }
    static measureLines(text, options) {
        const textMeasurer = this.getMeasurer(options);
        return textMeasurer.measureLines(text);
    }
    // Gets a TextMeasurer instance, configuring text alignment and baseline if provided.
    static getMeasurer(options) {
        const font2 = TextUtils.toFontString(options.font);
        var _options_textAlign, _options_textBaseline;
        const key = "".concat(font2, "-").concat((_options_textAlign = options.textAlign) !== null && _options_textAlign !== void 0 ? _options_textAlign : "start", "-").concat((_options_textBaseline = options.textBaseline) !== null && _options_textBaseline !== void 0 ? _options_textBaseline : "top");
        var _this_instanceMap_get;
        return (_this_instanceMap_get = this.instanceMap.get(key)) !== null && _this_instanceMap_get !== void 0 ? _this_instanceMap_get : this.createFontMeasurer(font2, options, key);
    }
    static clear() {
        this.instanceMap.clear();
    }
    // Creates or retrieves a TextMeasurer instance for a specific font.
    static createFontMeasurer(font2, options, key) {
        const ctx = createCanvasContext();
        ctx.font = font2;
        var _options_textAlign;
        ctx.textAlign = (_options_textAlign = options.textAlign) !== null && _options_textAlign !== void 0 ? _options_textAlign : "start";
        var _options_textBaseline;
        ctx.textBaseline = (_options_textBaseline = options.textBaseline) !== null && _options_textBaseline !== void 0 ? _options_textBaseline : "top";
        const measurer2 = new CachedTextMeasurer(ctx, options);
        this.instanceMap.set(key, measurer2);
        return measurer2;
    }
};
CachedTextMeasurerPool.instanceMap = new LRUCache(10);
var CachedTextMeasurer = class {
    textWidth(text, estimate) {
        return this.textMeasurer.textWidth(text, estimate);
    }
    measureText(text) {
        return this.textMeasurer.measureText(text);
    }
    measureLines(text) {
        return this.textMeasurer.measureLines(text);
    }
    cachedCtxMeasureText(text) {
        if (!this.measureMap.has(text)) {
            const rawResult = this.ctx.measureText(text);
            this.measureMap.set(text, {
                actualBoundingBoxAscent: rawResult.actualBoundingBoxAscent,
                emHeightAscent: rawResult.emHeightAscent,
                emHeightDescent: rawResult.emHeightDescent,
                actualBoundingBoxDescent: rawResult.actualBoundingBoxDescent,
                actualBoundingBoxLeft: rawResult.actualBoundingBoxLeft,
                actualBoundingBoxRight: rawResult.actualBoundingBoxRight,
                alphabeticBaseline: rawResult.alphabeticBaseline,
                fontBoundingBoxAscent: rawResult.fontBoundingBoxAscent,
                fontBoundingBoxDescent: rawResult.fontBoundingBoxDescent,
                hangingBaseline: rawResult.hangingBaseline,
                ideographicBaseline: rawResult.ideographicBaseline,
                width: rawResult.width
            });
        }
        return this.measureMap.get(text);
    }
    constructor(ctx, options){
        this.ctx = ctx;
        // cached text measurements
        this.measureMap = new LRUCache(100);
        if (options.textAlign) {
            ctx.textAlign = options.textAlign;
        }
        if (options.textBaseline) {
            ctx.textBaseline = options.textBaseline;
        }
        ctx.font = TextUtils.toFontString(options.font);
        var _options_textBaseline;
        this.textMeasurer = new SimpleTextMeasurer((t)=>this.cachedCtxMeasureText(t), (_options_textBaseline = options.textBaseline) !== null && _options_textBaseline !== void 0 ? _options_textBaseline : "alphabetic");
    }
};
var TextUtils = class {
    static toFontString(param) {
        let { fontSize = 10, fontStyle, fontWeight, fontFamily } = param;
        let fontString = "";
        if (fontStyle && fontStyle !== "normal") {
            fontString += "".concat(fontStyle, " ");
        }
        if (fontWeight && fontWeight !== "normal" && fontWeight !== 400) {
            fontString += "".concat(fontWeight, " ");
        }
        fontString += "".concat(fontSize, "px");
        fontString += " ".concat(fontFamily);
        return fontString.trim();
    }
    static getLineHeight(fontSize) {
        return Math.ceil(fontSize * this.defaultLineHeight);
    }
    static getHorizontalModifier(textAlign) {
        switch(textAlign){
            case "left":
            case "start":
                return 0;
            case "center":
                return 0.5;
            case "right":
            case "end":
                return 1;
            default:
                return 0;
        }
    }
    // Determines vertical offset modifier based on text baseline.
    static getVerticalModifier(textBaseline) {
        switch(textBaseline){
            case "hanging":
            case "top":
                return 0;
            case "middle":
                return 0.5;
            case "alphabetic":
            case "bottom":
            case "ideographic":
            default:
                return 1;
        }
    }
};
TextUtils.EllipsisChar = "\u2026";
// Representation for text clipping.
TextUtils.defaultLineHeight = 1.15;
// Normally between 1.1 and 1.2
TextUtils.lineSplitter = /\r?\n/g;
var SimpleTextMeasurer = class {
    // Measures metrics for a single line of text.
    getMetrics(text) {
        const m = this.measureTextFn(text);
        var _m_fontBoundingBoxAscent;
        (_m_fontBoundingBoxAscent = m.fontBoundingBoxAscent) !== null && _m_fontBoundingBoxAscent !== void 0 ? _m_fontBoundingBoxAscent : m.fontBoundingBoxAscent = m.emHeightAscent;
        var _m_fontBoundingBoxDescent;
        (_m_fontBoundingBoxDescent = m.fontBoundingBoxDescent) !== null && _m_fontBoundingBoxDescent !== void 0 ? _m_fontBoundingBoxDescent : m.fontBoundingBoxDescent = m.emHeightDescent;
        return {
            width: m.width,
            height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,
            lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent
        };
    }
    // Calculates aggregated metrics for multiline text.
    getMultilineMetrics(lines) {
        let width2 = 0;
        let height2 = 0;
        let offsetTop = 0;
        let offsetLeft = 0;
        let baselineDistance = 0;
        let alphabeticBaseline = 0;
        const verticalModifier = TextUtils.getVerticalModifier(this.textBaseline);
        const lineMetrics = [];
        let index = 0;
        const length2 = lines.length;
        for (const line of lines){
            const m = this.measureTextFn(line);
            var _m_fontBoundingBoxAscent;
            (_m_fontBoundingBoxAscent = m.fontBoundingBoxAscent) !== null && _m_fontBoundingBoxAscent !== void 0 ? _m_fontBoundingBoxAscent : m.fontBoundingBoxAscent = m.emHeightAscent;
            var _m_fontBoundingBoxDescent;
            (_m_fontBoundingBoxDescent = m.fontBoundingBoxDescent) !== null && _m_fontBoundingBoxDescent !== void 0 ? _m_fontBoundingBoxDescent : m.fontBoundingBoxDescent = m.emHeightDescent;
            if (width2 < m.width) {
                width2 = m.width;
            }
            if (offsetLeft < m.actualBoundingBoxLeft) {
                offsetLeft = m.actualBoundingBoxLeft;
            }
            if (index === 0) {
                height2 += m.actualBoundingBoxAscent;
                offsetTop += m.actualBoundingBoxAscent;
                alphabeticBaseline = m.alphabeticBaseline;
            } else {
                baselineDistance += m.fontBoundingBoxAscent;
            }
            if (index === length2 - 1) {
                height2 += m.actualBoundingBoxDescent;
            } else {
                baselineDistance += m.fontBoundingBoxDescent;
            }
            lineMetrics.push({
                text: line,
                width: m.width,
                height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,
                lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,
                offsetTop: m.actualBoundingBoxAscent,
                offsetLeft: m.actualBoundingBoxLeft
            });
            index++;
        }
        height2 += baselineDistance;
        offsetTop += baselineDistance * verticalModifier;
        return {
            width: width2,
            height: height2,
            offsetTop,
            offsetLeft,
            alphabeticBaseline,
            lineMetrics
        };
    }
    textWidth(text, estimate) {
        if (estimate) {
            let estimatedWidth = 0;
            for(let i = 0; i < text.length; i++){
                estimatedWidth += this.textWidth(text.charAt(i));
            }
            return estimatedWidth;
        }
        if (text.length > 1) {
            return this.measureTextFn(text).width;
        }
        var _this_charMap_get;
        return (_this_charMap_get = this.charMap.get(text)) !== null && _this_charMap_get !== void 0 ? _this_charMap_get : this.charWidth(text);
    }
    measureText(text) {
        return this.getMetrics(text);
    }
    // Measures the dimensions of the provided text, handling multiline if needed.
    measureLines(text) {
        const lines = typeof text === "string" ? text.split(TextUtils.lineSplitter) : text;
        return this.getMultilineMetrics(lines);
    }
    charWidth(char) {
        const { width: width2 } = this.measureTextFn(char);
        this.charMap.set(char, width2);
        return width2;
    }
    constructor(measureTextFn, textBaseline = "alphabetic"){
        this.measureTextFn = measureTextFn;
        this.textBaseline = textBaseline;
        // local chars width cache per TextMeasurer
        this.charMap = /* @__PURE__ */ new Map();
    }
};
;
function formatBytes(value) {
    for (const unit of [
        "B",
        "KB",
        "MB",
        "GB"
    ]){
        if (value < 1536) {
            return "".concat(value.toFixed(1)).concat(unit);
        }
        value /= 1024;
    }
    return "".concat(value.toFixed(1), "TB}");
}
function memoryUsage() {
    if (!("memory" in performance)) return;
    const { totalJSHeapSize, usedJSHeapSize, jsHeapSizeLimit } = performance.memory;
    const result = [];
    for (const amount of [
        usedJSHeapSize,
        totalJSHeapSize,
        jsHeapSizeLimit
    ]){
        if (typeof amount !== "number") continue;
        result.push(formatBytes(amount));
    }
    return "Heap ".concat(result.join(" / "));
}
function debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats) {
    let extraDebugStats = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, seriesRect = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : BBox.zero;
    if (!Debug.check("scene:stats" /* SCENE_STATS */ , "scene:stats:verbose" /* SCENE_STATS_VERBOSE */ )) return;
    const { layersRendered = 0, layersSkipped = 0, nodesRendered = 0, nodesSkipped = 0, opsPerformed = 0, opsSkipped = 0 } = renderCtxStats !== null && renderCtxStats !== void 0 ? renderCtxStats : {};
    const end2 = performance.now();
    const { start: start2, ...durations } = debugSplitTimes;
    const splits = Object.entries(durations).map((param)=>{
        let [n, t] = param;
        return time(n, t);
    }).filter((v)=>v != null).join(" + ");
    const extras = Object.entries(extraDebugStats).map((param)=>{
        let [k, v] = param;
        return "".concat(k, ": ").concat(JSON.stringify(v));
    }).join(" ; ");
    const detailedStats = Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */ );
    const memUsage = memoryUsage();
    const stats = [
        "".concat(time("\u23F1\uFE0F", start2, end2), " (").concat(splits, ")"),
        "".concat(extras),
        "Layers: ".concat(detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size),
        detailedStats ? "Nodes: ".concat(pct(nodesRendered, nodesSkipped)) : null,
        detailedStats ? "Ops: ".concat(pct(opsPerformed, opsSkipped)) : null,
        detailedStats && memUsage ? memUsage : null
    ].filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"]);
    const measurer2 = new SimpleTextMeasurer((t)=>ctx.measureText(t));
    const statsSize = new Map(stats.map((t)=>[
            t,
            measurer2.measureLines(t)
        ]));
    const width2 = Math.max(...Array.from(statsSize.values(), (s)=>s.width));
    const height2 = accumulate(statsSize.values(), (s)=>s.height);
    const x = 2 + seriesRect.x;
    ctx.save();
    try {
        ctx.fillStyle = "white";
        ctx.fillRect(x, 0, width2, height2);
        ctx.fillStyle = "black";
        let y = 0;
        for (const [stat, size] of statsSize.entries()){
            y += size.height;
            ctx.fillText(stat, x, y);
        }
    } catch (e) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Error during debug stats rendering", e);
    } finally{
        ctx.restore();
    }
}
function prepareSceneNodeHighlight(ctx) {
    const config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])("agChartsSceneDebug"));
    const result = [];
    for (const name of config){
        if (name === "layout") {
            result.push("seriesRoot", "legend", "root", /.*Axis-\d+-axis.*/);
        } else {
            result.push(name);
        }
    }
    ctx.debugNodeSearch = result;
}
function debugSceneNodeHighlight(ctx, debugNodes) {
    ctx.save();
    try {
        for (const [name, node] of Object.entries(debugNodes)){
            const bbox = Transformable.toCanvas(node);
            if (!bbox) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].log("Scene.render() - no bbox for debugged node [".concat(name, "]."));
                continue;
            }
            ctx.globalAlpha = 0.8;
            ctx.strokeStyle = "red";
            ctx.lineWidth = 1;
            ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
            ctx.fillStyle = "red";
            ctx.strokeStyle = "white";
            ctx.font = "16px sans-serif";
            ctx.textBaseline = "top";
            ctx.textAlign = "left";
            ctx.lineWidth = 2;
            ctx.strokeText(name, bbox.x, bbox.y, bbox.width);
            ctx.fillText(name, bbox.x, bbox.y, bbox.width);
        }
    } catch (e) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Error during debug rendering", e);
    } finally{
        ctx.restore();
    }
}
var skippedProperties = /* @__PURE__ */ new Set();
var allowedProperties = /* @__PURE__ */ new Set([
    "gradient",
    // '_datum',
    "zIndex",
    "clipRect",
    "cachedBBox",
    "childNodeCounts",
    "path",
    "__zIndex",
    "name",
    "__scalingCenterX",
    "__scalingCenterY",
    "__rotationCenterX",
    "__rotationCenterY",
    "_previousDatum",
    "__fill",
    "__lineDash",
    "borderPath",
    "borderClipPath",
    "_clipPath"
]);
function nodeProps(node) {
    const { ...allProps } = node;
    for (const prop of Object.keys(allProps)){
        if (allowedProperties.has(prop)) continue;
        if (typeof allProps[prop] === "number") continue;
        if (typeof allProps[prop] === "string") continue;
        if (typeof allProps[prop] === "boolean") continue;
        skippedProperties.add(prop);
        delete allProps[prop];
    }
    return allProps;
}
function buildTree(node, mode) {
    if (!Debug.check(true, "scene" /* SCENE */ )) {
        return {};
    }
    let order = 0;
    var _node_name;
    return {
        node: mode === "json" ? nodeProps(node) : node,
        name: (_node_name = node.name) !== null && _node_name !== void 0 ? _node_name : node.id,
        dirty: node instanceof Group ? node.dirty : void 0,
        ...Array.from(node instanceof Group ? node.children() : [], (c)=>buildTree(c, mode)).reduce((result, childTree)=>{
            let { name: treeNodeName } = childTree;
            const { node: { visible, opacity, zIndex, translationX, translationY, rotation, scalingX, scalingY }, node: childNode } = childTree;
            if (!visible || opacity <= 0) {
                treeNodeName = "(".concat(treeNodeName, ")");
            }
            if (Group.is(childNode) && childNode.renderToOffscreenCanvas) {
                treeNodeName = "*".concat(treeNodeName, "*");
            }
            const zIndexString = Array.isArray(zIndex) ? "(".concat(zIndex.join(", "), ")") : zIndex;
            const key = [
                "".concat((order++).toString().padStart(3, "0"), "|"),
                "".concat(treeNodeName !== null && treeNodeName !== void 0 ? treeNodeName : "<unknown>"),
                "z: ".concat(zIndexString),
                translationX && "x: ".concat(translationX),
                translationY && "y: ".concat(translationY),
                rotation && "r: ".concat(rotation),
                scalingX != null && scalingX !== 1 && "sx: ".concat(scalingX),
                scalingY != null && scalingY !== 1 && "sy: ".concat(scalingY)
            ].filter((v)=>!!v).join(" ");
            let selectedKey = key;
            let index = 1;
            while(result[selectedKey] != null && index < 100){
                selectedKey = "".concat(key, " (").concat(index++, ")");
            }
            result[selectedKey] = childTree;
            return result;
        }, {})
    };
}
function buildDirtyTree(node) {
    const nodeDirty = node instanceof Group ? node.dirty : void 0;
    if (!nodeDirty) {
        return {
            dirtyTree: {},
            paths: []
        };
    }
    const childrenDirtyTree = Array.from(node instanceof Group ? node.children() : [], (c)=>buildDirtyTree(c)).filter((c)=>c.paths.length > 0);
    var _node_name;
    const name = Group.is(node) ? (_node_name = node.name) !== null && _node_name !== void 0 ? _node_name : node.id : node.id;
    const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c)=>c.paths).map((p)=>"".concat(name, ".").concat(p)) : [
        name
    ];
    return {
        dirtyTree: {
            name,
            node,
            dirty: nodeDirty,
            ...childrenDirtyTree.map((c)=>c.dirtyTree).filter((t)=>t.dirty != null).reduce((result, childTree)=>{
                var _childTree_name;
                result[(_childTree_name = childTree.name) !== null && _childTree_name !== void 0 ? _childTree_name : "<unknown>"] = childTree;
                return result;
            }, {})
        },
        paths
    };
}
function pct(rendered, skipped) {
    const total = rendered + skipped;
    return "".concat(rendered, " / ").concat(total, " (").concat(Math.round(100 * rendered / total), "%)");
}
function time(name, start2, end2) {
    const duration = end2 != null ? end2 - start2 : start2;
    return "".concat(name, ": ").concat(Math.round(duration * 100) / 100, "ms");
}
function accumulate(iterator, mapper) {
    let sum2 = 0;
    for (const item of iterator){
        sum2 += mapper(item);
    }
    return sum2;
}
;
// packages/ag-charts-community/src/scene/util/corner.ts
var drawCorner = (path, param, cornerRadius, move)=>{
    let { x0, y0, x1, y1, cx, cy } = param;
    if (move) {
        path.moveTo(x0, y0);
    }
    if (x0 !== x1 || y0 !== y1) {
        const r0 = Math.atan2(y0 - cy, x0 - cx);
        const r1 = Math.atan2(y1 - cy, x1 - cx);
        path.arc(cx, cy, cornerRadius, r0, r1);
    } else {
        path.lineTo(x0, y0);
    }
};
;
var Path = class extends Shape {
    set clipX(value) {
        this._clipX = value;
        this.dirtyPath = true;
    }
    set clipY(value) {
        this._clipY = value;
        this.dirtyPath = true;
    }
    set dirtyPath(value) {
        if (this._dirtyPath !== value) {
            this._dirtyPath = value;
            if (value) {
                this.markDirty("path");
            }
        }
    }
    get dirtyPath() {
        return this._dirtyPath;
    }
    checkPathDirty() {
        var _this_fillShadow, _this__clipPath;
        if (this._dirtyPath) {
            return;
        }
        var _this_fillShadow_isDirty, _this__clipPath_isDirty;
        this.dirtyPath = this.path.isDirty() || ((_this_fillShadow_isDirty = (_this_fillShadow = this.fillShadow) === null || _this_fillShadow === void 0 ? void 0 : _this_fillShadow.isDirty()) !== null && _this_fillShadow_isDirty !== void 0 ? _this_fillShadow_isDirty : false) || ((_this__clipPath_isDirty = (_this__clipPath = this._clipPath) === null || _this__clipPath === void 0 ? void 0 : _this__clipPath.isDirty()) !== null && _this__clipPath_isDirty !== void 0 ? _this__clipPath_isDirty : false);
    }
    resetPathDirty() {
        this.path.clear(true);
        this._dirtyPath = false;
    }
    isPathDirty() {
        return this.path.isDirty();
    }
    onChangeDetection(property) {
        if (!this._dirtyPath) {
            this._dirtyPath = true;
            super.onChangeDetection(property);
        }
    }
    computeBBox() {
        this.updatePathIfDirty();
        return this.path.computeBBox();
    }
    isPointInPath(x, y) {
        this.updatePathIfDirty();
        return this.path.closedPath && this.path.isPointInPath(x, y);
    }
    distanceSquared(x, y) {
        return this.distanceSquaredTransformedPoint(x, y);
    }
    svgPathData(transform) {
        this.updatePathIfDirty();
        return this.path.toSVG(transform);
    }
    distanceSquaredTransformedPoint(x, y) {
        this.updatePathIfDirty();
        if (this.path.closedPath && this.path.isPointInPath(x, y)) {
            return 0;
        }
        return this.path.distanceSquared(x, y);
    }
    isDirtyPath() {
        return false;
    }
    updatePath() {}
    updatePathIfDirty() {
        if (this.dirtyPath || this.isDirtyPath()) {
            this.updatePath();
            this.dirtyPath = false;
        }
    }
    preRender(renderCtx) {
        if (renderCtx.devicePixelRatio !== this.lastPixelRatio) {
            this.dirtyPath = true;
        }
        this.lastPixelRatio = renderCtx.devicePixelRatio;
        this.updatePathIfDirty();
        return super.preRender(renderCtx, this.path.commands.length);
    }
    render(renderCtx) {
        var _this_fillShadow;
        const { ctx } = renderCtx;
        if (this.clip && !isNaN(this._clipX) && !isNaN(this._clipY)) {
            ctx.save();
            try {
                var _this__clipPath;
                const margin = this.strokeWidth / 2;
                var _this__clipPath1;
                (_this__clipPath1 = this._clipPath) !== null && _this__clipPath1 !== void 0 ? _this__clipPath1 : this._clipPath = new ExtendedPath2D();
                this._clipPath.clear();
                this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);
                ctx.clip((_this__clipPath = this._clipPath) === null || _this__clipPath === void 0 ? void 0 : _this__clipPath.getPath2D());
                if (this._clipX > 0 && this._clipY > 0) {
                    this.drawPath(ctx);
                }
            } finally{
                ctx.restore();
            }
        } else {
            this._clipPath = void 0;
            this.drawPath(ctx);
        }
        (_this_fillShadow = this.fillShadow) === null || _this_fillShadow === void 0 ? void 0 : _this_fillShadow.markClean();
        super.render(renderCtx);
    }
    drawPath(ctx) {
        this.fillStroke(ctx, this.path.getPath2D());
    }
    toSVG() {
        if (!this.visible) return;
        const element2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("path");
        element2.setAttribute("d", this.svgPathData());
        const defs = this.applySvgFillAttributes(element2, []);
        this.applySvgStrokeAttributes(element2);
        return {
            elements: [
                element2
            ],
            defs
        };
    }
    constructor(){
        super(...arguments);
        /**
     * Declare a path to retain for later rendering and hit testing
     * using custom Path2D class. Think of it as a TypeScript version
     * of the native Path2D (with some differences) that works in all browsers.
     */ this.path = new ExtendedPath2D();
        this._clipX = NaN;
        this._clipY = NaN;
        this.clip = false;
        /**
     * The path only has to be updated when certain attributes change.
     * For example, if transform attributes (such as `translationX`)
     * are changed, we don't have to update the path. The `dirtyPath` flag
     * is how we keep track if the path has to be updated or not.
     */ this._dirtyPath = true;
        this.lastPixelRatio = NaN;
    }
};
Path.className = "Path";
__decorateClass([
    SceneChangeDetection()
], Path.prototype, "clip", 2);
__decorateClass([
    SceneChangeDetection()
], Path.prototype, "clipX", 1);
__decorateClass([
    SceneChangeDetection()
], Path.prototype, "clipY", 1);
// packages/ag-charts-community/src/scene/shape/rect.ts
var epsilon = 1e-6;
var cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius)=>{
    let leadingClipped = false;
    let trailingClipped = false;
    let leading0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - leadingInset ** 2, 0));
    let leading1 = 0;
    let trailing0 = 0;
    let trailing1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - trailingInset ** 2, 0));
    if (leading0 > leadingEdge) {
        leadingClipped = true;
        leading0 = leadingEdge;
        leading1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (trailingInset - leadingEdge) ** 2));
    } else if (leading0 < epsilon) {
        leading0 = 0;
    }
    if (trailing1 > trailingEdge) {
        trailingClipped = true;
        trailing0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (leadingInset - trailingEdge) ** 2));
        trailing1 = trailingEdge;
    } else if (trailing1 < epsilon) {
        trailing1 = 0;
    }
    return {
        leading0,
        leading1,
        trailing0,
        trailing1,
        leadingClipped,
        trailingClipped
    };
};
var clippedRoundRect = (path, x, y, width2, height2, cornerRadii, clipBBox)=>{
    let { topLeft: topLeftCornerRadius, topRight: topRightCornerRadius, bottomRight: bottomRightCornerRadius, bottomLeft: bottomLeftCornerRadius } = cornerRadii;
    const maxVerticalCornerRadius = Math.max(topLeftCornerRadius + bottomLeftCornerRadius, topRightCornerRadius + bottomRightCornerRadius);
    const maxHorizontalCornerRadius = Math.max(topLeftCornerRadius + topRightCornerRadius, bottomLeftCornerRadius + bottomRightCornerRadius);
    if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {
        if (clipBBox == null) {
            path.rect(x, y, width2, height2);
        } else {
            path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);
        }
        return;
    } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {
        path.roundRect(x, y, width2, height2, topLeftCornerRadius);
        return;
    }
    if (width2 < 0) {
        x += width2;
        width2 = Math.abs(width2);
    }
    if (height2 < 0) {
        y += height2;
        height2 = Math.abs(height2);
    }
    if (width2 <= 0 || height2 <= 0) return;
    if (clipBBox == null) {
        clipBBox = new BBox(x, y, width2, height2);
    } else {
        const x0 = Math.max(x, clipBBox.x);
        const x1 = Math.min(x + width2, clipBBox.x + clipBBox.width);
        const y0 = Math.max(y, clipBBox.y);
        const y1 = Math.min(y + height2, clipBBox.y + clipBBox.height);
        clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);
    }
    const borderScale = Math.max(maxVerticalCornerRadius / height2, maxHorizontalCornerRadius / width2, 1);
    if (borderScale > 1) {
        topLeftCornerRadius /= borderScale;
        topRightCornerRadius /= borderScale;
        bottomRightCornerRadius /= borderScale;
        bottomLeftCornerRadius /= borderScale;
    }
    let drawTopLeftCorner = true;
    let drawTopRightCorner = true;
    let drawBottomRightCorner = true;
    let drawBottomLeftCorner = true;
    let topLeftCorner;
    let topRightCorner;
    let bottomRightCorner;
    let bottomLeftCorner;
    if (drawTopLeftCorner) {
        const nodes = cornerEdges(clipBBox.height, clipBBox.width, Math.max(x + topLeftCornerRadius - clipBBox.x, 0), Math.max(y + topLeftCornerRadius - clipBBox.y, 0), topLeftCornerRadius);
        if (nodes.leadingClipped) drawBottomLeftCorner = false;
        if (nodes.trailingClipped) drawTopRightCorner = false;
        const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);
        const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);
        const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);
        const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);
        const cx = x + topLeftCornerRadius;
        const cy = y + topLeftCornerRadius;
        topLeftCorner = {
            x0,
            y0,
            x1,
            y1,
            cx,
            cy
        };
    }
    if (drawTopRightCorner) {
        const nodes = cornerEdges(clipBBox.width, clipBBox.height, Math.max(y + topRightCornerRadius - clipBBox.y, 0), Math.max(clipBBox.x + clipBBox.width - (x + width2 - topRightCornerRadius), 0), topRightCornerRadius);
        if (nodes.leadingClipped) drawTopLeftCorner = false;
        if (nodes.trailingClipped) drawBottomRightCorner = false;
        const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);
        const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);
        const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);
        const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);
        const cx = x + width2 - topRightCornerRadius;
        const cy = y + topRightCornerRadius;
        topRightCorner = {
            x0,
            y0,
            x1,
            y1,
            cx,
            cy
        };
    }
    if (drawBottomRightCorner) {
        const nodes = cornerEdges(clipBBox.height, clipBBox.width, Math.max(clipBBox.x + clipBBox.width - (x + width2 - bottomRightCornerRadius), 0), Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomRightCornerRadius), 0), bottomRightCornerRadius);
        if (nodes.leadingClipped) drawTopRightCorner = false;
        if (nodes.trailingClipped) drawBottomLeftCorner = false;
        const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);
        const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);
        const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);
        const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);
        const cx = x + width2 - bottomRightCornerRadius;
        const cy = y + height2 - bottomRightCornerRadius;
        bottomRightCorner = {
            x0,
            y0,
            x1,
            y1,
            cx,
            cy
        };
    }
    if (drawBottomLeftCorner) {
        const nodes = cornerEdges(clipBBox.width, clipBBox.height, Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomLeftCornerRadius), 0), Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0), bottomLeftCornerRadius);
        if (nodes.leadingClipped) drawBottomRightCorner = false;
        if (nodes.trailingClipped) drawTopLeftCorner = false;
        const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);
        const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);
        const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);
        const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);
        const cx = x + bottomLeftCornerRadius;
        const cy = y + height2 - bottomLeftCornerRadius;
        bottomLeftCorner = {
            x0,
            y0,
            x1,
            y1,
            cx,
            cy
        };
    }
    let didMove = false;
    if (drawTopLeftCorner && topLeftCorner != null) {
        drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);
        didMove || (didMove = true);
    }
    if (drawTopRightCorner && topRightCorner != null) {
        drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);
        didMove || (didMove = true);
    }
    if (drawBottomRightCorner && bottomRightCorner != null) {
        drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);
        didMove || (didMove = true);
    }
    if (drawBottomLeftCorner && bottomLeftCorner != null) {
        drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);
    }
    path.closePath();
};
var Rect = class extends Path {
    set cornerRadius(cornerRadius) {
        this.topLeftCornerRadius = cornerRadius;
        this.topRightCornerRadius = cornerRadius;
        this.bottomRightCornerRadius = cornerRadius;
        this.bottomLeftCornerRadius = cornerRadius;
    }
    isDirtyPath() {
        return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());
    }
    updatePath() {
        var _this_layerManager;
        const { path, borderPath, crisp, topLeftCornerRadius: topLeft, topRightCornerRadius: topRight, bottomRightCornerRadius: bottomRight, bottomLeftCornerRadius: bottomLeft } = this;
        let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;
        var _this_layerManager_canvas_pixelRatio;
        const pixelRatio = (_this_layerManager_canvas_pixelRatio = (_this_layerManager = this.layerManager) === null || _this_layerManager === void 0 ? void 0 : _this_layerManager.canvas.pixelRatio) !== null && _this_layerManager_canvas_pixelRatio !== void 0 ? _this_layerManager_canvas_pixelRatio : 1;
        const pixelSize = 1 / pixelRatio;
        let microPixelEffectOpacity = 1;
        path.clear(true);
        borderPath.clear(true);
        if (w === 0 || h === 0) {
            this.effectiveStrokeWidth = 0;
            this.lastUpdatePathStrokeWidth = 0;
            this.microPixelEffectOpacity = 0;
            return;
        }
        if (crisp) {
            if (w <= pixelSize) {
                microPixelEffectOpacity *= w / pixelSize;
            }
            if (h <= pixelSize) {
                microPixelEffectOpacity *= h / pixelSize;
            }
            w = this.align(x, w);
            h = this.align(y, h);
            x = this.align(x);
            y = this.align(y);
            clipBBox = clipBBox != null ? new BBox(this.align(clipBBox.x), this.align(clipBBox.y), this.align(clipBBox.x, clipBBox.width), this.align(clipBBox.y, clipBBox.height)) : void 0;
        }
        if (strokeWidth) {
            if (w < pixelSize) {
                const lx = x + pixelSize / 2;
                borderPath.moveTo(lx, y);
                borderPath.lineTo(lx, y + h);
                strokeWidth = pixelSize;
                this.borderClipPath = void 0;
            } else if (h < pixelSize) {
                const ly = y + pixelSize / 2;
                borderPath.moveTo(x, ly);
                borderPath.lineTo(x + w, ly);
                strokeWidth = pixelSize;
                this.borderClipPath = void 0;
            } else if (strokeWidth < w && strokeWidth < h) {
                const halfStrokeWidth = strokeWidth / 2;
                x += halfStrokeWidth;
                y += halfStrokeWidth;
                w -= strokeWidth;
                h -= strokeWidth;
                const adjustedClipBBox = clipBBox === null || clipBBox === void 0 ? void 0 : clipBBox.clone().shrink(halfStrokeWidth);
                const cornerRadii = {
                    topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,
                    topRight: topRight > 0 ? topRight - strokeWidth : 0,
                    bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,
                    bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0
                };
                this.borderClipPath = void 0;
                if (w > 0 && h > 0 && (adjustedClipBBox == null || (adjustedClipBBox === null || adjustedClipBBox === void 0 ? void 0 : adjustedClipBBox.width) > 0 && (adjustedClipBBox === null || adjustedClipBBox === void 0 ? void 0 : adjustedClipBBox.height) > 0)) {
                    clippedRoundRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);
                    clippedRoundRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);
                }
            } else {
                var _this_borderClipPath;
                this.borderClipPath = (_this_borderClipPath = this.borderClipPath) !== null && _this_borderClipPath !== void 0 ? _this_borderClipPath : new ExtendedPath2D();
                this.borderClipPath.clear(true);
                this.borderClipPath.rect(x, y, w, h);
                borderPath.rect(x, y, w, h);
            }
        } else {
            const cornerRadii = {
                topLeft,
                topRight,
                bottomRight,
                bottomLeft
            };
            this.borderClipPath = void 0;
            clippedRoundRect(path, x, y, w, h, cornerRadii, clipBBox);
        }
        if ([
            topLeft,
            topRight,
            bottomRight,
            bottomLeft
        ].every((r)=>r === 0)) {
            const bbox = this.getBBox();
            this.hittester = bbox.containsPoint.bind(bbox);
            this.distanceSquared = (hitX, hitY)=>this.getBBox().distanceSquared(hitX, hitY);
        } else {
            this.hittester = super.isPointInPath;
            this.distanceCalculator = super.distanceSquaredTransformedPoint;
        }
        this.effectiveStrokeWidth = strokeWidth;
        this.lastUpdatePathStrokeWidth = strokeWidth;
        this.microPixelEffectOpacity = microPixelEffectOpacity;
    }
    computeBBox() {
        const { x, y, width: width2, height: height2, clipBBox } = this;
        var _clipBBox_clone;
        return (_clipBBox_clone = clipBBox === null || clipBBox === void 0 ? void 0 : clipBBox.clone()) !== null && _clipBBox_clone !== void 0 ? _clipBBox_clone : new BBox(x, y, width2, height2);
    }
    isPointInPath(x, y) {
        return this.hittester(x, y);
    }
    get midPoint() {
        return {
            x: this.x + this.width / 2,
            y: this.y + this.height / 2
        };
    }
    distanceSquared(x, y) {
        return this.distanceCalculator(x, y);
    }
    applyFillAndAlpha(ctx) {
        super.applyFillAndAlpha(ctx);
        ctx.globalAlpha *= this.microPixelEffectOpacity;
    }
    applyStrokeAndAlpha(ctx) {
        super.applyStrokeAndAlpha(ctx);
        ctx.globalAlpha *= this.microPixelEffectOpacity;
    }
    renderStroke(ctx) {
        const { stroke: stroke2, effectiveStrokeWidth } = this;
        if (stroke2 && effectiveStrokeWidth) {
            const { globalAlpha } = ctx;
            const { lineDash, lineDashOffset, lineCap, lineJoin, borderPath, borderClipPath } = this;
            if (borderClipPath) {
                ctx.clip(borderClipPath.getPath2D());
            }
            this.applyStrokeAndAlpha(ctx);
            ctx.lineWidth = effectiveStrokeWidth;
            if (lineDash) {
                ctx.setLineDash(lineDash);
            }
            if (lineDashOffset) {
                ctx.lineDashOffset = lineDashOffset;
            }
            if (lineCap) {
                ctx.lineCap = lineCap;
            }
            if (lineJoin) {
                ctx.lineJoin = lineJoin;
            }
            ctx.stroke(borderPath.getPath2D());
            ctx.globalAlpha = globalAlpha;
        }
    }
    constructor(){
        super(...arguments);
        this.borderPath = new ExtendedPath2D();
        this.x = 0;
        this.y = 0;
        this.width = 10;
        this.height = 10;
        this.topLeftCornerRadius = 0;
        this.topRightCornerRadius = 0;
        this.bottomRightCornerRadius = 0;
        this.bottomLeftCornerRadius = 0;
        this.clipBBox = void 0;
        this.crisp = false;
        this.lastUpdatePathStrokeWidth = this.strokeWidth;
        this.effectiveStrokeWidth = this.strokeWidth;
        this.hittester = super.isPointInPath.bind(this);
        this.distanceCalculator = super.distanceSquaredTransformedPoint.bind(this);
        /**
     * When the rectangle's width or height is less than a pixel
     * and crisp mode is on, the rectangle will still fit into the pixel,
     * but will be less opaque to make an effect of holding less space.
     */ this.microPixelEffectOpacity = 1;
    }
};
Rect.className = "Rect";
__decorateClass([
    SceneChangeDetection()
], Rect.prototype, "x", 2);
__decorateClass([
    SceneChangeDetection()
], Rect.prototype, "y", 2);
__decorateClass([
    SceneChangeDetection()
], Rect.prototype, "width", 2);
__decorateClass([
    SceneChangeDetection()
], Rect.prototype, "height", 2);
__decorateClass([
    SceneChangeDetection()
], Rect.prototype, "topLeftCornerRadius", 2);
__decorateClass([
    SceneChangeDetection()
], Rect.prototype, "topRightCornerRadius", 2);
__decorateClass([
    SceneChangeDetection()
], Rect.prototype, "bottomRightCornerRadius", 2);
__decorateClass([
    SceneChangeDetection()
], Rect.prototype, "bottomLeftCornerRadius", 2);
__decorateClass([
    SceneObjectChangeDetection({
        equals: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boxesEqual"]
    })
], Rect.prototype, "clipBBox", 2);
__decorateClass([
    SceneChangeDetection()
], Rect.prototype, "crisp", 2);
// packages/ag-charts-community/src/scene/shape/text.ts
var externUseGlyphIndependentMeasurements = false;
var _Text = class _Text extends Shape {
    onTextChange() {
        var _this_richText, _this_textMap;
        (_this_richText = this.richText) === null || _this_richText === void 0 ? void 0 : _this_richText.clear();
        (_this_textMap = this.textMap) === null || _this_textMap === void 0 ? void 0 : _this_textMap.clear();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(this.text)) {
            this.lines = [];
            var _this_richText1;
            (_this_richText1 = this.richText) !== null && _this_richText1 !== void 0 ? _this_richText1 : this.richText = new Group();
            this.richText.setScene(this.scene);
            this.richText.append(this.text.map(()=>new _Text({
                    trimText: false
                })));
        } else {
            var _this_text;
            var _this_text_split;
            const lines = (_this_text_split = (_this_text = this.text) === null || _this_text === void 0 ? void 0 : _this_text.split("\n")) !== null && _this_text_split !== void 0 ? _this_text_split : [];
            this.lines = this.trimText ? lines.map((line)=>line.trim()) : lines;
        }
    }
    static computeBBox(lines, x, y, opts) {
        let useGlyphIndependentMeasurements = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
        const { font: font2, font: { fontSize }, textAlign, textBaseline, lineHeight = useGlyphIndependentMeasurements ? TextUtils.getLineHeight(fontSize) : void 0 } = opts;
        const { width: width2, alphabeticBaseline, offsetLeft: exactOffsetLeft, offsetTop: exactOffsetTop, height: exactHeight } = CachedTextMeasurerPool.measureLines(lines, useGlyphIndependentMeasurements ? {
            font: font2,
            lineHeight,
            textAlign: "start",
            textBaseline: "top"
        } : opts);
        const height2 = lineHeight == null ? exactHeight : lineHeight * lines.length;
        let offsetTop;
        if (lineHeight == null) {
            offsetTop = exactOffsetTop;
        } else if (textBaseline === "alphabetic") {
            const padding2 = (lineHeight - fontSize) / 2;
            offsetTop = padding2 - alphabeticBaseline;
        } else {
            offsetTop = TextUtils.getVerticalModifier(textBaseline) * height2;
        }
        const offsetLeft = useGlyphIndependentMeasurements ? width2 * TextUtils.getHorizontalModifier(textAlign) : exactOffsetLeft;
        return new BBox(x - offsetLeft, y - offsetTop, width2, height2);
    }
    computeBBox() {
        let useGlyphIndependentMeasurements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : externUseGlyphIndependentMeasurements;
        var _this_textMap;
        this.generateTextMap();
        if ((_this_textMap = this.textMap) === null || _this_textMap === void 0 ? void 0 : _this_textMap.size) {
            const bbox = BBox.merge(this.textMap.values());
            bbox.x = this.x;
            bbox.y = this.y;
            return bbox;
        }
        const { x, y, lines, textBaseline, textAlign, lineHeight } = this;
        const measuredTextBounds = _Text.computeBBox(lines, x, y, {
            font: this,
            textBaseline,
            textAlign,
            lineHeight
        }, useGlyphIndependentMeasurements);
        if (this.boxing != null) measuredTextBounds.grow(this.boxPadding);
        return measuredTextBounds;
    }
    getBBox() {
        let useGlyphIndependentMeasurements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (useGlyphIndependentMeasurements) {
            externUseGlyphIndependentMeasurements = true;
            const bbox = this.computeBBox(true);
            externUseGlyphIndependentMeasurements = false;
            return bbox;
        }
        return super.getBBox();
    }
    getPlainText() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toPlainText"])(this.text);
    }
    getTextMeasureBBox() {
        return this.computeBBox();
    }
    isPointInPath(x, y) {
        var _this_getBBox;
        var _this_getBBox_containsPoint;
        return (_this_getBBox_containsPoint = (_this_getBBox = this.getBBox()) === null || _this_getBBox === void 0 ? void 0 : _this_getBBox.containsPoint(x, y)) !== null && _this_getBBox_containsPoint !== void 0 ? _this_getBBox_containsPoint : false;
    }
    setScene(scene) {
        var _this_richText;
        (_this_richText = this.richText) === null || _this_richText === void 0 ? void 0 : _this_richText.setScene(scene);
        super.setScene(scene);
    }
    generateTextMap() {
        var _this_textMap;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(this.text) || ((_this_textMap = this.textMap) === null || _this_textMap === void 0 ? void 0 : _this_textMap.size)) return;
        var _this_textMap1;
        (_this_textMap1 = this.textMap) !== null && _this_textMap1 !== void 0 ? _this_textMap1 : this.textMap = /* @__PURE__ */ new Map();
        let index = 0;
        let totalWidth = 0;
        let offsetY = 0;
        const mainStyle = {
            fill: this.fill,
            fontSize: this.fontSize,
            fontFamily: this.fontFamily,
            fontStyle: this.fontStyle,
            fontWeight: this.fontWeight
        };
        for (const textNode of this.richText.children()){
            const { color: color11, ...textSegment } = this.text[index++];
            textNode.x = 0;
            textNode.y = 0;
            textNode.setProperties(mergeDefaults({
                fill: color11
            }, textSegment, mainStyle));
            const textBBox = textNode.getBBox();
            this.textMap.set(textNode, textBBox);
            var _textNode_lineHeight;
            offsetY = Math.max(offsetY, textBBox.y + textBBox.height / 2 + ((_textNode_lineHeight = textNode.lineHeight) !== null && _textNode_lineHeight !== void 0 ? _textNode_lineHeight : TextUtils.getLineHeight(textNode.fontSize)));
            totalWidth += textBBox.x + textBBox.width;
        }
        let offsetX = this.x - totalWidth / 2;
        for (const [textNode, bbox] of this.textMap){
            textNode.x += offsetX;
            textNode.y += offsetY;
            offsetX += bbox.width;
        }
    }
    render(renderCtx) {
        var _this_textMap;
        const { ctx, stats } = renderCtx;
        if (!this.text || !this.layerManager) {
            if (stats) stats.nodesSkipped += 1;
            return super.render(renderCtx);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(this.text)) {
            this.generateTextMap();
            const { width: width2 } = this.richText.getBBox();
            let translateX = 0;
            switch(this.textAlign){
                case "left":
                case "start":
                    translateX = width2 / 2;
                    break;
                case "right":
                case "end":
                    translateX = width2 / -2;
            }
            ctx.save();
            ctx.translate(translateX, this.y);
            this.richText.render(renderCtx);
            ctx.restore();
        } else {
            this.renderText(renderCtx);
        }
        if (_Text.debug.check() && !((_this_textMap = this.textMap) === null || _this_textMap === void 0 ? void 0 : _this_textMap.size)) {
            const bbox = this.getBBox(true);
            ctx.strokeStyle = "red";
            ctx.lineWidth = 1;
            ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
        }
        super.render(renderCtx);
    }
    markDirty(property) {
        var _this_textMap;
        (_this_textMap = this.textMap) === null || _this_textMap === void 0 ? void 0 : _this_textMap.clear();
        return super.markDirty(property);
    }
    renderText(renderCtx) {
        const { fill, stroke: stroke2, strokeWidth } = this;
        if (!fill && !(stroke2 && strokeWidth) || !this.layerManager) {
            return super.render(renderCtx);
        }
        const { ctx } = renderCtx;
        const font2 = TextUtils.toFontString(this);
        if (ctx.font !== font2) {
            ctx.font = font2;
        }
        const { fontSize, lineHeight = TextUtils.getLineHeight(fontSize), textAlign, textBaseline } = this;
        ctx.textAlign = textAlign;
        ctx.textBaseline = textBaseline;
        if (this.boxing) {
            const opts = {
                font: this,
                textBaseline,
                textAlign,
                lineHeight
            };
            const textBBox = _Text.computeBBox(this.lines, this.x, this.y, opts);
            if (textBBox.width !== 0 && textBBox.height !== 0) {
                const { x, y, width: width2, height: height2 } = textBBox.grow(this.boxPadding);
                this.boxing.opacity = this.opacity;
                this.boxing.x = x;
                this.boxing.y = y;
                this.boxing.width = width2;
                this.boxing.height = height2;
                this.boxing.preRender(renderCtx);
                this.boxing.render(renderCtx);
            }
        }
        this.fillStroke(ctx);
    }
    executeFill(ctx) {
        const { fontSize, lineHeight = TextUtils.getLineHeight(fontSize), textBaseline, lines } = this;
        const lineOriginY = textBaseline === "alphabetic" ? 0 : TextUtils.getVerticalModifier(textBaseline) * lineHeight * (1 - lines.length);
        this.renderLines(lineOriginY, lineHeight, (line, x, y)=>ctx.fillText(line, x, y));
    }
    executeStroke(ctx) {
        const { fontSize, lineHeight = TextUtils.getLineHeight(fontSize), textBaseline, lines } = this;
        const lineOriginY = textBaseline === "alphabetic" ? 0 : TextUtils.getVerticalModifier(textBaseline) * lineHeight * (1 - lines.length);
        this.renderLines(lineOriginY, lineHeight, (line, x, y)=>ctx.strokeText(line, x, y));
    }
    renderLines(offsetY, lineHeight, renderCallback) {
        const { lines, x, y } = this;
        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(offsetY) || !Number.isFinite(lineHeight)) {
            return;
        }
        for (const line of lines){
            renderCallback(line, x, y + offsetY);
            offsetY += lineHeight;
        }
    }
    setFont(props) {
        this.fontFamily = props.fontFamily;
        this.fontSize = props.fontSize;
        this.fontStyle = props.fontStyle;
        this.fontWeight = props.fontWeight;
    }
    setAlign(props) {
        this.textAlign = props.textAlign;
        this.textBaseline = props.textBaseline;
    }
    setBoxing(props) {
        var _props_border, _props_border1;
        const stroke2 = ((_props_border = props.border) === null || _props_border === void 0 ? void 0 : _props_border.enabled) ? (_props_border1 = props.border) === null || _props_border1 === void 0 ? void 0 : _props_border1.stroke : void 0;
        if (props.fill != null || stroke2 != null) {
            var _props_border2, _props_border3;
            var _this_boxing;
            (_this_boxing = this.boxing) !== null && _this_boxing !== void 0 ? _this_boxing : this.boxing = new Rect({
                scene: this.scene
            });
            this.boxing.fill = props.fill;
            var _props_fillOpacity;
            this.boxing.fillOpacity = (_props_fillOpacity = props.fillOpacity) !== null && _props_fillOpacity !== void 0 ? _props_fillOpacity : 1;
            var _props_cornerRadius;
            this.boxing.cornerRadius = (_props_cornerRadius = props.cornerRadius) !== null && _props_cornerRadius !== void 0 ? _props_cornerRadius : 0;
            this.boxing.stroke = stroke2;
            var _props_border_strokeWidth;
            this.boxing.strokeWidth = (_props_border_strokeWidth = (_props_border2 = props.border) === null || _props_border2 === void 0 ? void 0 : _props_border2.strokeWidth) !== null && _props_border_strokeWidth !== void 0 ? _props_border_strokeWidth : 0;
            var _props_border_strokeOpacity;
            this.boxing.strokeOpacity = (_props_border_strokeOpacity = (_props_border3 = props.border) === null || _props_border3 === void 0 ? void 0 : _props_border3.strokeOpacity) !== null && _props_border_strokeOpacity !== void 0 ? _props_border_strokeOpacity : 1;
            var _props_padding;
            this.boxPadding = (_props_padding = props.padding) !== null && _props_padding !== void 0 ? _props_padding : 0;
        } else if (this.boxing) {
            this.boxing.destroy();
            this.boxing = void 0;
        }
    }
    getBoxingProperties() {
        var _this_boxing;
        const { fill, fillOpacity, cornerRadius, stroke: stroke2, strokeWidth, strokeOpacity } = (_this_boxing = this.boxing) !== null && _this_boxing !== void 0 ? _this_boxing : {};
        return {
            border: {
                enabled: stroke2 != null,
                stroke: stroke2,
                strokeWidth,
                strokeOpacity
            },
            cornerRadius,
            fill,
            fillOpacity,
            padding: this.boxPadding
        };
    }
    toSVG() {
        if (!this.visible || !this.text) return;
        const element2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("text");
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(this.text)) {
            this.applySvgFillAttributes(element2);
            setSvgFontAttributes(element2, this);
            var _this_textAlign;
            element2.setAttribute("text-anchor", {
                center: "middle",
                left: "start",
                right: "end",
                start: "start",
                end: "end"
            }[(_this_textAlign = this.textAlign) !== null && _this_textAlign !== void 0 ? _this_textAlign : "start"]);
            element2.setAttribute("alignment-baseline", this.textBaseline);
            element2.setAttribute("x", String(this.x));
            element2.setAttribute("y", String(this.y));
            element2.textContent = this.text;
        } else {
            for (const segment of this.text){
                const segmentElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("tspan");
                var _segment_fontSize, _segment_fontFamily, _segment_fontWeight, _segment_fontStyle;
                setSvgFontAttributes(segmentElement, {
                    fontSize: (_segment_fontSize = segment.fontSize) !== null && _segment_fontSize !== void 0 ? _segment_fontSize : this.fontSize,
                    fontFamily: (_segment_fontFamily = segment.fontFamily) !== null && _segment_fontFamily !== void 0 ? _segment_fontFamily : this.fontFamily,
                    fontWeight: (_segment_fontWeight = segment.fontWeight) !== null && _segment_fontWeight !== void 0 ? _segment_fontWeight : this.fontWeight,
                    fontStyle: (_segment_fontStyle = segment.fontStyle) !== null && _segment_fontStyle !== void 0 ? _segment_fontStyle : this.fontStyle
                });
                this.applySvgFillAttributes(segmentElement);
                segmentElement.textContent = segment.text;
                element2.append(segmentElement);
            }
        }
        return {
            elements: [
                element2
            ]
        };
    }
    constructor(options){
        super(options);
        this.x = 0;
        this.y = 0;
        this.lines = [];
        this.text = void 0;
        this.fontSize = _Text.defaultFontSize;
        this.fontFamily = "sans-serif";
        this.textAlign = "start";
        this.textBaseline = "alphabetic";
        this.boxPadding = 0;
        var _options_trimText;
        this.trimText = (_options_trimText = options === null || options === void 0 ? void 0 : options.trimText) !== null && _options_trimText !== void 0 ? _options_trimText : true;
    }
};
_Text.className = "Text";
_Text.debug = Debug.create(true, "scene:text" /* SCENE_TEXT */ );
_Text.defaultFontSize = 10;
__decorateClass([
    SceneChangeDetection()
], _Text.prototype, "x", 2);
__decorateClass([
    SceneChangeDetection()
], _Text.prototype, "y", 2);
__decorateClass([
    SceneRefChangeDetection({
        changeCb: (o)=>o.onTextChange()
    })
], _Text.prototype, "text", 2);
__decorateClass([
    SceneChangeDetection()
], _Text.prototype, "fontStyle", 2);
__decorateClass([
    SceneChangeDetection()
], _Text.prototype, "fontWeight", 2);
__decorateClass([
    SceneChangeDetection()
], _Text.prototype, "fontSize", 2);
__decorateClass([
    SceneChangeDetection()
], _Text.prototype, "fontFamily", 2);
__decorateClass([
    SceneChangeDetection()
], _Text.prototype, "textAlign", 2);
__decorateClass([
    SceneChangeDetection()
], _Text.prototype, "textBaseline", 2);
__decorateClass([
    SceneChangeDetection()
], _Text.prototype, "lineHeight", 2);
var Text = _Text;
var RotatableText = class extends Rotatable(Text) {
};
var TransformableText = class extends Rotatable(Translatable(Text)) {
};
// packages/ag-charts-community/src/util/textWrapper.ts
var TextWrapper = class {
    static wrapText(text, options) {
        return this.wrapLines(text, options).join("\n");
    }
    static wrapLines(text, options) {
        const clippedResult = this.textWrap(text, options);
        if (options.overflow === "hide" && clippedResult.some((l)=>l.endsWith(TextUtils.EllipsisChar))) {
            return [];
        }
        return clippedResult;
    }
    static appendEllipsis(text) {
        return text.replace(/[.,]{1,5}$/, "") + TextUtils.EllipsisChar;
    }
    static truncateLine(text, measurer2, maxWidth, ellipsisForce) {
        const ellipsisWidth = measurer2.textWidth(TextUtils.EllipsisChar);
        let estimatedWidth = 0;
        let i = 0;
        for(; i < text.length; i++){
            const charWidth = measurer2.textWidth(text.charAt(i));
            if (estimatedWidth + charWidth > maxWidth) break;
            estimatedWidth += charWidth;
        }
        if (text.length === i && (!ellipsisForce || estimatedWidth + ellipsisWidth <= maxWidth)) {
            return ellipsisForce ? text + TextUtils.EllipsisChar : text;
        }
        text = text.slice(0, i).trimEnd();
        while(text.length && measurer2.textWidth(text) + ellipsisWidth > maxWidth){
            text = text.slice(0, -1).trimEnd();
        }
        return text + TextUtils.EllipsisChar;
    }
    static textWrap(text, options) {
        const lines = text.split(TextUtils.lineSplitter);
        const measurer2 = CachedTextMeasurerPool.getMeasurer(options);
        if (options.textWrap === "never") {
            return lines.map((line)=>this.truncateLine(line.trimEnd(), measurer2, options.maxWidth));
        }
        const result = [];
        const wrapHyphenate = options.textWrap === "hyphenate";
        const wrapOnSpace = options.textWrap == null || options.textWrap === "on-space";
        for (const untrimmedLine of lines){
            let line = untrimmedLine.trimEnd();
            if (line === "") {
                result.push(line);
                continue;
            }
            let i = 0;
            let estimatedWidth = 0;
            let lastSpaceIndex = 0;
            while(i < line.length){
                const char = line.charAt(i);
                estimatedWidth += measurer2.textWidth(char);
                if (char === " ") {
                    lastSpaceIndex = i;
                }
                if (estimatedWidth > options.maxWidth) {
                    if (i === 0) break;
                    const actualWidth = measurer2.textWidth(line.slice(0, i + 1));
                    if (actualWidth <= options.maxWidth) {
                        estimatedWidth = actualWidth;
                        i++;
                        continue;
                    }
                    if (lastSpaceIndex) {
                        const nextWord = this.getWordAt(line, lastSpaceIndex + 1);
                        const textWidth = measurer2.textWidth(nextWord);
                        if (textWidth <= options.maxWidth) {
                            result.push(line.slice(0, lastSpaceIndex).trimEnd());
                            line = line.slice(lastSpaceIndex).trimStart();
                            i = 0;
                            estimatedWidth = 0;
                            lastSpaceIndex = 0;
                            continue;
                        } else if (wrapOnSpace && textWidth > options.maxWidth) {
                            result.push(line.slice(0, lastSpaceIndex).trimEnd(), this.truncateLine(line.slice(lastSpaceIndex).trimStart(), measurer2, options.maxWidth, true));
                        }
                    } else if (wrapOnSpace) {
                        result.push(this.truncateLine(line, measurer2, options.maxWidth, true));
                    }
                    if (wrapOnSpace) {
                        line = "";
                        break;
                    }
                    const postfix = wrapHyphenate ? "-" : "";
                    let newLine = line.slice(0, i).trim();
                    while(newLine.length && measurer2.textWidth(newLine + postfix) > options.maxWidth){
                        newLine = newLine.slice(0, -1).trimEnd();
                    }
                    result.push(newLine + postfix);
                    if (!newLine.length) {
                        line = "";
                        break;
                    }
                    line = line.slice(newLine.length).trimStart();
                    i = -1;
                    estimatedWidth = 0;
                    lastSpaceIndex = 0;
                }
                i++;
            }
            if (line) {
                result.push(line);
            }
        }
        this.avoidOrphans(result, measurer2, options);
        return this.clipLines(result, measurer2, options);
    }
    static getWordAt(text, position) {
        const nextSpaceIndex = text.indexOf(" ", position);
        return nextSpaceIndex === -1 ? text.slice(position) : text.slice(position, nextSpaceIndex);
    }
    static clipLines(lines, measurer2, options) {
        if (!options.maxHeight) {
            return lines;
        }
        const { height: height2, lineMetrics } = measurer2.measureLines(lines);
        if (height2 <= options.maxHeight) {
            return lines;
        }
        for(let i = 0, cumulativeHeight = 0; i < lineMetrics.length; i++){
            const { lineHeight } = lineMetrics[i];
            cumulativeHeight += lineHeight;
            if (cumulativeHeight > options.maxHeight) {
                if (options.overflow === "hide") {
                    return [];
                }
                const clippedResults = lines.slice(0, i || 1);
                const lastLine = clippedResults.pop();
                return clippedResults.concat(this.truncateLine(lastLine, measurer2, options.maxWidth, true));
            }
        }
        return lines;
    }
    static avoidOrphans(lines, measurer2, options) {
        if (options.avoidOrphans === false || lines.length < 2) return;
        const { length: length2 } = lines;
        const lastLine = lines[length2 - 1];
        const beforeLast = lines[length2 - 2];
        if (beforeLast.length < lastLine.length) return;
        const lastSpaceIndex = beforeLast.lastIndexOf(" ");
        if (lastSpaceIndex === -1 || lastSpaceIndex === beforeLast.indexOf(" ") || lastLine.includes(" ")) return;
        const lastWord = beforeLast.slice(lastSpaceIndex + 1);
        if (measurer2.textWidth(lastLine + lastWord) <= options.maxWidth) {
            lines[length2 - 2] = beforeLast.slice(0, lastSpaceIndex);
            lines[length2 - 1] = lastWord + " " + lastLine;
        }
    }
};
// packages/ag-charts-community/src/chart/themes/constants.ts
var constants_exports = {};
__export(constants_exports, {
    BASE_FONT_SIZE: ()=>BASE_FONT_SIZE,
    CARTESIAN_AXIS_TYPE: ()=>CARTESIAN_AXIS_TYPE,
    CARTESIAN_POSITION: ()=>CARTESIAN_POSITION,
    FONT_SIZE: ()=>FONT_SIZE,
    FONT_SIZE_RATIO: ()=>FONT_SIZE_RATIO,
    POLAR_AXIS_SHAPE: ()=>POLAR_AXIS_SHAPE,
    POLAR_AXIS_TYPE: ()=>POLAR_AXIS_TYPE
});
var FONT_SIZE = /* @__PURE__ */ ((FONT_SIZE2)=>{
    FONT_SIZE2[FONT_SIZE2["SMALLEST"] = 8] = "SMALLEST";
    FONT_SIZE2[FONT_SIZE2["SMALLER"] = 10] = "SMALLER";
    FONT_SIZE2[FONT_SIZE2["SMALL"] = 12] = "SMALL";
    FONT_SIZE2[FONT_SIZE2["MEDIUM"] = 13] = "MEDIUM";
    FONT_SIZE2[FONT_SIZE2["LARGE"] = 14] = "LARGE";
    FONT_SIZE2[FONT_SIZE2["LARGEST"] = 17] = "LARGEST";
    return FONT_SIZE2;
})(FONT_SIZE || {});
var BASE_FONT_SIZE = 12 /* SMALL */ ;
var FONT_SIZE_RATIO = ((FONT_SIZE_RATIO2)=>{
    FONT_SIZE_RATIO2[FONT_SIZE_RATIO2["SMALLEST"] = 8 /* SMALLEST */  / BASE_FONT_SIZE] = "SMALLEST";
    FONT_SIZE_RATIO2[FONT_SIZE_RATIO2["SMALLER"] = 10 /* SMALLER */  / BASE_FONT_SIZE] = "SMALLER";
    FONT_SIZE_RATIO2[FONT_SIZE_RATIO2["SMALL"] = 12 /* SMALL */  / BASE_FONT_SIZE] = "SMALL";
    FONT_SIZE_RATIO2[FONT_SIZE_RATIO2["MEDIUM"] = 13 /* MEDIUM */  / BASE_FONT_SIZE] = "MEDIUM";
    FONT_SIZE_RATIO2[FONT_SIZE_RATIO2["LARGE"] = 14 /* LARGE */  / BASE_FONT_SIZE] = "LARGE";
    FONT_SIZE_RATIO2[FONT_SIZE_RATIO2["LARGEST"] = 17 /* LARGEST */  / BASE_FONT_SIZE] = "LARGEST";
    return FONT_SIZE_RATIO2;
})(FONT_SIZE_RATIO || {});
var CARTESIAN_POSITION = /* @__PURE__ */ ((CARTESIAN_POSITION2)=>{
    CARTESIAN_POSITION2["TOP"] = "top";
    CARTESIAN_POSITION2["TOP_RIGHT"] = "top-right";
    CARTESIAN_POSITION2["TOP_LEFT"] = "top-left";
    CARTESIAN_POSITION2["RIGHT"] = "right";
    CARTESIAN_POSITION2["RIGHT_TOP"] = "right-top";
    CARTESIAN_POSITION2["RIGHT_BOTTOM"] = "right-bottom";
    CARTESIAN_POSITION2["BOTTOM"] = "bottom";
    CARTESIAN_POSITION2["BOTTOM_RIGHT"] = "bottom-right";
    CARTESIAN_POSITION2["BOTTOM_LEFT"] = "bottom-left";
    CARTESIAN_POSITION2["LEFT"] = "left";
    CARTESIAN_POSITION2["LEFT_TOP"] = "left-top";
    CARTESIAN_POSITION2["LEFT_BOTTOM"] = "left-bottom";
    return CARTESIAN_POSITION2;
})(CARTESIAN_POSITION || {});
var CARTESIAN_AXIS_TYPE = /* @__PURE__ */ ((CARTESIAN_AXIS_TYPE2)=>{
    CARTESIAN_AXIS_TYPE2["CATEGORY"] = "category";
    CARTESIAN_AXIS_TYPE2["GROUPED_CATEGORY"] = "grouped-category";
    CARTESIAN_AXIS_TYPE2["ORDINAL_TIME"] = "ordinal-time";
    CARTESIAN_AXIS_TYPE2["UNIT_TIME"] = "unit-time";
    CARTESIAN_AXIS_TYPE2["TIME"] = "time";
    CARTESIAN_AXIS_TYPE2["NUMBER"] = "number";
    CARTESIAN_AXIS_TYPE2["LOG"] = "log";
    return CARTESIAN_AXIS_TYPE2;
})(CARTESIAN_AXIS_TYPE || {});
var POLAR_AXIS_TYPE = /* @__PURE__ */ ((POLAR_AXIS_TYPE2)=>{
    POLAR_AXIS_TYPE2["ANGLE_CATEGORY"] = "angle-category";
    POLAR_AXIS_TYPE2["ANGLE_NUMBER"] = "angle-number";
    POLAR_AXIS_TYPE2["RADIUS_CATEGORY"] = "radius-category";
    POLAR_AXIS_TYPE2["RADIUS_NUMBER"] = "radius-number";
    return POLAR_AXIS_TYPE2;
})(POLAR_AXIS_TYPE || {});
var POLAR_AXIS_SHAPE = /* @__PURE__ */ ((POLAR_AXIS_SHAPE2)=>{
    POLAR_AXIS_SHAPE2["CIRCLE"] = "circle";
    POLAR_AXIS_SHAPE2["POLYGON"] = "polygon";
    return POLAR_AXIS_SHAPE2;
})(POLAR_AXIS_SHAPE || {});
// packages/ag-charts-community/src/chart/caption.ts
var Caption = class extends BaseProperties {
    registerInteraction(moduleCtx, where) {
        return moduleCtx.eventsHub.on("layout:complete", ()=>this.updateA11yText(moduleCtx, where));
    }
    computeTextWrap(containerWidth, containerHeight) {
        const { text, padding: padding2, wrapping } = this;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(text)) return;
        var _this_maxWidth;
        const maxWidth = Math.min((_this_maxWidth = this.maxWidth) !== null && _this_maxWidth !== void 0 ? _this_maxWidth : Infinity, containerWidth) - padding2 * 2;
        var _this_maxHeight;
        const maxHeight = (_this_maxHeight = this.maxHeight) !== null && _this_maxHeight !== void 0 ? _this_maxHeight : containerHeight - padding2 * 2;
        if (!isFinite(maxWidth) && !isFinite(maxHeight)) {
            this.node.text = text;
            return;
        }
        const wrappedText = TextWrapper.wrapText(text !== null && text !== void 0 ? text : "", {
            maxWidth,
            maxHeight,
            font: this,
            textWrap: wrapping
        });
        this.node.text = wrappedText;
        this.truncated = wrappedText.includes(TextUtils.EllipsisChar);
    }
    updateA11yText(moduleCtx, where) {
        const { proxyInteractionService } = moduleCtx;
        if (this.enabled && this.text) {
            const bbox = Transformable.toCanvas(this.node);
            if (bbox) {
                const { id: domManagerId } = this;
                var _this_proxyText;
                (_this_proxyText = this.proxyText) !== null && _this_proxyText !== void 0 ? _this_proxyText : this.proxyText = proxyInteractionService.createProxyElement({
                    type: "text",
                    domManagerId,
                    where
                });
                this.proxyText.textContent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toPlainText"])(this.text);
                this.proxyText.setBounds(bbox);
                this.proxyText.addListener("mousemove", (ev)=>this.handleMouseMove(moduleCtx, ev));
                this.proxyText.addListener("mouseleave", (ev)=>this.handleMouseLeave(moduleCtx, ev));
            }
        } else {
            var _this_proxyText1;
            (_this_proxyText1 = this.proxyText) === null || _this_proxyText1 === void 0 ? void 0 : _this_proxyText1.destroy();
            this.proxyText = void 0;
        }
    }
    handleMouseMove(moduleCtx, event) {
        if (event != null && this.enabled && this.truncated) {
            const { x, y } = Transformable.toCanvas(this.node);
            const canvasX = event.sourceEvent.offsetX + x;
            const canvasY = event.sourceEvent.offsetY + y;
            moduleCtx.tooltipManager.updateTooltip(this.id, {
                canvasX,
                canvasY,
                showArrow: false
            }, [
                {
                    type: "structured",
                    title: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toPlainText"])(this.text)
                }
            ]);
        }
    }
    handleMouseLeave(moduleCtx, _event) {
        moduleCtx.tooltipManager.removeTooltip(this.id);
    }
    constructor(){
        super(...arguments);
        this.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createId"])(this);
        this.node = new RotatableText({
            zIndex: 1
        }).setProperties({
            textAlign: "center",
            pointerEvents: 1 /* None */ 
        });
        this.enabled = false;
        this.textAlign = "center";
        this.fontSize = 10 /* SMALLER */ ;
        this.fontFamily = "sans-serif";
        this.wrapping = "always";
        this.padding = 0;
        this.layoutStyle = "block";
        this.truncated = false;
    }
};
Caption.SMALL_PADDING = 10;
__decorateClass([
    Property,
    ProxyPropertyOnWrite("node", "visible")
], Caption.prototype, "enabled", 2);
__decorateClass([
    Property,
    ProxyPropertyOnWrite("node")
], Caption.prototype, "text", 2);
__decorateClass([
    Property,
    ProxyPropertyOnWrite("node")
], Caption.prototype, "textAlign", 2);
__decorateClass([
    Property,
    ProxyPropertyOnWrite("node")
], Caption.prototype, "fontStyle", 2);
__decorateClass([
    Property,
    ProxyPropertyOnWrite("node")
], Caption.prototype, "fontWeight", 2);
__decorateClass([
    Property,
    ProxyPropertyOnWrite("node")
], Caption.prototype, "fontSize", 2);
__decorateClass([
    Property,
    ProxyPropertyOnWrite("node")
], Caption.prototype, "fontFamily", 2);
__decorateClass([
    Property,
    ProxyPropertyOnWrite("node", "fill")
], Caption.prototype, "color", 2);
__decorateClass([
    Property
], Caption.prototype, "spacing", 2);
__decorateClass([
    Property
], Caption.prototype, "maxWidth", 2);
__decorateClass([
    Property
], Caption.prototype, "maxHeight", 2);
__decorateClass([
    Property
], Caption.prototype, "wrapping", 2);
__decorateClass([
    Property
], Caption.prototype, "padding", 2);
__decorateClass([
    Property
], Caption.prototype, "layoutStyle", 2);
// packages/ag-charts-community/src/chart/chartAxisDirection.ts
var ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection2)=>{
    ChartAxisDirection2["X"] = "x";
    ChartAxisDirection2["Y"] = "y";
    ChartAxisDirection2["Angle"] = "angle";
    ChartAxisDirection2["Radius"] = "radius";
    return ChartAxisDirection2;
})(ChartAxisDirection || {});
function isChartAxisDirection(d) {
    switch(d){
        case "x":
        case "y":
        case "angle":
        case "radius":
            return true;
        default:
            return false;
    }
}
;
var ChartCaptions = class {
    positionCaptions(ctx) {
        const { title, subtitle, footnote } = this;
        const maxHeight = ctx.layoutBox.height / 10;
        if (title.enabled) {
            this.positionCaption("top", title, ctx.layoutBox, maxHeight);
            this.shrinkLayoutByCaption("top", title, ctx.layoutBox);
        }
        if (subtitle.enabled) {
            this.positionCaption("top", subtitle, ctx.layoutBox, maxHeight);
            this.shrinkLayoutByCaption("top", subtitle, ctx.layoutBox);
        }
        if (footnote.enabled) {
            this.positionCaption("bottom", footnote, ctx.layoutBox, maxHeight);
            this.shrinkLayoutByCaption("bottom", footnote, ctx.layoutBox);
        }
    }
    positionAbsoluteCaptions(ctx) {
        const { title, subtitle, footnote } = this;
        const { rect } = ctx.series;
        for (const caption of [
            title,
            subtitle,
            footnote
        ]){
            if (caption.layoutStyle !== "overlay") continue;
            if (caption.textAlign === "left") {
                caption.node.x = rect.x + caption.padding;
            } else if (caption.textAlign === "right") {
                const bbox = caption.node.getBBox();
                caption.node.x = rect.x + rect.width - bbox.width - caption.padding;
            }
        }
    }
    computeX(align2, layoutBox) {
        if (align2 === "left") {
            return layoutBox.x;
        } else if (align2 === "right") {
            return layoutBox.x + layoutBox.width;
        }
        return layoutBox.x + layoutBox.width / 2;
    }
    positionCaption(vAlign, caption, layoutBox, maxHeight) {
        const containerHeight = Math.max(TextUtils.getLineHeight(caption.fontSize), maxHeight);
        caption.node.x = this.computeX(caption.textAlign, layoutBox) + caption.padding;
        caption.node.y = layoutBox.y + (vAlign === "top" ? 0 : layoutBox.height) + caption.padding;
        caption.node.textBaseline = vAlign;
        caption.computeTextWrap(layoutBox.width, containerHeight);
    }
    shrinkLayoutByCaption(vAlign, caption, layoutBox) {
        if (caption.layoutStyle === "block") {
            const bbox = caption.node.getBBox();
            const { spacing = 0 } = caption;
            if (vAlign === "bottom" && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(caption.text)) {
                caption.node.y -= bbox.height;
                bbox.y -= bbox.height;
            }
            layoutBox.shrink(vAlign === "top" ? Math.ceil(bbox.y - layoutBox.y + bbox.height + spacing) : Math.ceil(layoutBox.y + layoutBox.height - bbox.y + spacing), vAlign);
        }
    }
    constructor(){
        this.title = new Caption();
        this.subtitle = new Caption();
        this.footnote = new Caption();
    }
};
__decorateClass([
    Property
], ChartCaptions.prototype, "title", 2);
__decorateClass([
    Property
], ChartCaptions.prototype, "subtitle", 2);
__decorateClass([
    Property
], ChartCaptions.prototype, "footnote", 2);
;
;
var chartTypes = [
    "candlestick",
    "hollow-candlestick",
    "ohlc",
    "line",
    "step-line",
    "hlc",
    "high-low"
];
var ChartTypeOriginator = class {
    createMemento() {
        var _this_chartService_publicApi_getOptions, _this_chartService_publicApi;
        let chartType = (_this_chartService_publicApi = this.chartService.publicApi) === null || _this_chartService_publicApi === void 0 ? void 0 : (_this_chartService_publicApi_getOptions = _this_chartService_publicApi.getOptions()) === null || _this_chartService_publicApi_getOptions === void 0 ? void 0 : _this_chartService_publicApi_getOptions.chartType;
        chartType !== null && chartType !== void 0 ? chartType : chartType = "candlestick";
        return chartType;
    }
    guardMemento(blob) {
        return blob == null || chartTypes.includes(blob);
    }
    restoreMemento(_version, _mementoVersion, memento) {
        var _this_chartService_publicApi;
        if (memento == null) return;
        const options = {
            chartType: memento
        };
        (_this_chartService_publicApi = this.chartService.publicApi) === null || _this_chartService_publicApi === void 0 ? void 0 : _this_chartService_publicApi.updateDelta(options).catch((e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].error("error restoring state", e));
    }
    constructor(chartService){
        this.chartService = chartService;
        this.mementoOriginatorKey = "chartType";
    }
};
;
// packages/ag-charts-community/src/version.ts
var VERSION = "12.1.2";
// packages/ag-charts-community/src/api/state/historyManager.ts
var NOT_FOUND = Symbol("previous-memento-not-found");
var HistoryManager = class {
    destroy() {
        this.cleanup.flush();
    }
    addMementoOriginator(originator) {
        this.originators.set(originator.mementoOriginatorKey, originator);
        this.clearState.set(originator.mementoOriginatorKey, originator.createMemento());
        this.debugEvent("History add originator:", originator.mementoOriginatorKey);
    }
    clear() {
        this.debug("History clear:", Object.keys(this.originators));
        this.history = [];
        this.historyIndex = -1;
        for (const [mementoOriginatorKey, originator] of this.originators.entries()){
            this.clearState.set(mementoOriginatorKey, originator.createMemento());
        }
    }
    record(label) {
        for(var _len = arguments.length, originators = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            originators[_key - 1] = arguments[_key];
        }
        if (this.historyIndex < this.history.length - 1) {
            this.history = this.history.slice(0, this.historyIndex + 1);
        }
        if (this.history.length > this.maxHistoryLength) {
            this.history = this.history.slice(-this.maxHistoryLength);
        }
        const mementos = /* @__PURE__ */ new Map();
        for (const originator of originators){
            if (!this.originators.has(originator.mementoOriginatorKey)) {
                throw new Error("Originator [".concat(originator.mementoOriginatorKey, "] has not been added to the HistoryManager."));
            }
            mementos.set(originator.mementoOriginatorKey, originator.createMemento());
        }
        this.history.push({
            label,
            mementos
        });
        this.historyIndex = this.history.length - 1;
        this.debugEvent("History record: [".concat(label, "]"));
    }
    undo() {
        const undoAction = this.history[this.historyIndex];
        if (!undoAction) return;
        for (const mementoOriginatorKey of undoAction.mementos.keys()){
            const previousMemento = this.findPreviousMemento(mementoOriginatorKey);
            if (previousMemento === NOT_FOUND) {
                throw new Error("Could not find previous memento for [".concat(mementoOriginatorKey, "]."));
            }
            this.restoreMemento(mementoOriginatorKey, previousMemento);
        }
        this.historyIndex -= 1;
        this.debugEvent("History undo: [".concat(undoAction.label, "]"));
    }
    redo() {
        const redoAction = this.history[this.historyIndex + 1];
        if (!redoAction) return;
        for (const [mementoOriginatorKey, memento] of redoAction.mementos.entries()){
            this.restoreMemento(mementoOriginatorKey, memento);
        }
        this.historyIndex += 1;
        this.debugEvent("History redo: [".concat(redoAction.label, "]"));
    }
    findPreviousMemento(mementoOriginatorKey) {
        for(let i = this.historyIndex - 1; i >= 0; i--){
            if (this.history[i].mementos.has(mementoOriginatorKey)) {
                return this.history[i].mementos.get(mementoOriginatorKey);
            }
        }
        if (this.clearState.has(mementoOriginatorKey)) {
            return this.clearState.get(mementoOriginatorKey);
        }
        return NOT_FOUND;
    }
    restoreMemento(mementoOriginatorKey, memento) {
        var _this_originators_get;
        (_this_originators_get = this.originators.get(mementoOriginatorKey)) === null || _this_originators_get === void 0 ? void 0 : _this_originators_get.restoreMemento(VERSION, VERSION, memento);
    }
    debugEvent() {
        for(var _len = arguments.length, logContent = new Array(_len), _key = 0; _key < _len; _key++){
            logContent[_key] = arguments[_key];
        }
        this.debug(...logContent, this.history.map((action, index)=>index === this.historyIndex ? "** ".concat(action.label, " **") : action.label));
    }
    constructor(eventsHub){
        this.history = [];
        this.historyIndex = -1;
        this.originators = /* @__PURE__ */ new Map();
        this.clearState = /* @__PURE__ */ new Map();
        this.maxHistoryLength = 100;
        this.debug = Debug.create(true, "history");
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.cleanup.register(eventsHub.on("series:undo", this.undo.bind(this)), eventsHub.on("series:redo", this.redo.bind(this)));
    }
};
;
var MementoCaretaker = class _MementoCaretaker {
    save() {
        for(var _len = arguments.length, originators = new Array(_len), _key = 0; _key < _len; _key++){
            originators[_key] = arguments[_key];
        }
        const packet = {
            version: this.version
        };
        for (const originator of Object.values(originators)){
            packet[originator.mementoOriginatorKey] = this.encode(originator, originator.createMemento());
        }
        return packet;
    }
    restore(blob) {
        for(var _len = arguments.length, originators = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            originators[_key - 1] = arguments[_key];
        }
        if (typeof blob !== "object") {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Could not restore data of type [".concat(typeof blob, "], expecting an object, ignoring."));
            return;
        }
        if (blob == null) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Could not restore data of type [null], expecting an object, ignoring.");
            return;
        }
        if (!("version" in blob) || typeof blob.version !== "string") {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Could not restore data, missing [version] string in object, ignoring.");
            return;
        }
        for (const originator of originators){
            const memento = this.decode(originator, blob[originator.mementoOriginatorKey]);
            const messages = [];
            if (!originator.guardMemento(memento, messages)) {
                const messagesString = messages.length > 0 ? "\n\n".concat(messages.join("\n\n"), "\n\n") : "";
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Could not restore [".concat(originator.mementoOriginatorKey, "] data, value was invalid, ignoring.").concat(messagesString), memento);
                return;
            }
            originator.restoreMemento(this.version, blob.version, memento);
        }
    }
    /**
   * Encode a memento as a serializable object, encoding any non-serializble types.
   */ encode(originator, memento) {
        try {
            return JSON.parse(JSON.stringify(memento, _MementoCaretaker.encodeTypes));
        } catch (error) {
            throw new Error("Failed to encode [".concat(originator.mementoOriginatorKey, "] value [").concat(error, "]."), {
                cause: error
            });
        }
    }
    /**
   * Decode an encoded memento, decoding any non-serializable types.
   */ decode(originator, encoded) {
        if (encoded == null) return encoded;
        try {
            return JSON.parse(JSON.stringify(encoded), _MementoCaretaker.decodeTypes);
        } catch (error) {
            throw new Error("Failed to decode [".concat(originator.mementoOriginatorKey, "] value [").concat(error, "]."), {
                cause: error
            });
        }
    }
    static encodeTypes(key, value) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDate"])(this[key])) {
            return {
                __type: "date",
                value: this[key].toISOString()
            };
        }
        return value;
    }
    static decodeTypes(key, value) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(this[key]) && "__type" in this[key] && this[key].__type === "date") {
            return new Date(this[key].value);
        }
        return value;
    }
    constructor(version){
        this.version = version.split("-")[0];
    }
};
// packages/ag-charts-community/src/api/state/stateManager.ts
var StateManager = class {
    setState(originator, value) {
        if (objectsEqual(this.state.get(originator.mementoOriginatorKey), value)) {
            return;
        }
        this.setStateAndRestore(originator, value);
    }
    setStateAndRestore(originator, value) {
        this.state.set(originator.mementoOriginatorKey, value);
        this.restoreState(originator);
    }
    restoreState(originator) {
        const { caretaker, state } = this;
        if (!state.has(originator.mementoOriginatorKey)) return;
        const value = state.get(originator.mementoOriginatorKey);
        caretaker.restore({
            version: caretaker.version,
            [originator.mementoOriginatorKey]: value
        }, originator);
    }
    constructor(){
        this.caretaker = new MementoCaretaker(VERSION);
        this.state = /* @__PURE__ */ new Map();
    }
};
;
// packages/ag-charts-community/src/styles.css
var styles_default = '.ag-charts-wrapper,.ag-charts-wrapper:after,.ag-charts-wrapper:before,.ag-charts-wrapper *,.ag-charts-wrapper *:after,.ag-charts-wrapper *:before{box-sizing:border-box}.ag-charts-wrapper{--align-items: center;--justify-content: center;position:relative;user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.ag-charts-wrapper--safe-horizontal{--justify-content: flex-start}.ag-charts-wrapper--safe-vertical{--align-items: flex-start}.ag-charts-tab-guard{width:0%;height:0%;position:absolute;pointer-events:none}.ag-charts-canvas-center{width:100%;height:100%;position:absolute;touch-action:auto;pointer-events:auto;display:flex;align-items:var(--align-items);justify-content:var(--justify-content)}.ag-charts-canvas-container,.ag-charts-canvas{position:relative;user-select:none;-webkit-user-select:none}.ag-charts-canvas-container>*,.ag-charts-canvas>*{pointer-events:none}.ag-charts-canvas canvas{display:block}.ag-charts-series-area{outline:none;pointer-events:auto;position:absolute}.ag-charts-swapchain{top:0;left:0;outline:none;opacity:0;pointer-events:none;position:absolute;width:100%;height:100%}.ag-charts-swapchain:focus-visible{opacity:1}.ag-charts-canvas-proxy,.ag-charts-canvas-overlay{inset:0;pointer-events:none;position:absolute;user-select:none;-webkit-user-select:none}.ag-charts-canvas-overlay>*{position:absolute;pointer-events:auto}.ag-charts-theme-default,.ag-charts-theme-default-dark{--ag-charts-accent-color: #2196f3;--ag-charts-background-color: #fff;--ag-charts-border-color: #dddddd;--ag-charts-border-radius: 4px;--ag-charts-chart-background-color: #fff;--ag-charts-chart-padding: 20px;--ag-charts-focus-shadow: 0 0 0 3px #2196f3;--ag-charts-foreground-color: #181d1f;--ag-charts-font-family: Verdana, sans-serif;--ag-charts-font-size: 12px;--ag-charts-font-weight: 400;--ag-charts-popup-shadow: 0 0 16px rgba(0, 0, 0, .15);--ag-charts-subtle-text-color: #8c8c8c;--ag-charts-text-color: #181d1f;--ag-charts-chrome-background-color: #fafafa;--ag-charts-chrome-font-family: Verdana, sans-serif;--ag-charts-chrome-font-size: 12px;--ag-charts-chrome-font-weight: 400;--ag-charts-chrome-subtle-text-color: #8c8c8c;--ag-charts-chrome-text-color: #181d1f;--ag-charts-button-background-color: #fff;--ag-charts-button-border: 1px solid #dddddd;--ag-charts-button-font-weight: normal;--ag-charts-button-text-color: inherit;--ag-charts-input-background-color: #fff;--ag-charts-input-border: 1px solid #dddddd;--ag-charts-input-text-color: #181d1f;--ag-charts-menu-background-color: #fafafa;--ag-charts-menu-border: 1px solid #dddddd;--ag-charts-menu-text-color: #181d1f;--ag-charts-panel-background-color: #fafafa;--ag-charts-panel-text-color: #181d1f;--ag-charts-tooltip-background-color: #fafafa;--ag-charts-tooltip-border: 1px solid #dddddd;--ag-charts-tooltip-text-color: #181d1f;--ag-charts-tooltip-subtle-text-color: #8c8c8c;--ag-charts-crosshair-label-background-color: #fafafa;--ag-charts-crosshair-label-text-color: #181d1f;--ag-charts-spacing: 4px;--ag-charts-icon-size: 16px;--ag-charts-focus-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-accent-color) 12%);--ag-charts-input-border-radius: var(--ag-charts-border-radius);--ag-charts-input-focus-border-color: var(--ag-charts-accent-color);--ag-charts-input-focus-text-color: var(--ag-charts-accent-color);--ag-charts-input-disabled-background-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-foreground-color) 6% );--ag-charts-input-disabled-border-color: var(--ag-charts-border-color);--ag-charts-input-disabled-text-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-input-text-color) 50% );--ag-charts-input-placeholder-text-color: color-mix( in srgb, var(--ag-charts-input-background-color), var(--ag-charts-input-text-color) 60% );--ag-charts-button-border-radius: var(--ag-charts-border-radius);--ag-charts-button-focus-background-color: color-mix( in srgb, var(--ag-charts-button-background-color), var(--ag-charts-accent-color) 12% );--ag-charts-button-focus-border-color: var(--ag-charts-accent-color);--ag-charts-button-focus-text-color: var(--ag-charts-accent-color);--ag-charts-button-disabled-background-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-foreground-color) 6% );--ag-charts-button-disabled-border-color: var(--ag-charts-border-color);--ag-charts-button-disabled-text-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-chrome-text-color) 50% );--ag-charts-checkbox-background-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-foreground-color) 35% );--ag-charts-checkbox-checked-background-color: var(--ag-charts-accent-color);--ag-charts-tooltip-border-radius: var(--ag-charts-border-radius);--ag-charts-menu-border-radius: var(--ag-charts-border-radius);--ag-charts-chrome-font-size-small: var(--ag-charts-chrome-font-size);--ag-charts-chrome-font-size-medium: calc(var(--ag-charts-chrome-font-size) * (13 / 12));--ag-charts-chrome-font-size-large: calc(var(--ag-charts-chrome-font-size) * (14 / 12));--ag-charts-border: 1px solid var(--ag-charts-border-color);--ag-charts-focus-border: 1px solid var(--ag-charts-accent-color);--ag-charts-focus-border-shadow: 0 0 0 3px color-mix(in srgb, transparent, var(--ag-charts-accent-color) 20%);--ag-charts-layer-menu: 6;--ag-charts-layer-ui-overlay: 5;--ag-charts-layer-tooltip: 4;--ag-charts-layer-toolbar: 3;--ag-charts-layer-crosshair: 2;--ag-charts-layer-annotations: 1}.ag-charts-theme-default-dark{--ag-charts-focus-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-accent-color) 22%)}.ag-chart-canvas-wrapper .ag-charts-theme-default{--ag-charts-border-radius: var(--ag-border-radius, 4px);--ag-charts-border: var(--ag-borders-critical, solid 1px) var(--ag-charts-border-color);--ag-charts-focus-shadow: var(--ag-focus-shadow, 0 0 0 3px var(--ag-charts-accent-color));--ag-charts-focus-border-shadow: var( --ag-focus-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-charts-accent-color) 20%) )}.ag-charts-icon{display:block;width:20px;height:20px;speak:none;speak:never;mask:var(--icon) center / contain no-repeat;background-color:currentColor;transition:background-color .25s ease-in-out}.ag-charts-icon-align-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNyAxMGg2djFIN3pNNCA3aDEydjFINHptMSA2aDEwdjFINXoiLz48L3N2Zz4=)}.ag-charts-icon-align-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNCAxMGg2djFINHptMC0zaDEydjFINHptMCA2aDEwdjFINHoiLz48L3N2Zz4=)}.ag-charts-icon-align-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTAgMTBoNnYxaC02ek00IDdoMTJ2MUg0em0yIDZoMTB2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-arrow-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1LjI5MyA0LjVIMTIuNXYtMUgxN3Y0aC0xVjUuMjA3bC05LjY0NiA5LjY0Ny0uNzA4LS43MDh6IiBmaWxsPSIjMDAwIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03IDE2YTIuNSAyLjUgMCAxIDEtNSAwIDIuNSAyLjUgMCAwIDEgNSAwbS0yLjUgMS41YTEuNSAxLjUgMCAxIDAgMC0zIDEuNSAxLjUgMCAwIDAgMCAzIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-arrow-down-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02IDhMMS41IDhMMTAgMThMMTguNSA4TDE0IDhMMTQgM0w2IDNMNiA4Wk03IDRMNyA5SDMuNjYyNDRMMTAgMTYuNDU2TDE2LjMzNzYgOUwxMyA5TDEzIDRMNyA0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-arrow-up-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNCAxMkgxOC41TDEwIDJMMS41IDEySDZMNi4wMDAwMiAxN0gxNFYxMlpNMTMgMTZWMTFIMTYuMzM3NkwxMCAzLjU0NDA1TDMuNjYyNDQgMTFIN0w3LjAwMDAyIDE2SDEzWiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-callout-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtNC41MTRhMjYgMjYgMCAwIDAtMi4wMTcgMS41NGwtLjMxNC4yNmMtLjU1LjQ1Ny0xLjExNS45MjYtMS43NiAxLjQtLjY2OS40OTEtMS41NjItLjAxMi0xLjU2Mi0uOFYxNEg0LjVBMS41IDEuNSAwIDAgMSAzIDEyLjV6TTQuNSA0YS41LjUgMCAwIDAtLjUuNXY4YS41LjUgMCAwIDAgLjUuNWgxLjgzM3YzLjM3MmEzNiAzNiAwIDAgMCAxLjY3OC0xLjMzOGwuMzItLjI2NWEyNiAyNiAwIDAgMSAyLjIyNS0xLjY4NWwuMTI2LS4wODRIMTUuNWEuNS41IDAgMCAwIC41LS41di04YS41LjUgMCAwIDAtLjUtLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyAxdjNoMnYxMkg3djNINnYtM0g0VjRoMlYxek01IDVoM3YxMEg1ek0xMSAxNFY2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6bTEtN2gzdjZoLTN6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-close{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNSA1IDEwIDEwTTUgMTUgMTUgNSIgc3Ryb2tlPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-comment-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy41MTMgMy45OTVhNi41IDYuNSAwIDAgMSA2LjA5OCAxMS40MWMtLjU4OC4zOTMtMS4yMTcuNTM2LTEuODI5LjU4NWExMyAxMyAwIDAgMS0xLjI3LjAxN0EyNyAyNyAwIDAgMCAxMCAxNkg0LjVhLjUuNSAwIDAgMS0uNS0uNVYxMHEwLS4yNDctLjAwNy0uNTEzYy0uMDA4LS40MTYtLjAxNi0uODU3LjAxNy0xLjI2OS4wNS0uNjEyLjE5Mi0xLjI0LjU4NS0xLjgzYTYuNSA2LjUgMCAwIDEgMi45MTgtMi4zOTNtMy41Ni42MWE1LjUgNS41IDAgMCAwLTUuNjQ2IDIuMzRjLS4yNjYuMzk3LS4zNzkuODQyLS40MiAxLjM1NC0uMDMuMzYtLjAyMi43MTgtLjAxNSAxLjEwOFE1IDkuNjg5IDUgMTB2NWg1cS4zMTEuMDAxLjU5My4wMDhjLjM5LjAwNy43NDcuMDE1IDEuMTA4LS4wMTUuNTEyLS4wNDEuOTU3LS4xNTQgMS4zNTUtLjQyYTUuNSA1LjUgMCAwIDAtMS45ODMtOS45NjciIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-crosshair-add-line{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-date-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMiAyaDF2MTZIMnptMTUgMGgxdjE2aC0xeiIgZmlsbD0iIzE4MUQxRiIvPjxwYXRoIGQ9Ik0xMy4xNTcgMTFINXYtMWg3Ljc5M0wxMSA4LjIwN2wuNzA3LS43MDcgMy4xODIgMy4xODItMy4xODIgMy4xODItLjcwNy0uNzA3eiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-date-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMyAySDJ2MTZoMXptMy41MDcgNC44OUw4LjUgNC44OTVWMTBINXYxaDMuNXY3aDF2LTdoNS4wODhsLTEuOTU3IDEuOTU3LjcwNy43MDcgMy4xODItMy4xODJMMTMuMzM4IDcuM2wtLjcwNy43MDdMMTQuNjI0IDEwSDkuNVY0LjkzMmwxLjk1NyAxLjk1Ny43MDctLjcwN0w4Ljk4MiAzIDUuOCA2LjE4MnoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-delete{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTguNDk2IDguOTk2QS41LjUgMCAwIDEgOSA5LjQ5MnY0YS41LjUgMCAxIDEtMSAuMDA4di00YS41LjUgMCAwIDEgLjQ5Ni0uNTA0TTEyIDkuNWEuNS41IDAgMCAwLTEgMHY0YS41LjUgMCAwIDAgMSAweiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTYgNVYzLjVBMi41IDIuNSAwIDAgMSA4LjUgMWgzQTIuNSAyLjUgMCAwIDEgMTQgMy41VjVoMi44MzNhLjUuNSAwIDAgMSAwIDFIMTV2MTAuMjVjMCAuNDE1LS4wNjYuODYzLS4zIDEuMjIxLS4yNTcuMzk0LS42NzIuNjEyLTEuMi42MTJoLTdjLS41MjggMC0uOTQzLS4yMTgtMS4yLS42MTItLjIzNC0uMzU4LS4zLS44MDYtLjMtMS4yMjFWNkgzLjMzM2EuNS41IDAgMCAxIDAtMXptMS0xLjVBMS41IDEuNSAwIDAgMSA4LjUgMmgzQTEuNSAxLjUgMCAwIDEgMTMgMy41VjVIN3pNNiAxNi4yNVY2aDh2MTAuMjVjMCAuMzM1LS4wNTkuNTU0LS4xMzguNjc1LS4wNTUuMDg1LS4xNC4xNTgtLjM2Mi4xNThoLTdjLS4yMjIgMC0uMzA3LS4wNzMtLjM2Mi0uMTU4LS4wOC0uMTIxLS4xMzgtLjM0LS4xMzgtLjY3NSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-disjoint-channel,.ag-charts-icon-disjoint-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTkuMDI4IDE3LjQ2YTIuMjUgMi4yNSAwIDAgMC00LjA5Mi0xLjg1bC05LjUxMS0yLjM3OGEyLjI1IDIuMjUgMCAxIDAtLjIyNS45NzRsOS40NzUgMi4zNjlhMi4yNTEgMi4yNTEgMCAwIDAgNC4zNTMuODg2bS0xLjY2Mi0xLjk2NWExLjI1IDEuMjUgMCAxIDEtLjg4NSAyLjMzOCAxLjI1IDEuMjUgMCAwIDEgLjg4NS0yLjMzOE00LjM0MyAxMy42NjlhMS4yNSAxLjI1IDAgMSAwLTIuMzM4LS44ODUgMS4yNSAxLjI1IDAgMCAwIDIuMzM4Ljg4NU0zLjk3IDguNzY5YTIuMjUgMi4yNSAwIDAgMCAxLjQ1NS0yLjExbDkuNTExLTIuMzc4YTIuMjUgMi4yNSAwIDEgMC0uMjYtLjk2NUw1LjIgNS42ODVhMi4yNSAyLjI1IDAgMSAwLTEuMjMgMy4wODRtLjM3My0yLjU0N2ExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjc1LTMuNDM4YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-drag-handle{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjcuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjxjaXJjbGUgY3g9IjEzLjc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iMTMuNzUiIGN5PSIxMS43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjExLjc1IiByPSIuNzUiIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjUiLz48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iMTEuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjwvc3ZnPg==)}.ag-charts-icon-fibonacci-retracement-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA1aDEydjFIMnoiLz48Y2lyY2xlIGN4PSIxNS43NSIgY3k9IjUuNSIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC4yNSIgY3k9IjE0LjUiIHI9IjEuNzUiIHN0cm9rZT0iIzAwMCIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0xOCAxNUg2di0xaDEyem0wLTQuNUgydi0xaDE2eiIvPjwvc3ZnPg==)}.ag-charts-icon-fibonacci-retracement-trend-based-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJtNC45OTYgMTIuNjc0IDMuMjkxLTUuNzQzLjg2OC40OTctMy4yOTEgNS43NDN6Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjUuNSIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC4zNTEiIGN5PSIxNC41IiByPSIxLjc1IiBzdHJva2U9IiMwMDAiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTggNmgtN1Y1aDd6bTAgNC41aC03di0xaDd6bTAgNC41SDZ2LTFoMTJ6Ii8+PC9zdmc+)}.ag-charts-icon-fill-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtOC4wNzEgNC4wNi0uOTI0LS45MjQuNzA3LS43MDcgNy4yODggNy4yODgtNC45NSA0Ljk1YTMuNSAzLjUgMCAwIDEtNC45NSAwbC0xLjQxNC0xLjQxNGEzLjUgMy41IDAgMCAxIDAtNC45NXptLjcwNy43MDhMNC41MzYgOS4wMWEyLjUgMi41IDAgMCAwIDAgMy41MzZMNS45NSAxMy45NmEyLjUgMi41IDAgMCAwIDMuNTM1IDBsNC4yNDMtNC4yNDN6bTYuOSA3LjIwMi0uMzQ1LjM2My0uMzQ0LS4zNjNhLjUuNSAwIDAgMSAuNjg4IDBtLS4zNDUgMS4wOGE4IDggMCAwIDAtLjI4LjMyMyA0LjMgNC4zIDAgMCAwLS40MDkuNTgyYy0uMTEzLjIwMS0uMTQ0LjMyNi0uMTQ0LjM3OGEuODMzLjgzMyAwIDAgMCAxLjY2NyAwYzAtLjA1Mi0uMDMxLS4xNzctLjE0NC0uMzc4YTQuMyA0LjMgMCAwIDAtLjQxLS41ODIgOCA4IDAgMCAwLS4yOC0uMzIybS0uMzQ0LTEuMDguMzQ0LjM2My4zNDQtLjM2My4wMDIuMDAyLjAwNC4wMDQuMDEzLjAxMmE2IDYgMCAwIDEgLjIwNi4yMDhjLjEzMS4xMzYuMzA4LjMyNy40ODUuNTQ1LjE3Ni4yMTUuMzYzLjQ2Ny41MDcuNzI0LjEzNy4yNDMuMjczLjU1My4yNzMuODY4YTEuODMzIDEuODMzIDAgMSAxLTMuNjY3IDBjMC0uMzE1LjEzNi0uNjI1LjI3My0uODY4LjE0NC0uMjU3LjMzLS41MDkuNTA3LS43MjRhOSA5IDAgMCAxIC42NDUtLjcwOGwuMDQ2LS4wNDUuMDEzLS4wMTIuMDA0LS4wMDR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-hollow-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1vcGFjaXR5PSIuMTUiIGQ9Ik01IDVoM3YxMEg1eiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMXYzaDJ2MTJIN3YzSDZ2LTNINFY0aDJWMXpNNSA1aDN2MTBINXptNyAyaDN2NmgtM3ptLTEgN1Y2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-horizontal-line,.ag-charts-icon-horizontal-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNLjUgOS41aDcuMzA2YTIuMjUgMi4yNSAwIDAgMSA0LjM4OCAwSDE5LjV2MWgtNy4zMDZhMi4yNSAyLjI1IDAgMCAxLTQuMzg4IDBILjV6bTkuNSAxLjc1YTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMjQyIDIuNzIyYy0uNjEyIDAtMS4yLjI0My0xLjYzMi42NzVsLTEuMzQzIDEuMzQ0YS41LjUgMCAwIDAtLjExMi4xMTJMNC4wNSAxMS45NTljLS4yMDcuMjA3LS4zNi40Ni0uNDQ2Ljc0di4wMDFsLS42OSAyLjc2N3YuMDAyYS44Mi44MiAwIDAgMCAxLjAyMiAxLjAyMWguMDAybDIuNjM0LS44MjJjLjI4LS4wODUuNTM0LS4yMzcuNzQtLjQ0M2w3LjEwNy03LjEwOGEuNS41IDAgMCAwIC4xMTItLjExMmwxLjM0My0xLjM0M2EyLjMwOCAyLjMwOCAwIDAgMC0xLjYzMi0zLjk0TTE0LjEyMiA3bDEuMDQ0LTEuMDQ1YTEuMzA4IDEuMzA4IDAgMSAwLTEuODQ5LTEuODVMMTIuMjcxIDUuMTV6bS0yLjU1OC0xLjE0Mi02LjgwNyA2LjgwOWEuOC44IDAgMCAwLS4xOTYuMzI1bC0uNzUgMi40NjggMi40Ny0uNzQ5YS44LjggMCAwIDAgLjMyNS0uMTk0bDYuODA4LTYuODF6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTcuMzYyIDQuODczLTQuNTk0IDYuNjU0LTQuODUtMy4zMTctNC4yNTEgNi45NzctLjg1NC0uNTJMNy42MTIgNi43OWw0Ljg5OSAzLjM1IDQuMDI4LTUuODM2eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-line-style-dashed{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDR2MUgyem0xMiAwaDR2MWgtNHpNOCA5aDR2MUg4eiIvPjwvc3ZnPg==)}.ag-charts-icon-line-style-dotted{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIyLjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSI4LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTAuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSIxMi41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjE0LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-line-style-solid{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDE2djFIMnoiLz48L3N2Zz4=)}.ag-charts-icon-line-with-markers-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTk4IDQuODg4LTMuNTU2IDQuOTE4YTIuMjUgMi4yNSAwIDEgMS0zLjg2Ni43NWwtMS40MzItLjlhMi4yNCAyLjI0IDAgMCAxLTIuMDA5LjQzNWwtMy44MjggNi40MjgtLjg2LS41MTJMNi40NSA5LjYyM2EyLjI1IDIuMjUgMCAxIDEgMy41MS0uNzYxbDEuMzI5LjgzNWEyLjI0IDIuMjQgMCAwIDEgMi41NTctLjQ5N2wzLjU0Mi00Ljg5OHptLTQuOTYgNS4xNTNhMS4yNSAxLjI1IDAgMSAwLS42NCAyLjQxOSAxLjI1IDEuMjUgMCAwIDAgLjY0LTIuNDE5TTkuMSA4LjMyMXEuMDY2LS4xOTIuMDY3LS40MDRhMS4yNSAxLjI1IDAgMSAwLS4wNjcuNDA0IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-lock,.ag-charts-icon-locked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuMjA3IDMuNzY0YTIuODk0IDIuODk0IDAgMCAwLTIuODk1IDIuODk0VjloNS43ODlWNi42NThhMi44OTQgMi44OTQgMCAwIDAtMi44OTUtMi44OTRNMTQuMSA5VjYuNjU4YTMuODk0IDMuODk0IDAgMSAwLTcuNzg5IDB2Mi4zNDlBMi41IDIuNSAwIDAgMCA0IDExLjV2M0EyLjUgMi41IDAgMCAwIDYuNSAxN2g4YTIuNSAyLjUgMCAwIDAgMi41LTIuNXYtM0EyLjUgMi41IDAgMCAwIDE0LjUgOXpNNi41IDEwQTEuNSAxLjUgMCAwIDAgNSAxMS41djNBMS41IDEuNSAwIDAgMCA2LjUgMTZoOGExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTNhMS41IDEuNSAwIDAgMC0xLjUtMS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-measurer-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibTQuNDYxIDEyLjcxIDEuNTMyLTEuNTMxIDEuNDE0IDEuNDE0LjcwNy0uNzA3TDYuNyAxMC40NzJsMS41MzItMS41MzMgMiAyIC43MDctLjcwNy0yLTIgNi4wMS02LjAxIDIuODMgMi44MjhMNS4wNSAxNy43NzggMi4yMjIgMTQuOTVsMS41MzItMS41MzIgMS40MTQgMS40MTQuNzA3LS43MDd6TS44MDggMTQuOTVsLjcwNy0uNzA3TDE0LjI0MyAxLjUxNWwuNzA3LS43MDcuNzA3LjcwNyAyLjgyOCAyLjgyOC43MDcuNzA3LS43MDcuNzA3TDUuNzU3IDE4LjQ4NWwtLjcwNy43MDctLjcwNy0uNzA3LTIuODI4LTIuODI4em0xMS4wNzgtNi44MzVMMTAuNDcgNi43bC43MDctLjcwNyAxLjQxNSAxLjQxNHptLjgyNC0zLjY1NCAxIDEgLjcwOC0uNzA3LTEtMXoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-note-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtMy4yMWwtMS40NjkgMi41N2ExIDEgMCAwIDEtMS42ODIuMDg1TDcuMjQzIDE0SDQuNUExLjUgMS41IDAgMCAxIDMgMTIuNXpNNC41IDRhLjUuNSAwIDAgMC0uNS41djhhLjUuNSAwIDAgMCAuNS41aDMuMjU3bDIuMTk2IDMuMDc0TDExLjcxIDEzaDMuNzlhLjUuNSAwIDAgMCAuNS0uNXYtOGEuNS41IDAgMCAwLS41LS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNi41IDYuNUEuNS41IDAgMCAxIDcgNmg2YS41LjUgMCAwIDEgMCAxSDdhLjUuNSAwIDAgMS0uNS0uNU02LjUgOS41QS41LjUgMCAwIDEgNyA5aDZhLjUuNSAwIDAgMSAwIDFIN2EuNS41IDAgMCAxLS41LS41IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-ohlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTEzIDExaC0zdi0xaDNWM2gxdjJoNHYxaC00djExaC0xek02IDE3di0yaDN2LTFINlY0SDV2MUgydjFoM3YxMXoiLz48L3N2Zz4=)}.ag-charts-icon-pan-end{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0ibTYuNjQ2IDEzLjgxMy0uMzUzLjM1NC43MDcuNzA3LjM1NC0uMzU0ek0xMS4xNjYgMTBsLjM1NC4zNTQuMzU0LS4zNTQtLjM1NC0uMzU0ek03LjM1NSA1LjQ4IDcgNS4xMjZsLS43MDcuNzA3LjM1My4zNTR6bTAgOS4wNCA0LjE2Ni00LjE2Ni0uNzA3LS43MDgtNC4xNjcgNC4xNjd6bTQuMTY2LTQuODc0TDcuMzU0IDUuNDhsLS43MDguNzA3IDQuMTY3IDQuMTY3ek0xMy4wODMgNXYxMGgxVjV6Ii8+PC9zdmc+)}.ag-charts-icon-pan-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuNzkgNS44MzMgOC42MjUgMTBsNC4xNjYgNC4xNjctLjcwNy43MDdMNy4yMSAxMGw0Ljg3My00Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy4yMSAxNC4xNjcgMTEuMzc2IDEwIDcuMjEgNS44MzNsLjcwNy0uNzA3TDEyLjc5IDEwbC00Ljg3MyA0Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-start{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgNXYxMGgxVjV6TTkuNjI0IDEwbDQuMTY2LTQuMTY3LS43MDctLjcwN0w4LjIxIDEwbDQuODc0IDQuODc0LjcwNy0uNzA3eiIvPjwvc3ZnPg==)}.ag-charts-icon-parallel-channel,.ag-charts-icon-parallel-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNzIgNS4zMzFBMi4yNSAyLjI1IDAgMSAwIDE0LjcwNSAzLjZsLTkuNDkgNC41NjJhMi4yNSAyLjI1IDAgMSAwIC4yMDkgMS4wMWw5LjY2Mi00LjY0NmEyLjI1IDIuMjUgMCAwIDAgMi42MzQuODA1bS4zNzMtMi41NDdhMS4yNSAxLjI1IDAgMSAxLTIuMzM4Ljg4NSAxLjI1IDEuMjUgMCAwIDEgMi4zMzgtLjg4NU00LjM0MyA4LjY3YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODVNNS4zMDcgMTYuNzI4YTIuMjUgMi4yNSAwIDEgMS0uNTI1LS44NThsOS45MjMtNC43N2EyLjI1IDIuMjUgMCAxIDEgLjM4MS45MjZ6bS0uOTY0LjI3NGExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjAyMy01LjEwNmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-position-bottom{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzem0zLTNoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgMTNoOHYxSDZ6Ii8+PC9zdmc+)}.ag-charts-icon-position-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMyAxMGgxNHYxSDN6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDdoOHYxSDZ6bTAgNmg4djFINnoiLz48L3N2Zz4=)}.ag-charts-icon-position-top{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzeiIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik02IDdoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDEzaDh2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-price-label-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNC41IDNBMS41IDEuNSAwIDAgMCAzIDQuNVYxM2ExLjUgMS41IDAgMCAwIDEuNSAxLjVoLjgzM3YuMDU3Yy4yNDItLjI5OS41OTctLjUwMyAxLS41NDhWMTMuNUg0LjVBLjUuNSAwIDAgMSA0IDEzVjQuNWEuNS41IDAgMCAxIC41LS41aDExYS41LjUgMCAwIDEgLjUuNXY4YS41LjUgMCAwIDEtLjUuNWgtNC44MThsLS4xMjYuMDg0YTI2IDI2IDAgMCAwLTIuMjI1IDEuNjg1bC0uMzIuMjY1LS4wNjguMDU2YTEuNSAxLjUgMCAwIDEtMi42MDkgMS4zNTRjLjAzMy43NjMuOTA1IDEuMjM4IDEuNTYuNzU2LjY0Ni0uNDc0IDEuMjEtLjk0MyAxLjc2MS0xLjRsLjMxMy0uMjZBMjYgMjYgMCAwIDEgMTAuOTg2IDE0SDE1LjVhMS41IDEuNSAwIDAgMCAxLjUtMS41di04QTEuNSAxLjUgMCAwIDAgMTUuNSAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43MTYgMTQuODE1YTIuMjUgMi4yNSAwIDEgMS00LjIxIDEuNTkzIDIuMjUgMi4yNSAwIDAgMSA0LjIxLTEuNTkzbS0xLjY2MiAxLjk2NmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS41IDYuMjI4IDcuMTY3IDguMzc2IDYuNSA3Ljc2MiA5LjUgNWwzIDIuNzYyLS42NjcuNjE0eiIgZmlsbD0iIzAwMCIvPjxwYXRoIGQ9Ik0yIDE4di0xaDE2djF6TTIgM1YyaDE2djF6IiBmaWxsPSIjMTgxRDFGIi8+PC9zdmc+)}.ag-charts-icon-reset{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuMDQgNC40NDVhNS44MSA1LjgxIDAgMCAwLTcuMjU3IDIuNDUzLjUuNSAwIDAgMS0uODY1LS41MDJBNi44MSA2LjgxIDAgMSAxIDMgOS44MTNhLjUuNSAwIDAgMSAxIDAgNS44MSA1LjgxIDAgMSAwIDguMDQtNS4zNjgiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTQuMjg5IDMuMDAyYS41LjUgMCAwIDEgLjUuNXYyLjY1NWgyLjY1NWEuNS41IDAgMCAxIDAgMUg0LjI5YS41LjUgMCAwIDEtLjUtLjVWMy41MDJhLjUuNSAwIDAgMSAuNS0uNSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-settings{--icon: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkIj48cGF0aCBkPSJNMTAgMTNhMyAzIDAgMSAwIDAtNiAzIDMgMCAwIDAgMCA2bTAtMWEyIDIgMCAxIDEtLjAwMS0zLjk5OUEyIDIgMCAwIDEgMTAgMTIiLz48cGF0aCBkPSJNMi4zMSAxNC4zNDVjLS44MTctMS40OTEuMDI3LTIuNDk5LjQ3NC0yLjg2NS41MzEtLjQzNC45NjktLjM2NS45NzItMS40OC0uMDAzLTEuMTE1LS40NDEtMS4wNDYtLjk3Mi0xLjQ4MS0uNDU0LS4zNzEtMS4zMTctMS40MDUtLjQzNC0yLjkzNmwuMDA1LS4wMDljLjg4NC0xLjUyIDIuMjA3LTEuMjkgMi43NTUtMS4wODMuNjQxLjI0My44MDEuNjU2IDEuNzY4LjEwMS45NjQtLjU2LjY4Ni0uOTA0Ljc5Ni0xLjU4Mi4wOTQtLjU3OC41NTktMS44NDMgMi4zMjYtMS44NDNoLjAxYzEuNzU5LjAwNSAyLjIyMiAxLjI2NiAyLjMxNiAxLjg0My4xMS42NzgtLjE2OCAxLjAyMi43OTYgMS41ODIuOTY3LjU1NSAxLjEyNy4xNDIgMS43NjgtLjEwMS41NDktLjIwOCAxLjg3Ni0uNDM4IDIuNzYgMS4wOTJzLjAyIDIuNTY1LS40MzQgMi45MzZjLS41MzEuNDM1LS45NjkuMzY2LS45NzIgMS40ODEuMDAzIDEuMTE1LjQ0MSAxLjA0Ni45NzIgMS40OC40NTQuMzcyIDEuMzE3IDEuNDA2LjQzNCAyLjkzN2wtLjAwNS4wMDljLS44ODQgMS41Mi0yLjIwNyAxLjI5LTIuNzU1IDEuMDgzLS42NDEtLjI0My0uODAxLS42NTYtMS43NjgtLjEwMS0uOTY0LjU2LS42ODYuOTA0LS43OTYgMS41ODEtLjA5NC41NzktLjU1OSAxLjg0NC0yLjMyNiAxLjg0NGgtLjAxYy0xLjc1OS0uMDA1LTIuMjIyLTEuMjY2LTIuMzE2LTEuODQ0LS4xMS0uNjc3LjE2OC0xLjAyMS0uNzk2LTEuNTgxLS45NjctLjU1NS0xLjEyNy0uMTQyLTEuNzY4LjEwMS0uNTQ5LjIwOC0xLjg3Ni40MzgtMi43Ni0xLjA5MmwtLjAyLS4wMzZ6TTkuOTg0IDIuMTYySDEwYzEuMzU1IDAgMS4zNDIgMS4wMzkgMS4zNTMgMS40MjUuMDA4LjMxMi4wNCAxLjE2IDEuMjU5IDEuODcybC4wMTUuMDA4YzEuMjI1LjcgMS45NzYuMzA0IDIuMjUxLjE1NS4zMzctLjE4MyAxLjIyNi0uNzExIDEuOTAyLjQ0NWwuMDA4LjAxNGMuNjc4IDEuMTczLS4yMjkgMS42ODItLjU1OCAxLjg4NC0uMjY2LjE2My0uOTg0LjYxNS0uOTkxIDIuMDI3di4wMTZjLjAwNyAxLjQxMi43MjUgMS44NjQuOTkxIDIuMDI3LjMyOC4yMDEgMS4yMjkuNzA3LjU2NiAxLjg3bC0uMDA4LjAxNGMtLjY3NyAxLjE3NC0xLjU3MS42NDMtMS45MS40NTktLjI3NS0uMTQ5LTEuMDI2LS41NDUtMi4yNTEuMTU0bC0uMDE1LjAwOWMtMS4yMTkuNzEyLTEuMjUxIDEuNTYtMS4yNTkgMS44NzItLjAxMS4zODYuMDAyIDEuNDI1LTEuMzUzIDEuNDI1cy0xLjM0Mi0xLjAzOS0xLjM1My0xLjQyNWMtLjAwOC0uMzEyLS4wNC0xLjE2LTEuMjU5LTEuODcybC0uMDE1LS4wMDljLTEuMjI1LS42OTktMS45NzYtLjMwMy0yLjI1MS0uMTU0LS4zMzYuMTgzLTEuMjE5LjcwNi0xLjg5NC0uNDMybC0uMDE2LS4wMjdjLS42NzgtMS4xNzQuMjI5LTEuNjgyLjU1OC0xLjg4NC4yNjYtLjE2My45ODQtLjYxNS45OTEtMi4wMjd2LS4wMTZjLS4wMDctMS40MTItLjcyNS0xLjg2NC0uOTkxLTIuMDI3LS4zMjgtLjIwMS0xLjIyOS0uNzA3LS41NjYtMS44N2wuMDA4LS4wMTRjLjY3Ny0xLjE3NCAxLjU3MS0uNjQzIDEuOTEtLjQ1OS4yNzUuMTQ5IDEuMDI2LjU0NSAyLjI1MS0uMTU1bC4wMTUtLjAwOGMxLjIxOS0uNzEyIDEuMjUxLTEuNTYgMS4yNTktMS44NzIuMDEtLjM4NC0uMDAyLTEuNDE3IDEuMzM3LTEuNDI1Ii8+PC9zdmc+)}.ag-charts-icon-step-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzE4MUQxRiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNiA0aDV2OGgzVjhoNXYxaC00djRoLTVWNUg3djEwSDJ2LTFoNHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-text-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDRIMTZWN0gxNVY1SDEwLjVWMTVIMTRWMTZINlYxNUg5LjVWNUg1VjdINFY0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-trend-line,.ag-charts-icon-trend-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS4zMTQgMTAuOTM4YTIuMjUgMi4yNSAwIDEgMSAuMDEtMWg5LjM1MmEyLjI1IDIuMjUgMCAxIDEgLjAxIDF6bS0yLjE4OS43MjlhMS4yNSAxLjI1IDAgMSAwIDAtMi41IDEuMjUgMS4yNSAwIDAgMCAwIDIuNW0xMy43NSAwYTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock,.ag-charts-icon-unlocked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNjUxIDMuNWEyLjg5NCAyLjg5NCAwIDAgMC0yLjg5NCAyLjg5NFY5SDE0LjVhMi41IDIuNSAwIDAgMSAyLjUgMi41djNhMi41IDIuNSAwIDAgMS0yLjUgMi41aC04QTIuNSAyLjUgMCAwIDEgNCAxNC41di0zQTIuNSAyLjUgMCAwIDEgNi41IDloLjI1N1Y2LjM5NGEzLjg5NCAzLjg5NCAwIDEgMSA3Ljc4OSAwIC41LjUgMCAwIDEtMSAwQTIuODk0IDIuODk0IDAgMCAwIDEwLjY1IDMuNU02LjUgMTBBMS41IDEuNSAwIDAgMCA1IDExLjV2M0ExLjUgMS41IDAgMCAwIDYuNSAxNmg4YTEuNSAxLjUgMCAwIDAgMS41LTEuNXYtM2ExLjUgMS41IDAgMCAwLTEuNS0xLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-vertical-line,.ag-charts-icon-vertical-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNSA3LjgwNmEyLjI1IDIuMjUgMCAwIDEgMCA0LjM4OFYxOS41aC0xdi03LjMwNmEyLjI1IDIuMjUgMCAwIDEgMC00LjM4OFYuNWgxem0tLjUuOTQ0YTEuMjUgMS4yNSAwIDEgMSAwIDIuNSAxLjI1IDEuMjUgMCAwIDEgMC0yLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-zoom-in{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS41IDEwYS41LjUgMCAwIDEgLjUtLjVoOGEuNS41IDAgMCAxIDAgMUg2YS41LjUgMCAwIDEtLjUtLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-high-low-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyA0aDJ2MTJINFY0aDNNNSA1aDN2MTBINXpNMTEgMTRWNmg1djhoLTVtMS03aDN2NmgtM3oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTYzIDEuODM3LTUuMzM0IDExLjYyMUw2Ljk1NyA4LjEybC00LjE5OSA5LjYyMi0uOTE2LS40IDQuNzU2LTEwLjlMMTIuNDkgMTEuOCAxNy4yNTQgMS40MnoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTUuODI1IDIuNzA0LjU1IDEzLjc4NWwuOTAyLjQzIDQuNzI0LTkuOTE5IDYuMDM0IDUuMDI5IDMuMjU1LTguMTQtLjkyOC0uMzctMi43NDUgNi44NnptNy44NTIgMTQuNjM2IDUuNzgtMTMuMTM5LS45MTUtLjQwMi01LjIxOSAxMS44Ni02LjAwNS01LjUwNC0zLjI3OCA3LjY0OC45Mi4zOTQgMi43MjItNi4zNTJ6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-chevron-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03LjQ3IDUuNDdhLjc1Ljc1IDAgMCAxIDEuMDYgMGw0IDRhLjc1Ljc1IDAgMCAxIDAgMS4wNmwtNCA0YS43NS43NSAwIDAgMS0xLjA2LTEuMDZMMTAuOTQgMTAgNy40NyA2LjUzYS43NS43NSAwIDAgMSAwLTEuMDYiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-alt{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+)}.ag-charts-icon-zoom-out-alt{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=)}.ag-charts-input{--input-layer-active: 1;--input-layer-focus: 2;--input-padding: calc(var(--ag-charts-spacing) * 2);--input-padding-large: calc(var(--ag-charts-spacing) * 2.5);color:var(--ag-charts-input-text-color);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-large);transition-duration:.25s;transition-property:none;transition-timing-function:ease-out}.ag-charts-input:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:var(--input-layer-focus)}.ag-charts-button{background:var(--ag-charts-button-background-color);border:var(--ag-charts-button-border);border-radius:var(--ag-charts-button-border-radius);color:var(--ag-charts-button-text-color);cursor:pointer;padding:var(--input-padding);transition-property:background,border-color}.ag-charts-button:hover{background:var(--ag-charts-focus-color)}.ag-charts-button:has(.ag-charts-icon){padding:2px}.ag-charts-checkbox{--checkbox-transition-duration: .1s;appearance:none;background:var(--ag-charts-checkbox-background-color);border-radius:calc(var(--ag-charts-border-radius) * 9);cursor:pointer;height:18px;margin:0;transition-duration:var(--checkbox-transition-duration);transition-property:margin;width:29px}.ag-charts-checkbox:before{display:block;background:var(--ag-charts-input-background-color);border-radius:calc(var(--ag-charts-border-radius) * 7);content:" ";height:14px;margin:2px;transition-duration:var(--checkbox-transition-duration);transition-property:margin;transition-timing-function:var(--ag-charts-input-transition-easing);width:14px}.ag-charts-checkbox:checked{background:var(--ag-charts-checkbox-checked-background-color)}.ag-charts-checkbox:checked:before{margin-left:13px}.ag-charts-select{background:var(--ag-charts-input-background-color);border:var(--ag-charts-input-border);border-radius:var(--ag-charts-input-border-radius);padding:3px 2px 4px;font-size:inherit}.ag-charts-textarea{--textarea-line-height: 1.38;background:var(--ag-charts-input-background-color);border:var(--ag-charts-input-border);border-radius:var(--ag-charts-input-border-radius);line-height:var(--textarea-line-height);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-large);padding:var(--input-padding-large) var(--input-padding)}.ag-charts-textarea::placeholder{color:var(--ag-charts-input-placeholder-text-color)}.ag-charts-proxy-container{pointer-events:none;position:absolute}.ag-charts-proxy-legend-toolbar{pointer-events:auto}.ag-charts-proxy-legend-toolbar>div[role=listitem]{pointer-events:none}.ag-charts-proxy-elem{-webkit-appearance:none;appearance:none;background:none;border:none;color:#0000;overflow:hidden;pointer-events:auto;position:absolute}.ag-charts-proxy-elem::-moz-range-thumb,.ag-charts-proxy-elem::-moz-range-track{opacity:0}.ag-charts-proxy-elem::-webkit-slider-runnable-track,.ag-charts-proxy-elem::-webkit-slider-thumb{opacity:0}.ag-charts-proxy-elem:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus-indicator{position:absolute;display:block;pointer-events:none;user-select:none;-webkit-user-select:none;width:100%;height:100%}.ag-charts-focus-indicator>div{position:absolute;outline:solid 1px var(--ag-charts-chrome-background-color);box-shadow:var(--ag-charts-focus-shadow)}.ag-charts-focus-indicator>svg{width:100%;height:100%;fill:none;overflow:visible}.ag-charts-focus-svg-outer-path{stroke:var(--ag-charts-chrome-background-color);stroke-width:4px}.ag-charts-focus-svg-inner-path{stroke:var(--ag-charts-accent-color);stroke-width:2px}.ag-charts-overlay{color:#181d1f;pointer-events:none}.ag-charts-overlay.ag-charts-dark-overlay{color:#fff}.ag-charts-overlay--loading{color:#8c8c8c}.ag-charts-overlay__loading-background{background:#fff;pointer-events:none}.ag-charts-overlay.ag-charts-dark-overlay .ag-charts-overlay__loading-background{background:#192232}.ag-charts-tooltip{--tooltip-arrow-size: 8px;--tooltip-row-spacing: 8px;--tooltip-column-spacing: 16px;position:fixed;inset:unset;margin:0;padding:0;overflow:visible;top:var(--top, 0px);left:var(--left, 0px);width:max-content;max-width:100%;font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size);font-weight:var(--ag-charts-chrome-font-weight);color:var(--ag-charts-tooltip-text-color);background:var(--ag-charts-tooltip-background-color);border:var(--ag-charts-tooltip-border);border-radius:var(--ag-charts-tooltip-border-radius);box-shadow:var(--ag-charts-popup-shadow)}.ag-charts-tooltip--compact .ag-charts-tooltip-content{--tooltip-row-spacing: 2px;--tooltip-column-spacing: 8px;padding:3px 6px}.ag-charts-tooltip--arrow-top:before,.ag-charts-tooltip--arrow-right:before,.ag-charts-tooltip--arrow-bottom:before,.ag-charts-tooltip--arrow-left:before{content:"";position:absolute;display:block;width:var(--tooltip-arrow-size);height:var(--tooltip-arrow-size);border:inherit;border-bottom-color:transparent;border-right-color:transparent;background:inherit;clip-path:polygon(0 0,100% 0,100% 1px,1px 100%,0 100%)}.ag-charts-tooltip--arrow-top:before{bottom:100%;left:50%;transform:translate(-50%) translateY(calc(var(--tooltip-arrow-size) * .5)) rotate(45deg)}.ag-charts-tooltip--arrow-bottom:before{top:100%;left:50%;transform:translate(-50%) translateY(calc(var(--tooltip-arrow-size) * -.5)) rotate(225deg)}.ag-charts-tooltip--arrow-left:before{right:100%;top:50%;transform:translateY(-50%) translate(calc(var(--tooltip-arrow-size) * .5)) rotate(315deg)}.ag-charts-tooltip--arrow-right:before{left:100%;top:50%;transform:translateY(-50%) translate(calc(var(--tooltip-arrow-size) * -.5)) rotate(135deg)}.ag-charts-tooltip--no-interaction{pointer-events:none;user-select:none;-webkit-user-select:none}.ag-charts-tooltip--wrap-always{overflow-wrap:break-word;word-break:break-word;hyphens:none}.ag-charts-tooltip--wrap-hyphenate{overflow-wrap:break-word;word-break:break-word;hyphens:auto}.ag-charts-tooltip--wrap-on-space{overflow-wrap:normal;word-break:normal}.ag-charts-tooltip--wrap-never{white-space:nowrap}.ag-charts-tooltip-heading,.ag-charts-tooltip-title,.ag-charts-tooltip-label,.ag-charts-tooltip-value{overflow:hidden;text-overflow:ellipsis}.ag-charts-tooltip-content{display:grid;grid:auto-flow minmax(1em,auto) / 1fr;padding:8px 12px;gap:var(--tooltip-row-spacing)}.ag-charts-tooltip-content:has(.ag-charts-tooltip-symbol){grid:auto-flow minmax(1em,auto) / auto 1fr}.ag-charts-tooltip-heading{grid-column:1 / -1}.ag-charts-tooltip-symbol{grid-column:1 / 2;place-self:center}.ag-charts-tooltip-symbol svg{display:block}.ag-charts-tooltip-title{grid-column:-2 / -1}.ag-charts-tooltip-row{grid-column:1 / -1;display:flex;gap:var(--tooltip-column-spacing);align-items:baseline;justify-content:space-between;overflow:hidden}.ag-charts-tooltip-row--inline{grid-column:-2 / -1}.ag-charts-tooltip-label{flex:1;min-width:0}.ag-charts-tooltip-value{min-width:0}.ag-charts-tooltip-footer{grid-column:1 / -1;color:var(--ag-charts-tooltip-subtle-text-color);text-align:center}.ag-charts-popover{position:absolute;border:var(--ag-charts-border);border-radius:var(--ag-charts-border-radius);background:var(--ag-charts-panel-background-color);color:var(--ag-charts-chrome-text-color);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size);font-weight:var(--ag-charts-chrome-font-weight);box-shadow:var(--ag-charts-popup-shadow);z-index:var(--ag-charts-layer-ui-overlay)}.ag-charts-menu{--item-padding: 6px 12px;--icon-color: var(--ag-charts-menu-text-color);display:grid;grid:auto-flow auto / 1fr;column-gap:12px;font-size:var(--ag-charts-chrome-font-size)}.ag-charts-menu:has(.ag-charts-menu__icon,.ag-charts-menu__row--stroke-width-visible){grid:auto-flow auto / auto 1fr}.ag-charts-menu__row--stroke-width-visible:before{content:"";height:var(--strokeWidth);width:12px;background:var(--icon-color)}.ag-charts-menu__row--stroke-width-visible[aria-disabled=true]:before{filter:grayscale(1);opacity:.5}.ag-charts-menu__row{display:grid;grid-column:1 / -1;grid-template-columns:subgrid;align-items:center;padding:var(--item-padding)}.ag-charts-menu__row:not(.ag-charts-menu__row--active){cursor:pointer}.ag-charts-menu__row:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.ag-charts-menu__row:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.ag-charts-menu__row:focus{background:var(--ag-charts-focus-color)}.ag-charts-menu__row:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:var(--ag-charts-layer-menu)}.ag-charts-menu__row--active{--icon-color: var(--ag-charts-accent-color);background:var(--ag-charts-focus-color);color:var(--ag-charts-accent-color)}.ag-charts-menu__label{grid-column:-1 / span 1}.ag-charts-toolbar{--toolbar-gap: calc(var(--ag-charts-spacing) * 2);--toolbar-size: 34px;--toolbar-button-padding: 6px;align-items:center;display:flex;flex-wrap:nowrap;position:absolute}.ag-charts-toolbar__button{align-items:center;background:var(--ag-charts-chrome-background-color);border:var(--ag-charts-button-border);color:var(--ag-charts-button-text-color);cursor:pointer;display:flex;font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-medium);font-weight:var(--ag-charts-chrome-font-weight);justify-content:center;min-height:var(--toolbar-size);min-width:var(--toolbar-size);padding:var(--toolbar-button-padding);position:relative;transition:background-color .25s ease-in-out,border-color .25s ease-in-out,color .25s ease-in-out;white-space:nowrap}.ag-charts-toolbar__button:hover{background:var(--ag-charts-focus-color);z-index:1}.ag-charts-toolbar__button:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-charts-toolbar__button--active{background:var(--ag-charts-focus-color);border-color:var(--ag-charts-accent-color);color:var(--ag-charts-accent-color);z-index:2}.ag-charts-toolbar__button[aria-disabled=true]{background:var(--ag-charts-button-disabled-background-color);color:var(--ag-charts-button-disabled-text-color);cursor:default}.ag-charts-toolbar--horizontal{flex-direction:row;.ag-charts-toolbar__button{margin:0 0 0 -1px}.ag-charts-toolbar__button--first{border-bottom-left-radius:var(--ag-charts-border-radius);border-top-left-radius:var(--ag-charts-border-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-right-radius:var(--ag-charts-border-radius);border-top-right-radius:var(--ag-charts-border-radius)}}.ag-charts-toolbar--vertical{flex-direction:column;.ag-charts-toolbar__button{margin:-1px 0 0;max-width:100%}.ag-charts-toolbar__button--first{border-top-left-radius:var(--ag-charts-border-radius);border-top-right-radius:var(--ag-charts-border-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-left-radius:var(--ag-charts-border-radius);border-bottom-right-radius:var(--ag-charts-border-radius)}}.ag-charts-toolbar__icon+.ag-charts-toolbar__label{margin-left:var(--toolbar-gap)}.ag-charts-toolbar__icon,.ag-charts-toolbar__label{pointer-events:none}.ag-charts-floating-toolbar{border:none;display:flex;.ag-charts-toolbar{align-items:unset;position:unset}}.ag-charts-floating-toolbar__drag-handle{align-items:center;background:var(--ag-charts-chrome-background-color);border:var(--ag-charts-border);border-bottom-left-radius:var(--ag-charts-border-radius);border-top-left-radius:var(--ag-charts-border-radius);cursor:grab;display:flex;justify-content:center;min-width:24px;padding-left:0;padding-right:0}.ag-charts-floating-toolbar__drag-handle--dragging{cursor:grabbing}\n';
;
var BaseManager = class {
    destroy() {
        this.cleanup.flush();
        this.destroyed = true;
    }
    constructor(){
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.destroyed = false;
    }
};
;
var GuardedElement = class _GuardedElement {
    set tabIndex(index) {
        this.guardTabIndex = index;
        if (this.guardTabIndex === 0) {
            this.setGuardIndices(void 0);
        } else if (!this.hasFocus) {
            this.setGuardIndices(this.guardTabIndex);
        }
    }
    destroy() {
        this.cleanup.flush();
    }
    initTabGuard(guard, reverse) {
        this.cleanup.register((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(guard, "focus", ()=>this.onTab(guard, reverse)));
    }
    setGuardIndices(index) {
        const tabindex = index;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.topTabGuard, "tabindex", tabindex);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.bottomTabGuard, "tabindex", tabindex);
    }
    onFocus() {
        this.hasFocus = true;
        if (this.guardTabIndex !== 0) {
            this.setGuardIndices(0);
        }
    }
    onBlur(param) {
        let { relatedTarget } = param;
        const { topTabGuard: top, bottomTabGuard: bot } = this;
        this.hasFocus = false;
        if (this.guardTabIndex !== 0 && relatedTarget !== top && relatedTarget !== bot) {
            this.setGuardIndices(this.guardTabIndex);
        }
    }
    onTab(guard, reverse) {
        if (this.guardTabIndex !== 0) {
            let focusTarget;
            if (guard.tabIndex === 0) {
                focusTarget = this.findExitTarget(!reverse);
                this.setGuardIndices(this.guardTabIndex);
            } else {
                focusTarget = this.findEnterTarget(reverse);
            }
            focusTarget === null || focusTarget === void 0 ? void 0 : focusTarget.focus();
        }
    }
    static queryFocusable(element2, selectors) {
        const myWindow = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])();
        return Array.from(element2.querySelectorAll(selectors)).filter((e)=>{
            if (e instanceof HTMLElement) {
                const style = myWindow.getComputedStyle(e);
                return style.display !== "none" && style.visibility !== "none";
            }
            return false;
        });
    }
    findEnterTarget(reverse) {
        const focusables = _GuardedElement.queryFocusable(this.element, '[tabindex="0"]');
        const index = reverse ? focusables.length - 1 : 0;
        return focusables[index];
    }
    findExitTarget(reverse) {
        const focusables = _GuardedElement.queryFocusable((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])(), "[tabindex]").filter((e)=>e.tabIndex > 0).sort((a, b)=>a.tabIndex - b.tabIndex);
        const { before, after } = _GuardedElement.findBeforeAndAfter(focusables, this.guardTabIndex);
        return reverse ? before : after;
    }
    static findBeforeAndAfter(elements, targetTabIndex) {
        let left = 0;
        let right = elements.length - 1;
        let before = void 0;
        let after = void 0;
        while(left <= right){
            const mid = Math.floor((left + right) / 2);
            const currentTabIndex = elements[mid].tabIndex;
            if (currentTabIndex === targetTabIndex) {
                before = elements[mid - 1] || void 0;
                after = elements[mid + 1] || void 0;
                break;
            } else if (currentTabIndex < targetTabIndex) {
                before = elements[mid];
                left = mid + 1;
            } else {
                after = elements[mid];
                right = mid - 1;
            }
        }
        return {
            before,
            after
        };
    }
    constructor(element2, topTabGuard, bottomTabGuard){
        this.element = element2;
        this.topTabGuard = topTabGuard;
        this.bottomTabGuard = bottomTabGuard;
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.guardTabIndex = 0;
        this.hasFocus = false;
        this.initTabGuard(this.topTabGuard, false);
        this.initTabGuard(this.bottomTabGuard, true);
        this.element.addEventListener("focus", ()=>this.onFocus(), {
            capture: true
        });
        this.element.addEventListener("blur", (ev)=>this.onBlur(ev), {
            capture: true
        });
    }
};
;
function addEscapeEventListener(elem, onEscape) {
    let keyCodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [
        "Escape"
    ];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(elem, "keydown", (event)=>{
        if (matchesKey(event, ...keyCodes)) {
            onEscape(event);
        }
    });
}
function addMouseCloseListener(menu, hideCallback) {
    const removeEvent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(), "mousedown", (event)=>{
        if ([
            0,
            2
        ].includes(event.button) && !containsEvent(menu, event)) {
            hideCallback();
            removeEvent();
        }
    });
    return removeEvent;
}
function addTouchCloseListener(menu, hideCallback) {
    const removeEvent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(), "touchstart", (event)=>{
        const touches = Array.from(event.targetTouches);
        if (touches.some((touch)=>!containsEvent(menu, touch))) {
            hideCallback();
            removeEvent();
        }
    });
    return removeEvent;
}
function containsEvent(container, event) {
    if (event.target instanceof Element && event.target.shadowRoot != null) {
        return true;
    }
    return event.target instanceof Node && container.contains(event.target);
}
function addOverrideFocusVisibleEventListener(menu, buttons, overrideFocusVisible) {
    const setFocusVisible = (value)=>{
        for (const btn of buttons){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(btn, "data-focus-visible-override", value);
        }
    };
    setFocusVisible(overrideFocusVisible);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(menu, "keydown", ()=>setFocusVisible(true), {
        once: true
    });
}
function hasNoModifiers(event) {
    return !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey);
}
function matchesKey(event) {
    for(var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        keys[_key - 1] = arguments[_key];
    }
    return hasNoModifiers(event) && keys.some((key)=>event.key === key);
}
function linkTwoButtons(src, dst, key) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(src, "keydown", (event)=>{
        if (matchesKey(event, key)) {
            dst.focus();
        }
    });
}
var PREV_NEXT_KEYS = {
    horizontal: {
        nextKey: "ArrowRight",
        prevKey: "ArrowLeft"
    },
    vertical: {
        nextKey: "ArrowDown",
        prevKey: "ArrowUp"
    }
};
function initRovingTabIndex(opts) {
    const { orientation, buttons, wrapAround = false, onEscape, onFocus, onBlur } = opts;
    const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];
    const setTabIndices = (event)=>{
        if (event.target && "tabIndex" in event.target) {
            buttons.forEach((b)=>b.tabIndex = -1);
            event.target.tabIndex = 0;
        }
    };
    const [c, m] = wrapAround ? [
        buttons.length,
        buttons.length
    ] : [
        0,
        Infinity
    ];
    const cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
    for(let i = 0; i < buttons.length; i++){
        const prev = buttons[(c + i - 1) % m];
        const curr = buttons[i];
        const next = buttons[(c + i + 1) % m];
        cleanup.register((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(curr, "focus", setTabIndices), onFocus && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(curr, "focus", onFocus), onBlur && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(curr, "blur", onBlur), onEscape && addEscapeEventListener(curr, onEscape), prev && linkTwoButtons(curr, prev, prevKey), next && linkTwoButtons(curr, next, nextKey), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(curr, "keydown", (event)=>{
            if (matchesKey(event, nextKey, prevKey)) {
                event.preventDefault();
            }
        }));
        curr.tabIndex = i === 0 ? 0 : -1;
    }
    return cleanup;
}
var MenuCloserImp = class {
    close(mousedown) {
        this.cleanup.flush();
        this.closeCallback();
        this.finishClosing(mousedown);
    }
    finishClosing(mousedown) {
        this.cleanup.flush();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.lastFocus, "aria-expanded", false);
        if (!mousedown) {
            var _this_lastFocus;
            (_this_lastFocus = this.lastFocus) === null || _this_lastFocus === void 0 ? void 0 : _this_lastFocus.focus({
                preventScroll: true
            });
        }
        this.lastFocus = void 0;
    }
    constructor(menu, lastFocus, closeCallback){
        this.lastFocus = lastFocus;
        this.closeCallback = closeCallback;
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.cleanup.register(addMouseCloseListener(menu, ()=>this.close(true)), addTouchCloseListener(menu, ()=>this.close(true)));
    }
};
function initMenuKeyNav(opts) {
    var _buttons_;
    const { sourceEvent, orientation, menu, buttons, closeCallback, overrideFocusVisible } = opts;
    const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];
    const lastFocus = getLastFocus(sourceEvent);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(lastFocus, "aria-expanded", true);
    const menuCloser = new MenuCloserImp(menu, lastFocus, closeCallback);
    const onEscape = ()=>menuCloser.close();
    const { cleanup } = menuCloser;
    menu.role = "menu";
    menu.ariaOrientation = orientation;
    cleanup.merge(initRovingTabIndex({
        orientation,
        buttons,
        onEscape,
        wrapAround: true
    }));
    menu.tabIndex = -1;
    cleanup.register(addEscapeEventListener(menu, onEscape), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(menu, "keydown", (ev)=>{
        if (ev.target === menu && (ev.key === nextKey || ev.key === prevKey)) {
            var _buttons_;
            ev.preventDefault();
            (_buttons_ = buttons[0]) === null || _buttons_ === void 0 ? void 0 : _buttons_.focus();
        }
    }));
    (_buttons_ = buttons[0]) === null || _buttons_ === void 0 ? void 0 : _buttons_.focus({
        preventScroll: true
    });
    if (overrideFocusVisible !== void 0) {
        cleanup.register(addOverrideFocusVisibleEventListener(menu, buttons, overrideFocusVisible));
    }
    return menuCloser;
}
function makeAccessibleClickListener(element2, onclick) {
    return (event)=>{
        if (element2.ariaDisabled === "true") {
            return event.preventDefault();
        }
        onclick(event);
    };
}
function isButtonClickEvent(event) {
    if ("button" in event) {
        return event.button === 0;
    }
    return hasNoModifiers(event) && (event.code === "Space" || event.key === "Enter");
}
function getLastFocus(sourceEvent) {
    if ((sourceEvent === null || sourceEvent === void 0 ? void 0 : sourceEvent.target) instanceof HTMLElement && "tabindex" in sourceEvent.target.attributes) {
        return sourceEvent.target;
    }
    return void 0;
}
function stopPageScrolling(element2) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(element2, "keydown", (event)=>{
        if (event.defaultPrevented) return;
        const shouldPrevent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttribute"])(event.target, "data-preventdefault", true);
        if (shouldPrevent && matchesKey(event, "ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp")) {
            event.preventDefault();
        }
    });
}
;
;
var PixelRatioObserver = class {
    get pixelRatio() {
        return this.devicePixelRatio;
    }
    observe() {
        this.registerDevicePixelRatioListener();
    }
    disconnect() {
        this.unregisterDevicePixelRatioListener();
    }
    unregisterDevicePixelRatioListener() {
        var _this_devicePixelRatioMediaQuery;
        (_this_devicePixelRatioMediaQuery = this.devicePixelRatioMediaQuery) === null || _this_devicePixelRatioMediaQuery === void 0 ? void 0 : _this_devicePixelRatioMediaQuery.removeEventListener("change", this.devicePixelRatioListener);
        this.devicePixelRatioMediaQuery = void 0;
    }
    registerDevicePixelRatioListener() {
        var _getWindow10;
        const devicePixelRatioMediaQuery = (_getWindow10 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])("matchMedia")) === null || _getWindow10 === void 0 ? void 0 : _getWindow10("(resolution: ".concat(this.pixelRatio, "dppx)"));
        devicePixelRatioMediaQuery === null || devicePixelRatioMediaQuery === void 0 ? void 0 : devicePixelRatioMediaQuery.addEventListener("change", this.devicePixelRatioListener);
        this.devicePixelRatioMediaQuery = devicePixelRatioMediaQuery;
    }
    constructor(callback8){
        this.callback = callback8;
        var _getWindow10;
        this.devicePixelRatio = (_getWindow10 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])("devicePixelRatio")) !== null && _getWindow10 !== void 0 ? _getWindow10 : 1;
        this.devicePixelRatioMediaQuery = void 0;
        this.devicePixelRatioListener = (e)=>{
            if (e.matches) return;
            var _getWindow10;
            this.devicePixelRatio = (_getWindow10 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])("devicePixelRatio")) !== null && _getWindow10 !== void 0 ? _getWindow10 : 1;
            this.unregisterDevicePixelRatioListener();
            this.registerDevicePixelRatioListener();
            this.callback(this.pixelRatio);
        };
    }
};
// packages/ag-charts-community/src/util/sizeMonitor.ts
var SizeMonitor = class {
    destroy() {
        var _getWindow11, _this_resizeObserver, _this_pixelRatioObserver;
        (_getWindow11 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])()) === null || _getWindow11 === void 0 ? void 0 : _getWindow11.removeEventListener("load", this.onLoad);
        (_this_resizeObserver = this.resizeObserver) === null || _this_resizeObserver === void 0 ? void 0 : _this_resizeObserver.disconnect();
        this.resizeObserver = void 0;
        (_this_pixelRatioObserver = this.pixelRatioObserver) === null || _this_pixelRatioObserver === void 0 ? void 0 : _this_pixelRatioObserver.disconnect();
        this.pixelRatioObserver = void 0;
    }
    observeWindow() {
        var _this_pixelRatioObserver;
        (_this_pixelRatioObserver = this.pixelRatioObserver) === null || _this_pixelRatioObserver === void 0 ? void 0 : _this_pixelRatioObserver.observe();
    }
    checkPixelRatio() {
        var _this_pixelRatioObserver;
        var _this_pixelRatioObserver_pixelRatio;
        const pixelRatio = (_this_pixelRatioObserver_pixelRatio = (_this_pixelRatioObserver = this.pixelRatioObserver) === null || _this_pixelRatioObserver === void 0 ? void 0 : _this_pixelRatioObserver.pixelRatio) !== null && _this_pixelRatioObserver_pixelRatio !== void 0 ? _this_pixelRatioObserver_pixelRatio : 1;
        for (const [element2, entry] of this.elements){
            if (entry.size != null && entry.size.pixelRatio !== pixelRatio) {
                const { width: width2, height: height2 } = entry.size;
                entry.size = {
                    width: width2,
                    height: height2,
                    pixelRatio
                };
                entry.cb(entry.size, element2);
            }
        }
    }
    checkSize(entry, element2, width2, height2) {
        var _entry_size, _entry_size1;
        if (!entry) return;
        if (width2 !== ((_entry_size = entry.size) === null || _entry_size === void 0 ? void 0 : _entry_size.width) || height2 !== ((_entry_size1 = entry.size) === null || _entry_size1 === void 0 ? void 0 : _entry_size1.height)) {
            var _this_pixelRatioObserver;
            var _this_pixelRatioObserver_pixelRatio;
            const pixelRatio = (_this_pixelRatioObserver_pixelRatio = (_this_pixelRatioObserver = this.pixelRatioObserver) === null || _this_pixelRatioObserver === void 0 ? void 0 : _this_pixelRatioObserver.pixelRatio) !== null && _this_pixelRatioObserver_pixelRatio !== void 0 ? _this_pixelRatioObserver_pixelRatio : 1;
            entry.size = {
                width: width2,
                height: height2,
                pixelRatio
            };
            entry.cb(entry.size, element2);
        }
    }
    // Only a single callback is supported.
    observe(element2, cb) {
        if (!this.documentReady) {
            this.queuedObserveRequests.push([
                element2,
                cb
            ]);
            return;
        }
        if (this.elements.has(element2)) {
            this.removeFromQueue(element2);
        } else {
            var _this_resizeObserver;
            (_this_resizeObserver = this.resizeObserver) === null || _this_resizeObserver === void 0 ? void 0 : _this_resizeObserver.observe(element2);
        }
        const entry = {
            cb
        };
        this.elements.set(element2, entry);
    }
    unobserve(element2) {
        var _this_resizeObserver;
        (_this_resizeObserver = this.resizeObserver) === null || _this_resizeObserver === void 0 ? void 0 : _this_resizeObserver.unobserve(element2);
        this.elements.delete(element2);
        this.removeFromQueue(element2);
        if (!this.elements.size) {
            this.destroy();
        }
    }
    removeFromQueue(element2) {
        this.queuedObserveRequests = this.queuedObserveRequests.filter((param)=>{
            let [el] = param;
            return el !== element2;
        });
    }
    constructor(){
        this.elements = /* @__PURE__ */ new Map();
        this.documentReady = false;
        this.queuedObserveRequests = [];
        this.onLoad = ()=>{
            this.documentReady = true;
            this.queuedObserveRequests.forEach((param)=>{
                let [el, cb] = param;
                return this.observe(el, cb);
            });
            this.queuedObserveRequests = [];
            this.observeWindow();
        };
        if (typeof ResizeObserver !== "undefined") {
            this.resizeObserver = new ResizeObserver((entries8)=>{
                for (const { target, contentRect: { width: width2, height: height2 } } of entries8){
                    const entry = this.elements.get(target);
                    this.checkSize(entry, target, width2, height2);
                }
            });
        }
        let animationFrame;
        this.pixelRatioObserver = new PixelRatioObserver(()=>{
            clearTimeout(animationFrame);
            animationFrame = setTimeout(()=>this.checkPixelRatio(), 0);
        });
        this.documentReady = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])("readyState") === "complete";
        if (this.documentReady) {
            this.observeWindow();
        } else {
            var _getWindow11;
            (_getWindow11 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])()) === null || _getWindow11 === void 0 ? void 0 : _getWindow11.addEventListener("load", this.onLoad);
        }
    }
};
// packages/ag-charts-community/src/util/stateTracker.ts
var StateTracker = class extends Map {
    set(key, value) {
        this.delete(key);
        if (typeof value !== "undefined") {
            super.set(key, value);
        }
        delete this.cachedState;
        delete this.cachedValue;
        return this;
    }
    stateId() {
        var _Array_from_pop, _this_cachedState;
        (_this_cachedState = this.cachedState) !== null && _this_cachedState !== void 0 ? _this_cachedState : this.cachedState = (_Array_from_pop = Array.from(this.keys()).pop()) !== null && _Array_from_pop !== void 0 ? _Array_from_pop : this.defaultState;
        return this.cachedState;
    }
    stateValue() {
        var _Array_from_pop, _this_cachedValue;
        (_this_cachedValue = this.cachedValue) !== null && _this_cachedValue !== void 0 ? _this_cachedValue : this.cachedValue = (_Array_from_pop = Array.from(this.values()).pop()) !== null && _Array_from_pop !== void 0 ? _Array_from_pop : this.defaultValue;
        return this.cachedValue;
    }
    constructor(defaultValue, defaultState){
        super();
        this.defaultValue = defaultValue;
        this.defaultState = defaultState;
    }
};
// packages/ag-charts-community/src/dom/domLayout.html
var domLayout_default = '<div role="presentation" class="ag-charts-wrapper ag-charts-styles" data-ag-charts><div role="presentation" class="ag-charts-canvas-center"><div role="presentation" class="ag-charts-canvas-container"><div role="presentation" class="ag-charts-canvas" aria-hidden="true"></div><div role="figure" class="ag-charts-canvas-proxy"><div role="presentation" class="ag-charts-series-area"></div></div><div role="presentation" class="ag-charts-canvas-overlay ag-charts-tooltip-container"></div></div></div></div>';
// packages/ag-charts-community/src/dom/domManager.ts
var DOM_ELEMENT_CLASSES = [
    "styles",
    "canvas",
    "canvas-center",
    "canvas-container",
    "canvas-overlay",
    "canvas-proxy",
    "series-area",
    "tooltip-container"
];
var MINIMAL_DOM_ELEMENT_ROLES = /* @__PURE__ */ new Set([
    "styles",
    "canvas-container",
    "canvas",
    "tooltip-container"
]);
var CONTAINER_MODIFIERS = {
    safeHorizontal: "ag-charts-wrapper--safe-horizontal",
    safeVertical: "ag-charts-wrapper--safe-vertical"
};
var domElementConfig = /* @__PURE__ */ new Map([
    [
        "styles",
        {
            childElementType: "style"
        }
    ],
    [
        "canvas",
        {
            childElementType: "canvas"
        }
    ],
    [
        "canvas-proxy",
        {
            childElementType: "div"
        }
    ],
    [
        "canvas-overlay",
        {
            childElementType: "div"
        }
    ],
    [
        "canvas-center",
        {
            childElementType: "div"
        }
    ],
    [
        "series-area",
        {
            childElementType: "div"
        }
    ],
    [
        "tooltip-container",
        {
            childElementType: "div"
        }
    ]
]);
function setupObserver(element2, cb) {
    if (typeof IntersectionObserver === "undefined") return;
    const observer = new IntersectionObserver((observedEntries)=>{
        for (const entry of observedEntries){
            if (entry.target === element2) {
                cb(entry.intersectionRatio);
            }
        }
    }, {
        root: element2
    });
    observer.observe(element2);
    return observer;
}
var NULL_DOMRECT = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    toJSON () {
        return NULL_DOMRECT;
    }
};
function createTabGuardElement(guardedElem, where) {
    const div = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div");
    div.className = "ag-charts-tab-guard";
    guardedElem.insertAdjacentElement(where, div);
    return div;
}
var _DOMManager = class _DOMManager extends BaseManager {
    initDOM() {
        if (this.mode === "normal") {
            const templateEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div");
            templateEl.innerHTML = domLayout_default;
            return templateEl.firstChild;
        }
        const element2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div");
        element2.role = "presentation";
        element2.dataset.agCharts = "";
        element2.classList.add("ag-charts-wrapper");
        const seriesArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div");
        element2.appendChild(seriesArea);
        seriesArea.role = "presentation";
        seriesArea.classList.add("ag-charts-series-area");
        return element2;
    }
    initRootElements() {
        const { mode, element: element2 } = this;
        const rootElements = {};
        for (const domElement of DOM_ELEMENT_CLASSES){
            const className = "ag-charts-".concat(domElement);
            let el;
            if (mode === "normal") {
                el = element2.classList.contains(className) ? element2 : element2.getElementsByClassName(className)[0];
            } else if (MINIMAL_DOM_ELEMENT_ROLES.has(domElement)) {
                el = element2;
            } else {
                var _element2_getElementsByClassName_;
                el = (_element2_getElementsByClassName_ = element2.getElementsByClassName(className)[0]) !== null && _element2_getElementsByClassName_ !== void 0 ? _element2_getElementsByClassName_ : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div");
            }
            if (el == null) {
                throw new Error("AG Charts - unable to find DOM element ".concat(className));
            }
            rootElements[domElement] = {
                element: el,
                children: /* @__PURE__ */ new Map(),
                listeners: []
            };
        }
        return rootElements;
    }
    destroy() {
        var _this_observer;
        super.destroy();
        (_this_observer = this.observer) === null || _this_observer === void 0 ? void 0 : _this_observer.unobserve(this.element);
        if (this.container) {
            this.sizeMonitor.unobserve(this.container);
        }
        this.pendingContainer = void 0;
        Object.values(this.rootElements).forEach((el)=>{
            el.children.forEach((c)=>c.remove());
            el.element.remove();
        });
        this.element.remove();
    }
    postRenderUpdate() {
        if (this.mode === "minimal") return;
        if (this.pendingContainer == null || this.pendingContainer === this.container) return;
        if (_DOMManager.batchedUpdateContainer.length === 0) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])().setTimeout(this.applyBatchedUpdateContainer.bind(this), 0);
        }
        _DOMManager.batchedUpdateContainer.push(this);
    }
    applyBatchedUpdateContainer() {
        for (const manager of _DOMManager.batchedUpdateContainer){
            if (!manager.destroyed) {
                manager.updateContainer();
            }
        }
        _DOMManager.batchedUpdateContainer.splice(0);
    }
    setSizeOptions() {
        let minWidth = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 300, minHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 300, optionsWidth = arguments.length > 2 ? arguments[2] : void 0, optionsHeight = arguments.length > 3 ? arguments[3] : void 0;
        const { style } = this.element;
        style.width = "".concat(optionsWidth !== null && optionsWidth !== void 0 ? optionsWidth : minWidth, "px");
        style.height = "".concat(optionsHeight !== null && optionsHeight !== void 0 ? optionsHeight : minHeight, "px");
        this.minWidth = optionsWidth !== null && optionsWidth !== void 0 ? optionsWidth : minWidth;
        this.minHeight = optionsHeight !== null && optionsHeight !== void 0 ? optionsHeight : minHeight;
        this.updateContainerClassName();
    }
    updateContainerSize() {
        const { style: centerStyle } = this.rootElements["canvas-center"].element;
        centerStyle.visibility = this.containerSize == null ? "hidden" : "";
        if (this.containerSize) {
            var _this_containerSize_width;
            centerStyle.width = "".concat((_this_containerSize_width = this.containerSize.width) !== null && _this_containerSize_width !== void 0 ? _this_containerSize_width : 0, "px");
            var _this_containerSize_height;
            centerStyle.height = "".concat((_this_containerSize_height = this.containerSize.height) !== null && _this_containerSize_height !== void 0 ? _this_containerSize_height : 0, "px");
        } else {
            centerStyle.width = "";
            centerStyle.height = "";
        }
        this.updateContainerClassName();
    }
    setTabGuardIndex(tabIndex) {
        if (!this.tabGuards) return;
        this.tabGuards.tabIndex = tabIndex;
    }
    setContainer(newContainer) {
        if (newContainer === this.container) return;
        this.pendingContainer = newContainer;
        if (this.mode === "minimal" || this.container == null) {
            this.updateContainer();
        }
    }
    updateContainer() {
        const { pendingContainer } = this;
        if (pendingContainer == null || pendingContainer === this.container) return;
        if (this.container) {
            this.container.removeChild(this.element);
            this.sizeMonitor.unobserve(this.container);
        }
        if (this.documentRoot != null) {
            for (const id of this.rootElements["styles"].children.keys()){
                this.removeChild("styles", id);
            }
        }
        this.container = pendingContainer;
        this.pendingContainer = void 0;
        this.documentRoot = this.getShadowDocumentRoot(pendingContainer);
        this.initiallyConnected = pendingContainer.isConnected;
        for (const [id, styles] of this.styles){
            this.addStyles(id, styles);
        }
        pendingContainer.appendChild(this.element);
        this.sizeMonitor.observe(pendingContainer, (size)=>{
            this.containerSize = size;
            this.updateContainerSize();
            this.eventsHub.emit("dom:resize", null);
        });
        this.eventsHub.emit("dom:container-change", null);
    }
    setThemeClass(themeClassName) {
        const themeClassNamePrefix = "ag-charts-theme-";
        this.element.classList.forEach((className)=>{
            if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {
                this.element.classList.remove(className);
            }
        });
        this.element.classList.add(themeClassName);
    }
    setThemeParameters(params) {
        for (const [key, value] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entries"])(params)){
            let formattedValue = "".concat(value);
            if (key.endsWith("Size") || key.endsWith("Radius")) {
                formattedValue = "".concat(value, "px");
            } else if (key.endsWith("Border") && typeof value === "boolean") {
                formattedValue = value ? "var(--ag-charts-border)" : "none";
            }
            this.element.style.setProperty("--ag-charts-".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kebabCase"])(key)), formattedValue);
        }
    }
    updateCanvasLabel(ariaLabel) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.rootElements["canvas-proxy"].element, "aria-label", ariaLabel);
    }
    getEventElement(defaultElem, eventType) {
        const events = [
            "focus",
            "blur",
            "keydown",
            "keyup"
        ];
        return events.includes(eventType) ? this.rootElements["series-area"].element : defaultElem;
    }
    addEventListener(type, listener, options) {
        const element2 = this.getEventElement(this.element, type);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachListener"])(element2, type, listener, options);
    }
    removeEventListener(type, listener, options) {
        this.getEventElement(this.element, type).removeEventListener(type, listener, options);
    }
    /** Get the main chart area client bound rect. */ getBoundingClientRect() {
        return this.rootElements["canvas"].element.getBoundingClientRect();
    }
    /**
   * Get the client bounding rect for overlay elements that might float outside the bounds of the
   * main chart area.
   */ getOverlayClientRect() {
        var _windowBBox_intersection;
        const window2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])();
        const windowBBox = new BBox(0, 0, window2.innerWidth, window2.innerHeight);
        const containerBBox = this.getRawOverlayClientRect();
        var _windowBBox_intersection_toDOMRect;
        return (_windowBBox_intersection_toDOMRect = (_windowBBox_intersection = windowBBox.intersection(containerBBox)) === null || _windowBBox_intersection === void 0 ? void 0 : _windowBBox_intersection.toDOMRect()) !== null && _windowBBox_intersection_toDOMRect !== void 0 ? _windowBBox_intersection_toDOMRect : NULL_DOMRECT;
    }
    getRawOverlayClientRect() {
        var _this_element_getRootNode;
        let element2 = this.element;
        const fullScreenElement = (_this_element_getRootNode = this.element.getRootNode()) === null || _this_element_getRootNode === void 0 ? void 0 : _this_element_getRootNode.fullscreenElement;
        while(element2 != null){
            let isContainer;
            if (fullScreenElement != null && element2 === fullScreenElement) {
                isContainer = true;
            } else {
                var _element2_computedStyleMap, _styleMap_get;
                const styleMap = (_element2_computedStyleMap = element2.computedStyleMap) === null || _element2_computedStyleMap === void 0 ? void 0 : _element2_computedStyleMap.call(element2);
                const overflowY = styleMap === null || styleMap === void 0 ? void 0 : (_styleMap_get = styleMap.get("overflow-y")) === null || _styleMap_get === void 0 ? void 0 : _styleMap_get.toString();
                isContainer = overflowY === "auto" || overflowY === "scroll";
            }
            if (isContainer) {
                return BBox.fromDOMRect(element2.getBoundingClientRect());
            }
            element2 = element2.parentElement;
        }
        if (this.documentRoot != null) return BBox.fromDOMRect(this.documentRoot.getBoundingClientRect());
        const { innerWidth, innerHeight } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])();
        return new BBox(0, 0, innerWidth, innerHeight);
    }
    getShadowDocumentRoot() {
        let current = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.container;
        var _current_ownerDocument;
        var _current_ownerDocument_body;
        const docRoot = (_current_ownerDocument_body = current === null || current === void 0 ? void 0 : (_current_ownerDocument = current.ownerDocument) === null || _current_ownerDocument === void 0 ? void 0 : _current_ownerDocument.body) !== null && _current_ownerDocument_body !== void 0 ? _current_ownerDocument_body : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])("body");
        while(current != null){
            if (current === docRoot) {
                return void 0;
            }
            if (current.parentNode instanceof DocumentFragment) {
                return current;
            }
            current = current.parentNode;
        }
    }
    getParent(domElementClass) {
        return this.rootElements[domElementClass].element;
    }
    getChildBoundingClientRect(type) {
        const { children } = this.rootElements[type];
        const childRects = [];
        for (const child of children.values()){
            childRects.push(BBox.fromDOMRect(child.getBoundingClientRect()));
        }
        return BBox.merge(childRects);
    }
    isManagedChildDOMElement(el, domElementClass, id) {
        const { children } = this.rootElements[domElementClass];
        const search = children === null || children === void 0 ? void 0 : children.get(id);
        return search != null && el.contains(search);
    }
    contains(element2, domElementClass) {
        if (domElementClass == null) return this.element.contains(element2);
        return this.rootElements[domElementClass].element.contains(element2);
    }
    addStyles(id, styles) {
        const dataAttribute = "data-ag-charts";
        this.styles.set(id, styles);
        if (this.container == null) return;
        const checkId = (el)=>{
            return el.getAttribute(dataAttribute) === id;
        };
        const addStyleElement = (el)=>{
            const metaElements = /* @__PURE__ */ new Set([
                "TITLE",
                "META"
            ]);
            let skippingMetaElements = true;
            let insertAfterEl;
            for (const child of el.children){
                if (skippingMetaElements && metaElements.has(child.tagName)) {
                    insertAfterEl = child;
                    continue;
                }
                skippingMetaElements = false;
                if (checkId(child)) return;
                if (child.hasAttribute(dataAttribute)) {
                    insertAfterEl = child;
                }
            }
            const styleEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("style");
            if (this.chart.styleNonce != null) {
                styleEl.nonce = this.chart.styleNonce;
            }
            if (insertAfterEl == null) {
                el.prepend(styleEl);
            } else {
                el.insertBefore(styleEl, insertAfterEl.nextSibling);
            }
            return styleEl;
        };
        let styleElement;
        if (this.styleContainer) {
            styleElement = addStyleElement(this.styleContainer);
        } else if (this.initiallyConnected === false) {
            styleElement = this.addChild("styles", id);
        } else if (this.documentRoot == null && !_DOMManager.headStyles.has(id)) {
            styleElement = addStyleElement((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])("head"));
            _DOMManager.headStyles.add(id);
        } else if (this.documentRoot != null) {
            styleElement = this.addChild("styles", id);
        }
        if (styleElement == null || checkId(styleElement)) return;
        styleElement.setAttribute(dataAttribute, id);
        styleElement.innerHTML = styles;
    }
    removeStyles(id) {
        this.removeChild("styles", id);
    }
    updateCursor(callerId, style) {
        this.cursorState.set(callerId, style);
        this.element.style.cursor = this.cursorState.stateValue();
    }
    getCursor() {
        return this.element.style.cursor;
    }
    addChild(domElementClass, id, child, insert) {
        const { element: element2, children, listeners } = this.rootElements[domElementClass];
        if (!children) {
            throw new Error("AG Charts - unable to create DOM elements after destroy()");
        }
        if (children.has(id)) {
            return children.get(id);
        }
        var _domElementConfig_get;
        const { childElementType = "div" } = (_domElementConfig_get = domElementConfig.get(domElementClass)) !== null && _domElementConfig_get !== void 0 ? _domElementConfig_get : {};
        if (child && child.tagName.toLowerCase() !== childElementType.toLowerCase()) {
            throw new Error("AG Charts - mismatching DOM element type");
        }
        const newChild = child !== null && child !== void 0 ? child : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(childElementType);
        for (const [type, fn, opts] of listeners){
            newChild.addEventListener(type, fn, opts);
        }
        children.set(id, newChild);
        if (childElementType === "style" && this.chart.styleNonce != null) {
            newChild.nonce = this.chart.styleNonce;
        }
        if (insert) {
            const queryResult = element2.querySelector(insert.query);
            if (queryResult == null) {
                throw new Error("AG Charts - addChild query failed ".concat(insert.query));
            }
            queryResult.insertAdjacentElement(insert.where, newChild);
        } else {
            element2 === null || element2 === void 0 ? void 0 : element2.appendChild(newChild);
        }
        return newChild;
    }
    removeChild(domElementClass, id) {
        var _children_get;
        const { children } = this.rootElements[domElementClass];
        if (!children) return;
        (_children_get = children.get(id)) === null || _children_get === void 0 ? void 0 : _children_get.remove();
        children.delete(id);
    }
    incrementDataCounter(name) {
        const { dataset } = this.element;
        var _dataset_name;
        (_dataset_name = dataset[name]) !== null && _dataset_name !== void 0 ? _dataset_name : dataset[name] = "0";
        dataset[name] = String(Number(dataset[name]) + 1);
    }
    setDataBoolean(name, value) {
        this.element.dataset[name] = String(value);
    }
    updateContainerClassName() {
        const { element: element2, containerSize, minWidth, minHeight } = this;
        var _containerSize_width;
        element2.classList.toggle(CONTAINER_MODIFIERS.safeHorizontal, minWidth >= ((_containerSize_width = containerSize === null || containerSize === void 0 ? void 0 : containerSize.width) !== null && _containerSize_width !== void 0 ? _containerSize_width : Infinity));
        var _containerSize_height;
        element2.classList.toggle(CONTAINER_MODIFIERS.safeVertical, minHeight >= ((_containerSize_height = containerSize === null || containerSize === void 0 ? void 0 : containerSize.height) !== null && _containerSize_height !== void 0 ? _containerSize_height : Infinity));
    }
    constructor(eventsHub, chart, initialContainer, styleContainer, mode = "normal"){
        super();
        this.eventsHub = eventsHub;
        this.chart = chart;
        this.styleContainer = styleContainer;
        this.mode = mode;
        this.anchorName = "--".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createId"])(this));
        this.styles = /* @__PURE__ */ new Map();
        this.pendingContainer = void 0;
        this.container = void 0;
        this.documentRoot = void 0;
        this.initiallyConnected = void 0;
        this.containerSize = void 0;
        this.sizeMonitor = new SizeMonitor();
        this.cursorState = new StateTracker("default");
        this.minWidth = 0;
        this.minHeight = 0;
        this.element = this.initDOM();
        this.rootElements = this.initRootElements();
        this.rootElements["canvas"].element.style.setProperty("anchor-name", this.anchorName);
        let hidden = false;
        this.observer = setupObserver(this.element, (intersectionRatio)=>{
            if (intersectionRatio === 0 && !hidden) {
                this.eventsHub.emit("dom:hidden", null);
            }
            hidden = intersectionRatio === 0;
        });
        this.setSizeOptions();
        this.updateContainerSize();
        this.addStyles("ag-charts-community", styles_default);
        this.setContainer(initialContainer);
        this.cleanup.register(stopPageScrolling(this.element));
        if (this.mode === "normal") {
            const guardedElement = this.rootElements["canvas-center"].element;
            if (guardedElement == null) throw new Error("Error initializing tab guards");
            const topGuard = createTabGuardElement(guardedElement, "beforebegin");
            const botGuard = createTabGuardElement(guardedElement, "afterend");
            this.tabGuards = new GuardedElement(guardedElement, topGuard, botGuard);
        }
    }
};
_DOMManager.batchedUpdateContainer = [];
_DOMManager.headStyles = /* @__PURE__ */ new Set();
var DOMManager = _DOMManager;
;
;
var BoundedTextWidget = class extends Widget {
    set textContent(text) {
        var _bboxCalculator_getBBox;
        this.textElement.textContent = text;
        const bboxCalculator = this.textElement;
        const bbox = (_bboxCalculator_getBBox = bboxCalculator.getBBox) === null || _bboxCalculator_getBBox === void 0 ? void 0 : _bboxCalculator_getBBox.call(bboxCalculator);
        if (bbox) {
            this.svgElement.setAttribute("viewBox", "".concat(bbox.x, " ").concat(bbox.y, " ").concat(bbox.width, " ").concat(bbox.height));
        }
    }
    get textContent() {
        return this.textElement.textContent;
    }
    destructor() {}
    constructor(){
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div"));
        this.textElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("text");
        this.textElement.role = "presentation";
        this.svgElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("svg");
        this.svgElement.appendChild(this.textElement);
        this.svgElement.style.width = "100%";
        this.svgElement.style.opacity = "0";
        this.svgElement.role = "presentation";
        this.elem.appendChild(this.svgElement);
        this.elem.role = "presentation";
    }
};
;
;
var AbstractButtonWidget = class extends Widget {
    destructor() {}
    setEnabled(enabled) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "aria-disabled", !enabled);
    }
    addListener(type, listener) {
        return super.addListener(type, (ev, current)=>{
            if ((type === "click" || type === "dblclick") && this.isDisabled()) return;
            listener(ev, current);
        });
    }
    constructor(element2, role){
        super(element2);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "role", role);
        this.setEnabled(true);
        this.addListener("keydown", (param)=>{
            let { sourceEvent } = param;
            if (isButtonClickEvent(sourceEvent)) {
                var _this_htmlListener;
                sourceEvent.preventDefault();
                (_this_htmlListener = this.htmlListener) === null || _this_htmlListener === void 0 ? void 0 : _this_htmlListener.dispatch("click", this, {
                    type: "click",
                    device: "keyboard",
                    sourceEvent
                });
            }
        });
    }
};
// packages/ag-charts-community/src/widget/buttonWidget.ts
var ButtonWidget = class extends AbstractButtonWidget {
    constructor(){
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("button"));
    }
};
;
var GroupWidget = class extends Widget {
    destructor() {}
    constructor(){
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div"));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "role", "group");
    }
};
;
;
var RovingTabContainerWidget = class extends Widget {
    get orientation() {
        var _getAttribute3;
        return (_getAttribute3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttribute"])(this.elem, "aria-orientation")) !== null && _getAttribute3 !== void 0 ? _getAttribute3 : "both";
    }
    set orientation(orientation) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "aria-orientation", orientation !== "both" ? orientation : void 0);
    }
    focus() {
        var _this_children_this_focusedChildIndex;
        (_this_children_this_focusedChildIndex = this.children[this.focusedChildIndex]) === null || _this_children_this_focusedChildIndex === void 0 ? void 0 : _this_children_this_focusedChildIndex.focus();
    }
    clear() {
        this.focusedChildIndex = 0;
        for (const child of this.children){
            this.removeChildListeners(child);
            child.parent = void 0;
        }
        this.elem.textContent = "";
        this.children.length = 0;
    }
    addChildListeners(child) {
        child.addListener("focus", this.onChildFocus);
        child.addListener("keydown", this.onChildKeyDown);
    }
    removeChildListeners(child) {
        child.removeListener("focus", this.onChildFocus);
        child.removeListener("keydown", this.onChildKeyDown);
    }
    onChildAdded(child) {
        this.addChildListeners(child);
        child.setTabIndex(this.children.length === 1 ? 0 : -1);
    }
    onChildRemoved(removedChild) {
        this.removeChildListeners(removedChild);
        const { focusedChildIndex, children } = this;
        const removedFocusedChild = focusedChildIndex === removedChild.index;
        for(let i = 0; i < children.length; i++){
            const child = children[i];
            if (child.index === focusedChildIndex) {
                this.focusedChildIndex = i;
            }
            child.index = i;
        }
        if (removedFocusedChild) {
            var _children_focusedChildIndex;
            const newFocusChild = (_children_focusedChildIndex = children[focusedChildIndex]) !== null && _children_focusedChildIndex !== void 0 ? _children_focusedChildIndex : children[focusedChildIndex - 1];
            if (newFocusChild) {
                this.focusedChildIndex = newFocusChild.index;
                newFocusChild.setTabIndex(0);
            } else {
                this.focusedChildIndex = 0;
            }
        }
    }
    constructor(initialOrientation, role){
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div"));
        this.focusedChildIndex = 0;
        this.onChildFocus = (_event, child)=>{
            const oldFocus = this.children[this.focusedChildIndex];
            this.focusedChildIndex = child.index;
            oldFocus === null || oldFocus === void 0 ? void 0 : oldFocus.setTabIndex(-1);
            child.setTabIndex(0);
        };
        this.onChildKeyDown = (event, child)=>{
            var _this_children_targetIndex;
            const rovingOrientation = this.orientation;
            const [primaryKeys, secondaryKeys] = rovingOrientation === "both" ? [
                PREV_NEXT_KEYS["horizontal"],
                PREV_NEXT_KEYS["vertical"]
            ] : [
                PREV_NEXT_KEYS[rovingOrientation],
                void 0
            ];
            let targetIndex = -1;
            if (hasNoModifiers(event.sourceEvent)) {
                const key = event.sourceEvent.key;
                if (key === primaryKeys.nextKey || key === (secondaryKeys === null || secondaryKeys === void 0 ? void 0 : secondaryKeys.nextKey)) {
                    targetIndex = child.index + 1;
                } else if (key === primaryKeys.prevKey || key === (secondaryKeys === null || secondaryKeys === void 0 ? void 0 : secondaryKeys.prevKey)) {
                    targetIndex = child.index - 1;
                }
            }
            (_this_children_targetIndex = this.children[targetIndex]) === null || _this_children_targetIndex === void 0 ? void 0 : _this_children_targetIndex.focus();
        };
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "role", role);
        this.orientation = initialOrientation;
    }
};
// packages/ag-charts-community/src/widget/listWidget.ts
var ListWidget = class extends RovingTabContainerWidget {
    destructor() {
        this.children.forEach((c)=>c.getElement().parentElement.remove());
    }
    addChildToDOM(child, before) {
        const listItem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(listItem, "role", "listitem");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setElementStyle"])(listItem, "position", "absolute");
        Widget.setElementContainer(child, listItem);
        this.appendOrInsert(listItem, before);
        this.setHidden(false);
    }
    removeChildFromDOM(child) {
        child.getElement().parentElement.remove();
        this.setHidden(this.children.length === 0);
    }
    setHidden(hidden) {
        if (this.children.length === 0) {
            hidden = true;
        }
        super.setHidden(hidden);
    }
    constructor(){
        super("both", "list");
        this.setHidden(true);
    }
};
// packages/ag-charts-community/src/widget/nativeWidget.ts
var NativeWidget = class extends Widget {
    destructor() {}
    constructor(elem){
        super(elem);
    }
};
;
// packages/ag-charts-community/src/util/format.util.ts
var percentFormatter = new Intl.NumberFormat("en-US", {
    style: "percent"
});
function formatValue(value) {
    let maximumFractionDigits = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    if (typeof value === "number") {
        return formatNumber(value, maximumFractionDigits);
    }
    return typeof value === "string" ? value : String(value !== null && value !== void 0 ? value : "");
}
function formatPercent(value) {
    return percentFormatter.format(value);
}
var numberFormatters = /* @__PURE__ */ new Map().set(2, new Intl.NumberFormat("en-US", {
    maximumFractionDigits: 2,
    useGrouping: false
}));
function formatNumber(value, maximumFractionDigits) {
    let formatter2 = numberFormatters.get(maximumFractionDigits);
    if (!formatter2) {
        formatter2 = new Intl.NumberFormat("en-US", {
            maximumFractionDigits,
            useGrouping: false
        });
        numberFormatters.set(maximumFractionDigits, formatter2);
    }
    return formatter2.format(value);
}
// packages/ag-charts-community/src/widget/sliderWidget.ts
var _SliderWidget = class _SliderWidget extends Widget {
    get step() {
        return this._step;
    }
    set step(step) {
        this._step = step;
        this.getElement().step = step.attributeValue;
    }
    get keyboardStep() {
        var _this__keyboardStep;
        var _this__keyboardStep_step;
        return (_this__keyboardStep_step = (_this__keyboardStep = this._keyboardStep) === null || _this__keyboardStep === void 0 ? void 0 : _this__keyboardStep.step) !== null && _this__keyboardStep_step !== void 0 ? _this__keyboardStep_step : this._step;
    }
    set keyboardStep(step) {
        var _this__keyboardStep;
        if (step === ((_this__keyboardStep = this._keyboardStep) === null || _this__keyboardStep === void 0 ? void 0 : _this__keyboardStep.step)) return;
        if (this._keyboardStep !== void 0) {
            this.removeListener("keydown", this._keyboardStep.onKeyDown);
            this.removeListener("keyup", this._keyboardStep.onKeyUp);
            this.removeListener("blur", this._keyboardStep.onBlur);
            this._keyboardStep = void 0;
        }
        if (step !== void 0) {
            const onKeyDown = ()=>this.getElement().step = step.attributeValue;
            const resetStep = ()=>this.getElement().step = this._step.attributeValue;
            this._keyboardStep = {
                step,
                onKeyDown,
                onKeyUp: resetStep,
                onBlur: resetStep
            };
            this.addListener("keydown", this._keyboardStep.onKeyDown);
            this.addListener("keyup", this._keyboardStep.onKeyUp);
            this.addListener("blur", this._keyboardStep.onBlur);
        }
    }
    get orientation() {
        var _getAttribute4;
        return (_getAttribute4 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttribute"])(this.elem, "aria-orientation")) !== null && _getAttribute4 !== void 0 ? _getAttribute4 : "both";
    }
    set orientation(orientation) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "aria-orientation", orientation !== "both" ? orientation : void 0);
        _SliderWidget.registerDefaultPreventers(this, orientation);
    }
    destructor() {}
    clampValueRatio(clampMin, clampMax) {
        const ratio11 = this.getValueRatio();
        const clampedRatio = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(clampMin, ratio11, clampMax);
        if (clampedRatio !== ratio11) {
            this.setValueRatio(clampedRatio);
        }
        return clampedRatio;
    }
    setValueRatio(ratio11, opts) {
        const { divider } = this.step;
        const value = Math.round(ratio11 * 1e4) / divider;
        const { ariaValueText = formatPercent(value / divider) } = opts !== null && opts !== void 0 ? opts : {};
        const elem = this.getElement();
        elem.value = "".concat(value);
        elem.ariaValueText = ariaValueText;
    }
    getValueRatio() {
        return this.getElement().valueAsNumber / this.step.divider;
    }
    static registerDefaultPreventers(target, orientation) {
        if (orientation === "both") {
            target.removeListener("keydown", _SliderWidget.onKeyDown);
        } else {
            target.addListener("keydown", _SliderWidget.onKeyDown);
        }
    }
    static onKeyDown(ev, current) {
        let ignoredKeys = [];
        const { orientation } = current;
        if (orientation === "horizontal") {
            ignoredKeys = [
                "ArrowUp",
                "ArrowDown"
            ];
        } else if (orientation === "vertical") {
            ignoredKeys = [
                "ArrowLeft",
                "ArrowRight"
            ];
        }
        if (ignoredKeys.includes(ev.sourceEvent.code)) {
            ev.sourceEvent.preventDefault();
        }
    }
    constructor(){
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("input"));
        this._step = _SliderWidget.STEP_ONE;
        this.orientation = "both";
    }
};
_SliderWidget.STEP_ONE = {
    attributeValue: "1",
    divider: 1
};
_SliderWidget.STEP_HUNDRETH = {
    attributeValue: "0.01",
    divider: 100
};
var SliderWidget = _SliderWidget;
;
var SwitchWidget = class extends ButtonWidget {
    setChecked(checked) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "aria-checked", checked);
    }
    constructor(){
        super();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "role", "switch");
        this.setChecked(false);
    }
};
// packages/ag-charts-community/src/widget/toolbarWidget.ts
var ToolbarWidget = class extends RovingTabContainerWidget {
    destructor() {}
    constructor(orientation = "horizontal"){
        super(orientation, "toolbar");
    }
};
// packages/ag-charts-community/src/dom/proxyInteractionService.ts
function checkType(type, meta) {
    var _meta_params;
    return ((_meta_params = meta.params) === null || _meta_params === void 0 ? void 0 : _meta_params.type) === type;
}
function allocateResult(type) {
    if ("button" === type) {
        return new ButtonWidget();
    } else if ("slider" === type) {
        return new SliderWidget();
    } else if ("toolbar" === type) {
        return new ToolbarWidget();
    } else if ("group" === type) {
        return new GroupWidget();
    } else if ("list" === type) {
        return new ListWidget();
    } else if ("region" === type) {
        return new NativeWidget((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div"));
    } else if ("text" === type) {
        return new BoundedTextWidget();
    } else if ("listswitch" === type) {
        return new SwitchWidget();
    } else {
        throw Error("AG Charts - error allocating meta");
    }
}
function allocateMeta(params) {
    const meta = {
        params,
        result: void 0
    };
    meta.result = allocateResult(meta.params.type);
    return meta;
}
var ProxyInteractionService = class {
    destroy() {
        this.cleanup.flush();
    }
    addLocalisation(fn) {
        fn();
        this.cleanup.register(this.eventsHub.on("locale:change", fn));
    }
    createProxyContainer(args) {
        const meta = allocateMeta(args);
        const { params, result } = meta;
        const div = result.getElement();
        this.domManager.addChild("canvas-proxy", params.domManagerId, div);
        div.classList.add(...params.classList, "ag-charts-proxy-container");
        div.role = params.type;
        if (checkType("toolbar", meta)) {
            meta.result.orientation = meta.params.orientation;
        }
        this.addLocalisation(()=>{
            div.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);
        });
        return result;
    }
    createProxyElement(args) {
        const meta = allocateMeta(args);
        if (checkType("button", meta)) {
            const { params, result } = meta;
            const button = result.getElement();
            this.initInteract(params, result);
            if (typeof params.textContent === "string") {
                button.textContent = params.textContent;
            } else {
                const { textContent } = params;
                this.addLocalisation(()=>{
                    button.textContent = this.localeManager.t(textContent.id, textContent.params);
                });
            }
            this.setParent(meta.params, meta.result);
        }
        if (checkType("slider", meta)) {
            const { params, result } = meta;
            const slider = result.getElement();
            this.initInteract(params, result);
            slider.type = "range";
            slider.role = "presentation";
            slider.style.margin = "0px";
            this.addLocalisation(()=>{
                slider.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);
            });
            this.setParent(meta.params, meta.result);
        }
        if (checkType("text", meta)) {
            const { params, result } = meta;
            this.initElement(params, result);
            this.setParent(meta.params, meta.result);
        }
        if (checkType("listswitch", meta)) {
            const { params, result: button } = meta;
            this.initInteract(params, button);
            button.setTextContent(params.textContent);
            button.setChecked(params.ariaChecked);
            button.setAriaDescribedBy(params.ariaDescribedBy);
            this.setParent(meta.params, meta.result);
        }
        if (checkType("region", meta)) {
            const { params, result } = meta;
            const region = result.getElement();
            this.initInteract(params, result);
            region.role = "region";
            this.setParent(meta.params, meta.result);
        }
        return meta.result;
    }
    initElement(params, widget) {
        const element2 = widget.getElement();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setElementStyle"])(element2, "cursor", params.cursor);
        element2.classList.toggle("ag-charts-proxy-elem", true);
        return element2;
    }
    initInteract(params, widget) {
        const { tabIndex, domIndex } = params;
        const element2 = this.initElement(params, widget);
        if (tabIndex !== void 0) {
            element2.tabIndex = tabIndex;
        }
        if (domIndex !== void 0) {
            widget.domIndex = domIndex;
        }
    }
    setParent(params, element2) {
        if ("parent" in params) {
            var _params_parent;
            (_params_parent = params.parent) === null || _params_parent === void 0 ? void 0 : _params_parent.addChild(element2);
        } else {
            const insert = {
                where: params.where,
                query: ".ag-charts-series-area"
            };
            this.domManager.addChild("canvas-proxy", params.domManagerId, element2.getElement(), insert);
            element2.destroyListener = ()=>{
                this.domManager.removeChild("canvas-proxy", params.domManagerId);
            };
        }
    }
    constructor(eventsHub, localeManager, domManager){
        this.eventsHub = eventsHub;
        this.localeManager = localeManager;
        this.domManager = domManager;
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
    }
};
// packages/ag-charts-locale/src/en-US.ts
var AG_CHARTS_LOCALE_EN_US = {
    // Initial screen reader alt-text of the series area
    ariaInitSeriesArea: "interactive chart",
    // Screen reader announcement when focusing an item in the chart
    ariaAnnounceHoverDatum: "${datum}",
    // Screen reader announcement when focusing a chart
    ariaAnnounceChart: "chart, ${seriesCount}[number] series",
    // Screen reader announcement when focusing a standalone chart (gauges, pyramid)
    ariaAnnounceStandaloneChart: "chart, ${caption}",
    // Screen reader announcement when focusing a hierarchy chart
    ariaAnnounceHierarchyChart: "hierarchy chart, ${caption}",
    // Screen reader announcement when focusing a gauge chart
    ariaAnnounceGaugeChart: "gauge chart, ${caption}",
    // Screen reader announcement when focusing an item in a treemap or sunburst chart
    ariaAnnounceHierarchyDatum: "level ${level}[number], ${count}[number] children, ${description}",
    // Screen reader announcement when focusing a link in a Sankey or chord chart
    ariaAnnounceFlowProportionLink: "link ${index} of ${count}, from ${from} to ${to}, ${sizeName} ${size}",
    // Screen reader announcement when focusing a node in a Sankey or chord chart
    ariaAnnounceFlowProportionNode: "node ${index} of ${count}, ${description}",
    // Screen reader description for legend items
    ariaDescriptionLegendItem: "Press Space or Enter to toggle visibility",
    // Screen reader for the '+' horizontal line button on the Y-axis
    ariaLabelAddHorizontalLine: "Add Horizontal Line",
    // Screen reader text for annotations toolbar
    ariaLabelAnnotationsToolbar: "Annotations",
    // Screen reader text for annotation-options toolbar
    ariaLabelAnnotationOptionsToolbar: "Annotation Options",
    // Screen reader text for annotation-settings dialog
    ariaLabelAnnotationSettingsDialog: "Annotation Settings",
    // Screen reader text for the color-code label in the picker dialog
    ariaLabelColor: "Color",
    // Screen reader text for the color picker dialog
    ariaLabelColorPicker: "Color picker",
    // Screen reader text for the alpha-channel slider label
    ariaLabelColorPickerAlpha: "Transparency",
    // Screen reader text for the hue slider label
    ariaLabelColorPickerHue: "Hue",
    // Screen reader text for when the color-code is multi-colored
    ariaLabelColorPickerMultiColor: "Multi Color",
    // Screen reader text for the 2D palette slider label
    ariaLabelColorPickerPalette: "Palette",
    // Screen reader text for the financial charts toolbar
    ariaLabelFinancialCharts: "Financial Charts",
    // Screen reader text for the legend toolbar
    ariaLabelLegend: "Legend",
    // Screen reader text for the legend pagination button
    ariaLabelLegendPagination: "Legend Pagination",
    // Screen reader text for the previous legend page button
    ariaLabelLegendPagePrevious: "Previous Legend Page",
    // Screen reader text for the next legend page button
    ariaLabelLegendPageNext: "Next Legend Page",
    // Screen reader text for the an item in the legend
    ariaLabelLegendItem: "${label}, Legend item ${index}[number] of ${count}[number]",
    // Screen reader text for the an unknown item in the legend
    ariaLabelLegendItemUnknown: "Unknown legend item",
    // Screen reader text for the navigator element
    ariaLabelNavigator: "Navigator",
    // Screen reader text for an accessibility control that changes the position of the navigator's range
    ariaLabelNavigatorRange: "Range",
    // Screen reader text for an accessibility control that changes the start of the navigator's range
    ariaLabelNavigatorMinimum: "Minimum",
    // Screen reader text for an accessibility control that changes the end of the navigator's range
    ariaLabelNavigatorMaximum: "Maximum",
    // Screen reader text for ranges toolbar
    ariaLabelRangesToolbar: "Ranges",
    // Screen reader text for the settings dialog tab-bar
    ariaLabelSettingsTabBar: "Settings",
    // Screen reader text for zoom toolbar
    ariaLabelZoomToolbar: "Zoom",
    // Aria role description for a 2D role="slider"
    ariaRoleDescription2DSlider: "2D slider",
    // Screen reader text for color picker's 2D slider palette
    ariaValueColorPalette: "s ${s}[percent0to2dp], v ${v}[percent0to2dp]",
    // Screen reader text for color picker's 2D slider palette (when arrowing up or down)
    ariaValueColorPaletteFirstV: "v ${v}[percent0to2dp], s ${s}[percent0to2dp]",
    // Screen reader text for the value of the navigator's range
    ariaValuePanRange: "${min}[percent0to2dp] to ${max}[percent0to2dp]",
    // Alt-text for the solid line dash style menu item icon
    iconAltTextLineStyleSolid: "Solid",
    // Alt-text for the long-dashed line dash style menu item icon
    iconAltTextLineStyleDashed: "Long-dashed",
    // Alt-text for the short-dashed line dash style menu item icon
    iconAltTextLineStyleDotted: "Short-dashed",
    // Alt-text for the 'position-top' icon
    iconAltTextPositionTop: "Top",
    // Alt-text for the 'position-center' icon
    iconAltTextPositionCenter: "Center",
    // Alt-text for the 'position-bottom' icon
    iconAltTextPositionBottom: "Bottom",
    // Alt-text for the 'position-left' icon
    iconAltTextAlignLeft: "Left",
    // Alt-text for the 'align-center' icon
    iconAltTextAlignCenter: "Center",
    // Alt-text for the 'position-right' icon
    iconAltTextAlignRight: "Right",
    // Alt-text for the 'close' icon
    iconAltTextClose: "Close",
    // Default text for the 'loading data' overlay
    overlayLoadingData: "Loading data...",
    // Default text for the 'no data' overlay
    overlayNoData: "No data to display",
    // Default text for the 'no visible series' overlay
    overlayNoVisibleSeries: "No visible series",
    // Default text for the 'unsupported browser' overlay
    overlayUnsupportedBrowser: "Incompatible browser version. Please upgrade your browser.",
    // Text for frequency label in Histogram Series tooltip
    seriesHistogramTooltipFrequency: "Frequency",
    // Text for sum label in Histogram Series tooltip
    seriesHistogramTooltipSum: "${yName} (sum)",
    // Text for sum label in Histogram Series tooltip
    seriesHistogramTooltipCount: "${yName} (count)",
    // Text for sum label in Histogram Series tooltip
    seriesHistogramTooltipMean: "${yName} (mean)",
    // Text for the series type toolbar's chart type button
    toolbarSeriesTypeDropdown: "Chart Type",
    // Text for the series type toolbar's OHLC chart type button
    toolbarSeriesTypeOHLC: "OHLC",
    // Text for the series type toolbar's HLC chart type button
    toolbarSeriesTypeHLC: "HLC",
    // Text for the series type toolbar's high low chart type button
    toolbarSeriesTypeHighLow: "High Low",
    // Text for the series type toolbar's candles chart type button
    toolbarSeriesTypeCandles: "Candles",
    // Text for the series type toolbar's hollow candles chart type button
    toolbarSeriesTypeHollowCandles: "Hollow Candles",
    // Text for the series type toolbar's line chart type button
    toolbarSeriesTypeLine: "Line",
    // Text for the series type toolbar's line with markers chart type button
    toolbarSeriesTypeLineWithMarkers: "Line with Markers",
    // Text for the series type toolbar's line with step line chart type button
    toolbarSeriesTypeStepLine: "Step Line",
    // Text for the annotation toolbar's trend line button
    toolbarAnnotationsTrendLine: "Trend Line",
    // Text for the annotation toolbar's Fibonacci Retracement button
    toolbarAnnotationsFibonacciRetracement: "Fib Retracement",
    // Text for the annotation toolbar's Fibonacci Retracement Trend Based button
    toolbarAnnotationsFibonacciRetracementTrendBased: "Fib Trend Based",
    // Text for the annotation toolbar's horizontal line button
    toolbarAnnotationsHorizontalLine: "Horizontal Line",
    // Text for the annotation toolbar's vertical line button
    toolbarAnnotationsVerticalLine: "Vertical Line",
    // Text for the annotation toolbar's parallel channel button
    toolbarAnnotationsParallelChannel: "Parallel Channel",
    // Text for the annotation toolbar's disjoint channel button
    toolbarAnnotationsDisjointChannel: "Disjoint Channel",
    // Text for the annotation toolbar's clear all button
    toolbarAnnotationsClearAll: "Clear All",
    // Text for the annotation toolbar's fill color picker annotation button
    toolbarAnnotationsFillColor: "Fill Color",
    // Text for the annotation toolbar's line color picker annotation button
    toolbarAnnotationsLineColor: "Line Color",
    // Text for the annotation toolbar's line style type button
    toolbarAnnotationsLineStyle: "Line Style",
    // Text for the annotation toolbar's line stroke width button
    toolbarAnnotationsLineStrokeWidth: "Line Stroke Width",
    // Text for the annotation toolbar's settings annotation button
    toolbarAnnotationsSettings: "Settings",
    // Text for the annotation toolbar's text color picker annotation button
    toolbarAnnotationsTextColor: "Text Color",
    // Text for the annotation toolbar's text size picker annotation button
    toolbarAnnotationsTextSize: "Text Size",
    // Text for the annotation toolbar's lock annotation button
    toolbarAnnotationsLock: "Lock",
    // Text for the annotation toolbar's unlock annotation button
    toolbarAnnotationsUnlock: "Unlock",
    // Text for the annotation toolbar's delete annotation button
    toolbarAnnotationsDelete: "Delete",
    // Text for the annotation toolbar's drag handle
    toolbarAnnotationsDragHandle: "Drag Toolbar",
    // Text for the annotation toolbar's line drawings menu button
    toolbarAnnotationsLineAnnotations: "Trend Lines",
    // Text for the annotation toolbar's Fibonacci drawings menu button
    toolbarAnnotationsFibonacciAnnotations: "Fibonacci",
    // Text for the annotation toolbar's text annotations menu button
    toolbarAnnotationsTextAnnotations: "Text Annotations",
    // Text for the annotation toolbar's shapes menu button
    toolbarAnnotationsShapeAnnotations: "Arrows",
    // Text for the annotation toolbar's measurers menu button
    toolbarAnnotationsMeasurerAnnotations: "Measurers",
    // Text for the annotation toolbar's callout button
    toolbarAnnotationsCallout: "Callout",
    // Text for the annotation toolbar's comment button
    toolbarAnnotationsComment: "Comment",
    // Text for the annotation toolbar's note button
    toolbarAnnotationsNote: "Note",
    // Text for the annotation toolbar's text button
    toolbarAnnotationsText: "Text",
    // Text for the annotation toolbar's arrow button
    toolbarAnnotationsArrow: "Arrow",
    // Text for the annotation toolbar's arrow up button
    toolbarAnnotationsArrowUp: "Arrow Up",
    // Text for the annotation toolbar's arrow down button
    toolbarAnnotationsArrowDown: "Arrow Down",
    // Text for the annotation toolbar's date range button
    toolbarAnnotationsDateRange: "Date Range",
    // Text for the annotation toolbar's price range button
    toolbarAnnotationsPriceRange: "Price Range",
    // Text for the annotation toolbar's date and price range button
    toolbarAnnotationsDatePriceRange: "Date and Price",
    // Text for the annotation toolbar's quick date and price range button
    toolbarAnnotationsQuickDatePriceRange: "Measure",
    // Text for the range toolbar's 1 month button
    toolbarRange1Month: "1M",
    // Aria label for the range toolbar's 1 month button
    toolbarRange1MonthAria: "1 month",
    // Text for the range toolbar's 3 month button
    toolbarRange3Months: "3M",
    // Aria label for the range toolbar's 3 month button
    toolbarRange3MonthsAria: "3 months",
    // Text for the range toolbar's 6 month button
    toolbarRange6Months: "6M",
    // Aria label for the range toolbar's 6 month button
    toolbarRange6MonthsAria: "6 months",
    // Text for the range toolbar's year to date button
    toolbarRangeYearToDate: "YTD",
    // Aria label for the range toolbar's year to date month button
    toolbarRangeYearToDateAria: "Year to date",
    // Text for the range toolbar's 1 year button
    toolbarRange1Year: "1Y",
    // Aria label for the range toolbar's 1 year button
    toolbarRange1YearAria: "1 year",
    // Text for the range toolbar's full range button
    toolbarRangeAll: "All",
    // Aria label for the range toolbar's full range button
    toolbarRangeAllAria: "All",
    // Text for the zoom toolbar's zoom out button
    toolbarZoomZoomOut: "Zoom out",
    // Text for the zoom toolbar's zoom in button
    toolbarZoomZoomIn: "Zoom in",
    // Text for the zoom toolbar's pan left button
    toolbarZoomPanLeft: "Pan left",
    // Text for the zoom toolbar's pan right button
    toolbarZoomPanRight: "Pan right",
    // Text for the zoom toolbar's pan to the start button
    toolbarZoomPanStart: "Pan to the start",
    // Text for the zoom toolbar's pan to the end button
    toolbarZoomPanEnd: "Pan to the end",
    // Text for the zoom toolbar's pan reset button
    toolbarZoomReset: "Reset the zoom",
    // Text for the context menu's download button
    contextMenuDownload: "Download",
    // Text for the context menu's toggle series visibility button
    contextMenuToggleSeriesVisibility: "Toggle Visibility",
    // Text for the context menu's toggle other series visibility button
    contextMenuToggleOtherSeries: "Toggle Other Series",
    // Text for the context menu's zoom to point button
    contextMenuZoomToCursor: "Zoom to here",
    // Text for the context menu's pan to point button
    contextMenuPanToCursor: "Pan to here",
    // Text for the context menu's reset zoom button
    contextMenuResetZoom: "Reset zoom",
    // Text for the annotation dialog's header channel tab label
    dialogHeaderChannel: "Channel",
    // Text for the annotation dialog's header line tab label
    dialogHeaderLine: "Line",
    // Text for the annotation dialog's header fibonacci retracement line tab label
    dialogHeaderFibonacciRange: "Fib Retracement",
    // Text for the annotation dialog's header date range tab label
    dialogHeaderDateRange: "Date Range",
    // Text for the annotation dialog's header price range tab label
    dialogHeaderPriceRange: "Price Range",
    // Text for the annotation dialog's header date and price range tab label
    dialogHeaderDatePriceRange: "Date and Price",
    // Text for the annotation dialog's header text tab label
    dialogHeaderText: "Text",
    // Text for the annotation dialog's text alignment radio label
    dialogInputAlign: "Align",
    // Text for the annotation dialog's color picker label
    dialogInputColorPicker: "Color",
    // Text for the annotation dialog's color picker alt text
    dialogInputColorPickerAltText: "Text Color",
    // Text for the annotation dialog's fill color picker label
    dialogInputFillColorPicker: "Fill",
    // Text for the annotation dialog's fill color picker alt text
    dialogInputFillColorPickerAltText: "Fill Color",
    // Text for the annotation dialog's extend channel start checkbox
    dialogInputExtendChannelStart: "Extend channel start",
    // Text for the annotation dialog's extend channel end checkbox
    dialogInputExtendChannelEnd: "Extend channel end",
    // Text for the annotation dialog's extend line start checkbox
    dialogInputExtendLineStart: "Extend line start",
    // Text for the annotation dialog's extend line end checkbox
    dialogInputExtendLineEnd: "Extend line end",
    // Text for the annotation dialog's extend above checkbox
    dialogInputExtendAbove: "Extend above",
    // Text for the annotation dialog's extend below checkbox
    dialogInputExtendBelow: "Extend below",
    // Text for the annotation dialog's extend left checkbox
    dialogInputExtendLeft: "Extend left",
    // Text for the annotation dialog's extend right checkbox
    dialogInputExtendRight: "Extend right",
    // Text for the annotation dialog's reverse checkbox
    dialogInputReverse: "Reverse",
    // Text for the annotation dialog's show fill checkbox
    dialogInputShowFill: "Show Fill",
    // Text for the annotation dialog's font size select box label
    dialogInputFontSize: "Size",
    // Text for the annotation dialog's font size select box alt text
    dialogInputFontSizeAltText: "Font Size",
    // Text for the annotation dialog's line style radio label
    dialogInputLineStyle: "Dash",
    // Text for the annotation dialog's text position radio label
    dialogInputPosition: "Position",
    // Text for the annotation dialog's stroke width label
    dialogInputStrokeWidth: "Weight",
    // Text for the annotation dialog's stroke width label
    dialogInputStrokeWidthAltText: "Line Weight",
    // Text for the annotation dialog's Fibonacci bands label
    dialogInputFibonacciBands: "Bands",
    // Text for the annotation dialog's Fibonacci bands label
    dialogInputFibonacciBandsAltText: "Fibonacci Bands",
    // Text for text area input placeholders
    inputTextareaPlaceholder: "Add Text",
    // Text for the measurer statistics date range bars value
    measurerDateRangeBars: "${value}[number] bars",
    // Text for the measurer statistics price range value
    measurerPriceRangeValue: "${value}[number]",
    // Text for the measurer statistics price range percentage
    measurerPriceRangePercent: "${value}[percent]",
    // Text for the measurer statistics volume value
    measurerVolume: "Vol ${value}",
    // Status when multiple data are under the cursor, and the user can click to cycle through which one appears in the tooltip
    tooltipPaginationStatus: "${index}[number] of ${count}[number]"
};
;
var messageRegExp = /\$\{(\w+)}(?:\[(\w+)])?/gi;
var formatters = {
    number: new Intl.NumberFormat("en-US"),
    percent: new Intl.NumberFormat("en-US", {
        style: "percent",
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }),
    percent0to2dp: new Intl.NumberFormat("en-US", {
        style: "percent",
        minimumFractionDigits: 0,
        maximumFractionDigits: 2
    }),
    date: new Intl.DateTimeFormat("en-US", {
        dateStyle: "full"
    }),
    time: new Intl.DateTimeFormat("en-US", {
        timeStyle: "full"
    }),
    datetime: new Intl.DateTimeFormat("en-US", {
        dateStyle: "full",
        timeStyle: "full"
    })
};
var defaultMessageFormatter = (param)=>{
    let { defaultValue, variables } = param;
    return defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.replaceAll(messageRegExp, (_, match, format)=>{
        const value = variables[match];
        const formatter2 = format != null ? formatters[format] : null;
        if (format != null && formatter2 == null) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Format style [".concat(format, "] is not supported"));
        }
        if (formatter2 != null) {
            return formatter2.format(value);
        } else if (typeof value === "number") {
            return formatters.number.format(value);
        } else if (value instanceof Date) {
            return formatters.datetime.format(value);
        }
        return String(value);
    });
};
// packages/ag-charts-community/src/locale/localeManager.ts
var LocaleManager = class {
    setLocaleText(localeText) {
        if (this.localeText !== localeText) {
            this.localeText = localeText;
            this.eventsHub.emit("locale:change", null);
        }
    }
    setLocaleTextFormatter(getLocaleText) {
        this.getLocaleText = getLocaleText;
        if (this.getLocaleText !== getLocaleText) {
            this.getLocaleText = getLocaleText;
            this.eventsHub.emit("locale:change", null);
        }
    }
    t(key) {
        let variables = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const { localeText = AG_CHARTS_LOCALE_EN_US, getLocaleText } = this;
        const defaultValue = localeText[key];
        var _getLocaleText, _ref;
        return (_ref = (_getLocaleText = getLocaleText === null || getLocaleText === void 0 ? void 0 : getLocaleText({
            key,
            defaultValue,
            variables
        })) !== null && _getLocaleText !== void 0 ? _getLocaleText : defaultMessageFormatter({
            key,
            defaultValue,
            variables
        })) !== null && _ref !== void 0 ? _ref : key;
    }
    constructor(eventsHub){
        this.eventsHub = eventsHub;
        this.localeText = void 0;
        this.getLocaleText = void 0;
    }
};
;
;
var HdpiCanvas = class {
    drawImage(context) {
        let dx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, dy = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        return context.drawImage(this.context.canvas, dx, dy);
    }
    toDataURL(type) {
        return this.element.toDataURL(type);
    }
    resize(width2, height2, pixelRatio) {
        if (!(width2 > 0 && height2 > 0)) return;
        const { element: element2, context } = this;
        element2.width = Math.round(width2 * pixelRatio);
        element2.height = Math.round(height2 * pixelRatio);
        context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        element2.style.width = width2 + "px";
        element2.style.height = height2 + "px";
        this.width = width2;
        this.height = height2;
        this.pixelRatio = pixelRatio;
    }
    clear() {
        clearContext(this);
    }
    destroy() {
        this.element.remove();
        this.element.width = 0;
        this.element.height = 0;
        this.context.clearRect(0, 0, 0, 0);
        Object.freeze(this);
    }
    reset() {
        var _this_context_verifyDepthZero, _this_context;
        this.context.reset();
        (_this_context_verifyDepthZero = (_this_context = this.context).verifyDepthZero) === null || _this_context_verifyDepthZero === void 0 ? void 0 : _this_context_verifyDepthZero.call(_this_context);
    }
    onEnabledChange() {
        if (this.element) {
            this.element.style.display = this.enabled ? "" : "none";
        }
    }
    constructor(options){
        this.enabled = true;
        this.width = 600;
        this.height = 300;
        const { width: width2, height: height2, canvasElement, willReadFrequently = false } = options;
        var _options_pixelRatio, _ref;
        this.pixelRatio = (_ref = (_options_pixelRatio = options.pixelRatio) !== null && _options_pixelRatio !== void 0 ? _options_pixelRatio : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])("devicePixelRatio")) !== null && _ref !== void 0 ? _ref : 1;
        this.element = canvasElement !== null && canvasElement !== void 0 ? canvasElement : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("canvas");
        this.element.style.display = "block";
        this.element.style.width = (width2 !== null && width2 !== void 0 ? width2 : this.width) + "px";
        this.element.style.height = (height2 !== null && height2 !== void 0 ? height2 : this.height) + "px";
        this.element.width = Math.round((width2 !== null && width2 !== void 0 ? width2 : this.width) * this.pixelRatio);
        this.element.height = Math.round((height2 !== null && height2 !== void 0 ? height2 : this.height) * this.pixelRatio);
        this.context = this.element.getContext("2d", {
            willReadFrequently
        });
        this.onEnabledChange();
        this.resize(width2 !== null && width2 !== void 0 ? width2 : 0, height2 !== null && height2 !== void 0 ? height2 : 0, this.pixelRatio);
        debugContext(this.context);
    }
};
__decorateClass([
    ObserveChanges((target)=>target.onEnabledChange())
], HdpiCanvas.prototype, "enabled", 2);
;
var ImageLoader = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventEmitter"] {
    loadImage(uri, affectedNode) {
        const entry = this.cache.get(uri);
        if (entry === null || entry === void 0 ? void 0 : entry.image) {
            return entry.image;
        } else if (entry != null && affectedNode) {
            entry.nodes.add(affectedNode);
            return;
        }
        if (!affectedNode) {
            return;
        }
        const nextEntry = {
            image: void 0,
            nodes: /* @__PURE__ */ new Set([
                affectedNode
            ])
        };
        const image = new Image();
        this.imageLoadingCount++;
        image.onload = ()=>{
            nextEntry.image = image;
            for (const node of nextEntry.nodes){
                node.markDirty();
            }
            nextEntry.nodes.clear();
            this.imageLoadingCount--;
            this.emit("image-loaded", {
                uri
            });
        };
        image.onerror = ()=>{
            this.imageLoadingCount--;
            nextEntry.nodes.clear();
            this.emit("image-error", {
                uri
            });
        };
        image.src = uri;
        this.cache.set(uri, nextEntry);
        return nextEntry.image;
    }
    waitingToLoad() {
        return this.imageLoadingCount > 0;
    }
    destroy() {
        this.cache.forEach((entry)=>{
            entry.nodes.clear();
        });
        this.cache.clear();
    }
    constructor(){
        super(...arguments);
        this.cache = /* @__PURE__ */ new Map();
        this.imageLoadingCount = 0;
    }
};
// packages/ag-charts-community/src/scene/layersManager.ts
var LayersManager = class {
    get size() {
        return this.layersMap.size;
    }
    resize(width2, height2, pixelRatio) {
        this.canvas.resize(width2, height2, pixelRatio);
        this.layersMap.forEach((param)=>{
            let { canvas } = param;
            return canvas.resize(width2, height2, pixelRatio);
        });
    }
    addLayer(opts) {
        const { width: width2, height: height2, pixelRatio } = this.canvas;
        const { name } = opts;
        const canvas = new HdpiOffscreenCanvas({
            width: width2,
            height: height2,
            pixelRatio
        });
        this.layersMap.set(canvas, {
            id: this.nextLayerId++,
            name,
            canvas
        });
        this.debug("Scene.addLayer() - layers", this.layersMap);
        return canvas;
    }
    removeLayer(canvas) {
        if (this.layersMap.has(canvas)) {
            this.layersMap.delete(canvas);
            canvas.destroy();
            this.debug("Scene.removeLayer() -  layers", this.layersMap);
        }
    }
    clear() {
        for (const layer of this.layersMap.values()){
            layer.canvas.destroy();
        }
        this.layersMap.clear();
    }
    constructor(canvas){
        this.canvas = canvas;
        this.debug = Debug.create(true, "scene");
        this.layersMap = /* @__PURE__ */ new Map();
        this.nextLayerId = 0;
    }
};
// packages/ag-charts-community/src/scene/scene.ts
var Scene = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventEmitter"] {
    waitingForUpdate() {
        var _this_imageLoader;
        var _this_imageLoader_waitingToLoad;
        return (_this_imageLoader_waitingToLoad = (_this_imageLoader = this.imageLoader) === null || _this_imageLoader === void 0 ? void 0 : _this_imageLoader.waitingToLoad()) !== null && _this_imageLoader_waitingToLoad !== void 0 ? _this_imageLoader_waitingToLoad : false;
    }
    get width() {
        var _this_pendingSize;
        var _this_pendingSize_;
        return (_this_pendingSize_ = (_this_pendingSize = this.pendingSize) === null || _this_pendingSize === void 0 ? void 0 : _this_pendingSize[0]) !== null && _this_pendingSize_ !== void 0 ? _this_pendingSize_ : this.canvas.width;
    }
    get height() {
        var _this_pendingSize;
        var _this_pendingSize_;
        return (_this_pendingSize_ = (_this_pendingSize = this.pendingSize) === null || _this_pendingSize === void 0 ? void 0 : _this_pendingSize[1]) !== null && _this_pendingSize_ !== void 0 ? _this_pendingSize_ : this.canvas.height;
    }
    get pixelRatio() {
        var _this_pendingSize;
        var _this_pendingSize_;
        return (_this_pendingSize_ = (_this_pendingSize = this.pendingSize) === null || _this_pendingSize === void 0 ? void 0 : _this_pendingSize[2]) !== null && _this_pendingSize_ !== void 0 ? _this_pendingSize_ : this.canvas.pixelRatio;
    }
    /** @deprecated v10.2.0 Only used by AG Grid Sparklines */ setContainer(value) {
        var _element2_parentElement;
        const { element: element2 } = this.canvas;
        (_element2_parentElement = element2.parentElement) === null || _element2_parentElement === void 0 ? void 0 : _element2_parentElement.removeChild(element2);
        value.appendChild(element2);
        return this;
    }
    setRoot(node) {
        var _this_root;
        if (this.root === node) {
            return this;
        }
        this.isDirty = true;
        (_this_root = this.root) === null || _this_root === void 0 ? void 0 : _this_root.setScene();
        this.root = node;
        if (node) {
            node.visible = true;
            node.setScene(this);
        }
        return this;
    }
    updateDebugFlags() {
        Debug.inDevelopmentMode(()=>Node2._debugEnabled = true);
    }
    clearCanvas() {
        this.canvas.clear();
    }
    attachNode(node) {
        this.appendChild(node);
        return ()=>this.removeChild(node);
    }
    appendChild(node) {
        var _this_root;
        (_this_root = this.root) === null || _this_root === void 0 ? void 0 : _this_root.appendChild(node);
        return this;
    }
    removeChild(node) {
        var _this_root;
        (_this_root = this.root) === null || _this_root === void 0 ? void 0 : _this_root.removeChild(node);
        return this;
    }
    download(fileName, fileFormat) {
        var _fileName_trim;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["downloadUrl"])(this.canvas.toDataURL(fileFormat), (_fileName_trim = fileName === null || fileName === void 0 ? void 0 : fileName.trim()) !== null && _fileName_trim !== void 0 ? _fileName_trim : "image");
    }
    /** NOTE: Integrated Charts undocumented image download method. */ getDataURL(fileFormat) {
        return this.canvas.toDataURL(fileFormat);
    }
    resize(width2, height2, pixelRatio) {
        width2 = Math.round(width2);
        height2 = Math.round(height2);
        pixelRatio !== null && pixelRatio !== void 0 ? pixelRatio : pixelRatio = this.pixelRatio;
        if (width2 > 0 && height2 > 0 && (width2 !== this.width || height2 !== this.height || pixelRatio !== this.pixelRatio)) {
            this.pendingSize = [
                width2,
                height2,
                pixelRatio
            ];
            this.isDirty = true;
            return true;
        }
        return false;
    }
    render(opts) {
        var _ctx_verifyDepthZero;
        const { debugSplitTimes = {
            start: performance.now()
        }, extraDebugStats, seriesRect } = opts !== null && opts !== void 0 ? opts : {};
        const { canvas, canvas: { context: ctx } = {}, root, pendingSize, width: width2, height: height2, pixelRatio: devicePixelRatio } = this;
        if (!ctx) {
            return;
        }
        const renderStartTime = performance.now();
        let resized = false;
        if (pendingSize) {
            resized = true;
            this.layersManager.resize(...pendingSize);
            this.pendingSize = null;
        }
        if (root && !root.visible) {
            this.isDirty = false;
            return;
        }
        let rootDirty;
        if (root instanceof Group) {
            rootDirty = root.dirty;
        }
        if (root != null && rootDirty === false && !this.isDirty) {
            if (this.debug.check()) {
                this.debug("Scene.render() - no-op", {
                    tree: buildTree(root, "console")
                });
            }
            debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats, seriesRect);
            return;
        }
        const renderCtx = {
            ctx,
            width: width2,
            height: height2,
            devicePixelRatio,
            debugNodes: {}
        };
        if (Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */ )) {
            renderCtx.stats = {
                layersRendered: 0,
                layersSkipped: 0,
                nodesRendered: 0,
                nodesSkipped: 0,
                opsPerformed: 0,
                opsSkipped: 0
            };
        }
        prepareSceneNodeHighlight(renderCtx);
        let canvasCleared = false;
        if (rootDirty !== false || resized) {
            canvasCleared = true;
            canvas.clear();
        }
        if (root && Debug.check("scene:dirtyTree" /* SCENE_DIRTY_TREE */ )) {
            const { dirtyTree, paths } = buildDirtyTree(root);
            Debug.create("scene:dirtyTree" /* SCENE_DIRTY_TREE */ )("Scene.render() - dirtyTree", {
                dirtyTree,
                paths
            });
        }
        if (root && canvasCleared) {
            if (root.visible) {
                root.preRender(renderCtx);
            }
            if (this.debug.check()) {
                const tree = buildTree(root, "console");
                this.debug("Scene.render() - before", {
                    canvasCleared,
                    tree
                });
            }
            if (root.visible) {
                try {
                    ctx.save();
                    root.render(renderCtx);
                    ctx.restore();
                } catch (e) {
                    this.canvas.reset();
                    throw e;
                }
            }
        }
        debugSplitTimes["\u270D\uFE0F"] = performance.now() - renderStartTime;
        (_ctx_verifyDepthZero = ctx.verifyDepthZero) === null || _ctx_verifyDepthZero === void 0 ? void 0 : _ctx_verifyDepthZero.call(ctx);
        this.isDirty = false;
        debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats, seriesRect);
        debugSceneNodeHighlight(ctx, renderCtx.debugNodes);
        if (root && this.debug.check()) {
            this.debug("Scene.render() - after", {
                tree: buildTree(root, "console"),
                canvasCleared
            });
        }
    }
    toSVG() {
        const { root, width: width2, height: height2 } = this;
        if (root == null) return;
        return Node2.toSVG(root, width2, height2);
    }
    /** Alternative to destroy() that preserves re-usable resources. */ strip() {
        const { context, pixelRatio } = this.canvas;
        context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        this.layersManager.clear();
        this.setRoot(null);
        this.isDirty = false;
        this.clear();
    }
    destroy() {
        this.strip();
        this.canvas.destroy();
        this.imageLoader.destroy();
        this.cleanup.flush();
        Object.assign(this, {
            canvas: void 0
        });
    }
    constructor(canvasOptions){
        super();
        this.debug = Debug.create(true, "scene" /* SCENE */ );
        this.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createId"])(this);
        this.imageLoader = new ImageLoader();
        this.root = null;
        this.pendingSize = null;
        this.isDirty = false;
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.updateDebugFlags();
        this.canvas = new HdpiCanvas(canvasOptions);
        this.layersManager = new LayersManager(this.canvas);
        this.cleanup.register(this.imageLoader.on("image-loaded", ()=>{
            this.emit("scene-changed", {});
        }), this.imageLoader.on("image-error", (param)=>{
            let { uri } = param;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Unable to load image ".concat(uri));
        }));
    }
};
Scene.className = "Scene";
;
var AnnotationManager = class {
    createMemento() {
        return this.annotations;
    }
    guardMemento(blob) {
        return blob == null || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(blob);
    }
    restoreMemento(_version, _mementoVersion, memento) {
        this.annotations = this.cleanData(memento !== null && memento !== void 0 ? memento : []).map((annotation)=>{
            const annotationTheme = this.getAnnotationTypeStyles(annotation.type);
            return mergeDefaults(annotation, annotationTheme);
        });
        this.eventsHub.emit("annotations:restore", {
            annotations: this.annotations
        });
    }
    updateData(annotations) {
        this.annotations = this.cleanData(annotations !== null && annotations !== void 0 ? annotations : []);
    }
    fireChangedEvent() {
        this.fireChartEvent({
            type: "annotations",
            annotations: deepClone([
                ...this.annotations
            ])
        });
    }
    attachNode(node) {
        this.annotationRoot.append(node);
        return ()=>{
            var _this_annotationRoot;
            (_this_annotationRoot = this.annotationRoot) === null || _this_annotationRoot === void 0 ? void 0 : _this_annotationRoot.removeChild(node);
            return this;
        };
    }
    setAnnotationStyles(styles) {
        this.styles = styles;
    }
    getAnnotationTypeStyles(type) {
        var _this_styles;
        return (_this_styles = this.styles) === null || _this_styles === void 0 ? void 0 : _this_styles[type];
    }
    cleanData(annotations) {
        for (const annotation of annotations){
            if ("textAlign" in annotation) delete annotation.textAlign;
        }
        return annotations;
    }
    constructor(eventsHub, annotationRoot, fireChartEvent){
        this.eventsHub = eventsHub;
        this.annotationRoot = annotationRoot;
        this.fireChartEvent = fireChartEvent;
        this.mementoOriginatorKey = "annotations";
        this.annotations = [];
    }
};
// packages/ag-charts-community/src/chart/zIndexMap.ts
var ZIndexMap = /* @__PURE__ */ ((ZIndexMap2)=>{
    ZIndexMap2[ZIndexMap2["CHART_BACKGROUND"] = 0] = "CHART_BACKGROUND";
    ZIndexMap2[ZIndexMap2["AXIS_BAND_HIGHLIGHT"] = 1] = "AXIS_BAND_HIGHLIGHT";
    ZIndexMap2[ZIndexMap2["AXIS_GRID"] = 2] = "AXIS_GRID";
    ZIndexMap2[ZIndexMap2["AXIS"] = 3] = "AXIS";
    ZIndexMap2[ZIndexMap2["SERIES_AREA_CONTAINER"] = 4] = "SERIES_AREA_CONTAINER";
    ZIndexMap2[ZIndexMap2["ZOOM_SELECTION"] = 5] = "ZOOM_SELECTION";
    ZIndexMap2[ZIndexMap2["SERIES_CROSSLINE_RANGE"] = 6] = "SERIES_CROSSLINE_RANGE";
    ZIndexMap2[ZIndexMap2["SERIES_LAYER"] = 7] = "SERIES_LAYER";
    ZIndexMap2[ZIndexMap2["AXIS_FOREGROUND"] = 8] = "AXIS_FOREGROUND";
    ZIndexMap2[ZIndexMap2["SERIES_CROSSHAIR"] = 9] = "SERIES_CROSSHAIR";
    ZIndexMap2[ZIndexMap2["SERIES_CROSSLINE_LINE"] = 10] = "SERIES_CROSSLINE_LINE";
    ZIndexMap2[ZIndexMap2["SERIES_ANNOTATION"] = 11] = "SERIES_ANNOTATION";
    ZIndexMap2[ZIndexMap2["CHART_ANNOTATION"] = 12] = "CHART_ANNOTATION";
    ZIndexMap2[ZIndexMap2["CHART_ANNOTATION_FOCUSED"] = 13] = "CHART_ANNOTATION_FOCUSED";
    ZIndexMap2[ZIndexMap2["STATUS_BAR"] = 14] = "STATUS_BAR";
    ZIndexMap2[ZIndexMap2["SERIES_LABEL"] = 15] = "SERIES_LABEL";
    ZIndexMap2[ZIndexMap2["LEGEND"] = 16] = "LEGEND";
    ZIndexMap2[ZIndexMap2["NAVIGATOR"] = 17] = "NAVIGATOR";
    ZIndexMap2[ZIndexMap2["FOREGROUND"] = 18] = "FOREGROUND";
    return ZIndexMap2;
})(ZIndexMap || {});
// packages/ag-charts-community/src/chart/axis/axisManager.ts
var AxisManager = class {
    updateAxes(oldAxes, newAxes) {
        const axisNodes = {
            axisNode: this.axisGroup,
            gridNode: this.axisGridGroup,
            labelNode: this.axisLabelGroup,
            crossLineRangeNode: this.axisCrosslineRangeGroup,
            crossLineLineNode: this.axisCrosslineLineGroup,
            crossLineLabelNode: this.axisCrosslineLabelGroup
        };
        for (const axis of oldAxes){
            if (newAxes.includes(axis)) continue;
            axis.detachAxis(axisNodes);
            axis.destroy();
        }
        for (const axis of newAxes){
            if (oldAxes === null || oldAxes === void 0 ? void 0 : oldAxes.includes(axis)) continue;
            axis.attachAxis(axisNodes);
        }
        this.axes.clear();
        for (const axis of newAxes){
            const ctx = axis.createAxisContext();
            if (this.axes.has(ctx.direction)) {
                var _this_axes_get;
                (_this_axes_get = this.axes.get(ctx.direction)) === null || _this_axes_get === void 0 ? void 0 : _this_axes_get.push(ctx);
            } else {
                this.axes.set(ctx.direction, [
                    ctx
                ]);
            }
        }
        this.eventsHub.emit("axis:change", null);
    }
    getAxisContext(direction) {
        var _this_axes_get;
        return (_this_axes_get = this.axes.get(direction)) !== null && _this_axes_get !== void 0 ? _this_axes_get : [];
    }
    destroy() {
        this.axes.clear();
        this.sceneRoot.removeChild(this.axisGroup);
        this.sceneRoot.removeChild(this.axisGridGroup);
    }
    constructor(eventsHub, sceneRoot){
        this.eventsHub = eventsHub;
        this.sceneRoot = sceneRoot;
        this.axes = /* @__PURE__ */ new Map();
        this.axisGridGroup = new Group({
            name: "Axes-Grids",
            zIndex: 2 /* AXIS_GRID */ 
        });
        this.axisGroup = new Group({
            name: "Axes",
            zIndex: 3 /* AXIS */ 
        });
        this.axisLabelGroup = new Group({
            name: "Axes-Labels",
            zIndex: 15 /* SERIES_LABEL */ 
        });
        this.axisCrosslineRangeGroup = new Group({
            name: "Axes-Crosslines-Range",
            zIndex: 6 /* SERIES_CROSSLINE_RANGE */ 
        });
        this.axisCrosslineLineGroup = new Group({
            name: "Axes-Crosslines-Line",
            zIndex: 10 /* SERIES_CROSSLINE_LINE */ 
        });
        this.axisCrosslineLabelGroup = new Group({
            name: "Axes-Crosslines-Label",
            zIndex: 15 /* SERIES_LABEL */ 
        });
        this.sceneRoot.appendChild(this.axisGroup);
        this.sceneRoot.appendChild(this.axisGridGroup);
        this.sceneRoot.appendChild(this.axisLabelGroup);
        this.sceneRoot.appendChild(this.axisCrosslineRangeGroup);
        this.sceneRoot.appendChild(this.axisCrosslineLineGroup);
        this.sceneRoot.appendChild(this.axisCrosslineLabelGroup);
    }
};
// packages/ag-charts-community/src/chart/chartUpdateType.ts
var ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType2)=>{
    ChartUpdateType2[ChartUpdateType2["FULL"] = 0] = "FULL";
    ChartUpdateType2[ChartUpdateType2["UPDATE_DATA"] = 1] = "UPDATE_DATA";
    ChartUpdateType2[ChartUpdateType2["PROCESS_DATA"] = 2] = "PROCESS_DATA";
    ChartUpdateType2[ChartUpdateType2["PROCESS_DOMAIN"] = 3] = "PROCESS_DOMAIN";
    ChartUpdateType2[ChartUpdateType2["PERFORM_LAYOUT"] = 4] = "PERFORM_LAYOUT";
    ChartUpdateType2[ChartUpdateType2["SERIES_UPDATE"] = 5] = "SERIES_UPDATE";
    ChartUpdateType2[ChartUpdateType2["PRE_SCENE_RENDER"] = 6] = "PRE_SCENE_RENDER";
    ChartUpdateType2[ChartUpdateType2["SCENE_RENDER"] = 7] = "SCENE_RENDER";
    ChartUpdateType2[ChartUpdateType2["NONE"] = 8] = "NONE";
    return ChartUpdateType2;
})(ChartUpdateType || {});
;
var DataService = class {
    updateCallback(dataSourceCallback) {
        if (typeof dataSourceCallback !== "function") return;
        this.debug("DataService - updated data source callback");
        this.dataSourceCallback = dataSourceCallback;
        this.isLoadingInitialData = true;
        this.animationManager.skip();
        this.eventsHub.emit("data:source-change", null);
    }
    clearCallback() {
        this.dataSourceCallback = void 0;
    }
    load(params) {
        var _pendingData_params_windowStart, _params_windowStart, _pendingData_params_windowEnd, _params_windowEnd;
        const { pendingData } = this;
        if (pendingData != null && ((_pendingData_params_windowStart = pendingData.params.windowStart) === null || _pendingData_params_windowStart === void 0 ? void 0 : _pendingData_params_windowStart.valueOf()) === ((_params_windowStart = params.windowStart) === null || _params_windowStart === void 0 ? void 0 : _params_windowStart.valueOf()) && ((_pendingData_params_windowEnd = pendingData.params.windowEnd) === null || _pendingData_params_windowEnd === void 0 ? void 0 : _pendingData_params_windowEnd.valueOf()) === ((_params_windowEnd = params.windowEnd) === null || _params_windowEnd === void 0 ? void 0 : _params_windowEnd.valueOf())) {
            const id = this.requestCounter++;
            this.isLoadingInitialData = false;
            this.dispatch(id, pendingData.data);
            return;
        }
        this.isLoadingData = true;
        this.throttledFetch(params);
    }
    isLazy() {
        return this.dataSourceCallback != null;
    }
    isLoading() {
        return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);
    }
    async getData() {
        const { latestRequest } = this;
        if (!latestRequest) return;
        const { params, fetchRequest } = latestRequest;
        const data = await fetchRequest;
        return {
            params,
            data
        };
    }
    restoreData(data) {
        this.pendingData = data;
    }
    createThrottledFetch(requestThrottle) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throttle"])((params)=>this.fetch(params).catch((e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].error("callback failed", e)), requestThrottle, {
            leading: false,
            trailing: true
        });
    }
    createThrottledDispatch(dispatchThrottle) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throttle"])((id, data)=>this.dispatch(id, data), dispatchThrottle, {
            leading: true,
            trailing: true
        });
    }
    dispatch(id, data) {
        this.debug("DataService - dispatching 'data-load' | ".concat(id));
        this.eventsHub.emit("data:load", {
            data
        });
    }
    async fetch(params) {
        if ("context" in this.caller) {
            params.context = this.caller.context;
        }
        const fetchRequest = Promise.resolve().then(async ()=>{
            if (!this.dataSourceCallback) {
                throw new Error("DataService - [dataSource.getData] callback not initialised");
            }
            const start2 = performance.now();
            const id = this.requestCounter++;
            this.debug("DataService - requesting | ".concat(id));
            let response;
            try {
                response = await this.dataSourceCallback(params);
                this.debug("DataService - response | ".concat(performance.now() - start2, "ms | ").concat(id));
            } catch (error) {
                this.debug("DataService - request failed | ".concat(id));
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].errorOnce("DataService - request failed | [".concat(error, "]"));
            }
            this.isLoadingInitialData = false;
            const requestIndex = this.freshRequests.indexOf(fetchRequest);
            if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {
                this.debug("DataService - discarding stale request | ".concat(id));
                return response;
            }
            this.freshRequests = this.freshRequests.slice(requestIndex + 1);
            if (this.freshRequests.length === 0) {
                this.isLoadingData = false;
            }
            if (Array.isArray(response)) {
                this.throttledDispatch(id, response);
            } else {
                this.eventsHub.emit("data:error", null);
            }
            return response;
        });
        this.latestRequest = {
            params,
            fetchRequest
        };
        this.freshRequests.push(fetchRequest);
        await fetchRequest;
    }
    constructor(eventsHub, caller, animationManager){
        this.eventsHub = eventsHub;
        this.caller = caller;
        this.animationManager = animationManager;
        this.dispatchOnlyLatest = true;
        this.dispatchThrottle = 0;
        this.requestThrottle = 300;
        this.isLoadingInitialData = false;
        this.isLoadingData = false;
        this.freshRequests = [];
        this.requestCounter = 0;
        this.pendingData = void 0;
        this.debug = Debug.create(true, "data-model", "data-source");
        this.throttledFetch = this.createThrottledFetch(this.requestThrottle);
        this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);
    }
};
__decorateClass([
    ActionOnSet({
        newValue (dispatchThrottle) {
            this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);
        }
    })
], DataService.prototype, "dispatchThrottle", 2);
__decorateClass([
    ActionOnSet({
        newValue (requestThrottle) {
            this.throttledFetch = this.createThrottledFetch(requestThrottle);
        }
    })
], DataService.prototype, "requestThrottle", 2);
// packages/ag-charts-community/src/chart/fonts/fontManager.ts
var FontManager = class {
    updateFonts(fonts) {
        if (!fonts || fonts.size === 0) return;
        this.loadFonts(fonts);
        fonts.forEach((font2)=>{
            this.observeFontStatus(font2);
        });
    }
    destroy() {
        for (const observer of this.observers){
            observer.disconnect();
        }
        this.observers = [];
    }
    loadFonts(fonts) {
        const fontStrings = Array.from(fonts).map((font2)=>encodeURIComponent(font2));
        const fontStyle = ":wght@100;200;300;400;500;600;700;800;900";
        const joinString = "".concat(fontStyle, "&family=");
        const css = "@import url('https://fonts.googleapis.com/css2?family=".concat(fontStrings.join(joinString)).concat(fontStyle, "&display=swap');\n");
        this.domManager.addStyles("google-font-".concat(fontStrings.join("-")), css);
    }
    observeFontStatus(font2) {
        const fontCheckElement = window.document.createElement("div");
        fontCheckElement.style.setProperty("position", "absolute");
        fontCheckElement.style.setProperty("top", "0");
        fontCheckElement.style.setProperty("margin", "0");
        fontCheckElement.style.setProperty("padding", "0");
        fontCheckElement.style.setProperty("overflow", "hidden");
        fontCheckElement.style.setProperty("visibility", "hidden");
        fontCheckElement.style.setProperty("width", "auto");
        fontCheckElement.style.setProperty("max-width", "none");
        fontCheckElement.style.setProperty("font-synthesis", "none");
        fontCheckElement.style.setProperty("font-family", font2);
        fontCheckElement.style.setProperty("font-size", "16px");
        fontCheckElement.style.setProperty("white-space", "nowrap");
        fontCheckElement.textContent = "UVWxyz";
        this.domManager.addChild("canvas-container", "font-check-".concat(encodeURIComponent(font2)), fontCheckElement);
        const fontCheckObserver = new ResizeObserver((entries8)=>{
            var _entries8_at_contentBoxSize_at, _entries8_at;
            const width2 = entries8 === null || entries8 === void 0 ? void 0 : (_entries8_at = entries8.at(0)) === null || _entries8_at === void 0 ? void 0 : (_entries8_at_contentBoxSize_at = _entries8_at.contentBoxSize.at(0)) === null || _entries8_at_contentBoxSize_at === void 0 ? void 0 : _entries8_at_contentBoxSize_at.inlineSize;
            if (width2 != null && width2 > 0) {
                CachedTextMeasurerPool.clear();
                this.updateService.update(4 /* PERFORM_LAYOUT */ );
            }
        });
        fontCheckObserver.observe(fontCheckElement);
        this.observers.push(fontCheckObserver);
    }
    constructor(domManager, updateService){
        this.domManager = domManager;
        this.updateService = updateService;
        this.observers = [];
    }
};
;
// packages/ag-charts-types/src/chart/errorBarOptions.ts
var AgErrorBarSupportedSeriesTypes = [
    "bar",
    "line",
    "scatter"
];
// packages/ag-charts-types/src/chart/navigatorOptions.ts
var __MINI_CHART_SERIES_OPTIONS = void 0;
var __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;
__VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;
// packages/ag-charts-types/src/chart/themeOptions.ts
var __THEME_OVERRIDES = void 0;
var __VERIFY_THEME_OVERRIDES = void 0;
__VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;
// packages/ag-charts-types/src/chart/tooltipOptions.ts
var AgTooltipAnchorToType = /* @__PURE__ */ ((AgTooltipAnchorToType2)=>{
    AgTooltipAnchorToType2["POINTER"] = "pointer";
    AgTooltipAnchorToType2["NODE"] = "node";
    AgTooltipAnchorToType2["CHART"] = "chart";
    return AgTooltipAnchorToType2;
})(AgTooltipAnchorToType || {});
var AgTooltipPlacementType = /* @__PURE__ */ ((AgTooltipPlacementType2)=>{
    AgTooltipPlacementType2["TOP"] = "top";
    AgTooltipPlacementType2["RIGHT"] = "right";
    AgTooltipPlacementType2["BOTTOM"] = "bottom";
    AgTooltipPlacementType2["LEFT"] = "left";
    AgTooltipPlacementType2["TOP_RIGHT"] = "top-right";
    AgTooltipPlacementType2["BOTTOM_RIGHT"] = "bottom-right";
    AgTooltipPlacementType2["BOTTOM_LEFT"] = "bottom-left";
    AgTooltipPlacementType2["TOP_LEFT"] = "top-left";
    AgTooltipPlacementType2["CENTER"] = "center";
    return AgTooltipPlacementType2;
})(AgTooltipPlacementType || {});
// packages/ag-charts-types/src/presets/gauge/commonOptions.ts
var __THEMEABLE_OPTIONS = void 0;
var __VERIFY_THEMEABLE_OPTIONS = void 0;
__VERIFY_THEMEABLE_OPTIONS = __THEMEABLE_OPTIONS;
var __AXIS_LABEL_OPTIONS = void 0;
var __VERIFY_AXIS_LABEL_OPTIONS = void 0;
__VERIFY_AXIS_LABEL_OPTIONS = __AXIS_LABEL_OPTIONS;
;
var Listeners = class {
    addListener(eventType, handler) {
        const record = {
            symbol: Symbol(eventType),
            handler
        };
        if (this.registeredListeners.has(eventType)) {
            this.registeredListeners.get(eventType).push(record);
        } else {
            this.registeredListeners.set(eventType, [
                record
            ]);
        }
        return ()=>this.removeListener(record.symbol);
    }
    removeListener(eventSymbol) {
        for (const [type, listeners] of this.registeredListeners.entries()){
            const matchIndex = listeners.findIndex((listener)=>listener.symbol === eventSymbol);
            if (matchIndex >= 0) {
                listeners.splice(matchIndex, 1);
                if (listeners.length === 0) {
                    this.registeredListeners.delete(type);
                }
                break;
            }
        }
    }
    dispatch(eventType) {
        for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            params[_key - 1] = arguments[_key];
        }
        for (const listener of this.getListenersByType(eventType)){
            try {
                listener.handler(...params);
            } catch (e) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].errorOnce(e);
            }
        }
    }
    getListenersByType(eventType) {
        var _this_registeredListeners_get;
        return (_this_registeredListeners_get = this.registeredListeners.get(eventType)) !== null && _this_registeredListeners_get !== void 0 ? _this_registeredListeners_get : [];
    }
    destroy() {
        this.registeredListeners.clear();
    }
    constructor(){
        this.registeredListeners = /* @__PURE__ */ new Map();
    }
};
// packages/ag-charts-community/src/util/memo.ts
var memorizedFns = /* @__PURE__ */ new WeakMap();
function memo(params, fnGenerator) {
    var _memorizedFns_get, _memorizedFns_get1;
    const serialisedParams = JSON.stringify(params, null, 0);
    if (!memorizedFns.has(fnGenerator)) {
        memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());
    }
    if (!((_memorizedFns_get = memorizedFns.get(fnGenerator)) === null || _memorizedFns_get === void 0 ? void 0 : _memorizedFns_get.has(serialisedParams))) {
        var _memorizedFns_get2;
        (_memorizedFns_get2 = memorizedFns.get(fnGenerator)) === null || _memorizedFns_get2 === void 0 ? void 0 : _memorizedFns_get2.set(serialisedParams, fnGenerator(params));
    }
    return (_memorizedFns_get1 = memorizedFns.get(fnGenerator)) === null || _memorizedFns_get1 === void 0 ? void 0 : _memorizedFns_get1.get(serialisedParams);
}
var MemoizeNode = class {
    constructor(){
        this.weak = /* @__PURE__ */ new WeakMap();
        this.strong = /* @__PURE__ */ new Map();
        this.set = false;
        this.value = void 0;
    }
};
function simpleMemorize2(fn, cacheCallback2) {
    let root = new MemoizeNode();
    const memoised = function() {
        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){
            p[_key] = arguments[_key];
        }
        let current = root;
        for (const param of p){
            const target = typeof param === "object" || typeof param === "symbol" ? current.weak : current.strong;
            let next = target.get(param);
            if (next == null) {
                next = new MemoizeNode();
                target.set(param, next);
            }
            current = next;
        }
        if (current.set) {
            cacheCallback2 === null || cacheCallback2 === void 0 ? void 0 : cacheCallback2("hit", fn, p);
            return current.value;
        } else {
            const out = fn(...p);
            current.set = true;
            current.value = out;
            cacheCallback2 === null || cacheCallback2 === void 0 ? void 0 : cacheCallback2("miss", fn, p);
            return out;
        }
    };
    memoised.reset = ()=>{
        root = new MemoizeNode();
    };
    return memoised;
}
function simpleMemorize(fn, cacheCallback2) {
    const primitiveCache = /* @__PURE__ */ new Map();
    const paramsToKeys = function() {
        for(var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++){
            params[_key] = arguments[_key];
        }
        return params.map((v)=>{
            if (typeof v === "object") return v;
            if (typeof v === "symbol") return v;
            if (!primitiveCache.has(v)) {
                primitiveCache.set(v, {
                    v
                });
            }
            return primitiveCache.get(v);
        });
    };
    const empty = {};
    const cache = /* @__PURE__ */ new WeakMap();
    return function() {
        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){
            p[_key] = arguments[_key];
        }
        const keys = p.length === 0 ? [
            empty
        ] : paramsToKeys(...p);
        let currentCache = cache;
        for (const key of keys.slice(0, -1)){
            if (!currentCache.has(key)) {
                currentCache.set(key, /* @__PURE__ */ new WeakMap());
            }
            currentCache = currentCache.get(key);
        }
        const finalKey = keys.at(-1);
        let cachedValue = currentCache.get(finalKey);
        if (cachedValue) {
            cacheCallback2 === null || cacheCallback2 === void 0 ? void 0 : cacheCallback2("hit", fn, p);
        } else {
            cachedValue = fn(...p);
            currentCache.set(finalKey, cachedValue);
            cacheCallback2 === null || cacheCallback2 === void 0 ? void 0 : cacheCallback2("miss", fn, p);
        }
        return cachedValue;
    };
}
// packages/ag-charts-community/src/util/timeFormat.ts
var CONSTANTS = {
    periods: [
        "AM",
        "PM"
    ],
    days: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
    ],
    shortDays: [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
    ],
    months: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
    ],
    shortMonths: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    ]
};
function dayOfYear(date5) {
    let startOfYear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Date(date5.getFullYear(), 0, 1);
    const startOffset = date5.getTimezoneOffset() - startOfYear.getTimezoneOffset();
    const timeDiff = date5.getTime() - startOfYear.getTime() + startOffset * 6e4;
    const timeOneDay = 36e5 * 24;
    return Math.floor(timeDiff / timeOneDay);
}
function weekOfYear(date5, startDay) {
    const startOfYear = new Date(date5.getFullYear(), 0, 1);
    const startOfYearDay = startOfYear.getDay();
    const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;
    const startOffset = new Date(date5.getFullYear(), 0, firstWeekStartOffset + 1);
    if (startOffset <= date5) {
        return Math.floor(dayOfYear(date5, startOffset) / 7) + 1;
    }
    return 0;
}
var SUNDAY = 0;
var MONDAY = 1;
var THURSDAY = 4;
function isoWeekOfYear(date5) {
    let year = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : date5.getFullYear();
    const firstOfYear = new Date(year, 0, 1);
    const firstOfYearDay = firstOfYear.getDay();
    const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;
    const startOffset = new Date(year, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);
    if (startOffset <= date5) {
        return Math.floor(dayOfYear(date5, startOffset) / 7) + 1;
    }
    return isoWeekOfYear(date5, year - 1);
}
function timezone(date5) {
    const offset = date5.getTimezoneOffset();
    const unsignedOffset = Math.abs(offset);
    const sign = offset > 0 ? "-" : "+";
    return "".concat(sign).concat(pad(Math.floor(unsignedOffset / 60), 2, "0")).concat(pad(Math.floor(unsignedOffset % 60), 2, "0"));
}
var FORMATTERS = {
    a: (d)=>CONSTANTS.shortDays[d.getDay()],
    A: (d)=>CONSTANTS.days[d.getDay()],
    b: (d)=>CONSTANTS.shortMonths[d.getMonth()],
    B: (d)=>CONSTANTS.months[d.getMonth()],
    c: "%x, %X",
    d: (d, p)=>pad(d.getDate(), 2, p !== null && p !== void 0 ? p : "0"),
    e: "%_d",
    f: (d, p)=>pad(d.getMilliseconds() * 1e3, 6, p !== null && p !== void 0 ? p : "0"),
    H: (d, p)=>pad(d.getHours(), 2, p !== null && p !== void 0 ? p : "0"),
    I: (d, p)=>{
        const hours = d.getHours() % 12;
        return hours === 0 ? "12" : pad(hours, 2, p !== null && p !== void 0 ? p : "0");
    },
    j: (d, p)=>pad(dayOfYear(d) + 1, 3, p !== null && p !== void 0 ? p : "0"),
    m: (d, p)=>pad(d.getMonth() + 1, 2, p !== null && p !== void 0 ? p : "0"),
    M: (d, p)=>pad(d.getMinutes(), 2, p !== null && p !== void 0 ? p : "0"),
    L: (d, p)=>pad(d.getMilliseconds(), 3, p !== null && p !== void 0 ? p : "0"),
    p: (d)=>d.getHours() < 12 ? "AM" : "PM",
    Q: (d)=>String(d.getTime()),
    s: (d)=>String(Math.floor(d.getTime() / 1e3)),
    S: (d, p)=>pad(d.getSeconds(), 2, p !== null && p !== void 0 ? p : "0"),
    u: (d)=>{
        let day = d.getDay();
        if (day < 1) day += 7;
        return String(day % 7);
    },
    U: (d, p)=>pad(weekOfYear(d, SUNDAY), 2, p !== null && p !== void 0 ? p : "0"),
    V: (d, p)=>pad(isoWeekOfYear(d), 2, p !== null && p !== void 0 ? p : "0"),
    w: (d, p)=>pad(d.getDay(), 2, p !== null && p !== void 0 ? p : "0"),
    W: (d, p)=>pad(weekOfYear(d, MONDAY), 2, p !== null && p !== void 0 ? p : "0"),
    x: "%-m/%-d/%Y",
    X: "%-I:%M:%S %p",
    y: (d, p)=>pad(d.getFullYear() % 100, 2, p !== null && p !== void 0 ? p : "0"),
    Y: (d, p)=>pad(d.getFullYear(), 4, p !== null && p !== void 0 ? p : "0"),
    Z: (d)=>timezone(d),
    "%": ()=>"%"
};
var PADS = {
    _: " ",
    "0": "0",
    "-": ""
};
function pad(value, size, padChar) {
    const output = String(Math.floor(value));
    if (output.length >= size) {
        return output;
    }
    return "".concat(padChar.repeat(size - output.length)).concat(output);
}
function buildDateFormatter(formatString) {
    const formatParts = [];
    while(formatString.length > 0){
        let nextEscapeIdx = formatString.indexOf("%");
        if (nextEscapeIdx !== 0) {
            const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;
            formatParts.push(literalPart);
        }
        if (nextEscapeIdx < 0) break;
        const maybePadSpecifier = formatString[nextEscapeIdx + 1];
        const maybePad = PADS[maybePadSpecifier];
        if (maybePad != null) {
            nextEscapeIdx++;
        }
        const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];
        const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];
        if (typeof maybeFormatter === "function") {
            formatParts.push([
                maybeFormatter,
                maybePad
            ]);
        } else if (typeof maybeFormatter === "string") {
            const formatter2 = buildDateFormatter(maybeFormatter);
            formatParts.push([
                formatter2,
                maybePad
            ]);
        } else {
            formatParts.push("".concat(maybePad !== null && maybePad !== void 0 ? maybePad : "").concat(maybeFormatterSpecifier));
        }
        formatString = formatString.substring(nextEscapeIdx + 2);
    }
    return (dateTime)=>{
        const dateTimeAsDate = typeof dateTime === "number" ? new Date(dateTime) : dateTime;
        return formatParts.map((c)=>typeof c === "string" ? c : c[0](dateTimeAsDate, c[1])).join("");
    };
}
// packages/ag-charts-community/src/chart/axis/timeFormatUtil.ts
var defaultTimeFormats = {
    millisecond: "%H:%M:%S.%L",
    second: "%H:%M:%S",
    minute: "%H:%M",
    hour: "%H:%M",
    day: "%e",
    month: "%b",
    year: "%Y"
};
var hardCodedTimeFormats = {
    millisecond: "%Y %b %e %H:%M:%S.%L",
    second: "%Y %b %e %H:%M:%S",
    minute: "%Y %b %e %H:%M",
    hour: "%Y %b %e %H:%M",
    day: "%Y %b %e",
    month: "%Y %b",
    year: "%Y"
};
var FORMAT_ORDERS = {
    year: 0,
    month: 1,
    day: 2,
    hour: 3,
    minute: 4,
    second: 5,
    millisecond: 6
};
var MILLISECOND_FORMAT = /%[-_0]?L/;
var SECOND_FORMAT = /%[-_0]?S/;
var MINUTE_FORMAT = /%[-_0]?M/;
var HOUR_FORMAT = /%[-_0]?[HI]/;
var DAY_FORMAT = /^%[-_0]?[de]$/;
var MONTH_FORMAT = /^%[-_0]?[Bbm]$/;
var YEAR_FORMAT = /^%[-_0]?[Yy]$/;
function deriveTimeSpecifier(format, unit, truncateDate) {
    if (typeof format === "string") return format;
    format !== null && format !== void 0 ? format : format = defaultTimeFormats;
    const { millisecond = defaultTimeFormats.millisecond, second = defaultTimeFormats.second, minute = defaultTimeFormats.minute, hour = defaultTimeFormats.hour, day = defaultTimeFormats.day, month = defaultTimeFormats.month, year = defaultTimeFormats.year } = format;
    const formatOrder = FORMAT_ORDERS[unit];
    const hardcodedTimeFormat = hardCodedTimeFormats[unit];
    const truncationOrder = truncateDate ? FORMAT_ORDERS[truncateDate] : -1;
    if (truncationOrder < FORMAT_ORDERS.year && formatOrder >= FORMAT_ORDERS.year && !YEAR_FORMAT.test(year) || truncationOrder < FORMAT_ORDERS.month && formatOrder >= FORMAT_ORDERS.month && !MONTH_FORMAT.test(month) || truncationOrder < FORMAT_ORDERS.day && formatOrder >= FORMAT_ORDERS.day && !DAY_FORMAT.test(day)) {
        return hardcodedTimeFormat;
    }
    let timeFormat;
    switch(unit){
        case "year":
            return year;
        case "month":
            return truncationOrder < FORMAT_ORDERS.year ? "".concat(month, " ").concat(year) : month;
        case "day":
            return truncationOrder < FORMAT_ORDERS.year ? "".concat(month, " ").concat(day, " ").concat(year) : "".concat(month, " ").concat(day);
        case "hour":
            timeFormat = hour;
            break;
        case "minute":
            timeFormat = minute;
            break;
        case "second":
            timeFormat = second;
            break;
        case "millisecond":
            timeFormat = millisecond;
            break;
        default:
            return hardcodedTimeFormat;
    }
    if (formatOrder >= FORMAT_ORDERS.hour && !HOUR_FORMAT.test(timeFormat) || formatOrder >= FORMAT_ORDERS.minute && !MINUTE_FORMAT.test(timeFormat) || formatOrder >= FORMAT_ORDERS.second && !SECOND_FORMAT.test(timeFormat) || formatOrder >= FORMAT_ORDERS.millisecond && !MILLISECOND_FORMAT.test(timeFormat)) {
        return hardcodedTimeFormat;
    }
    let dateFormat;
    if (truncationOrder < FORMAT_ORDERS.year) {
        dateFormat = "".concat(month, " ").concat(day, " ").concat(year);
    } else if (truncationOrder < FORMAT_ORDERS.month) {
        dateFormat = "".concat(month, " ").concat(day);
    }
    return dateFormat ? "".concat(timeFormat, " ").concat(dateFormat) : timeFormat;
}
// packages/ag-charts-community/src/chart/formatter/formatManager.ts
var FormatManager = class _FormatManager extends Listeners {
    static mergeSpecifiers() {
        for(var _len = arguments.length, specifiers = new Array(_len), _key = 0; _key < _len; _key++){
            specifiers[_key] = arguments[_key];
        }
        let out;
        for (const specifier of specifiers){
            if (typeof specifier === "string") {
                out = specifier;
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(specifier)) {
                out = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(out) ? {
                    ...out,
                    ...specifier
                } : specifier;
            }
        }
        return out;
    }
    static getFormatter(type, specifier, unit) {
        let style = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "long", { truncateDate } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(specifier)) {
            if (type !== "date") {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("Date formatter configuration is not supported for non-date types.");
                return;
            }
            unit !== null && unit !== void 0 ? unit : unit = "millisecond";
            var _specifier_unit;
            const fullFormat = style === "component" ? (_specifier_unit = specifier === null || specifier === void 0 ? void 0 : specifier[unit]) !== null && _specifier_unit !== void 0 ? _specifier_unit : defaultTimeFormats[unit] : deriveTimeSpecifier(specifier, unit, truncateDate);
            return buildDateFormatter(fullFormat);
        }
        switch(type){
            case "number":
                {
                    const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNumberFormat"])(specifier);
                    if (options == null) return;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createNumberFormatter"])(options);
                }
            case "date":
                return buildDateFormatter(specifier);
            case "category":
                return (value)=>specifier.replace("%s", String(value));
        }
    }
    setFormatter(formatter2) {
        if (this.formatter !== formatter2) {
            this.formatter = formatter2;
            this.formats.clear();
            this.dateFormatter.reset();
            this.dispatch("format-changed");
        }
    }
    format(formatInContext, params) {
        let { specifier, truncateDate } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (params.value == null) return;
        const { formatter: formatter2 } = this;
        if (formatter2 == null) return;
        if (typeof formatter2 === "function") {
            const value = formatInContext(formatter2, params);
            return value != null ? String(value) : void 0;
        }
        const propertyFormatter = formatter2[params.property];
        if (propertyFormatter == null) return;
        if (typeof propertyFormatter === "function") {
            const value = formatInContext(propertyFormatter, params);
            return value != null ? String(value) : void 0;
        } else if (params.type === "date") {
            const { unit, style } = params;
            const dateFormatter = this.dateFormatter(propertyFormatter, specifier, unit, style, truncateDate);
            return dateFormatter === null || dateFormatter === void 0 ? void 0 : dateFormatter(params.value);
        }
        const valueSpecifier = specifier !== null && specifier !== void 0 ? specifier : propertyFormatter;
        if (typeof valueSpecifier !== "string") return;
        let valueFormatter = this.formats.get(valueSpecifier);
        if (valueFormatter == null) {
            valueFormatter = _FormatManager.getFormatter(params.type, valueSpecifier);
            this.formats.set(valueSpecifier, valueFormatter);
        }
        return valueFormatter === null || valueFormatter === void 0 ? void 0 : valueFormatter(params.value, params.type === "number" ? params.fractionDigits : void 0);
    }
    defaultFormat(params) {
        let { specifier, truncateDate } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const { formatter: formatter2 } = this;
        const propertyFormatter = typeof formatter2 === "function" ? void 0 : formatter2 === null || formatter2 === void 0 ? void 0 : formatter2[params.property];
        switch(params.type){
            case "date":
                {
                    const { unit, style } = params;
                    const propertySpecifier = propertyFormatter != null && typeof propertyFormatter !== "function" ? propertyFormatter : void 0;
                    const dateFormatter = this.dateFormatter(propertySpecifier, specifier, unit, style, truncateDate);
                    var _dateFormatter;
                    return (_dateFormatter = dateFormatter === null || dateFormatter === void 0 ? void 0 : dateFormatter(params.value)) !== null && _dateFormatter !== void 0 ? _dateFormatter : String(params.value);
                }
            case "number":
                return formatValue(params.value, params.fractionDigits);
            case "category":
                if (Array.isArray(params.value)) {
                    return params.value.join(" - ");
                } else if (typeof params.value === "string") {
                    return params.value;
                } else if (typeof params.value === "number") {
                    return formatValue(params.value);
                } else {
                    return String(params.value);
                }
        }
    }
    constructor(){
        super(...arguments);
        this.formats = /* @__PURE__ */ new Map();
        this.dateFormatter = simpleMemorize2((propertyFormatter, specifier, unit, style, truncateDate)=>{
            var _FormatManager_mergeSpecifiers;
            const mergedFormatter = (_FormatManager_mergeSpecifiers = _FormatManager.mergeSpecifiers(propertyFormatter, specifier)) !== null && _FormatManager_mergeSpecifiers !== void 0 ? _FormatManager_mergeSpecifiers : defaultTimeFormats;
            return _FormatManager.getFormatter("date", mergedFormatter, unit, style, {
                truncateDate
            });
        });
        this.formatter = void 0;
    }
};
;
;
// packages/ag-charts-community/src/util/interpolate.ts
function interpolateNumber(a, b) {
    return (d)=>Number(a) * (1 - d) + Number(b) * d;
}
function interpolateColor(a, b) {
    if (typeof a === "string") {
        try {
            a = Color.fromString(a);
        } catch (e) {
            a = Color.fromArray([
                0,
                0,
                0
            ]);
        }
    }
    if (typeof b === "string") {
        try {
            b = Color.fromString(b);
        } catch (e) {
            b = Color.fromArray([
                0,
                0,
                0
            ]);
        }
    }
    return (d)=>Color.mix(a, b, d).toRgbaString();
}
// packages/ag-charts-community/src/motion/easing.ts
var easing_exports = {};
__export(easing_exports, {
    easeIn: ()=>easeIn,
    easeInOut: ()=>easeInOut,
    easeInOutQuad: ()=>easeInOutQuad,
    easeInQuad: ()=>easeInQuad,
    easeOut: ()=>easeOut,
    easeOutQuad: ()=>easeOutQuad,
    inverseEaseOut: ()=>inverseEaseOut,
    linear: ()=>linear
});
var linear = (n)=>n;
var easeIn = (n)=>1 - Math.cos(n * Math.PI / 2);
var easeOut = (n)=>Math.sin(n * Math.PI / 2);
var easeInOut = (n)=>-(Math.cos(n * Math.PI) - 1) / 2;
var easeInQuad = (n)=>n * n;
var easeOutQuad = (n)=>1 - (1 - n) ** 2;
var easeInOutQuad = (n)=>n < 0.5 ? 2 * n * n : 1 - (-2 * n + 2) ** 2 / 2;
var inverseEaseOut = (x)=>2 * Math.asin(x) / Math.PI;
// packages/ag-charts-community/src/motion/animation.ts
var QUICK_TRANSITION = 0.2;
var PHASE_ORDER = [
    "initial",
    "remove",
    "update",
    "add",
    "trailing",
    "end",
    "none"
];
var PHASE_METADATA = {
    initial: {
        animationDuration: 1,
        animationDelay: 0
    },
    add: {
        animationDuration: 0.25,
        animationDelay: 0.75
    },
    remove: {
        animationDuration: 0.25,
        animationDelay: 0
    },
    update: {
        animationDuration: 0.5,
        animationDelay: 0.25
    },
    trailing: {
        animationDuration: QUICK_TRANSITION,
        animationDelay: 1,
        skipIfNoEarlierAnimations: true
    },
    end: {
        animationDelay: 1 + QUICK_TRANSITION,
        animationDuration: 0,
        skipIfNoEarlierAnimations: true
    },
    none: {
        animationDuration: 0,
        animationDelay: 0
    }
};
var RepeatType = /* @__PURE__ */ ((RepeatType2)=>{
    RepeatType2["Loop"] = "loop";
    RepeatType2["Reverse"] = "reverse";
    return RepeatType2;
})(RepeatType || {});
function isNodeArray(array6) {
    return array6.every((n)=>n instanceof Node2);
}
function deconstructSelectionsOrNodes(selectionsOrNodes) {
    return isNodeArray(selectionsOrNodes) ? {
        nodes: selectionsOrNodes,
        selections: []
    } : {
        nodes: [],
        selections: selectionsOrNodes
    };
}
function animationValuesEqual(a, b) {
    if (a === b) {
        return true;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        return a.length === b.length && a.every((v, i)=>animationValuesEqual(v, b[i]));
    } else if (isInterpolating(a) && isInterpolating(b)) {
        return a.equals(b);
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(a) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(b)) {
        return objectsEqualWith(a, b, animationValuesEqual);
    }
    return false;
}
var Animation = class {
    checkCollapse(opts, calculatedDuration) {
        return animationValuesEqual(opts.from, opts.to) ? 0 : calculatedDuration;
    }
    play() {
        let initialUpdate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var _this_onPlay, _this, _this_onUpdate, _this1;
        if (this.isPlaying || this.isComplete) return;
        this.isPlaying = true;
        (_this_onPlay = (_this = this).onPlay) === null || _this_onPlay === void 0 ? void 0 : _this_onPlay.call(_this, this);
        if (!this.autoplay) return;
        this.autoplay = false;
        if (!initialUpdate) return;
        (_this_onUpdate = (_this1 = this).onUpdate) === null || _this_onUpdate === void 0 ? void 0 : _this_onUpdate.call(_this1, this.from, true, this);
    }
    stop() {
        this.isPlaying = false;
        if (!this.isComplete) {
            var _this_onStop, _this;
            this.isComplete = true;
            (_this_onStop = (_this = this).onStop) === null || _this_onStop === void 0 ? void 0 : _this_onStop.call(_this, this);
        }
    }
    update(time3) {
        var _this_onUpdate, _this;
        if (this.isComplete) return time3;
        if (!this.isPlaying && this.autoplay) {
            this.play(true);
        }
        const previousElapsed = this.elapsed;
        this.elapsed += time3;
        if (this.delay > this.elapsed) return 0;
        const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);
        (_this_onUpdate = (_this = this).onUpdate) === null || _this_onUpdate === void 0 ? void 0 : _this_onUpdate.call(_this, value, false, this);
        const totalDuration = this.delay + this.duration;
        if (this.elapsed >= totalDuration) {
            var _this_onComplete, _this1;
            this.stop();
            this.isComplete = true;
            (_this_onComplete = (_this1 = this).onComplete) === null || _this_onComplete === void 0 ? void 0 : _this_onComplete.call(_this1, this);
            return time3 - (totalDuration - previousElapsed);
        }
        return 0;
    }
    get delta() {
        return this.ease((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, (this.elapsed - this.delay) / this.duration, 1));
    }
    createInterpolator(from3, to) {
        if (typeof to !== "object" || isInterpolating(to)) {
            return this.interpolateValue(from3, to);
        }
        const interpolatorEntries = [];
        for (const key of Object.keys(to)){
            const interpolator = this.interpolateValue(from3[key], to[key]);
            if (interpolator != null) {
                interpolatorEntries.push([
                    key,
                    interpolator
                ]);
            }
        }
        return (d)=>{
            const result = {};
            for (const [key, interpolator] of interpolatorEntries){
                result[key] = interpolator(d);
            }
            return result;
        };
    }
    interpolateValue(a, b) {
        if (a == null || b == null) {
            return;
        } else if (isInterpolating(a)) {
            return (d)=>a[interpolate](b, d);
        }
        try {
            switch(typeof a){
                case "number":
                    return interpolateNumber(a, b);
                case "string":
                    return interpolateColor(a, b);
                case "boolean":
                    if (a === b) {
                        return ()=>a;
                    }
                    break;
                case "object":
                    return ()=>a;
                default:
                    throw new Error("Unable to interpolate values: ".concat(a, ", ").concat(b));
            }
        } catch (e) {}
        throw new Error("Unable to interpolate values: ".concat(a, ", ").concat(b));
    }
    constructor(opts){
        this.isComplete = false;
        this.elapsed = 0;
        this.iteration = 0;
        this.isPlaying = false;
        this.isReverse = false;
        this.id = opts.id;
        this.groupId = opts.groupId;
        var _opts_autoplay;
        this.autoplay = (_opts_autoplay = opts.autoplay) !== null && _opts_autoplay !== void 0 ? _opts_autoplay : true;
        var _opts_ease;
        this.ease = (_opts_ease = opts.ease) !== null && _opts_ease !== void 0 ? _opts_ease : linear;
        this.phase = opts.phase;
        var _opts_duration;
        const durationProportion = (_opts_duration = opts.duration) !== null && _opts_duration !== void 0 ? _opts_duration : PHASE_METADATA[this.phase].animationDuration;
        this.duration = durationProportion * opts.defaultDuration;
        var _opts_delay;
        this.delay = ((_opts_delay = opts.delay) !== null && _opts_delay !== void 0 ? _opts_delay : 0) * opts.defaultDuration;
        this.onComplete = opts.onComplete;
        this.onPlay = opts.onPlay;
        this.onStop = opts.onStop;
        this.onUpdate = opts.onUpdate;
        this.interpolate = this.createInterpolator(opts.from, opts.to);
        this.from = opts.from;
        if (opts.skip === true) {
            var _this_onUpdate, _this, _this_onStop, _this1, _this_onComplete, _this2;
            (_this_onUpdate = (_this = this).onUpdate) === null || _this_onUpdate === void 0 ? void 0 : _this_onUpdate.call(_this, opts.to, false, this);
            (_this_onStop = (_this1 = this).onStop) === null || _this_onStop === void 0 ? void 0 : _this_onStop.call(_this1, this);
            (_this_onComplete = (_this2 = this).onComplete) === null || _this_onComplete === void 0 ? void 0 : _this_onComplete.call(_this2, this);
            this.isComplete = true;
        }
        if (opts.collapsable !== false) {
            this.duration = this.checkCollapse(opts, this.duration);
        }
    }
};
;
var AnimationBatch = class {
    get size() {
        return this.controllers.size;
    }
    get consumedTimeMs() {
        return this.animationTimeConsumed;
    }
    isActive() {
        return this.controllers.size > 0;
    }
    getActiveControllers() {
        var _this_phases_get;
        return (_this_phases_get = this.phases.get(PHASE_ORDER[this.currentPhase])) !== null && _this_phases_get !== void 0 ? _this_phases_get : [];
    }
    checkOverlappingId(id) {
        if (id != null && this.controllers.has(id)) {
            this.controllers.get(id).stop();
            this.debug("Skipping animation batch due to update of existing animation: ".concat(id));
            this.skip();
        }
    }
    addAnimation(animation) {
        var _this_phases_get;
        if (animation.isComplete) return;
        const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);
        if (animationPhaseIdx < this.currentPhase) {
            this.debug("Skipping animation due to being for an earlier phase", animation.id);
            animation.stop();
            return;
        }
        this.controllers.set(animation.id, animation);
        (_this_phases_get = this.phases.get(animation.phase)) === null || _this_phases_get === void 0 ? void 0 : _this_phases_get.push(animation);
    }
    removeAnimation(animation) {
        this.controllers.delete(animation.id);
        const phase = this.phases.get(animation.phase);
        const index = phase === null || phase === void 0 ? void 0 : phase.indexOf(animation);
        if (index != null && index >= 0) {
            phase === null || phase === void 0 ? void 0 : phase.splice(index, 1);
        }
    }
    progress(deltaTime) {
        if (!this.isReady) return;
        let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;
        const refresh = ()=>{
            const phase2 = PHASE_ORDER[this.currentPhase];
            return {
                phaseControllers: [
                    ...this.getActiveControllers()
                ],
                phase: phase2,
                phaseMeta: PHASE_METADATA[phase2]
            };
        };
        let { phase, phaseControllers, phaseMeta } = refresh();
        const arePhasesComplete = ()=>PHASE_ORDER[this.currentPhase] == null;
        const progressPhase = ()=>{
            ({ phase, phaseControllers, phaseMeta } = refresh());
            while(!arePhasesComplete() && phaseControllers.length === 0){
                this.currentPhase++;
                ({ phase, phaseControllers, phaseMeta } = refresh());
                this.debug("AnimationBatch - phase changing to ".concat(phase), {
                    unusedTime
                }, phaseControllers);
            }
        };
        const total = this.controllers.size;
        this.debug("AnimationBatch - ".concat(deltaTime, "ms; phase ").concat(phase, " with ").concat(phaseControllers === null || phaseControllers === void 0 ? void 0 : phaseControllers.length, " of ").concat(total));
        do {
            const phaseDeltaTime = unusedTime;
            const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;
            let completeCount = 0;
            for (const controller of phaseControllers){
                if (skipPhase) {
                    controller.stop();
                } else {
                    unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);
                }
                if (controller.isComplete) {
                    completeCount++;
                    this.removeAnimation(controller);
                }
            }
            this.animationTimeConsumed += phaseDeltaTime - unusedTime;
            this.debug("AnimationBatch - updated ".concat(phaseControllers.length, " controllers; ").concat(completeCount, " completed"), phaseControllers);
            this.debug("AnimationBatch - animationTimeConsumed: ".concat(this.animationTimeConsumed));
            progressPhase();
        }while (unusedTime > 0 && !arePhasesComplete())
        if (this.animationTimeConsumed > this.maxAnimationTime) {
            this.debug("Animation batch exceeded max animation time, skipping", [
                ...this.controllers
            ]);
            this.stop();
        }
    }
    ready() {
        if (this.isReady) return;
        this.isReady = true;
        this.debug("AnimationBatch - ready; skipped: ".concat(this.skipAnimations), [
            ...this.controllers
        ]);
        let skipAll = true;
        for (const [, controller] of this.controllers){
            if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {
                skipAll = false;
                break;
            }
        }
        if (!skipAll) {
            for (const [, controller] of this.controllers){
                if (controller.autoplay) {
                    controller.play(true);
                }
            }
        }
    }
    skip() {
        let skip = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (this.skipAnimations === false && skip === true) {
            for (const controller of this.controllers.values()){
                controller.stop();
            }
            this.controllers.clear();
        }
        this.skipAnimations = skip;
    }
    play() {
        for (const controller of this.controllers.values()){
            controller.play();
        }
    }
    stop() {
        for (const controller of this.controllers.values()){
            try {
                controller.stop();
                this.removeAnimation(controller);
            } catch (error) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].error("Error during animation stop", error);
            }
        }
        this.dispatchStopped();
    }
    stopByAnimationId(id) {
        if (id != null && this.controllers.has(id)) {
            const controller = this.controllers.get(id);
            if (controller) {
                controller.stop();
                this.removeAnimation(controller);
            }
        }
    }
    stopByAnimationGroupId(id) {
        for (const controller of this.controllers.values()){
            if (controller.groupId === id) {
                this.stopByAnimationId(controller.id);
            }
        }
    }
    dispatchStopped() {
        this.stoppedCbs.forEach((cb)=>cb());
        this.stoppedCbs.clear();
    }
    isSkipped() {
        return this.skipAnimations;
    }
    getRemainingTime(restrictPhase) {
        if (!this.isActive()) return 0;
        let total = 0;
        for (const [phase, controllers] of this.phases){
            if (controllers.length === 0) continue;
            if (restrictPhase != null && restrictPhase !== phase) continue;
            total += Math.max(...controllers.map((c)=>{
                var _c_elapsed;
                return c.isComplete ? 0 : c.delay + c.duration - ((_c_elapsed = c.elapsed) !== null && _c_elapsed !== void 0 ? _c_elapsed : 0);
            }));
        }
        return total;
    }
    destroy() {
        this.stop();
        this.controllers.clear();
    }
    constructor(maxAnimationTime){
        this.maxAnimationTime = maxAnimationTime;
        this.debug = Debug.create(true, "animation");
        this.controllers = /* @__PURE__ */ new Map();
        this.stoppedCbs = /* @__PURE__ */ new Set();
        this.currentPhase = 0;
        this.phases = new Map(PHASE_ORDER.map((p)=>[
                p,
                []
            ]));
        this.skipAnimations = false;
        this.animationTimeConsumed = 0;
        /** Guard against premature animation execution. */ this.isReady = false;
    }
};
// packages/ag-charts-community/src/chart/interaction/interactionManager.ts
var InteractionState = /* @__PURE__ */ ((InteractionState2)=>{
    InteractionState2[InteractionState2["Default"] = 32] = "Default";
    InteractionState2[InteractionState2["ZoomDrag"] = 16] = "ZoomDrag";
    InteractionState2[InteractionState2["Annotations"] = 8] = "Annotations";
    InteractionState2[InteractionState2["ContextMenu"] = 4] = "ContextMenu";
    InteractionState2[InteractionState2["Animation"] = 2] = "Animation";
    InteractionState2[InteractionState2["AnnotationsSelected"] = 1] = "AnnotationsSelected";
    InteractionState2[InteractionState2["Clickable"] = 41] = "Clickable";
    InteractionState2[InteractionState2["Focusable"] = 34] = "Focusable";
    InteractionState2[InteractionState2["Keyable"] = 43] = "Keyable";
    InteractionState2[InteractionState2["ContextMenuable"] = 36] = "ContextMenuable";
    InteractionState2[InteractionState2["AnnotationsMoveable"] = 9] = "AnnotationsMoveable";
    InteractionState2[InteractionState2["AnnotationsDraggable"] = 57] = "AnnotationsDraggable";
    InteractionState2[InteractionState2["ZoomDraggable"] = 50] = "ZoomDraggable";
    InteractionState2[InteractionState2["ZoomClickable"] = 34] = "ZoomClickable";
    InteractionState2[InteractionState2["ZoomWheelable"] = 59] = "ZoomWheelable";
    InteractionState2[InteractionState2["All"] = 63] = "All";
    return InteractionState2;
})(InteractionState || {});
var InteractionManager = class {
    pushState(state) {
        this.stateQueue |= state;
    }
    popState(state) {
        this.stateQueue &= ~state;
    }
    isState(allowedStates) {
        return !!(this.stateQueue & -this.stateQueue & allowedStates);
    }
    constructor(){
        this.stateQueue = 32 /* Default */  | 2 /* Animation */ ;
    }
};
// packages/ag-charts-community/src/chart/interaction/animationManager.ts
function validAnimationDuration(testee) {
    if (testee == null) return true;
    return !isNaN(testee) && testee >= 0 && testee <= 2;
}
var AnimationManager = class {
    addListener(eventName, listener) {
        return this.events.on(eventName, listener);
    }
    /**
   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists
   * with the same `id`, immediately stop it.
   */ animate(opts) {
        const batch = this.batch;
        try {
            batch.checkOverlappingId(opts.id);
        } catch (error) {
            this.failsafeOnError(error);
            return;
        }
        let { id } = opts;
        if (id == null) {
            id = "__".concat(this.currentAnonymousAnimationId);
            this.currentAnonymousAnimationId += 1;
        }
        const skip = this.isSkipped() || opts.phase === "none";
        if (skip) {
            this.debug("AnimationManager - skipping animation");
        }
        const { delay, duration } = opts;
        if (!validAnimationDuration(delay)) {
            throw new Error("Animation delay of ".concat(delay, " is unsupported (").concat(id, ")"));
        }
        if (!validAnimationDuration(duration)) {
            throw new Error("Animation duration of ".concat(duration, " is unsupported (").concat(id, ")"));
        }
        const animation = new Animation({
            ...opts,
            id,
            skip,
            autoplay: this.isPlaying ? opts.autoplay : false,
            phase: opts.phase,
            defaultDuration: this.defaultDuration
        });
        if (this.forceTimeJump(animation, this.defaultDuration)) {
            return;
        }
        this.batch.addAnimation(animation);
        return animation;
    }
    play() {
        if (this.isPlaying) {
            return;
        }
        this.isPlaying = true;
        this.debug("AnimationManager.play()");
        try {
            this.batch.play();
        } catch (error) {
            this.failsafeOnError(error);
        }
        this.requestAnimation();
    }
    stop() {
        this.isPlaying = false;
        this.cancelAnimation();
        this.debug("AnimationManager.stop()");
        this.batch.stop();
    }
    stopByAnimationId(id) {
        try {
            this.batch.stopByAnimationId(id);
        } catch (error) {
            this.failsafeOnError(error);
        }
    }
    stopByAnimationGroupId(id) {
        try {
            this.batch.stopByAnimationGroupId(id);
        } catch (error) {
            this.failsafeOnError(error);
        }
    }
    reset() {
        if (this.isPlaying) {
            this.stop();
            this.play();
        } else {
            this.stop();
        }
    }
    skip() {
        let skip = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        this.skipAnimations = skip;
    }
    isSkipped() {
        return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();
    }
    isActive() {
        return this.isPlaying && this.batch.isActive();
    }
    getRemainingTime(phase) {
        return this.batch.getRemainingTime(phase);
    }
    skipCurrentBatch() {
        if (this.debug.check()) {
            this.debug("AnimationManager - skipCurrentBatch()", {
                stack: new Error().stack
            });
        }
        this.batch.skip();
    }
    /** Mocking point for tests to guarantee that animation updates happen. */ isSkippingFrames() {
        return true;
    }
    /** Mocking point for tests to capture requestAnimationFrame callbacks. */ scheduleAnimationFrame(cb) {
        this.requestId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])().requestAnimationFrame((t)=>{
            cb(t).catch((e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].error(e));
        });
    }
    /** Mocking point for tests to skip animations to a specific point in time. */ forceTimeJump(_animation, _defaultDuration) {
        return false;
    }
    requestAnimation() {
        if (!this.rafAvailable) return;
        if (!this.batch.isActive() || this.requestId !== null) return;
        let prevTime;
        const onAnimationFrame = async (time3)=>{
            await this.debug.group("AnimationManager.onAnimationFrame()", async ()=>{
                const executeAnimationFrame = ()=>{
                    const deltaTime = time3 - (prevTime !== null && prevTime !== void 0 ? prevTime : time3);
                    prevTime = time3;
                    this.debug("AnimationManager", {
                        controllersCount: this.batch.size,
                        deltaTime
                    });
                    this.interactionManager.pushState(2 /* Animation */ );
                    try {
                        this.batch.progress(deltaTime);
                    } catch (error) {
                        this.failsafeOnError(error);
                    }
                    this.events.emit("animation-frame", {
                        type: "animation-frame",
                        deltaMs: deltaTime
                    });
                };
                if (this.isSkippingFrames()) {
                    await this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);
                } else {
                    await this.chartUpdateMutex.acquire(executeAnimationFrame);
                }
                if (this.batch.isActive()) {
                    this.scheduleAnimationFrame(onAnimationFrame);
                } else {
                    this.batch.stop();
                    this.events.emit("animation-stop", {
                        type: "animation-stop",
                        deltaMs: this.batch.consumedTimeMs
                    });
                }
            });
        };
        this.events.emit("animation-start", {
            type: "animation-start",
            deltaMs: 0
        });
        this.scheduleAnimationFrame(onAnimationFrame);
    }
    cancelAnimation() {
        if (this.requestId === null) return;
        cancelAnimationFrame(this.requestId);
        this.events.emit("animation-stop", {
            type: "animation-stop",
            deltaMs: this.batch.consumedTimeMs
        });
        this.requestId = null;
        this.startBatch();
    }
    failsafeOnError(error) {
        let cancelAnimation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].error("Error during animation, skipping animations", error);
        if (cancelAnimation) {
            this.cancelAnimation();
        }
    }
    startBatch(skipAnimations) {
        this.debug("AnimationManager - startBatch() with skipAnimations=".concat(skipAnimations, "."));
        this.reset();
        this.batch.destroy();
        this.batch = new AnimationBatch(this.defaultDuration * 1.5);
        if (skipAnimations === true) {
            this.batch.skip();
        }
    }
    endBatch() {
        if (this.batch.isActive()) {
            this.batch.ready();
            this.requestAnimation();
        } else {
            this.interactionManager.popState(2 /* Animation */ );
            if (this.batch.isSkipped()) {
                this.batch.skip(false);
            }
        }
    }
    onBatchStop(cb) {
        this.batch.stoppedCbs.add(cb);
    }
    destroy() {
        this.stop();
        this.events.clear();
    }
    constructor(interactionManager, chartUpdateMutex){
        this.interactionManager = interactionManager;
        this.chartUpdateMutex = chartUpdateMutex;
        this.defaultDuration = 1e3;
        this.batch = new AnimationBatch(this.defaultDuration * 1.5);
        this.debug = Debug.create(true, "animation");
        this.events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventEmitter"]();
        this.rafAvailable = typeof requestAnimationFrame !== "undefined";
        this.isPlaying = true;
        this.requestId = null;
        this.skipAnimations = true;
        this.currentAnonymousAnimationId = 0;
    }
};
// packages/ag-charts-community/src/chart/interaction/contextMenuTypes.ts
var ContextMenuBuiltinItems = class {
    constructor(){
        this.download = {
            type: "action",
            showOn: "always",
            label: "contextMenuDownload",
            enabled: true,
            action: void 0,
            items: void 0
        };
        this["zoom-to-cursor"] = {
            type: "action",
            showOn: "series-area",
            label: "contextMenuZoomToCursor",
            enabled: true,
            action: void 0,
            items: void 0
        };
        this["pan-to-cursor"] = {
            type: "action",
            showOn: "series-area",
            label: "contextMenuPanToCursor",
            enabled: true,
            action: void 0,
            items: void 0
        };
        this["reset-zoom"] = {
            type: "action",
            showOn: "series-area",
            label: "contextMenuResetZoom",
            enabled: true,
            action: void 0,
            items: void 0
        };
        this["toggle-series-visibility"] = {
            type: "action",
            showOn: "legend-item",
            label: "contextMenuToggleSeriesVisibility",
            enabled: true,
            action: void 0,
            items: void 0
        };
        this["toggle-other-series"] = {
            type: "action",
            showOn: "legend-item",
            label: "contextMenuToggleOtherSeries",
            enabled: true,
            action: void 0,
            items: void 0
        };
        this["separator"] = {
            type: "separator",
            showOn: "always",
            label: "separator",
            enabled: true,
            action: void 0,
            items: void 0
        };
    }
};
var ContextMenuBuiltinItemLists = class {
    constructor(){
        this.defaults = [
            "download",
            "zoom-to-cursor",
            "pan-to-cursor",
            "reset-zoom",
            "toggle-series-visibility",
            "toggle-other-series"
        ];
    }
};
var ContextMenuBuiltins = class {
    constructor(){
        this.items = new ContextMenuBuiltinItems();
        this.lists = new ContextMenuBuiltinItemLists();
    }
};
// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts
var ContextMenuRegistry = class {
    static check(showOn, event) {
        return event.showOn == showOn;
    }
    static checkCallback(desiredShowOn, showOn, _callback) {
        return desiredShowOn === showOn;
    }
    dispatchContext(showOn, pointerEvent, context, position) {
        const { widgetEvent } = pointerEvent;
        if (widgetEvent.sourceEvent.defaultPrevented) {
            return;
        }
        var _position_x;
        const x = (_position_x = position === null || position === void 0 ? void 0 : position.x) !== null && _position_x !== void 0 ? _position_x : pointerEvent.canvasX;
        var _position_y;
        const y = (_position_y = position === null || position === void 0 ? void 0 : position.y) !== null && _position_y !== void 0 ? _position_y : pointerEvent.canvasY;
        const event = {
            showOn,
            x,
            y,
            context,
            widgetEvent
        };
        this.eventsHub.emit("context-menu:setup", event);
        this.eventsHub.emit("context-menu:complete", event);
    }
    isVisible(id) {
        return !this.hiddenActions.has(id);
    }
    setVisible(id, visible) {
        if (visible) {
            this.hiddenActions.delete(id);
        } else {
            this.hiddenActions.add(id);
        }
    }
    constructor(eventsHub){
        this.eventsHub = eventsHub;
        this.builtins = new ContextMenuBuiltins();
        this.hiddenActions = /* @__PURE__ */ new Set();
        this.setVisible("zoom-to-cursor", false);
        this.setVisible("pan-to-cursor", false);
        this.setVisible("reset-zoom", false);
    }
};
// packages/ag-charts-community/src/chart/interaction/highlightManager.ts
var HighlightManager = class {
    updateHighlight(callerId, highlightedDatum) {
        const previousHighlight = this.getActiveHighlight();
        this.highlightStates.set(callerId, highlightedDatum);
        const currentHighlight = this.getActiveHighlight();
        if (!this.isEqual(currentHighlight, previousHighlight)) {
            this.eventsHub.emit("highlight:change", {
                callerId,
                currentHighlight,
                previousHighlight
            });
        }
    }
    getActiveHighlight() {
        return this.highlightStates.stateValue();
    }
    isEqual(a, b) {
        return a === b || a != null && b != null && (a === null || a === void 0 ? void 0 : a.series) === (b === null || b === void 0 ? void 0 : b.series) && (a === null || a === void 0 ? void 0 : a.itemId) === (b === null || b === void 0 ? void 0 : b.itemId) && (a === null || a === void 0 ? void 0 : a.datum) === (b === null || b === void 0 ? void 0 : b.datum);
    }
    constructor(eventsHub){
        this.eventsHub = eventsHub;
        this.highlightStates = new StateTracker();
    }
};
;
;
function datumBoundaryPoints(datum, domain) {
    if (datum == null || domain.length === 0) {
        return [
            false,
            false
        ];
    }
    const datumValue = datum.valueOf();
    const d0 = domain[0];
    const d1 = domain[domain.length - 1];
    if (typeof d0 === "string") {
        return [
            datumValue === d0,
            datumValue === d1
        ];
    }
    let min = d0.valueOf();
    let max = d1.valueOf();
    if (min > max) {
        [min, max] = [
            max,
            min
        ];
    }
    return [
        datumValue === min,
        datumValue === max
    ];
}
function datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain) {
    const [min, max] = datumBoundaryPoints(yValue, yDomain);
    const [first2, last] = datumBoundaryPoints(xValue, xDomain);
    return {
        xKey,
        yKey,
        xValue,
        yValue,
        first: first2,
        last,
        min,
        max
    };
}
function visibleRangeIndices(sortOrder, length2, param, xRange) {
    let [range0, range1] = param;
    var _findMinIndex;
    let xMinIndex = (_findMinIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMinIndex"])(0, length2 - 1, (i)=>{
        var _xRange;
        const index = sortOrder === 1 ? i : length2 - i;
        var _xRange_;
        const x1 = (_xRange_ = (_xRange = xRange(index)) === null || _xRange === void 0 ? void 0 : _xRange[1]) !== null && _xRange_ !== void 0 ? _xRange_ : NaN;
        return !Number.isFinite(x1) || x1 > range0;
    })) !== null && _findMinIndex !== void 0 ? _findMinIndex : 0;
    var _findMaxIndex;
    let xMaxIndex = (_findMaxIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMaxIndex"])(0, length2 - 1, (i)=>{
        var _xRange;
        const index = sortOrder === 1 ? i : length2 - i;
        var _xRange_;
        const x0 = (_xRange_ = (_xRange = xRange(index)) === null || _xRange === void 0 ? void 0 : _xRange[0]) !== null && _xRange_ !== void 0 ? _xRange_ : NaN;
        return !Number.isFinite(x0) || x0 < range1;
    })) !== null && _findMaxIndex !== void 0 ? _findMaxIndex : length2 - 1;
    if (sortOrder === -1) {
        [xMinIndex, xMaxIndex] = [
            length2 - xMaxIndex,
            length2 - xMinIndex
        ];
    }
    xMinIndex = Math.max(xMinIndex, 0);
    xMaxIndex = Math.min(xMaxIndex + 1, length2);
    return [
        xMinIndex,
        xMaxIndex
    ];
}
function getDatumRefPoint(series, datum, movedBounds) {
    var _datum_yBar, _series_datumMidPoint;
    if (movedBounds) {
        const { x, y, width: width2, height: height2 } = movedBounds;
        return {
            canvasX: x + width2 / 2,
            canvasY: y + height2 / 2
        };
    }
    var _datum_yBar_upperPoint, _ref;
    const refPoint = (_ref = (_datum_yBar_upperPoint = (_datum_yBar = datum.yBar) === null || _datum_yBar === void 0 ? void 0 : _datum_yBar.upperPoint) !== null && _datum_yBar_upperPoint !== void 0 ? _datum_yBar_upperPoint : datum.midPoint) !== null && _ref !== void 0 ? _ref : (_series_datumMidPoint = series.datumMidPoint) === null || _series_datumMidPoint === void 0 ? void 0 : _series_datumMidPoint.call(series, datum);
    if (refPoint) {
        const { x, y } = Transformable.toCanvasPoint(series.contentGroup, refPoint.x, refPoint.y);
        return {
            canvasX: Math.round(x),
            canvasY: Math.round(y)
        };
    }
}
function countExpandingSearch(min, max, start2, countUntil, iteratee) {
    let i = -1;
    let count = 0;
    let shift = 0;
    let reachedAnEnd = false;
    while(count < countUntil && i <= max - min){
        i += 1;
        const index = start2 + shift;
        if (!reachedAnEnd) shift *= -1;
        if (shift >= 0) shift += 1;
        if (reachedAnEnd && shift < 0) shift -= 1;
        if (index < min || index > max) {
            reachedAnEnd = true;
            continue;
        }
        if (iteratee(index)) count += 1;
    }
    return count;
}
// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts
var TooltipManager = class {
    destroy() {
        this.cleanup.flush();
    }
    updateTooltip(callerId, meta, content, pagination) {
        var _this_stateTracker_get;
        content !== null && content !== void 0 ? content : content = (_this_stateTracker_get = this.stateTracker.get(callerId)) === null || _this_stateTracker_get === void 0 ? void 0 : _this_stateTracker_get.content;
        this.stateTracker.set(callerId, {
            meta,
            content,
            pagination
        });
        this.applyStates();
    }
    removeTooltip(callerId) {
        this.stateTracker.delete(callerId);
        this.applyStates();
    }
    suppressTooltip(callerId) {
        this.suppressState.set(callerId, true);
    }
    unsuppressTooltip(callerId) {
        this.suppressState.delete(callerId);
    }
    applyStates() {
        var _this_appliedState, _this_appliedState1;
        const id = this.stateTracker.stateId();
        const state = id ? this.stateTracker.get(id) : void 0;
        if (this.suppressState.stateValue() || (state === null || state === void 0 ? void 0 : state.meta) == null || (state === null || state === void 0 ? void 0 : state.content) == null) {
            this.appliedState = null;
            this.tooltip.hide();
            return;
        }
        const canvasRect = this.domManager.getBoundingClientRect();
        const boundingRect = this.tooltip.bounds === "extended" ? this.domManager.getOverlayClientRect() : canvasRect;
        if (objectsEqual((_this_appliedState = this.appliedState) === null || _this_appliedState === void 0 ? void 0 : _this_appliedState.content, state === null || state === void 0 ? void 0 : state.content) && objectsEqual((_this_appliedState1 = this.appliedState) === null || _this_appliedState1 === void 0 ? void 0 : _this_appliedState1.pagination, state === null || state === void 0 ? void 0 : state.pagination)) {
            const renderInstantly = this.tooltip.isVisible();
            this.tooltip.show(boundingRect, canvasRect, state === null || state === void 0 ? void 0 : state.meta, null, void 0, renderInstantly);
        } else {
            this.tooltip.show(boundingRect, canvasRect, state === null || state === void 0 ? void 0 : state.meta, state === null || state === void 0 ? void 0 : state.content, state === null || state === void 0 ? void 0 : state.pagination);
        }
        this.appliedState = state;
    }
    static makeTooltipMeta(event, series, datum, movedBounds) {
        var _tooltip_interaction;
        const { canvasX, canvasY } = event;
        const tooltip = series.properties.tooltip;
        const { placement, anchorTo, xOffset, yOffset } = tooltip.position;
        const refPoint = getDatumRefPoint(series, datum, movedBounds);
        var _refPoint_canvasX, _refPoint_canvasY, _tooltip_interaction_enabled;
        const meta = {
            canvasX,
            canvasY,
            nodeCanvasX: (_refPoint_canvasX = refPoint === null || refPoint === void 0 ? void 0 : refPoint.canvasX) !== null && _refPoint_canvasX !== void 0 ? _refPoint_canvasX : canvasX,
            nodeCanvasY: (_refPoint_canvasY = refPoint === null || refPoint === void 0 ? void 0 : refPoint.canvasY) !== null && _refPoint_canvasY !== void 0 ? _refPoint_canvasY : canvasY,
            enableInteraction: (_tooltip_interaction_enabled = (_tooltip_interaction = tooltip.interaction) === null || _tooltip_interaction === void 0 ? void 0 : _tooltip_interaction.enabled) !== null && _tooltip_interaction_enabled !== void 0 ? _tooltip_interaction_enabled : false,
            showArrow: tooltip.showArrow,
            position: {
                placement,
                anchorTo,
                xOffset,
                yOffset
            }
        };
        return meta;
    }
    constructor(eventsHub, localeManager, domManager, tooltip){
        this.domManager = domManager;
        this.tooltip = tooltip;
        this.stateTracker = new StateTracker();
        this.suppressState = new StateTracker(false);
        this.appliedState = null;
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.cleanup.register(tooltip.setup(localeManager, domManager), eventsHub.on("dom:hidden", ()=>this.tooltip.hide()));
    }
};
;
var DRAG_THRESHOLD_PX = 3;
var DOUBLE_TAP_TIMER_MS = 505;
var DOUBLE_TAP_THRESHOLD_PX = 30;
function makeSynthetic(type, event) {
    const { device, offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent } = event;
    return {
        type,
        device,
        offsetX,
        offsetY,
        clientX,
        clientY,
        currentX,
        currentY,
        sourceEvent
    };
}
function checkDragDistance(dx, dy) {
    const distanceSquared2 = dx * dx + dy * dy;
    const thresholdSquared = DRAG_THRESHOLD_PX * DRAG_THRESHOLD_PX;
    return distanceSquared2 >= thresholdSquared;
}
function checkDoubleTapDistance(t1, t2) {
    const dx = t1.clientX - t2.clientX;
    const dy = t1.clientY - t2.clientY;
    const distanceSquared2 = dx * dx + dy * dy;
    const thresholdSquared = DOUBLE_TAP_THRESHOLD_PX * DOUBLE_TAP_THRESHOLD_PX;
    return distanceSquared2 < thresholdSquared;
}
var DragInterpreter = class {
    destroy() {
        this.cleanup.flush();
    }
    onTouchStart(e) {
        var _e_sourceEvent_targetTouches_;
        const { clientX, clientY } = (_e_sourceEvent_targetTouches_ = e.sourceEvent.targetTouches[0]) !== null && _e_sourceEvent_targetTouches_ !== void 0 ? _e_sourceEvent_targetTouches_ : {
            clientX: Infinity,
            clientY: Infinity
        };
        this.touch.distanceTravelledX = 0;
        this.touch.distanceTravelledY = 0;
        this.touch.clientX = clientX;
        this.touch.clientY = clientY;
    }
    onTouchMove(e) {
        var _e_sourceEvent_targetTouches_;
        const { clientX, clientY } = (_e_sourceEvent_targetTouches_ = e.sourceEvent.targetTouches[0]) !== null && _e_sourceEvent_targetTouches_ !== void 0 ? _e_sourceEvent_targetTouches_ : {
            clientX: Infinity,
            clientY: Infinity
        };
        this.touch.distanceTravelledX += Math.abs(this.touch.clientX - clientX);
        this.touch.distanceTravelledY += Math.abs(this.touch.clientY - clientY);
        this.touch.clientX = clientX;
        this.touch.clientY = clientY;
    }
    onTouchEnd(event) {
        event.sourceEvent.preventDefault();
    }
    onMouseMove(event) {
        this.events.emit("mousemove", event);
    }
    onDblClick(event) {
        this.events.emit("dblclick", event);
    }
    onDragStart(event) {
        this.dragStartEvent = event;
    }
    onDragMove(event) {
        if (this.dragStartEvent != null) {
            if (checkDragDistance(event.originDeltaX, event.originDeltaY)) {
                this.events.emit("drag-start", this.dragStartEvent);
                this.events.emit("drag-move", {
                    ...this.dragStartEvent,
                    type: "drag-move"
                });
                this.dragStartEvent = void 0;
                this.isDragging = true;
            }
        }
        if (this.isDragging) {
            this.events.emit("drag-move", event);
        }
    }
    onDragEnd(event) {
        if (this.isDragging) {
            this.events.emit("drag-end", event);
            this.isDragging = false;
            return;
        }
        if (event.device === "mouse") {
            const click = makeSynthetic("click", event);
            this.events.emit("click", click);
        } else if (event.sourceEvent.type === "touchend") {
            if (checkDragDistance(this.touch.distanceTravelledX, this.touch.distanceTravelledY)) {
                return;
            }
            const click = makeSynthetic("click", event);
            this.events.emit("click", click);
            const now = Date.now();
            if (this.lastClick !== void 0 && now - this.lastClick.time <= DOUBLE_TAP_TIMER_MS && checkDoubleTapDistance(this.lastClick, event)) {
                const dblClick = makeSynthetic("dblclick", event);
                this.events.emit("dblclick", dblClick);
                this.lastClick = void 0;
            } else {
                this.lastClick = {
                    time: now,
                    clientX: event.clientX,
                    clientY: event.clientY
                };
            }
        }
    }
    constructor(widget){
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventEmitter"]();
        this.isDragging = false;
        this.touch = {
            distanceTravelledX: 0,
            distanceTravelledY: 0,
            clientX: 0,
            clientY: 0
        };
        this.cleanup.register(widget.addListener("touchstart", this.onTouchStart.bind(this)), widget.addListener("touchmove", this.onTouchMove.bind(this)), widget.addListener("touchend", this.onTouchEnd.bind(this)), widget.addListener("mousemove", this.onMouseMove.bind(this)), widget.addListener("dblclick", this.onDblClick.bind(this)), widget.addListener("drag-start", this.onDragStart.bind(this)), widget.addListener("drag-move", this.onDragMove.bind(this)), widget.addListener("drag-end", this.onDragEnd.bind(this)));
    }
};
// packages/ag-charts-community/src/chart/interaction/widgetSet.ts
var DOMManagerWidget = class extends NativeWidget {
    addChildToDOM() {}
    removeChildFromDOM() {}
    constructor(elem){
        super(elem);
    }
};
var WidgetSet = class {
    destroy() {
        var _this_seriesDragInterpreter;
        (_this_seriesDragInterpreter = this.seriesDragInterpreter) === null || _this_seriesDragInterpreter === void 0 ? void 0 : _this_seriesDragInterpreter.destroy();
        this.seriesWidget.destroy();
        this.chartWidget.destroy();
        this.containerWidget.destroy();
    }
    constructor(domManager, opts){
        this.seriesWidget = new DOMManagerWidget(domManager.getParent("series-area"));
        this.chartWidget = new DOMManagerWidget(domManager.getParent("canvas-proxy"));
        this.containerWidget = new DOMManagerWidget(domManager.getParent("canvas-container"));
        this.containerWidget.addChild(this.chartWidget);
        this.chartWidget.addChild(this.seriesWidget);
        if (opts.withDragInterpretation) {
            this.seriesDragInterpreter = new DragInterpreter(this.seriesWidget);
        }
    }
};
;
;
function clampArray(value, array6) {
    const [min, max] = findMinMax(array6);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(min, value, max);
}
function findMinMax(array6) {
    if (array6.length === 0) return [];
    const result = [
        Infinity,
        -Infinity
    ];
    for (const val of array6){
        if (val < result[0]) result[0] = val;
        if (val > result[1]) result[1] = val;
    }
    return result;
}
function findRangeExtent(array6) {
    const [min, max] = findMinMax(array6);
    return max - min;
}
function nextPowerOf2(value) {
    value = value | 0;
    if (value <= 0) return 1;
    if (value === 1) return 2;
    return 1 << 32 - Math.clz32(value - 1);
}
function previousPowerOf2(value) {
    value = value | 0;
    if (value <= 0) return 0;
    if (value === 1) return 1;
    return 1 << 31 - Math.clz32(value);
}
// packages/ag-charts-community/src/scale/continuousScale.ts
var _ContinuousScale = class _ContinuousScale extends AbstractScale {
    static is(value) {
        return value instanceof _ContinuousScale;
    }
    normalizeDomains() {
        for(var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++){
            domains[_key] = arguments[_key];
        }
        return normalizeContinuousDomains(...domains);
    }
    calcBandwidth() {
        let smallestInterval = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, minWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        const { domain } = this;
        const rangeDistance = this.getPixelRange();
        if (domain.length === 0) return rangeDistance;
        const intervals = Math.abs(domain[1].valueOf() - domain[0].valueOf()) / smallestInterval + 1;
        let bands = intervals;
        if (minWidth !== 0) {
            const maxBands = Math.floor(rangeDistance);
            bands = Math.min(bands, maxBands);
        }
        return rangeDistance / Math.max(1, bands);
    }
    convert(value, options) {
        const { domain } = this;
        if (!domain || domain.length < 2 || value == null) {
            return NaN;
        }
        const { range: range3 } = this;
        var _options_clamp;
        const clamp26 = (_options_clamp = options === null || options === void 0 ? void 0 : options.clamp) !== null && _options_clamp !== void 0 ? _options_clamp : this.defaultClamp;
        let d0 = domain[0].valueOf();
        let d1 = domain[1].valueOf();
        let x = value.valueOf();
        if (this.transform) {
            d0 = this.transform(d0);
            d1 = this.transform(d1);
            x = this.transform(x);
        }
        if (clamp26) {
            const [start2, stop] = findMinMax([
                d0,
                d1
            ]);
            if (x < start2) {
                return range3[0];
            } else if (x > stop) {
                return range3[1];
            }
        }
        if (d0 === d1) {
            return (range3[0] + range3[1]) / 2;
        } else if (x === d0) {
            return range3[0];
        } else if (x === d1) {
            return range3[1];
        }
        const r0 = range3[0];
        return r0 + (x - d0) / (d1 - d0) * (range3[1] - r0);
    }
    invert(x, _nearest) {
        const { domain } = this;
        if (domain.length < 2) return;
        let d0 = domain[0].valueOf();
        let d1 = domain[1].valueOf();
        if (this.transform) {
            d0 = this.transform(d0);
            d1 = this.transform(d1);
        }
        const { range: range3 } = this;
        const [r0, r1] = range3;
        let d;
        if (r0 === r1) {
            d = this.toDomain((d0 + d1) / 2);
        } else {
            d = this.toDomain(d0 + (x - r0) / (r1 - r0) * (d1 - d0));
        }
        return this.transformInvert ? this.transformInvert(d) : d;
    }
    getPixelRange() {
        const [a, b] = this.range;
        return Math.abs(b - a);
    }
    constructor(domain = [], range3 = []){
        super();
        this.domain = domain;
        this.range = range3;
        this.defaultTickCount = _ContinuousScale.defaultTickCount;
        this.defaultClamp = false;
    }
};
_ContinuousScale.defaultTickCount = 5;
var ContinuousScale = _ContinuousScale;
function normalizeContinuousDomains() {
    for(var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++){
        domains[_key] = arguments[_key];
    }
    let min;
    let minValue = Infinity;
    let max;
    let maxValue = -Infinity;
    for (const domain of domains){
        for (const d of domain){
            const value = d.valueOf();
            if (value < minValue) {
                minValue = value;
                min = d;
            }
            if (value > maxValue) {
                maxValue = value;
                max = d;
            }
        }
    }
    if (min != null && max != null) {
        const domain = [
            min,
            max
        ];
        return {
            domain,
            animatable: true
        };
    } else {
        return {
            domain: [],
            animatable: false
        };
    }
}
;
;
var _BandScale = class _BandScale extends AbstractScale {
    static is(value) {
        return value instanceof _BandScale;
    }
    get bandwidth() {
        this.refresh();
        return this._bandwidth;
    }
    get step() {
        this.refresh();
        return this._step;
    }
    get inset() {
        this.refresh();
        return this._inset;
    }
    get rawBandwidth() {
        this.refresh();
        return this._rawBandwidth;
    }
    set padding(value) {
        value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, value, 1);
        this._paddingInner = value;
        this._paddingOuter = value;
    }
    get padding() {
        return this._paddingInner;
    }
    set paddingInner(value) {
        this.invalid = true;
        this._paddingInner = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, value, 1);
    }
    get paddingInner() {
        return this._paddingInner;
    }
    set paddingOuter(value) {
        this.invalid = true;
        this._paddingOuter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, value, 1);
    }
    get paddingOuter() {
        return this._paddingOuter;
    }
    refresh() {
        if (!this.invalid) return;
        this.invalid = false;
        this.update();
        if (this.invalid) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Expected update to not invalidate scale");
        }
    }
    convert(d, options) {
        this.refresh();
        const i = this.findIndex(d, options === null || options === void 0 ? void 0 : options.alignment);
        if (i == null || i < 0 || i >= this.bands.length) {
            return NaN;
        }
        return this.ordinalRange(i);
    }
    invertNearestIndex(position) {
        this.refresh();
        const bandCount = this.bands.length;
        if (bandCount === 0) return -1;
        let low = 0;
        let high = bandCount - 1;
        let closestDistance = Infinity;
        let closestIndex = 0;
        while(low <= high){
            const mid = (high + low) / 2 | 0;
            const p = this.ordinalRange(mid);
            const distance2 = Math.abs(p - position);
            if (distance2 === 0) return mid;
            if (distance2 < closestDistance) {
                closestDistance = distance2;
                closestIndex = mid;
            }
            if (p < position) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return closestIndex;
    }
    update() {
        const [r0, r1] = this.range;
        let { _paddingInner: paddingInner } = this;
        const { _paddingOuter: paddingOuter, round: round3, bands } = this;
        const bandCount = bands.length;
        if (bandCount === 0) return;
        const rangeDistance = r1 - r0;
        let rawStep;
        if (bandCount === 1) {
            paddingInner = 0;
            rawStep = rangeDistance * (1 - paddingOuter * 2);
        } else {
            rawStep = rangeDistance / Math.max(1, bandCount - paddingInner + paddingOuter * 2);
        }
        const step = round3 ? Math.floor(rawStep) : rawStep;
        let inset = r0 + (rangeDistance - step * (bandCount - paddingInner)) / 2;
        let bandwidth = step * (1 - paddingInner);
        if (round3) {
            inset = Math.round(inset);
            bandwidth = Math.round(bandwidth);
        }
        this._step = step;
        this._inset = inset;
        this._bandwidth = bandwidth;
        this._rawBandwidth = rawStep * (1 - paddingInner);
    }
    ordinalRange(i) {
        const { _inset: inset, _step: step, range: range3 } = this;
        const min = Math.min(range3[0], range3[1]);
        const max = Math.max(range3[0], range3[1]);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(min, inset + step * i, max);
    }
    constructor(){
        super(...arguments);
        this.invalid = true;
        this.range = [
            0,
            1
        ];
        this.round = false;
        this._bandwidth = 1;
        this._step = 1;
        this._inset = 1;
        this._rawBandwidth = 1;
        /**
     * The ratio of the range that is reserved for space between bands.
     */ this._paddingInner = 0;
        /**
     * The ratio of the range that is reserved for space before the first
     * and after the last band.
     */ this._paddingOuter = 0;
    }
};
__decorateClass([
    Invalidating
], _BandScale.prototype, "range", 2);
__decorateClass([
    Invalidating
], _BandScale.prototype, "round", 2);
var BandScale = _BandScale;
// packages/ag-charts-community/src/scale/discreteTimeScale.ts
var DiscreteTimeScale = class _DiscreteTimeScale extends BandScale {
    static is(value) {
        return value instanceof _DiscreteTimeScale;
    }
    toDomain(value) {
        return new Date(value);
    }
    convert(value, options) {
        if (!(value instanceof Date)) value = new Date(value);
        const { domain, bands } = this;
        if (domain.length <= 0) return NaN;
        const r0 = this.ordinalRange(0);
        const r1 = this.ordinalRange(bands.length - 1);
        if (bands.length === 0) return r0;
        if ((options === null || options === void 0 ? void 0 : options.clamp) === true) {
            const { range: range3 } = this;
            if (value < bands[0]) return range3[0];
            if (value > bands[bands.length - 1]) return range3[1];
        }
        var _options_alignment;
        const alignment = (_options_alignment = options === null || options === void 0 ? void 0 : options.alignment) !== null && _options_alignment !== void 0 ? _options_alignment : 0 /* Leading */ ;
        const reversed = domain[0].valueOf() > domain[domain.length - 1].valueOf();
        if (alignment !== 2 /* Interpolate */ ) {
            const r2 = super.convert(value, options);
            return reversed ? r1 - (r2 - r0) : r2;
        }
        const v = value.valueOf();
        var _this_findIndex;
        let bandIndex = (_this_findIndex = this.findIndex(value)) !== null && _this_findIndex !== void 0 ? _this_findIndex : 0;
        let dIndex;
        if (reversed) {
            bandIndex = Math.min(Math.max(bandIndex, 1), bands.length - 1);
            dIndex = -1;
        } else {
            bandIndex = Math.min(Math.max(bandIndex, 0), bands.length - 2);
            dIndex = 1;
        }
        const v0 = bands[bandIndex].valueOf();
        const v1 = bands[bandIndex + dIndex].valueOf();
        const vr0 = this.ordinalRange(bandIndex);
        const vr1 = this.ordinalRange(bandIndex + dIndex);
        const ratio11 = (v - v0) / (v1 - v0);
        const r = ratio11 * (vr1 - vr0) + vr0;
        return reversed ? r1 - (r - r0) : r;
    }
    invert(position) {
        let nearest = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        this.refresh();
        const { domain, bands } = this;
        if (domain.length <= 0) return;
        const reversed = domain[0].valueOf() > domain[domain.length - 1].valueOf();
        let index;
        if (nearest) {
            index = this.invertNearestIndex(position - this.bandwidth / 2);
        } else {
            const closestIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMinIndex"])(0, bands.length - 1, (i)=>{
                const p = this.ordinalRange(i);
                return p >= position;
            });
            index = closestIndex !== null && closestIndex !== void 0 ? closestIndex : bands.length - 1;
        }
        return bands[reversed ? bands.length - 1 - index : index];
    }
    findIndex(value) {
        let alignment = arguments.length > 1 && arguments[1] !== void 0 /* Leading */  ? arguments[1] : 0;
        const { bands } = this;
        const target = value.valueOf();
        if (alignment === 1 /* Trailing */ ) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMinIndex"])(0, bands.length - 1, (index)=>bands[index].valueOf() >= target);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMaxIndex"])(0, bands.length - 1, (index)=>bands[index].valueOf() <= target);
    }
};
;
// packages/ag-charts-community/src/util/vector4.ts
var Vec4 = {
    bottomCenter,
    center,
    clone,
    collides,
    end,
    from,
    height,
    round,
    start,
    topCenter,
    origin,
    width
};
function start(a) {
    return {
        x: a.x1,
        y: a.y1
    };
}
function end(a) {
    return {
        x: a.x2,
        y: a.y2
    };
}
function topCenter(a) {
    return {
        x: (a.x1 + a.x2) / 2,
        y: Math.min(a.y1, a.y2)
    };
}
function center(a) {
    return {
        x: (a.x1 + a.x2) / 2,
        y: (a.y1 + a.y2) / 2
    };
}
function bottomCenter(a) {
    return {
        x: (a.x1 + a.x2) / 2,
        y: Math.max(a.y1, a.y2)
    };
}
function width(a) {
    return Math.abs(a.x2 - a.x1);
}
function height(a) {
    return Math.abs(a.y2 - a.y1);
}
function round(a) {
    return {
        x1: Math.round(a.x1),
        y1: Math.round(a.y1),
        x2: Math.round(a.x2),
        y2: Math.round(a.y2)
    };
}
function clone(a) {
    return {
        x1: a.x1,
        y1: a.y1,
        x2: a.x2,
        y2: a.y2
    };
}
function collides(a, b) {
    const an = normalise(a);
    const bn = normalise(b);
    return an.x1 <= bn.x2 && an.x2 >= bn.x1 && an.y1 <= bn.y2 && an.y2 >= bn.y1;
}
function normalise(a) {
    return {
        x1: Math.min(a.x1, a.x2),
        x2: Math.max(a.x1, a.x2),
        y1: Math.min(a.y1, a.y2),
        y2: Math.max(a.y1, a.y2)
    };
}
function from(a, b, c, d) {
    if (typeof a === "number") {
        return {
            x1: a,
            y1: b,
            x2: c,
            y2: d
        };
    }
    if ("width" in a) {
        return normalise({
            x1: a.x,
            y1: a.y,
            x2: a.x + a.width,
            y2: a.y + a.height
        });
    }
    throw new Error("Values can not be converted into a vector4: [".concat(JSON.stringify(a), "] [").concat(b, "] [").concat(c, "] [").concat(d, "]"));
}
function origin() {
    return {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0
    };
}
// packages/ag-charts-community/src/util/panToBBox.ts
function normalize(screenMin, min, screenMax, max, target) {
    return min + (max - min) * ((target - screenMin) / (screenMax - screenMin));
}
function unnormalize(screenMin, min, screenMax, max, ratio11) {
    return screenMin + (ratio11 - min) * ((screenMax - screenMin) / (max - min));
}
function calcWorldAxis(viewportMin, viewportMax, ratio11) {
    return [
        unnormalize(viewportMin, ratio11.min, viewportMax, ratio11.max, 0),
        unnormalize(viewportMin, ratio11.min, viewportMax, ratio11.max, 1)
    ];
}
function calcWorldVec4(viewport, ratioX, ratioY) {
    const [x1, x2] = calcWorldAxis(viewport.x1, viewport.x2, ratioX);
    const [y1, y2] = calcWorldAxis(viewport.y1, viewport.y2, ratioY);
    return {
        x1,
        x2,
        y1,
        y2
    };
}
function panAxesUnnormalized(worldMin, worldMax, viewportMin, viewportMax, targetMin, targetMax) {
    if (viewportMin <= targetMin && targetMax <= viewportMax) return viewportMin;
    const minDiff = targetMin - viewportMin;
    const maxDiff = targetMax - viewportMax;
    const diff2 = Math.abs(minDiff) < Math.abs(maxDiff) ? minDiff : maxDiff;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(worldMin, viewportMin + diff2, worldMax);
}
function calcPanToBBoxRatios(viewportBBox, ratios, targetBBox) {
    const { x: ratioX = {
        min: 0,
        max: 1
    }, y: ratioY = {
        min: 0,
        max: 1
    } } = ratios;
    const target = Vec4.from(targetBBox);
    const viewport = Vec4.from(viewportBBox);
    const world = calcWorldVec4(viewport, ratioX, ratioY);
    const x = panAxesUnnormalized(world.x1, world.x2, viewport.x1, viewport.x2, target.x1, target.x2);
    const y = panAxesUnnormalized(world.y1, world.y2, viewport.y1, viewport.y2, target.y1, target.y2);
    const result = {
        x: {
            min: normalize(viewport.x1, ratioX.min, viewport.x2, ratioX.max, x),
            max: normalize(viewport.x1, ratioX.min, viewport.x2, ratioX.max, x + viewportBBox.width)
        },
        y: {
            min: normalize(viewport.y1, ratioY.min, viewport.y2, ratioY.max, y),
            max: normalize(viewport.y1, ratioY.min, viewport.y2, ratioY.max, y + viewportBBox.height)
        }
    };
    const diffX = result.x.max - result.x.min;
    const diffY = result.y.max - result.y.min;
    result.x.min = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, result.x.min, 1 - diffX);
    result.x.max = result.x.min + diffX;
    result.y.min = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, result.y.min, 1 - diffY);
    result.y.max = result.y.min + diffY;
    return result;
}
// packages/ag-charts-community/src/chart/rangeAlignment.ts
function rangeAlignment(start2, end2) {
    const startValue = start2 === null || start2 === void 0 ? void 0 : start2.valueOf();
    const endValue = end2 === null || end2 === void 0 ? void 0 : end2.valueOf();
    if (typeof startValue !== "number" || typeof endValue !== "number") return [
        void 0,
        void 0
    ];
    return startValue < endValue ? [
        0 /* Leading */ ,
        1 /* Trailing */ 
    ] : [
        1 /* Trailing */ ,
        0 /* Leading */ 
    ];
}
// packages/ag-charts-community/src/chart/interaction/zoomManager.ts
var ZoomManagerAutoScaleAxis = class {
    constructor(){
        this.enabled = false;
        this.padding = 0;
        this.manuallyAdjusted = false;
    }
};
var rangeValidator = (axis)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachDescription"])((value, param)=>{
        let { options } = param;
        if (!ContinuousScale.is(axis === null || axis === void 0 ? void 0 : axis.scale) && !DiscreteTimeScale.is(axis === null || axis === void 0 ? void 0 : axis.scale)) return true;
        if (value == null || options.end == null) return true;
        return value < options.end;
    }, "to be less than end");
var ZoomManager = class extends BaseManager {
    createMemento() {
        return this.getMementoRanges();
    }
    guardMemento(blob, messages) {
        if (blob == null) return true;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(blob)) return false;
        const primaryX = this.getPrimaryAxis("x" /* X */ );
        const primaryY = this.getPrimaryAxis("y" /* Y */ );
        const zoomMementoDefs = {
            rangeX: {
                start: rangeValidator(primaryX),
                end: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]
            },
            rangeY: {
                start: rangeValidator(primaryY),
                end: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]
            },
            ratioX: {
                start: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
                end: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]
            },
            ratioY: {
                start: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
                end: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]
            },
            autoScaledAxes: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]
        };
        const { invalid } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"])(blob, zoomMementoDefs);
        if (invalid.length > 0) {
            messages.push(...invalid.map(String));
            return false;
        }
        return true;
    }
    restoreMemento(version, mementoVersion, memento) {
        const { independentAxes } = this;
        if (!this.axes || !this.didLayoutAxes) {
            this.pendingMemento = {
                version,
                mementoVersion,
                memento
            };
            return;
        }
        this.pendingMemento = void 0;
        const zoom = this.getDefinedZoom();
        if (memento === null || memento === void 0 ? void 0 : memento.rangeX) {
            var _this_rangeToRatio;
            zoom.x = (_this_rangeToRatio = this.rangeToRatio(memento.rangeX, "x" /* X */ )) !== null && _this_rangeToRatio !== void 0 ? _this_rangeToRatio : {
                min: 0,
                max: 1
            };
        } else if (memento === null || memento === void 0 ? void 0 : memento.ratioX) {
            var _memento_ratioX_start, _memento_ratioX_end;
            zoom.x = {
                min: (_memento_ratioX_start = memento.ratioX.start) !== null && _memento_ratioX_start !== void 0 ? _memento_ratioX_start : 0,
                max: (_memento_ratioX_end = memento.ratioX.end) !== null && _memento_ratioX_end !== void 0 ? _memento_ratioX_end : 1
            };
        } else {
            zoom.x = {
                min: 0,
                max: 1
            };
        }
        if (!this.navigatorModule || this.zoomModule) {
            var _memento_autoScaledAxes;
            let yAutoScale = memento === null || memento === void 0 ? void 0 : (_memento_autoScaledAxes = memento.autoScaledAxes) === null || _memento_autoScaledAxes === void 0 ? void 0 : _memento_autoScaledAxes.includes("y");
            if (memento === null || memento === void 0 ? void 0 : memento.rangeY) {
                yAutoScale !== null && yAutoScale !== void 0 ? yAutoScale : yAutoScale = false;
                var _this_rangeToRatio1;
                zoom.y = (_this_rangeToRatio1 = this.rangeToRatio(memento.rangeY, "y" /* Y */ )) !== null && _this_rangeToRatio1 !== void 0 ? _this_rangeToRatio1 : {
                    min: 0,
                    max: 1
                };
            } else if (memento === null || memento === void 0 ? void 0 : memento.ratioY) {
                yAutoScale !== null && yAutoScale !== void 0 ? yAutoScale : yAutoScale = false;
                var _memento_ratioY_start, _memento_ratioY_end;
                zoom.y = {
                    min: (_memento_ratioY_start = memento.ratioY.start) !== null && _memento_ratioY_start !== void 0 ? _memento_ratioY_start : 0,
                    max: (_memento_ratioY_end = memento.ratioY.end) !== null && _memento_ratioY_end !== void 0 ? _memento_ratioY_end : 1
                };
            } else {
                yAutoScale !== null && yAutoScale !== void 0 ? yAutoScale : yAutoScale = true;
                const autoZoomY = yAutoScale ? this.getAutoScaleYZoom(zoom.x) : void 0;
                zoom.y = autoZoomY !== null && autoZoomY !== void 0 ? autoZoomY : {
                    min: 0,
                    max: 1
                };
            }
            zoom.autoScaleYAxis = yAutoScale;
        }
        this.lastRestoredState = zoom;
        if (independentAxes !== true) {
            this.updateZoom("zoom-manager", zoom);
            return;
        }
        const primaryX = this.getPrimaryAxis("x" /* X */ );
        const primaryY = this.getPrimaryAxis("y" /* Y */ );
        for (const axis of [
            primaryX,
            primaryY
        ]){
            if (!axis) continue;
            this.updateAxisZoom("zoom-manager", axis.id, zoom[axis.direction]);
        }
    }
    updateAxes(axes) {
        this.axes = axes;
        const zoomManagers = new Map(axes.map((axis)=>[
                axis.id,
                this.axisZoomManagers.get(axis.id)
            ]));
        this.axisZoomManagers.clear();
        for (const axis of axes){
            var _zoomManagers_get;
            this.axisZoomManagers.set(axis.id, (_zoomManagers_get = zoomManagers.get(axis.id)) !== null && _zoomManagers_get !== void 0 ? _zoomManagers_get : new AxisZoomManager(axis));
        }
        if (this.state.size > 0 && axes.length > 0) {
            this.updateZoom(this.state.stateId(), this.state.stateValue());
        }
    }
    setIndependentAxes() {
        let independent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        this.independentAxes = independent;
    }
    setAutoScaleYAxis(enabled, padding2) {
        this.autoScaleYAxis.enabled = enabled;
        this.autoScaleYAxis.padding = padding2;
        if (enabled) {
            this.autoScaleYZoom("toggle-auto-scale");
        }
    }
    setNavigatorEnabled() {
        let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        this.navigatorModule = enabled;
    }
    setZoomModuleEnabled() {
        let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        this.zoomModule = enabled;
    }
    isNavigatorEnabled() {
        return this.navigatorModule;
    }
    isZoomEnabled() {
        return this.zoomModule;
    }
    updateZoom(callerId, newZoom) {
        if ((newZoom === null || newZoom === void 0 ? void 0 : newZoom.x) && (newZoom.x.min < 0 || newZoom.x.max > 1)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Attempted to update x-axis zoom to an invalid ratio of [{ min: ".concat(newZoom.x.min, ", max: ").concat(newZoom.x.max, " }], expecting a ratio of 0 to 1, ignoring."));
            newZoom.x = void 0;
        }
        if ((newZoom === null || newZoom === void 0 ? void 0 : newZoom.y) && (newZoom.y.min < 0 || newZoom.y.max > 1)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Attempted to update y-axis zoom to an invalid ratio of [{ min: ".concat(newZoom.y.min, ", max: ").concat(newZoom.y.max, " }], expecting a ratio of 0 to 1, ignoring."));
            newZoom.y = void 0;
        }
        if (this.axisZoomManagers.size === 0) {
            const stateId = this.state.stateId();
            if (stateId === "initial" || stateId === callerId) {
                this.state.set(callerId, newZoom);
            }
            return;
        }
        this.state.set(callerId, newZoom);
        const autoScaleYAxis = newZoom === null || newZoom === void 0 ? void 0 : newZoom.autoScaleYAxis;
        if (autoScaleYAxis != null) {
            this.autoScaleYAxis.manuallyAdjusted = !autoScaleYAxis;
        }
        this.axisZoomManagers.forEach((axis)=>{
            axis.updateZoom(callerId, newZoom === null || newZoom === void 0 ? void 0 : newZoom[axis.getDirection()]);
        });
        this.applyChanges(callerId);
    }
    updateAxisZoom(callerId, axisId, newZoom) {
        var _this_axisZoomManagers_get;
        (_this_axisZoomManagers_get = this.axisZoomManagers.get(axisId)) === null || _this_axisZoomManagers_get === void 0 ? void 0 : _this_axisZoomManagers_get.updateZoom(callerId, newZoom);
        this.applyChanges(callerId);
    }
    resetZoom(callerId) {
        var _zoom_x, _zoom_x1, _zoom_y, _zoom_y1;
        this.autoScaleYAxis.manuallyAdjusted = false;
        const zoom = this.getRestoredZoom();
        var _zoom_x_min, _zoom_x_max, _zoom_y_min, _zoom_y_max, _zoom_autoScaleYAxis;
        this.updateZoom(callerId, {
            x: {
                min: (_zoom_x_min = zoom === null || zoom === void 0 ? void 0 : (_zoom_x = zoom.x) === null || _zoom_x === void 0 ? void 0 : _zoom_x.min) !== null && _zoom_x_min !== void 0 ? _zoom_x_min : 0,
                max: (_zoom_x_max = zoom === null || zoom === void 0 ? void 0 : (_zoom_x1 = zoom.x) === null || _zoom_x1 === void 0 ? void 0 : _zoom_x1.max) !== null && _zoom_x_max !== void 0 ? _zoom_x_max : 1
            },
            y: {
                min: (_zoom_y_min = zoom === null || zoom === void 0 ? void 0 : (_zoom_y = zoom.y) === null || _zoom_y === void 0 ? void 0 : _zoom_y.min) !== null && _zoom_y_min !== void 0 ? _zoom_y_min : 0,
                max: (_zoom_y_max = zoom === null || zoom === void 0 ? void 0 : (_zoom_y1 = zoom.y) === null || _zoom_y1 === void 0 ? void 0 : _zoom_y1.max) !== null && _zoom_y_max !== void 0 ? _zoom_y_max : 1
            },
            autoScaleYAxis: (_zoom_autoScaleYAxis = zoom === null || zoom === void 0 ? void 0 : zoom.autoScaleYAxis) !== null && _zoom_autoScaleYAxis !== void 0 ? _zoom_autoScaleYAxis : true
        });
    }
    resetAxisZoom(callerId, axisId) {
        const axisZoomManager = this.axisZoomManagers.get(axisId);
        const direction = axisZoomManager === null || axisZoomManager === void 0 ? void 0 : axisZoomManager.getDirection();
        if (direction == null) return;
        const restoredZoom = this.getRestoredZoom();
        if (direction === "y" /* Y */ ) {
            var _restoredZoom_autoScaleYAxis;
            const autoScaleYAxis = (_restoredZoom_autoScaleYAxis = restoredZoom === null || restoredZoom === void 0 ? void 0 : restoredZoom.autoScaleYAxis) !== null && _restoredZoom_autoScaleYAxis !== void 0 ? _restoredZoom_autoScaleYAxis : true;
            this.autoScaleYAxis.manuallyAdjusted = !autoScaleYAxis;
        }
        for (const axis of this.axes){
            if (axis.direction !== direction) continue;
            var _restoredZoom_direction;
            this.updateAxisZoom(callerId, axis.id, (_restoredZoom_direction = restoredZoom === null || restoredZoom === void 0 ? void 0 : restoredZoom[direction]) !== null && _restoredZoom_direction !== void 0 ? _restoredZoom_direction : {
                min: 0,
                max: 1
            });
        }
    }
    setAxisManuallyAdjusted(_callerId, axisId) {
        var _this_axisZoomManagers_get;
        const direction = (_this_axisZoomManagers_get = this.axisZoomManagers.get(axisId)) === null || _this_axisZoomManagers_get === void 0 ? void 0 : _this_axisZoomManagers_get.getDirection();
        if (direction !== "y" /* Y */ ) return;
        this.autoScaleYAxis.manuallyAdjusted = true;
    }
    updatePrimaryAxisZoom(callerId, direction, newZoom) {
        const primaryAxis = this.getPrimaryAxis(direction);
        if (!primaryAxis) return;
        this.updateAxisZoom(callerId, primaryAxis.id, newZoom);
    }
    panToBBox(callerId, seriesRect, target) {
        if (!this.isZoomEnabled() && !this.isNavigatorEnabled()) return false;
        const zoom = this.getZoom();
        if (zoom === void 0 || !zoom.x && !zoom.y) return false;
        const panIsPossible = seriesRect.width > 0 && seriesRect.height > 0 && Math.abs(target.width) <= Math.abs(seriesRect.width) && Math.abs(target.height) <= Math.abs(seriesRect.height);
        if (!panIsPossible) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("cannot pan to target BBox - chart too small?");
            return false;
        }
        const newZoom = calcPanToBBoxRatios(seriesRect, zoom, target);
        if (this.independentAxes) {
            this.updatePrimaryAxisZoom(callerId, "x" /* X */ , newZoom.x);
            this.updatePrimaryAxisZoom(callerId, "y" /* Y */ , newZoom.y);
        } else {
            this.updateZoom(callerId, newZoom);
        }
        return true;
    }
    // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.
    fireZoomPanStartEvent(callerId) {
        this.eventsHub.emit("zoom:pan-start", {
            callerId
        });
    }
    extendToEnd(callerId, direction, extent2) {
        return this.extendWith(callerId, direction, (end2)=>Number(end2) - extent2);
    }
    extendWith(callerId, direction, fn) {
        const axis = this.getPrimaryAxis(direction);
        if (!axis) return;
        const extents = this.getDomainExtents(axis);
        if (!extents) return;
        const [, end2] = extents;
        const start2 = fn(end2);
        const ratio11 = this.rangeToRatio({
            start: start2,
            end: end2
        }, direction);
        if (!ratio11) return;
        this.updateZoom(callerId, {
            [direction]: ratio11
        });
    }
    updateWith(callerId, direction, fn) {
        const axis = this.getPrimaryAxis(direction);
        if (!axis) return;
        const extents = this.getDomainExtents(axis);
        if (!extents) return;
        let [start2, end2] = extents;
        [start2, end2] = fn(start2, end2);
        const ratio11 = this.rangeToRatio({
            start: start2,
            end: end2
        }, direction);
        if (!ratio11) return;
        this.updateZoom(callerId, {
            [direction]: ratio11
        });
    }
    getZoom() {
        let x;
        let y;
        this.axisZoomManagers.forEach((axis)=>{
            if (axis.getDirection() === "x" /* X */ ) {
                x !== null && x !== void 0 ? x : x = axis.getZoom();
            } else if (axis.getDirection() === "y" /* Y */ ) {
                y !== null && y !== void 0 ? y : y = axis.getZoom();
            }
        });
        if (x || y) {
            return {
                x,
                y
            };
        }
    }
    getAxisZoom(axisId) {
        var _this_axisZoomManagers_get;
        var _this_axisZoomManagers_get_getZoom;
        return (_this_axisZoomManagers_get_getZoom = (_this_axisZoomManagers_get = this.axisZoomManagers.get(axisId)) === null || _this_axisZoomManagers_get === void 0 ? void 0 : _this_axisZoomManagers_get.getZoom()) !== null && _this_axisZoomManagers_get_getZoom !== void 0 ? _this_axisZoomManagers_get_getZoom : {
            min: 0,
            max: 1
        };
    }
    getAxisZooms() {
        const axes = {};
        for (const [axisId, axis] of this.axisZoomManagers.entries()){
            axes[axisId] = {
                direction: axis.getDirection(),
                zoom: axis.getZoom()
            };
        }
        return axes;
    }
    getRestoredZoom() {
        return this.lastRestoredState;
    }
    getPrimaryAxisId(direction) {
        var _this_getPrimaryAxis;
        return (_this_getPrimaryAxis = this.getPrimaryAxis(direction)) === null || _this_getPrimaryAxis === void 0 ? void 0 : _this_getPrimaryAxis.id;
    }
    isVisibleItemsCountAtLeast(zoom, minVisibleItems) {
        const { autoScaleYAxis } = this;
        const xAxis = this.getPrimaryAxis("x" /* X */ );
        const yAxis = this.getPrimaryAxis("y" /* Y */ );
        let boundSeries;
        if (this.independentAxes) {
            var _xAxis_boundSeries;
            const xBoundSeries = new Set((_xAxis_boundSeries = xAxis === null || xAxis === void 0 ? void 0 : xAxis.boundSeries) !== null && _xAxis_boundSeries !== void 0 ? _xAxis_boundSeries : []);
            var _yAxis_boundSeries;
            const yBoundSeries = new Set((_yAxis_boundSeries = yAxis === null || yAxis === void 0 ? void 0 : yAxis.boundSeries) !== null && _yAxis_boundSeries !== void 0 ? _yAxis_boundSeries : []);
            boundSeries = /* @__PURE__ */ new Set();
            for (const series of xBoundSeries){
                if (yBoundSeries.has(series)) {
                    boundSeries.add(series);
                }
            }
        } else {
            var _xAxis_boundSeries1, _yAxis_boundSeries1;
            boundSeries = /* @__PURE__ */ new Set([
                ...(_xAxis_boundSeries1 = xAxis === null || xAxis === void 0 ? void 0 : xAxis.boundSeries) !== null && _xAxis_boundSeries1 !== void 0 ? _xAxis_boundSeries1 : [],
                ...(_yAxis_boundSeries1 = yAxis === null || yAxis === void 0 ? void 0 : yAxis.boundSeries) !== null && _yAxis_boundSeries1 !== void 0 ? _yAxis_boundSeries1 : []
            ]);
        }
        const xVisibleRange = [
            zoom.x.min,
            zoom.x.max
        ];
        const yVisibleRange = autoScaleYAxis.enabled && !autoScaleYAxis.manuallyAdjusted ? void 0 : [
            zoom.y.min,
            zoom.y.max
        ];
        let visibleItemsCount = 0;
        for (const series of boundSeries){
            const remainingItems = minVisibleItems - (visibleItemsCount !== null && visibleItemsCount !== void 0 ? visibleItemsCount : 0);
            const seriesVisibleItems = series.getVisibleItems(xVisibleRange, yVisibleRange, remainingItems);
            visibleItemsCount += seriesVisibleItems;
            if (visibleItemsCount >= minVisibleItems) return true;
        }
        return boundSeries.size === 0;
    }
    getMementoRanges() {
        const zoom = this.getDefinedZoom();
        let autoScaledAxes;
        if (this.autoScaleYAxis.enabled) {
            autoScaledAxes = this.autoScaleYAxis.manuallyAdjusted ? [] : [
                "y"
            ];
        }
        const memento = {
            rangeX: this.getRangeDirection(zoom.x, "x" /* X */ ),
            rangeY: this.getRangeDirection(zoom.y, "y" /* Y */ ),
            ratioX: {
                start: zoom.x.min,
                end: zoom.x.max
            },
            ratioY: {
                start: zoom.y.min,
                end: zoom.y.max
            },
            autoScaledAxes
        };
        return memento;
    }
    getAutoScaleYZoom(zoomX) {
        if (!this.isZoomEnabled()) return;
        const { independentAxes, autoScaleYAxis } = this;
        if (!autoScaleYAxis.enabled || autoScaleYAxis.manuallyAdjusted) return;
        const { padding: padding2 } = autoScaleYAxis;
        if ((zoomX === null || zoomX === void 0 ? void 0 : zoomX.min) === 0 && (zoomX === null || zoomX === void 0 ? void 0 : zoomX.max) === 1) {
            return {
                min: 0,
                max: 1
            };
        } else if (independentAxes) {
            return this.primaryAxisZoom("y" /* Y */ , zoomX, {
                padding: padding2
            });
        } else {
            return this.combinedAxisZoom("y" /* Y */ , zoomX, {
                padding: padding2
            });
        }
    }
    autoScaleYZoom(callerId) {
        let applyChanges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        const { independentAxes } = this;
        const zoom = this.getZoom();
        if ((zoom === null || zoom === void 0 ? void 0 : zoom.x) == null) return;
        const zoomY = this.getAutoScaleYZoom(zoom.x);
        if (zoomY == null || objectsEqual(zoom.y, zoomY)) return;
        if (independentAxes) {
            const primaryAxis = this.getPrimaryAxis("y" /* Y */ );
            const primaryAxisManager = primaryAxis == null ? void 0 : this.axisZoomManagers.get(primaryAxis.id);
            primaryAxisManager === null || primaryAxisManager === void 0 ? void 0 : primaryAxisManager.updateZoom("zoom-manager", zoomY);
        } else {
            for (const axisZoomManager of this.axisZoomManagers.values()){
                if (axisZoomManager.getDirection() === "y" /* Y */ ) {
                    axisZoomManager.updateZoom("zoom-manager", zoomY);
                }
            }
        }
        if (applyChanges) {
            this.applyChanges(callerId);
        }
    }
    applyChanges(callerId) {
        this.autoScaleYZoom(callerId, false);
        const changed = Array.from(this.axisZoomManagers.values(), (axis)=>axis.applyChanges()).includes(true);
        if (!changed) {
            return;
        }
        const axes = {};
        for (const [axisId, axis] of this.axisZoomManagers.entries()){
            axes[axisId] = axis.getZoom();
        }
        this.eventsHub.emit("zoom:change", {
            ...this.getZoom(),
            axes,
            callerId
        });
        this.eventsHub.on("layout:complete", this.boundFireOnceChartEvent);
    }
    fireOnceChartEvent() {
        this.fireChartEvent({
            type: "zoom",
            ...this.getMementoRanges()
        });
        this.eventsHub.off("layout:complete", this.boundFireOnceChartEvent);
    }
    getRangeDirection(ratio11, direction) {
        const axis = this.getPrimaryAxis(direction);
        if (!axis || !ContinuousScale.is(axis.scale) && !DiscreteTimeScale.is(axis.scale)) return;
        const extents = this.getDomainPixelExtents(axis);
        if (!extents) return;
        const [d0, d1] = extents;
        let start2;
        let end2;
        if (d0 <= d1) {
            start2 = axis.scale.invert(0);
            end2 = axis.scale.invert(d0 + (d1 - d0) * ratio11.max);
        } else {
            start2 = axis.scale.invert(d0 - (d0 - d1) * ratio11.min);
            end2 = axis.scale.invert(0);
        }
        return {
            start: start2,
            end: end2
        };
    }
    rangeToRatio(range3, direction) {
        const axis = this.getPrimaryAxis(direction);
        if (!axis) return;
        const extents = this.getDomainPixelExtents(axis);
        if (!extents) return;
        const [d0, d1] = extents;
        const { scale: scale2 } = axis;
        const { start: start2, end: end2 } = range3;
        const [startAlignment = 0 /* Leading */ , endAlignment = 1 /* Trailing */ ] = rangeAlignment(start2, end2);
        let r0 = range3.start == null ? d0 : scale2.convert(range3.start, {
            alignment: startAlignment
        });
        var _scale2_bandwidth;
        let r1 = range3.end == null ? d1 : scale2.convert(range3.end, {
            alignment: endAlignment
        }) + ((_scale2_bandwidth = scale2.bandwidth) !== null && _scale2_bandwidth !== void 0 ? _scale2_bandwidth : 0);
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(r0) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(r1)) return;
        const [dMin, dMax] = [
            Math.min(d0, d1),
            Math.max(d0, d1)
        ];
        if (r0 < dMin || r0 > dMax) {
            var _scale2_invert;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Invalid range start [".concat(range3.start, "], expecting a value between [").concat(scale2.invert(d0), "] and [").concat((_scale2_invert = scale2.invert) === null || _scale2_invert === void 0 ? void 0 : _scale2_invert.call(scale2, d1), "], ignoring."));
            return;
        }
        if (r1 < dMin || r1 > dMax) {
            var _scale2_invert1;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Invalid range end [".concat(range3.end, "], expecting a value between [").concat(scale2.invert(d0), "] and [").concat((_scale2_invert1 = scale2.invert) === null || _scale2_invert1 === void 0 ? void 0 : _scale2_invert1.call(scale2, d1), "], ignoring."));
            return;
        }
        r0 = Math.min(dMax, Math.max(dMin, r0));
        r1 = Math.min(dMax, Math.max(dMin, r1));
        const diff2 = d1 - d0;
        const min = Math.abs((r0 - d0) / diff2);
        const max = Math.abs((r1 - d0) / diff2);
        return {
            min,
            max
        };
    }
    getPrimaryAxis(direction) {
        var _this_axes;
        return (_this_axes = this.axes) === null || _this_axes === void 0 ? void 0 : _this_axes.find((a)=>a.direction === direction);
    }
    getDomainExtents(axis) {
        const { domain } = axis.scale;
        const d0 = domain.at(0);
        const d1 = domain.at(-1);
        if (d0 == null || d1 == null) return;
        return [
            d0,
            d1
        ];
    }
    getDomainPixelExtents(axis) {
        const [d0, d1] = axis.scale.range;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(d0) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(d1)) return;
        return [
            d0,
            d1
        ];
    }
    getDefinedZoom() {
        var _zoom_x, _zoom_x1, _zoom_y, _zoom_y1;
        const zoom = this.getZoom();
        var _zoom_x_min, _zoom_x_max, _zoom_y_min, _zoom_y_max;
        return {
            x: {
                min: (_zoom_x_min = zoom === null || zoom === void 0 ? void 0 : (_zoom_x = zoom.x) === null || _zoom_x === void 0 ? void 0 : _zoom_x.min) !== null && _zoom_x_min !== void 0 ? _zoom_x_min : 0,
                max: (_zoom_x_max = zoom === null || zoom === void 0 ? void 0 : (_zoom_x1 = zoom.x) === null || _zoom_x1 === void 0 ? void 0 : _zoom_x1.max) !== null && _zoom_x_max !== void 0 ? _zoom_x_max : 1
            },
            y: {
                min: (_zoom_y_min = zoom === null || zoom === void 0 ? void 0 : (_zoom_y = zoom.y) === null || _zoom_y === void 0 ? void 0 : _zoom_y.min) !== null && _zoom_y_min !== void 0 ? _zoom_y_min : 0,
                max: (_zoom_y_max = zoom === null || zoom === void 0 ? void 0 : (_zoom_y1 = zoom.y) === null || _zoom_y1 === void 0 ? void 0 : _zoom_y1.max) !== null && _zoom_y_max !== void 0 ? _zoom_y_max : 1
            }
        };
    }
    zoomBounds(xAxis, yAxis, zoom, padding2) {
        const xScale = xAxis.scale;
        const xScaleRange = xScale.range;
        xScale.range = [
            0,
            1
        ];
        const yScale = yAxis.scale;
        const yScaleRange = yScale.range;
        yScale.range = [
            0,
            1
        ];
        let min = 1;
        let minPadding = false;
        let max = 0;
        let maxPadding = false;
        for (const series of yAxis.boundSeries){
            if (!series.visible) continue;
            const { connectsToYAxis } = series;
            const yValues = series.getRange("y" /* Y */ , [
                zoom.min,
                zoom.max
            ]);
            for (const yValue of yValues){
                const y = yScale.convert(yValue);
                if (!Number.isFinite(y)) continue;
                if (y < min) {
                    min = y;
                    minPadding = !connectsToYAxis || yValue < 0;
                }
                if (y > max) {
                    max = y;
                    maxPadding = !connectsToYAxis || yValue > 0;
                }
            }
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(yAxis.min)) {
            min = 0;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(yAxis.max)) {
            max = 1;
        }
        xScale.range = xScaleRange;
        yScale.range = yScaleRange;
        if (min >= max) return;
        const totalPadding = (minPadding ? padding2 : 0) + (maxPadding ? padding2 : 0);
        const paddedDelta = Math.min((max - min) * (1 + totalPadding), 1);
        if (paddedDelta <= 0) return;
        if (minPadding && maxPadding) {
            const mid = (max + min) / 2;
            min = mid - paddedDelta / 2;
            max = mid + paddedDelta / 2;
        } else if (!minPadding && maxPadding) {
            max = min + paddedDelta;
        } else if (minPadding && !maxPadding) {
            min = max - paddedDelta;
        }
        if (min < 0) {
            max += -min;
            min = 0;
        } else if (max > 1) {
            min -= max - 1;
            max = 1;
        }
        return {
            min,
            max
        };
    }
    primaryAxisZoom(direction, zoom) {
        let { padding: padding2 = 0 } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const crossDirection = direction === "x" /* X */  ? "y" /* Y */  : "x" /* X */ ;
        const xAxis = this.getPrimaryAxis(crossDirection);
        const yAxis = this.getPrimaryAxis(direction);
        if (xAxis == null || yAxis == null) return;
        return this.zoomBounds(xAxis, yAxis, zoom, padding2);
    }
    combinedAxisZoom(direction, zoom) {
        let { padding: padding2 = 0 } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const crossDirection = direction === "x" /* X */  ? "y" /* Y */  : "x" /* X */ ;
        const seriesXAxes = /* @__PURE__ */ new Map();
        for (const xAxis of this.axes){
            if (xAxis.direction !== crossDirection) continue;
            for (const series of xAxis.boundSeries){
                seriesXAxes.set(series, xAxis);
            }
        }
        let min = 1;
        let max = 0;
        for (const yAxis of this.axes){
            if (yAxis.direction !== direction) continue;
            for (const series of yAxis.boundSeries){
                const xAxis = seriesXAxes.get(series);
                if (xAxis == null) continue;
                const bounds = this.zoomBounds(xAxis, yAxis, zoom, padding2);
                if (bounds == null) return;
                min = Math.min(min, bounds.min);
                max = Math.max(max, bounds.max);
            }
        }
        const delta3 = 1e-6;
        if (min < delta3) min = 0;
        if (max > 1 - delta3) max = 1;
        if (min > max) return;
        return {
            min,
            max
        };
    }
    constructor(eventsHub, fireChartEvent){
        super();
        this.eventsHub = eventsHub;
        this.fireChartEvent = fireChartEvent;
        this.mementoOriginatorKey = "zoom";
        this.axisZoomManagers = /* @__PURE__ */ new Map();
        this.state = new StateTracker(void 0, "initial");
        this.axes = [];
        this.didLayoutAxes = false;
        this.autoScaleYAxis = new ZoomManagerAutoScaleAxis();
        this.lastRestoredState = void 0;
        this.independentAxes = false;
        this.navigatorModule = false;
        this.zoomModule = false;
        // The initial state memento can not be restored until the chart has performed its first layout. Instead save it as
        // pending and restore then delete it on the first layout.
        this.pendingMemento = void 0;
        this.boundFireOnceChartEvent = this.fireOnceChartEvent.bind(this);
        this.cleanup.register(eventsHub.on("layout:complete", ()=>{
            this.didLayoutAxes = true;
            const { pendingMemento } = this;
            if (pendingMemento) {
                this.restoreMemento(pendingMemento.version, pendingMemento.mementoVersion, pendingMemento.memento);
            }
            this.autoScaleYZoom("zoom-manager");
        }));
    }
};
var AxisZoomManager = class {
    getDirection() {
        return this.axis.direction;
    }
    updateZoom(callerId, newZoom) {
        this.state.set(callerId, newZoom);
    }
    getZoom() {
        return deepClone(this.state.stateValue());
    }
    hasChanges() {
        const currentZoom = this.currentZoom;
        const pendingZoom = this.state.stateValue();
        return currentZoom.min !== pendingZoom.min || currentZoom.max !== pendingZoom.max;
    }
    applyChanges() {
        const hasChanges = this.hasChanges();
        this.currentZoom = this.state.stateValue();
        return hasChanges;
    }
    constructor(axis){
        this.axis = axis;
        const [min = 0, max = 1] = axis.visibleRange;
        this.state = new StateTracker({
            min,
            max
        });
        this.currentZoom = this.state.stateValue();
    }
};
// packages/ag-charts-community/src/chart/layout/layoutManager.ts
var LayoutElement = /* @__PURE__ */ ((LayoutElement2)=>{
    LayoutElement2[LayoutElement2["Caption"] = 0] = "Caption";
    LayoutElement2[LayoutElement2["Legend"] = 1] = "Legend";
    LayoutElement2[LayoutElement2["ToolbarLeft"] = 2] = "ToolbarLeft";
    LayoutElement2[LayoutElement2["ToolbarBottom"] = 3] = "ToolbarBottom";
    LayoutElement2[LayoutElement2["Navigator"] = 4] = "Navigator";
    LayoutElement2[LayoutElement2["Overlay"] = 5] = "Overlay";
    return LayoutElement2;
})(LayoutElement || {});
var LayoutManager = class {
    registerElement(element2, listener) {
        if (this.elements.has(element2)) {
            this.elements.get(element2).add(listener);
        } else {
            this.elements.set(element2, /* @__PURE__ */ new Set([
                listener
            ]));
        }
        return ()=>{
            var _this_elements_get;
            return (_this_elements_get = this.elements.get(element2)) === null || _this_elements_get === void 0 ? void 0 : _this_elements_get.delete(listener);
        };
    }
    createContext(width2, height2) {
        const context = new LayoutContext(width2, height2);
        for (const element2 of Object.values(LayoutElement)){
            var _this_elements_get;
            if (typeof element2 !== "number") continue;
            (_this_elements_get = this.elements.get(element2)) === null || _this_elements_get === void 0 ? void 0 : _this_elements_get.forEach((listener)=>listener(context));
        }
        return context;
    }
    emitLayoutComplete(context, options) {
        const { width: width2, height: height2 } = context;
        var _options_axes, _options_clipSeries;
        this.eventsHub.emit("layout:complete", {
            axes: (_options_axes = options.axes) !== null && _options_axes !== void 0 ? _options_axes : [],
            chart: {
                width: width2,
                height: height2
            },
            clipSeries: (_options_clipSeries = options.clipSeries) !== null && _options_clipSeries !== void 0 ? _options_clipSeries : false,
            series: options.series
        });
    }
    constructor(eventsHub){
        this.eventsHub = eventsHub;
        this.elements = /* @__PURE__ */ new Map();
    }
};
var LayoutContext = class {
    constructor(width2, height2){
        this.width = width2;
        this.height = height2;
        this.layoutBox = new BBox(0, 0, width2, height2);
    }
};
;
function circleRectOverlap(param, x, y, w, h) {
    let { point: c, anchor: unitCenter } = param;
    if (c.size === 0) {
        return false;
    }
    let cx = c.x;
    let cy = c.y;
    if (unitCenter != null) {
        cx -= (unitCenter.x - 0.5) * c.size;
        cy -= (unitCenter.y - 0.5) * c.size;
    }
    let edgeX = cx;
    if (cx < x) {
        edgeX = x;
    } else if (cx > x + w) {
        edgeX = x + w;
    }
    let edgeY = cy;
    if (cy < y) {
        edgeY = y;
    } else if (cy > y + h) {
        edgeY = y + h;
    }
    const dx = cx - edgeX;
    const dy = cy - edgeY;
    const d = Math.sqrt(dx * dx + dy * dy);
    return d <= c.size * 0.5;
}
function isPointLabelDatum(x) {
    return x != null && typeof x.point === "object" && typeof x.label === "object";
}
var labelPlacements = {
    top: {
        x: 0,
        y: -1
    },
    bottom: {
        x: 0,
        y: 1
    },
    left: {
        x: -1,
        y: 0
    },
    right: {
        x: 1,
        y: 0
    },
    "top-left": {
        x: -1,
        y: -1
    },
    "top-right": {
        x: 1,
        y: -1
    },
    "bottom-left": {
        x: -1,
        y: 1
    },
    "bottom-right": {
        x: 1,
        y: 1
    }
};
function placeLabels(data, bounds) {
    let padding2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5;
    const result = /* @__PURE__ */ new Map();
    const previousResults = [];
    const sortedDataClone = new Map([
        ...data.entries()
    ].map((param)=>{
        let [k, d] = param;
        return [
            k,
            d.toSorted((a, b)=>b.point.size - a.point.size)
        ];
    }));
    const dataValues = [
        ...sortedDataClone.values()
    ].flat();
    for (const [seriesId, datums] of sortedDataClone.entries()){
        var _datums_;
        const labels = [];
        if (!((_datums_ = datums[0]) === null || _datums_ === void 0 ? void 0 : _datums_.label)) continue;
        for(let index = 0, ln = datums.length; index < ln; index++){
            const d = datums[index];
            const { point, label, anchor } = d;
            const { text, width: width2, height: height2 } = label;
            const r = point.size * 0.5;
            let dx = 0;
            let dy = 0;
            if (r > 0 && d.placement != null) {
                const placement = labelPlacements[d.placement];
                dx = (width2 * 0.5 + r + padding2) * placement.x;
                dy = (height2 * 0.5 + r + padding2) * placement.y;
            }
            var _anchor_x;
            const x = point.x - width2 * 0.5 + dx - (((_anchor_x = anchor === null || anchor === void 0 ? void 0 : anchor.x) !== null && _anchor_x !== void 0 ? _anchor_x : 0.5) - 0.5) * point.size;
            var _anchor_y;
            const y = point.y - height2 * 0.5 + dy - (((_anchor_y = anchor === null || anchor === void 0 ? void 0 : anchor.y) !== null && _anchor_y !== void 0 ? _anchor_y : 0.5) - 0.5) * point.size;
            const withinBounds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boxContains"])(bounds, x, y, width2, height2);
            if (!withinBounds) continue;
            const overlapPoints = dataValues.some((dataDatum)=>circleRectOverlap(dataDatum, x, y, width2, height2));
            if (overlapPoints) continue;
            const overlapLabels = previousResults.some((pr)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boxCollides"])(pr, x, y, width2, height2));
            if (overlapLabels) continue;
            const resultDatum = {
                index,
                text,
                x,
                y,
                width: width2,
                height: height2,
                datum: d
            };
            labels.push(resultDatum);
            previousResults.push(resultDatum);
        }
        result.set(seriesId, labels);
    }
    return result;
}
// packages/ag-charts-community/src/chart/layout/seriesLabelLayoutManager.ts
var SeriesLabelLayoutManager = class {
    updateLabels(placedLabelSeries, padding2) {
        let seriesRect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : BBox.zero;
        const bounds = {
            x: -padding2.left,
            y: -padding2.top,
            width: seriesRect.width + padding2.left + padding2.right,
            height: seriesRect.height + padding2.top + padding2.bottom
        };
        const expectedSeriesId = new Set(placedLabelSeries.map((s)=>s.id));
        for (const seriesId of this.labelData.keys()){
            if (!expectedSeriesId.has(seriesId)) {
                this.labelData.delete(seriesId);
            }
        }
        for (const series of placedLabelSeries){
            const labelData = series.getLabelData();
            if (labelData.every(isPointLabelDatum)) {
                this.labelData.set(series.id, labelData);
            }
        }
        const placedLabels = placeLabels(this.labelData, bounds, 5);
        for (const series of placedLabelSeries){
            var _series_updatePlacedLabelData;
            var _placedLabels_get;
            (_series_updatePlacedLabelData = series.updatePlacedLabelData) === null || _series_updatePlacedLabelData === void 0 ? void 0 : _series_updatePlacedLabelData.call(series, (_placedLabels_get = placedLabels.get(series.id)) !== null && _placedLabels_get !== void 0 ? _placedLabels_get : []);
        }
    }
    constructor(){
        this.labelData = /* @__PURE__ */ new Map();
    }
};
;
var LegendManager = class {
    createMemento() {
        return this.getData().filter((param)=>{
            let { hideInLegend, isFixed } = param;
            return !hideInLegend && !isFixed;
        }).map((param)=>{
            let { enabled, seriesId, itemId, legendItemName } = param;
            return {
                visible: enabled,
                seriesId,
                itemId,
                legendItemName
            };
        });
    }
    guardMemento(blob) {
        return blob == null || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(blob);
    }
    restoreMemento(_version, _mementoVersion, memento) {
        memento === null || memento === void 0 ? void 0 : memento.forEach((datum)=>{
            var _this_getRestoredData;
            const { seriesId, data } = (_this_getRestoredData = this.getRestoredData(datum)) !== null && _this_getRestoredData !== void 0 ? _this_getRestoredData : {};
            if (!seriesId || !data) {
                return;
            }
            this.updateData(seriesId, data);
        });
        this.update();
    }
    getRestoredData(datum) {
        const { seriesId, itemId, legendItemName, visible } = datum;
        if (seriesId) {
            var _this_legendDataMap_get;
            const legendData = (_this_legendDataMap_get = this.legendDataMap.get(seriesId)) !== null && _this_legendDataMap_get !== void 0 ? _this_legendDataMap_get : [];
            const data = legendData.map((d)=>{
                const match = d.seriesId === seriesId && (!itemId || d.itemId === itemId);
                if (match && d.isFixed) {
                    this.warnFixed(d.seriesId, d.itemId);
                }
                return !d.isFixed && match ? {
                    ...d,
                    enabled: visible
                } : d;
            });
            return {
                seriesId,
                data
            };
        }
        if (itemId == null && legendItemName == null) {
            return;
        }
        for (const legendDatum of this.getData()){
            if (itemId != null && legendDatum.itemId !== itemId || legendItemName != null && legendDatum.legendItemName !== legendItemName) {
                continue;
            }
            if (legendDatum.isFixed) {
                this.warnFixed(legendDatum.seriesId, itemId);
                return;
            }
            var _this_legendDataMap_get1;
            const seriesLegendData = ((_this_legendDataMap_get1 = this.legendDataMap.get(legendDatum.seriesId)) !== null && _this_legendDataMap_get1 !== void 0 ? _this_legendDataMap_get1 : []).map((d)=>d.itemId === itemId || d.legendItemName === legendItemName ? {
                    ...d,
                    enabled: visible
                } : d);
            return {
                seriesId: legendDatum.seriesId,
                data: seriesLegendData
            };
        }
    }
    warnFixed(seriesId, itemId) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("The legend item with seriesId [".concat(seriesId, "] and itemId [").concat(itemId, "] is not configurable, this series item cannot be toggled through the legend."));
    }
    update(data) {
        this.eventsHub.emit("legend:change", {
            legendData: data !== null && data !== void 0 ? data : this.getData()
        });
    }
    updateData(seriesId) {
        let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        this.legendDataMap.set(seriesId, data);
    }
    clearData() {
        this.legendDataMap.clear();
    }
    toggleItem(enabled, seriesId, itemId, legendItemName) {
        if (legendItemName) {
            this.getData().forEach((datum)=>{
                var _this_legendDataMap_get;
                const newData = ((_this_legendDataMap_get = this.legendDataMap.get(datum.seriesId)) !== null && _this_legendDataMap_get !== void 0 ? _this_legendDataMap_get : []).map((d)=>d.legendItemName === legendItemName ? {
                        ...d,
                        enabled
                    } : d);
                this.updateData(datum.seriesId, newData);
            });
            return;
        }
        const seriesLegendData = this.getData(seriesId);
        const singleLegendItem = seriesLegendData.length === 1;
        const data = seriesLegendData.map((datum)=>itemId == null && singleLegendItem || datum.itemId === itemId ? {
                ...datum,
                enabled
            } : datum);
        this.updateData(seriesId, data);
    }
    getData(seriesId) {
        if (seriesId) {
            var _this_legendDataMap_get;
            return (_this_legendDataMap_get = this.legendDataMap.get(seriesId)) !== null && _this_legendDataMap_get !== void 0 ? _this_legendDataMap_get : [];
        }
        return [
            ...this.legendDataMap
        ].reduce((data, param)=>{
            let [_, legendData] = param;
            return data.concat(legendData);
        }, []);
    }
    getDatum() {
        let { seriesId, itemId } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return this.getData(seriesId).find((datum)=>datum.itemId === itemId);
    }
    getSeriesEnabled(seriesId) {
        const data = this.getData(seriesId);
        if (data.length > 0) {
            return data.some((d)=>d.enabled);
        }
    }
    getItemEnabled() {
        let { seriesId, itemId } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _this_getDatum;
        var _this_getDatum_enabled;
        return (_this_getDatum_enabled = (_this_getDatum = this.getDatum({
            seriesId,
            itemId
        })) === null || _this_getDatum === void 0 ? void 0 : _this_getDatum.enabled) !== null && _this_getDatum_enabled !== void 0 ? _this_getDatum_enabled : true;
    }
    constructor(eventsHub){
        this.eventsHub = eventsHub;
        this.mementoOriginatorKey = "legend";
        this.legendDataMap = /* @__PURE__ */ new Map();
    }
};
// packages/ag-charts-community/src/chart/series/seriesStateManager.ts
var SeriesStateManager = class {
    registerSeries(param) {
        let { internalId, seriesGrouping, visible, type } = param;
        if (!seriesGrouping) return;
        let group = this.groups.get(type);
        if (group == null) {
            group = /* @__PURE__ */ new Map();
            this.groups.set(type, group);
        }
        group.set(internalId, {
            grouping: seriesGrouping,
            visible
        });
    }
    updateSeries(param) {
        let { internalId, seriesGrouping, visible, type } = param;
        var _this_groups_get;
        if (!seriesGrouping) return;
        const entry = (_this_groups_get = this.groups.get(type)) === null || _this_groups_get === void 0 ? void 0 : _this_groups_get.get(internalId);
        if (entry) {
            entry.grouping = seriesGrouping;
            entry.visible = visible;
        }
    }
    deregisterSeries(param) {
        let { internalId, type } = param;
        const group = this.groups.get(type);
        if (group == null) return;
        group.delete(internalId);
        if (group.size === 0) {
            this.groups.delete(type);
        }
    }
    getVisiblePeerGroupIndex(param) {
        let { type, seriesGrouping, visible } = param;
        if (!seriesGrouping) {
            return {
                visibleGroupCount: visible ? 1 : 0,
                visibleSameStackCount: visible ? 1 : 0,
                index: 0
            };
        }
        const visibleGroupsSet = /* @__PURE__ */ new Set();
        const visibleSameStackSet = /* @__PURE__ */ new Set();
        const group = this.groups.get(type);
        var _group_values;
        for (const entry of (_group_values = group === null || group === void 0 ? void 0 : group.values()) !== null && _group_values !== void 0 ? _group_values : []){
            if (!entry.visible) continue;
            visibleGroupsSet.add(entry.grouping.groupIndex);
            if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {
                visibleSameStackSet.add(entry.grouping.stackIndex);
            }
        }
        const visibleGroups = Array.from(visibleGroupsSet);
        visibleGroups.sort((a, b)=>a - b);
        return {
            visibleGroupCount: visibleGroups.length,
            visibleSameStackCount: visibleSameStackSet.size,
            index: visibleGroups.indexOf(seriesGrouping.groupIndex)
        };
    }
    constructor(){
        this.groups = /* @__PURE__ */ new Map();
    }
};
;
var UpdateService = class {
    addListener(eventName, listener) {
        return this.events.on(eventName, listener);
    }
    destroy() {
        this.events.clear();
    }
    update() {
        let type = arguments.length > 0 && arguments[0] !== void 0 /* FULL */  ? arguments[0] : 0, options = arguments.length > 1 ? arguments[1] : void 0;
        this.updateCallback(type, options);
    }
    dispatchUpdateComplete(apiUpdate) {
        this.events.emit("update-complete", {
            type: "update-complete",
            apiUpdate
        });
    }
    dispatchPreDomUpdate() {
        this.events.emit("pre-dom-update", {
            type: "pre-dom-update"
        });
    }
    dispatchPreSceneRender() {
        this.events.emit("pre-scene-render", {
            type: "pre-scene-render"
        });
    }
    dispatchProcessData(param) {
        let { series } = param;
        this.events.emit("process-data", {
            type: "process-data",
            series
        });
    }
    constructor(updateCallback){
        this.updateCallback = updateCallback;
        this.events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventEmitter"]();
    }
};
// packages/ag-charts-community/src/chart/chartContext.ts
var ChartContext = class {
    destroy() {
        this.animationManager.destroy();
        this.axisManager.destroy();
        this.callbackCache.invalidateCache();
        this.domManager.destroy();
        this.fontManager.destroy();
        this.proxyInteractionService.destroy();
        this.tooltipManager.destroy();
        this.zoomManager.destroy();
        this.widgets.destroy();
        this.contextModules.forEach((m)=>m.destroy());
        this.cleanup.flush();
    }
    constructor(chart, vars){
        this.eventsHub = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventEmitter"]();
        this.callbackCache = new CallbackCache();
        this.highlightManager = new HighlightManager(this.eventsHub);
        this.formatManager = new FormatManager();
        this.layoutManager = new LayoutManager(this.eventsHub);
        this.localeManager = new LocaleManager(this.eventsHub);
        this.seriesStateManager = new SeriesStateManager();
        this.stateManager = new StateManager();
        this.seriesLabelLayoutManager = new SeriesLabelLayoutManager();
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.contextModules = [];
        const { scene, root, syncManager, container, fireEvent, updateCallback, updateMutex, styleContainer, chartType, domMode, withDragInterpretation } = vars;
        this.chartService = chart;
        this.syncManager = syncManager;
        this.domManager = new DOMManager(this.eventsHub, this.chartService, container, styleContainer, domMode);
        this.widgets = new WidgetSet(this.domManager, {
            withDragInterpretation
        });
        const canvasElement = this.domManager.addChild("canvas", "scene-canvas", scene === null || scene === void 0 ? void 0 : scene.canvas.element);
        this.scene = scene !== null && scene !== void 0 ? scene : new Scene({
            canvasElement
        });
        this.scene.setRoot(root);
        this.cleanup.register(this.scene.on("scene-changed", ()=>{
            this.updateService.update(7 /* SCENE_RENDER */ );
        }));
        this.axisManager = new AxisManager(this.eventsHub, root);
        this.legendManager = new LegendManager(this.eventsHub);
        this.annotationManager = new AnnotationManager(this.eventsHub, chart.annotationRoot, fireEvent);
        this.chartTypeOriginator = new ChartTypeOriginator(chart);
        this.interactionManager = new InteractionManager();
        this.contextMenuRegistry = new ContextMenuRegistry(this.eventsHub);
        this.updateService = new UpdateService(updateCallback);
        this.proxyInteractionService = new ProxyInteractionService(this.eventsHub, this.localeManager, this.domManager);
        this.fontManager = new FontManager(this.domManager, this.updateService);
        this.historyManager = new HistoryManager(this.eventsHub);
        this.animationManager = new AnimationManager(this.interactionManager, updateMutex);
        this.dataService = new DataService(this.eventsHub, chart, this.animationManager);
        this.tooltipManager = new TooltipManager(this.eventsHub, this.localeManager, this.domManager, chart.tooltip);
        this.zoomManager = new ZoomManager(this.eventsHub, fireEvent);
        for (const module of moduleRegistry.byType("context")){
            if (!module.chartTypes.includes(chartType)) continue;
            const moduleInstance = module.moduleFactory(this);
            this.contextModules.push(moduleInstance);
            this[module.contextKey] = moduleInstance;
        }
    }
};
// packages/ag-charts-community/src/chart/chartHighlight.ts
var ChartHighlight = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.range = "tooltip";
    }
};
__decorateClass([
    Property
], ChartHighlight.prototype, "range", 2);
;
function setsEqual(a, b) {
    if (a.size !== b.size) return false;
    for (const value of a){
        if (!b.has(value)) return false;
    }
    return true;
}
function idsMapEqual(a, b) {
    if (a == null || b == null) return a === b;
    if (a.size !== b.size) return false;
    for (const [key, aValue] of a){
        const bValue = b.get(key);
        if (bValue == null) return false;
        if (!setsEqual(aValue, bValue)) return false;
    }
    return true;
}
function propsEqual(a, b) {
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; i += 1){
        const { type: typeA, idsMap: idsMapA, scopes: scopesA, data: dataA, ...propA } = a[i];
        const { type: typeB, idsMap: idsMapB, scopes: scopesB, data: dataB, ...propB } = b[i];
        if (typeA !== typeB) return false;
        if (scopesA && scopesB && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraysEqual"])(scopesA, scopesB)) return false;
        if (dataA && dataB && dataA !== dataB) return false;
        if (!objectsEqual(propA, propB) || !idsMapEqual(idsMapA, idsMapB)) return false;
    }
    return true;
}
function optsEqual(a, b) {
    const { props: propsA, ...restA } = a;
    const { props: propsB, ...restB } = b;
    return objectsEqual(restA, restB) && propsEqual(propsA, propsB);
}
function canReuseCachedData(cachedDataItem, data, ids, opts) {
    return data === cachedDataItem.data && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraysEqual"])(ids, cachedDataItem.ids) && optsEqual(opts, cachedDataItem.opts);
}
;
;
// packages/ag-charts-community/src/chart/data/dataDomain.ts
var DiscreteDomain = class _DiscreteDomain {
    static is(value) {
        return value instanceof _DiscreteDomain;
    }
    extend(val) {
        this.domain.add(val);
    }
    getDomain() {
        return Array.from(this.domain);
    }
    constructor(){
        this.domain = /* @__PURE__ */ new Set();
    }
};
var ContinuousDomain = class _ContinuousDomain {
    static is(value) {
        return value instanceof _ContinuousDomain;
    }
    static extendDomain(values) {
        let domain = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [
            Infinity,
            -Infinity
        ];
        for (const value of values){
            if (typeof value !== "number") {
                continue;
            }
            if (domain[0] > value) {
                domain[0] = value;
            }
            if (domain[1] < value) {
                domain[1] = value;
            }
        }
        return domain;
    }
    extend(value) {
        if (this.domain[0] > value) {
            this.domain[0] = value;
        }
        if (this.domain[1] < value) {
            this.domain[1] = value;
        }
    }
    getDomain() {
        return [
            ...this.domain
        ];
    }
    constructor(){
        this.domain = [
            Infinity,
            -Infinity
        ];
    }
};
// packages/ag-charts-community/src/chart/data/rangeLookup.ts
var MIN = 0;
var MAX = 1;
var SPAN = 2;
var RangeLookup = class {
    computeRangeInto(buffer, start2, end2, bufferIndex, currentStart, step, into) {
        const currentEnd = currentStart + step - 1;
        if (currentEnd < start2 || currentStart >= end2) return into;
        if (currentStart >= start2 && currentEnd < end2) {
            const min = buffer[(bufferIndex * SPAN | 0) + MIN];
            const max = buffer[(bufferIndex * SPAN | 0) + MAX];
            if (Number.isFinite(min)) into[0] = Math.min(into[0], min);
            if (Number.isFinite(max)) into[1] = Math.max(into[1], max);
        } else if (step > 1) {
            bufferIndex = bufferIndex * 2 | 0;
            step = step / 2 | 0;
            this.computeRangeInto(buffer, start2, end2, bufferIndex + 1 | 0, currentStart, step, into);
            this.computeRangeInto(buffer, start2, end2, bufferIndex + 2 | 0, currentStart + step, step, into);
        }
        return into;
    }
    rangeBetween(start2, end2) {
        if (start2 > end2) return [
            NaN,
            NaN
        ];
        const { maxLevelSize, buffer } = this;
        const range3 = [
            Infinity,
            -Infinity
        ];
        this.computeRangeInto(buffer, start2, end2, 0, 0, maxLevelSize, range3);
        return range3;
    }
    get range() {
        const { buffer } = this;
        return [
            buffer[MIN],
            buffer[MAX]
        ];
    }
    constructor(allValues){
        const dataLength = allValues.reduce((acc, v)=>Math.max(acc, v.length), 0);
        const sizePower = 32 - Math.clz32(dataLength);
        let maxLevelSize = 1 << sizePower;
        if (dataLength === maxLevelSize / 2) {
            maxLevelSize = maxLevelSize >>> 1;
        }
        this.maxLevelSize = maxLevelSize;
        const buffer = new Float64Array((maxLevelSize * 2 - 1) * 2).fill(NaN);
        for (const values of allValues){
            for(let i = 0; i < values.length; i += 1){
                const value = Number(values[i]);
                const bufferIndex = maxLevelSize + i - 1;
                const bufferMinIndex = (bufferIndex * SPAN | 0) + MIN;
                const bufferMaxIndex = (bufferIndex * SPAN | 0) + MAX;
                const prevMinValue = buffer[bufferMinIndex];
                const prevMaxValue = buffer[bufferMaxIndex];
                if (!Number.isFinite(prevMinValue) || value < prevMinValue) {
                    buffer[bufferMinIndex] = value;
                }
                if (!Number.isFinite(prevMaxValue) || value > prevMaxValue) {
                    buffer[bufferMaxIndex] = value;
                }
            }
        }
        for(let size = maxLevelSize / 2 | 0; size >= 1; size = size / 2 | 0){
            const start2 = size - 1 | 0;
            const end2 = start2 + size | 0;
            for(let i = 0; i < size; i += 1){
                const nodeIndex = start2 + i;
                const leftIndex = end2 + i * 2;
                const rightIndex = leftIndex + 1;
                const aMin = buffer[(leftIndex * SPAN | 0) + MIN];
                const bMin = buffer[(rightIndex * SPAN | 0) + MIN];
                buffer[(nodeIndex * SPAN | 0) + MIN] = !Number.isFinite(bMin) || aMin < bMin ? aMin : bMin;
                const aMax = buffer[(leftIndex * SPAN | 0) + MAX];
                const bMax = buffer[(rightIndex * SPAN | 0) + MAX];
                buffer[(nodeIndex * SPAN | 0) + MAX] = !Number.isFinite(bMax) || aMax > bMax ? aMax : bMax;
            }
        }
        this.buffer = buffer;
    }
};
// packages/ag-charts-community/src/chart/data/sortOrder.ts
function valuesSortOrder(values) {
    if (values.length <= 1) return 1;
    let order = 0;
    let v0 = values[0];
    for(let i = 1; i < values.length; i++){
        const v1 = values[i];
        if (v1 == null) continue;
        const primitive = v1.valueOf();
        if (typeof primitive !== "number") return;
        const diff2 = Math.sign(v1 - v0);
        if (diff2 !== 0) {
            if (order !== 0 && order !== diff2) return;
            order = diff2;
        }
        v0 = v1;
    }
    return order === 0 ? 1 : order;
}
// packages/ag-charts-community/src/chart/data/dataModel.ts
var KEY_SORT_ORDERS = Symbol("key-sort-orders");
var COLUMN_SORT_ORDERS = Symbol("column-sort-orders");
var DOMAIN_RANGES = Symbol("domain-ranges");
function toKeyString(keys) {
    return keys.map((key)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(key) ? JSON.stringify(key) : key).join("-");
}
function fixNumericExtent(extent2) {
    const numberExtent = extent2 === null || extent2 === void 0 ? void 0 : extent2.map(Number);
    return (numberExtent === null || numberExtent === void 0 ? void 0 : numberExtent.every(Number.isFinite)) ? numberExtent : [];
}
function getMissCount(scopeProvider, missMap) {
    var _missMap_get;
    return (_missMap_get = missMap === null || missMap === void 0 ? void 0 : missMap.get(scopeProvider.id)) !== null && _missMap_get !== void 0 ? _missMap_get : 0;
}
function isScoped(obj) {
    return "scopes" in obj && Array.isArray(obj.scopes);
}
function createArray(length2, value) {
    const out = [];
    for(let i = 0; i < length2; i += 1){
        out[i] = value;
    }
    return out;
}
function datumKeys(keys, columnScope, datumIndex) {
    const out = [];
    for (const k of keys){
        var _k_get;
        const key = (_k_get = k.get(columnScope)) === null || _k_get === void 0 ? void 0 : _k_get[datumIndex];
        if (key == null) return;
        out.push(key);
    }
    return out;
}
function getPathComponents(path) {
    const components = [];
    let matchIndex = 0;
    let matchGroup;
    const regExp = RegExp("((?:(?:^|\\.)\\s*\\w+|\\[\\s*(?:'(?:[^']|(?<!\\\\)\\\\')*'|\"(?:[^\"]|(?<!\\\\)\\\\\")*\"|-?\\d+)\\s*\\])\\s*)", "g");
    while(matchGroup = regExp.exec(path)){
        if (matchGroup.index !== matchIndex) {
            return;
        }
        matchIndex = matchGroup.index + matchGroup[0].length;
        const match = matchGroup[1].trim();
        if (match.startsWith(".")) {
            components.push(match.slice(1).trim());
        } else if (match.startsWith("[")) {
            const accessor = match.slice(1, -1).trim();
            if (accessor.startsWith("'")) {
                components.push(accessor.slice(1, -1).replace(RegExp("(?<!\\\\)\\\\'", "g"), "'"));
            } else if (accessor.startsWith('"')) {
                components.push(accessor.slice(1, -1).replace(RegExp('(?<!\\\\)\\\\"', "g"), '"'));
            } else {
                components.push(accessor);
            }
        } else {
            components.push(match);
        }
    }
    if (matchIndex !== path.length) return;
    return components;
}
function createPathAccessor(components) {
    return (datum)=>{
        let current = datum;
        for (const component of components){
            current = current[component];
        }
        return current;
    };
}
var DataModel = class {
    resolveProcessedDataDefById(scope, searchId) {
        var _this_scopeCache_get;
        const def = (_this_scopeCache_get = this.scopeCache.get(scope.id)) === null || _this_scopeCache_get === void 0 ? void 0 : _this_scopeCache_get.get(searchId);
        if (!def) {
            throw new Error("AG Charts - didn't find property definition for [".concat(searchId, ", ").concat(scope.id, "]"));
        }
        return {
            index: def.index,
            def
        };
    }
    resolveProcessedDataIndexById(scope, searchId) {
        return this.resolveProcessedDataDefById(scope, searchId).index;
    }
    resolveKeysById(scope, searchId, processedData) {
        const index = this.resolveProcessedDataIndexById(scope, searchId);
        const keys = processedData.keys[index];
        if (keys == null) {
            throw new Error("AG Charts - didn't find keys for [".concat(searchId, ", ").concat(scope.id, "]"));
        }
        return keys.get(scope.id);
    }
    hasColumnById(scope, searchId) {
        var _this_scopeCache_get;
        return ((_this_scopeCache_get = this.scopeCache.get(scope.id)) === null || _this_scopeCache_get === void 0 ? void 0 : _this_scopeCache_get.get(searchId)) != null;
    }
    resolveColumnById(scope, searchId, processedData) {
        var _processedData_columns;
        const index = this.resolveProcessedDataIndexById(scope, searchId);
        const column = (_processedData_columns = processedData.columns) === null || _processedData_columns === void 0 ? void 0 : _processedData_columns[index];
        if (column == null) {
            throw new Error("AG Charts - didn't find column for [".concat(searchId, ", ").concat(scope.id, "]"));
        }
        return column;
    }
    /**
   * Provides a convenience iterator to iterate over all of the extract datum values in a
   * specific DataGroup.
   *
   * @param scope to which datums should belong
   * @param group containing the datums
   * @param processedData containing the group
   */ *forEachDatum(scope, processedData, group) {
        const columnIndex = processedData.columnScopes.findIndex((s)=>s.has(scope.id));
        var _group_datumIndices_columnIndex;
        for (const datumIndex of (_group_datumIndices_columnIndex = group.datumIndices[columnIndex]) !== null && _group_datumIndices_columnIndex !== void 0 ? _group_datumIndices_columnIndex : []){
            yield processedData.columns[columnIndex][datumIndex];
        }
    }
    /**
   * Provides a convenience iterator to iterate over all of the extracted datum values in a
   * GroupedData.
   *
   * @param scope to which datums should belong
   * @param processedData to iterate through
   */ *forEachGroupDatum(scope, processedData) {
        const columnIndex = processedData.columnScopes.findIndex((s)=>s.has(scope.id));
        const output = {
            groupIndex: 0,
            columnIndex
        };
        const empty = [];
        for (const group of processedData.groups){
            output.group = group;
            var _group_datumIndices_columnIndex;
            for (const datumIndex of (_group_datumIndices_columnIndex = group.datumIndices[columnIndex]) !== null && _group_datumIndices_columnIndex !== void 0 ? _group_datumIndices_columnIndex : empty){
                output.datumIndex = datumIndex;
                yield output;
            }
            output.groupIndex++;
        }
    }
    /**
   * Provides a window-based convenience iterator to iterate over all of the extracted datum
   * values in a GroupedData, including the previous and next entries relative to each datum.
   *
   * @param scope to which datums should belong
   * @param processedData to iterate through
   */ *forEachGroupDatumTuple(scope, processedData) {
        const columnIndex = processedData.columnScopes.findIndex((s)=>s.has(scope.id));
        const output = {
            columnIndex,
            datumIndexes: [
                void 0,
                void 0,
                void 0
            ]
        };
        for (const next of this.forEachGroupDatum(scope, processedData)){
            output.group = output.nextGroup;
            output.groupIndex = output.nextGroupIndex;
            output.nextGroup = next.group;
            output.nextGroupIndex = next.groupIndex;
            output.datumIndexes[0] = output.datumIndexes[1];
            output.datumIndexes[1] = output.datumIndexes[2];
            output.datumIndexes[2] = next.datumIndex;
            if (output.group != null && output.datumIndexes[1] != null) {
                yield output;
            }
        }
        output.group = output.nextGroup;
        output.groupIndex = output.nextGroupIndex;
        output.nextGroup = void 0;
        output.nextGroupIndex = void 0;
        output.datumIndexes[0] = output.datumIndexes[1];
        output.datumIndexes[1] = output.datumIndexes[2];
        output.datumIndexes[2] = void 0;
        if (output.group != null && output.datumIndexes[1] != null) {
            yield output;
        }
    }
    getDomain(scope, searchId, type, processedData) {
        const domains = this.getDomainsByType(type !== null && type !== void 0 ? type : "value", processedData);
        var _domains_this_resolveProcessedDataIndexById;
        return (_domains_this_resolveProcessedDataIndexById = domains === null || domains === void 0 ? void 0 : domains[this.resolveProcessedDataIndexById(scope, searchId)]) !== null && _domains_this_resolveProcessedDataIndexById !== void 0 ? _domains_this_resolveProcessedDataIndexById : [];
    }
    getDomainBetweenRange(scope, searchIds, param, processedData) {
        let [i0, i1] = param;
        const columnIndices = searchIds.map((searchId)=>this.resolveProcessedDataIndexById(scope, searchId));
        const cacheKey = columnIndices.join(":");
        const domainRanges = processedData[DOMAIN_RANGES];
        let rangeLookup = domainRanges.get(cacheKey);
        if (rangeLookup == null) {
            const values = columnIndices.map((columnIndex)=>processedData.columns[columnIndex]);
            rangeLookup = new RangeLookup(values);
            domainRanges.set(cacheKey, rangeLookup);
        }
        return rangeLookup.rangeBetween(i0, i1);
    }
    getSortOrder(values, index, sortOrders) {
        let sortOrder = sortOrders.get(index);
        if (sortOrder == null) {
            sortOrder = {
                sortOrder: valuesSortOrder(values)
            };
            sortOrders.set(index, sortOrder);
        }
        return sortOrder.sortOrder;
    }
    getKeySortOrder(scope, searchId, processedData) {
        var _processedData_keys_columnIndex;
        const columnIndex = this.resolveProcessedDataIndexById(scope, searchId);
        const keys = (_processedData_keys_columnIndex = processedData.keys[columnIndex]) === null || _processedData_keys_columnIndex === void 0 ? void 0 : _processedData_keys_columnIndex.get(scope.id);
        return keys ? this.getSortOrder(keys, columnIndex, processedData[KEY_SORT_ORDERS]) : void 0;
    }
    getColumnSortOrder(scope, searchId, processedData) {
        const columnIndex = this.resolveProcessedDataIndexById(scope, searchId);
        return this.getSortOrder(processedData.columns[columnIndex], columnIndex, processedData[COLUMN_SORT_ORDERS]);
    }
    getDomainsByType(type, processedData) {
        switch(type){
            case "key":
                return processedData.domain.keys;
            case "value":
                return processedData.domain.values;
            case "aggregate":
                return processedData.domain.aggValues;
            case "group-value-processor":
                return processedData.domain.groups;
            default:
                return null;
        }
    }
    processData(sources) {
        const { opts: { groupByKeys, groupByFn }, aggregates, groupProcessors, reducers, processors, propertyProcessors } = this;
        const start2 = performance.now();
        if (groupByKeys && this.keys.length === 0) {
            return;
        }
        let processedData = this.extractData(sources);
        if (groupByKeys) {
            processedData = this.groupData(processedData);
        } else if (groupByFn) {
            processedData = this.groupData(processedData, groupByFn(processedData));
        }
        if (groupProcessors.length > 0 && processedData.type === "grouped") {
            this.postProcessGroups(processedData);
        }
        if (aggregates.length > 0 && processedData.type === "ungrouped") {
            this.aggregateUngroupedData(processedData);
        } else if (aggregates.length > 0 && processedData.type === "grouped") {
            this.aggregateGroupedData(processedData);
        }
        if (propertyProcessors.length > 0) {
            this.postProcessProperties(processedData);
        }
        if (reducers.length > 0) {
            this.reduceData(processedData);
        }
        if (processors.length > 0) {
            this.postProcessData(processedData);
        }
        this.warnDataMissingProperties(sources);
        const end2 = performance.now();
        processedData.time = end2 - start2;
        if (this.debug.check()) {
            logProcessedData(processedData);
        }
        this.processScopeCache();
        return processedData;
    }
    warnDataMissingProperties(sources) {
        if (sources.size === 0) return;
        for (const def of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["iterate"])(this.keys, this.values)){
            for (const [scope, missCount] of def.missing){
                var _sources_get;
                var _sources_get_length;
                if (missCount < ((_sources_get_length = (_sources_get = sources.get(scope)) === null || _sources_get === void 0 ? void 0 : _sources_get.length) !== null && _sources_get_length !== void 0 ? _sources_get_length : Infinity)) continue;
                const scopeHint = scope == null ? "" : " for ".concat(scope);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("the key '".concat(def.property, "' was not found in any data element").concat(scopeHint, "."));
            }
        }
    }
    processScopeCache() {
        this.scopeCache.clear();
        for (const def of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["iterate"])(this.keys, this.values, this.aggregates)){
            if (!def.idsMap) continue;
            for (const [scope, ids] of def.idsMap){
                for (const id of ids){
                    var _this_scopeCache_get;
                    if (!this.scopeCache.has(scope)) {
                        this.scopeCache.set(scope, /* @__PURE__ */ new Map([
                            [
                                id,
                                def
                            ]
                        ]));
                    } else if ((_this_scopeCache_get = this.scopeCache.get(scope)) === null || _this_scopeCache_get === void 0 ? void 0 : _this_scopeCache_get.has(id)) {
                        throw new Error("duplicate definition ids on the same scope are not allowed.");
                    } else {
                        this.scopeCache.get(scope).set(id, def);
                    }
                }
            }
        }
    }
    valueGroupIdxLookup(param) {
        let { matchGroupIds } = param;
        const result = [];
        for (const [index, def] of this.values.entries()){
            if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {
                result.push(index);
            }
        }
        return result;
    }
    valueIdxLookup(scopes, prop) {
        const noScopesToMatch = scopes == null || scopes.length === 0;
        const propId = typeof prop === "string" ? prop : prop.id;
        const hasMatchingScopeId = (def)=>{
            if (def.idsMap) {
                for (const [scope, ids] of def.idsMap){
                    if ((scopes === null || scopes === void 0 ? void 0 : scopes.includes(scope)) && ids.has(propId)) {
                        return true;
                    }
                }
            }
            return false;
        };
        const result = this.values.reduce((res, def, index)=>{
            const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s)=>scopes === null || scopes === void 0 ? void 0 : scopes.includes(s));
            if (validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def))) {
                res.push(index);
            }
            return res;
        }, []);
        if (result.length === 0) {
            throw new Error("AG Charts - configuration error, unknown property ".concat(JSON.stringify(prop), " in scope(s) ").concat(JSON.stringify(scopes)));
        }
        return result;
    }
    extractData(sources) {
        const { dataDomain, processValue, allScopesHaveSameDefs } = this.initDataDomainProcessor();
        const { keys: keyDefs, values: valueDefs } = this;
        const { invalidData, invalidKeys, invalidKeyCount, allKeyMappings } = this.extractKeys(keyDefs, sources, processValue);
        const { columns, columnScopes, partialValidDataCount, maxDataLength } = this.extractValues(invalidData, valueDefs, sources, invalidKeys, processValue);
        const propertyDomain = (def)=>{
            const defDomain = dataDomain.get(def);
            const result = defDomain.getDomain();
            if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {
                return [];
            }
            return result;
        };
        return {
            type: "ungrouped",
            input: {
                count: maxDataLength
            },
            scopes: new Set(sources.keys()),
            dataSources: sources,
            aggregation: void 0,
            keys: [
                ...allKeyMappings.values()
            ],
            columns,
            columnScopes,
            invalidKeys,
            invalidKeyCount,
            invalidData,
            domain: {
                keys: keyDefs.map(propertyDomain),
                values: valueDefs.map(propertyDomain)
            },
            defs: {
                allScopesHaveSameDefs,
                keys: keyDefs,
                values: valueDefs
            },
            partialValidDataCount,
            time: 0,
            [DOMAIN_RANGES]: /* @__PURE__ */ new Map(),
            [KEY_SORT_ORDERS]: /* @__PURE__ */ new Map(),
            [COLUMN_SORT_ORDERS]: /* @__PURE__ */ new Map()
        };
    }
    extractKeys(keyDefs, sources, processValue) {
        const invalidKeys = /* @__PURE__ */ new Map();
        const invalidData = /* @__PURE__ */ new Map();
        const invalidKeyCount = /* @__PURE__ */ new Map();
        const allKeys = /* @__PURE__ */ new Map();
        let keyDefKeys;
        let scopeDataProcessed;
        const cloneScope = (source, target)=>{
            const sourceScope = scopeDataProcessed.get(source);
            keyDefKeys.set(target, keyDefKeys.get(sourceScope));
            if (invalidKeys.has(sourceScope)) {
                invalidKeys.set(target, invalidKeys.get(sourceScope));
                invalidData.set(target, invalidData.get(sourceScope));
            }
        };
        for (const keyDef of keyDefs){
            const { invalidValue, scopes: keyScopes } = keyDef;
            keyDefKeys = /* @__PURE__ */ new Map();
            scopeDataProcessed = /* @__PURE__ */ new Map();
            allKeys.set(keyDef, keyDefKeys);
            for (const scope of keyScopes !== null && keyScopes !== void 0 ? keyScopes : []){
                var _sources_get;
                const data = (_sources_get = sources.get(scope)) !== null && _sources_get !== void 0 ? _sources_get : [];
                if (scopeDataProcessed.has(data)) {
                    cloneScope(data, scope);
                    continue;
                }
                const keys = [];
                keyDefKeys.set(scope, keys);
                scopeDataProcessed.set(data, scope);
                let invalidScopeKeys;
                let invalidScopeData;
                let missingKeys = 0;
                for(let datumIndex = 0; datumIndex < data.length; datumIndex++){
                    if (data[datumIndex] == null || typeof data[datumIndex] !== "object") continue;
                    const result = processValue(keyDef, data[datumIndex], datumIndex, scope);
                    if (result.valid) {
                        keys.push(result.value);
                        continue;
                    }
                    keys.push(invalidValue);
                    invalidScopeKeys !== null && invalidScopeKeys !== void 0 ? invalidScopeKeys : invalidScopeKeys = createArray(data.length, false);
                    invalidScopeData !== null && invalidScopeData !== void 0 ? invalidScopeData : invalidScopeData = createArray(data.length, false);
                    missingKeys += 1;
                    invalidScopeKeys[datumIndex] = true;
                    invalidScopeData[datumIndex] = true;
                }
                if (invalidScopeKeys && invalidScopeData) {
                    invalidKeys.set(scope, invalidScopeKeys);
                    invalidData.set(scope, invalidScopeData);
                    invalidKeyCount.set(scope, missingKeys);
                }
            }
        }
        return {
            invalidData,
            invalidKeys,
            invalidKeyCount,
            allKeyMappings: allKeys
        };
    }
    extractValues(invalidData, valueDefs, sources, scopeInvalidKeys, processValue) {
        let partialValidDataCount = 0;
        const columns = [];
        const allColumnScopes = [];
        let maxDataLength = 0;
        for (const def of valueDefs){
            const { invalidValue } = def;
            const valueSources = new Set(def.scopes.map((s)=>sources.get(s)));
            if (valueSources.size > 1) {
                throw new Error("AG Charts - more than one data source for: ".concat(JSON.stringify(def)));
            }
            const columnScopes = new Set(def.scopes);
            const columnScope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(def.scopes);
            const columnSource = sources.get(columnScope);
            const column = new Array();
            const invalidKeys = scopeInvalidKeys.get(columnScope);
            for(let datumIndex = 0; datumIndex < columnSource.length; datumIndex++){
                if (columnSource[datumIndex] == null || typeof columnSource[datumIndex] !== "object") continue;
                const valueDatum = columnSource[datumIndex];
                const invalidKey = invalidKeys != null ? invalidKeys[datumIndex] : false;
                const result = processValue(def, valueDatum, datumIndex, def.scopes);
                let value = result.value;
                if (invalidKey || !result.valid) {
                    this.markScopeDatumInvalid(def.scopes, columnSource, datumIndex, invalidData);
                }
                if (invalidKey) {
                    value = invalidValue;
                } else if (!result.valid) {
                    partialValidDataCount += 1;
                    value = invalidValue;
                }
                column[datumIndex] = value;
            }
            columns.push(column);
            allColumnScopes.push(columnScopes);
            maxDataLength = Math.max(maxDataLength, column.length);
        }
        return {
            columns,
            columnScopes: allColumnScopes,
            partialValidDataCount,
            maxDataLength
        };
    }
    groupData(data, groupingFn) {
        var _a;
        const { keys: dataKeys, columns: allColumns, columnScopes, invalidKeys, invalidData } = data;
        const allScopes = data.scopes;
        const resultGroups = [];
        const resultData = [];
        const processedColumnIndexes = /* @__PURE__ */ new Set();
        const groups = allScopes.size !== 1 || groupingFn != null ? /* @__PURE__ */ new Map() : void 0;
        for (const scope of allScopes){
            const scopeColumnIndexes = allColumns.map((_, idx)=>idx).filter((idx)=>!processedColumnIndexes.has(idx) && columnScopes[idx].has(scope));
            if (scopeColumnIndexes.length === 0) continue;
            for (const idx of scopeColumnIndexes){
                processedColumnIndexes.add(idx);
            }
            const siblingScopes = /* @__PURE__ */ new Set();
            for (const columnIdx of scopeColumnIndexes){
                for (const columnScope of columnScopes[columnIdx]){
                    siblingScopes.add(columnScope);
                }
            }
            const scopeKeys = dataKeys.map((k)=>k.get(scope)).filter((k)=>k != null);
            const firstColumn = allColumns[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(scopeColumnIndexes)];
            const scopeInvalidData = invalidData === null || invalidData === void 0 ? void 0 : invalidData.get(scope);
            const scopeInvalidKeys = invalidKeys === null || invalidKeys === void 0 ? void 0 : invalidKeys.get(scope);
            for(let datumIndex = 0; datumIndex < firstColumn.length; datumIndex++){
                if ((scopeInvalidKeys === null || scopeInvalidKeys === void 0 ? void 0 : scopeInvalidKeys[datumIndex]) === true) continue;
                const keys = scopeKeys.map((k)=>k[datumIndex]);
                if (keys == null || keys.length === 0) {
                    throw new Error("AG Charts - no keys found for scope: " + scope);
                }
                var _groupingFn;
                const group = (_groupingFn = groupingFn === null || groupingFn === void 0 ? void 0 : groupingFn(keys)) !== null && _groupingFn !== void 0 ? _groupingFn : keys;
                const groupStr = groups != null ? toKeyString(group) : void 0;
                let outputGroup = groups === null || groups === void 0 ? void 0 : groups.get(groupStr);
                if (outputGroup == null) {
                    outputGroup = {
                        keys: group,
                        datumIndices: [],
                        aggregation: [],
                        validScopes: allScopes
                    };
                    groups === null || groups === void 0 ? void 0 : groups.set(groupStr, outputGroup);
                    resultGroups.push(outputGroup.keys);
                    resultData.push(outputGroup);
                }
                if ((scopeInvalidData === null || scopeInvalidData === void 0 ? void 0 : scopeInvalidData[datumIndex]) === true) {
                    if (outputGroup.validScopes === allScopes) {
                        outputGroup.validScopes = new Set(allScopes.values());
                    }
                    for (const invalidScope of siblingScopes){
                        outputGroup.validScopes.delete(invalidScope);
                    }
                }
                for (const columnIdx of scopeColumnIndexes){
                    var _columnIdx;
                    (_columnIdx = (_a = outputGroup.datumIndices)[columnIdx]) !== null && _columnIdx !== void 0 ? _columnIdx : _a[columnIdx] = [];
                    outputGroup.datumIndices[columnIdx].push(datumIndex);
                }
            }
        }
        return {
            ...data,
            type: "grouped",
            domain: {
                ...data.domain,
                groups: resultGroups
            },
            groups: resultData
        };
    }
    aggregateUngroupedData(processedData) {
        const domainAggValues = this.aggregates.map(()=>[
                Infinity,
                -Infinity
            ]);
        processedData.domain.aggValues = domainAggValues;
        const { keys, columns, dataSources } = processedData;
        const onlyScope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(dataSources.keys());
        const rawData = dataSources.get(onlyScope);
        processedData.aggregation = rawData === null || rawData === void 0 ? void 0 : rawData.map((_, datumIndex)=>{
            const aggregation = [];
            for (const [index, def] of this.aggregates.entries()){
                var _def_groupAggregateFunction, _def_finalFunction;
                const indices = this.valueGroupIdxLookup(def);
                var _def_groupAggregateFunction1;
                let groupAggValues = (_def_groupAggregateFunction1 = (_def_groupAggregateFunction = def.groupAggregateFunction) === null || _def_groupAggregateFunction === void 0 ? void 0 : _def_groupAggregateFunction.call(def)) !== null && _def_groupAggregateFunction1 !== void 0 ? _def_groupAggregateFunction1 : [
                    Infinity,
                    -Infinity
                ];
                const valuesToAgg = indices.map((columnIndex)=>columns[columnIndex][datumIndex]);
                const k = datumKeys(keys, onlyScope, datumIndex);
                const valuesAgg = k != null ? def.aggregateFunction(valuesToAgg, k) : void 0;
                if (valuesAgg) {
                    var _def_groupAggregateFunction2;
                    var _def_groupAggregateFunction3;
                    groupAggValues = (_def_groupAggregateFunction3 = (_def_groupAggregateFunction2 = def.groupAggregateFunction) === null || _def_groupAggregateFunction2 === void 0 ? void 0 : _def_groupAggregateFunction2.call(def, valuesAgg, groupAggValues)) !== null && _def_groupAggregateFunction3 !== void 0 ? _def_groupAggregateFunction3 : ContinuousDomain.extendDomain(valuesAgg, groupAggValues);
                }
                var _def_finalFunction1;
                const finalValues = (_def_finalFunction1 = (_def_finalFunction = def.finalFunction) === null || _def_finalFunction === void 0 ? void 0 : _def_finalFunction.call(def, groupAggValues)) !== null && _def_finalFunction1 !== void 0 ? _def_finalFunction1 : groupAggValues;
                aggregation[index] = finalValues;
                ContinuousDomain.extendDomain(finalValues, domainAggValues[index]);
            }
            return aggregation;
        });
    }
    aggregateGroupedData(processedData) {
        const domainAggValues = this.aggregates.map(()=>[
                Infinity,
                -Infinity
            ]);
        processedData.domain.aggValues = domainAggValues;
        const { columns } = processedData;
        for (const [index, def] of this.aggregates.entries()){
            const indices = this.valueGroupIdxLookup(def);
            for (const group of processedData.groups){
                var _def_groupAggregateFunction, _def_finalFunction;
                var _group_aggregation;
                (_group_aggregation = group.aggregation) !== null && _group_aggregation !== void 0 ? _group_aggregation : group.aggregation = [];
                const groupKeys = group.keys;
                var _def_groupAggregateFunction1;
                let groupAggValues = (_def_groupAggregateFunction1 = (_def_groupAggregateFunction = def.groupAggregateFunction) === null || _def_groupAggregateFunction === void 0 ? void 0 : _def_groupAggregateFunction.call(def)) !== null && _def_groupAggregateFunction1 !== void 0 ? _def_groupAggregateFunction1 : [
                    Infinity,
                    -Infinity
                ];
                const maxDatumIndex = Math.max(...indices.map((columnIndex)=>{
                    var _group_datumIndices_columnIndex;
                    var _group_datumIndices_columnIndex_length;
                    return (_group_datumIndices_columnIndex_length = (_group_datumIndices_columnIndex = group.datumIndices[columnIndex]) === null || _group_datumIndices_columnIndex === void 0 ? void 0 : _group_datumIndices_columnIndex.length) !== null && _group_datumIndices_columnIndex_length !== void 0 ? _group_datumIndices_columnIndex_length : 0;
                }));
                for(let datumIndex = 0; datumIndex < maxDatumIndex; datumIndex++){
                    const valuesToAgg = indices.map((columnIndex)=>{
                        var _group_datumIndices_columnIndex;
                        return columns[columnIndex][(_group_datumIndices_columnIndex = group.datumIndices[columnIndex]) === null || _group_datumIndices_columnIndex === void 0 ? void 0 : _group_datumIndices_columnIndex[datumIndex]];
                    });
                    const valuesAgg = def.aggregateFunction(valuesToAgg, groupKeys);
                    if (valuesAgg) {
                        var _def_groupAggregateFunction2;
                        var _def_groupAggregateFunction3;
                        groupAggValues = (_def_groupAggregateFunction3 = (_def_groupAggregateFunction2 = def.groupAggregateFunction) === null || _def_groupAggregateFunction2 === void 0 ? void 0 : _def_groupAggregateFunction2.call(def, valuesAgg, groupAggValues)) !== null && _def_groupAggregateFunction3 !== void 0 ? _def_groupAggregateFunction3 : ContinuousDomain.extendDomain(valuesAgg, groupAggValues);
                    }
                }
                var _def_finalFunction1;
                const finalValues = (_def_finalFunction1 = (_def_finalFunction = def.finalFunction) === null || _def_finalFunction === void 0 ? void 0 : _def_finalFunction.call(def, groupAggValues)) !== null && _def_finalFunction1 !== void 0 ? _def_finalFunction1 : groupAggValues;
                group.aggregation[index] = finalValues;
                ContinuousDomain.extendDomain(finalValues, domainAggValues[index]);
            }
        }
    }
    postProcessGroups(processedData) {
        const { groupProcessors } = this;
        const { columnScopes, columns, invalidData } = processedData;
        for (const processor of groupProcessors){
            const valueIndexes = this.valueGroupIdxLookup(processor);
            const adjustFn = processor.adjust()();
            for (const dataGroup of processedData.groups){
                adjustFn(columns, valueIndexes, dataGroup);
            }
            for (const valueIndex of valueIndexes){
                const valueDef = this.values[valueIndex];
                const isDiscrete = valueDef.valueType === "category";
                const column = columns[valueIndex];
                const columnScope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(columnScopes[valueIndex]);
                const invalidDatums = invalidData === null || invalidData === void 0 ? void 0 : invalidData.get(columnScope);
                const domain = isDiscrete ? new DiscreteDomain() : new ContinuousDomain();
                for(let datumIndex = 0; datumIndex < column.length; datumIndex += 1){
                    if ((invalidDatums === null || invalidDatums === void 0 ? void 0 : invalidDatums[datumIndex]) === true) continue;
                    domain.extend(column[datumIndex]);
                }
                processedData.domain.values[valueIndex] = domain.getDomain();
            }
        }
    }
    postProcessProperties(processedData) {
        for (const { adjust, property, scopes } of this.propertyProcessors){
            for (const idx of this.valueIdxLookup(scopes, property)){
                adjust()(processedData, idx);
            }
        }
    }
    reduceData(processedData) {
        var _processedData_reduced;
        (_processedData_reduced = processedData.reduced) !== null && _processedData_reduced !== void 0 ? _processedData_reduced : processedData.reduced = {};
        const { dataSources, keys } = processedData;
        for (const def of this.reducers){
            const reducer = def.reducer();
            let accValue = def.initialValue;
            if (processedData.type === "grouped") {
                for (const group of processedData.groups){
                    accValue = reducer(accValue, group.keys);
                }
            } else {
                const onlyScope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(dataSources.keys());
                const keyColumns = keys.map((k)=>k.get(onlyScope)).filter((k)=>k != null);
                const keysParam = keyColumns.map(()=>void 0);
                const rawData = dataSources.get(onlyScope);
                for(let datumIndex = 0; datumIndex < rawData.length; datumIndex += 1){
                    for(let keyIdx = 0; keyIdx < keysParam.length; keyIdx++){
                        var _keyColumns_keyIdx;
                        keysParam[keyIdx] = (_keyColumns_keyIdx = keyColumns[keyIdx]) === null || _keyColumns_keyIdx === void 0 ? void 0 : _keyColumns_keyIdx[datumIndex];
                    }
                    accValue = reducer(accValue, keysParam);
                }
            }
            processedData.reduced[def.property] = accValue;
        }
    }
    postProcessData(processedData) {
        var _processedData_reduced;
        (_processedData_reduced = processedData.reduced) !== null && _processedData_reduced !== void 0 ? _processedData_reduced : processedData.reduced = {};
        for (const def of this.processors){
            processedData.reduced[def.property] = def.calculate(processedData, processedData.reduced[def.property]);
        }
    }
    initDataDomainProcessor() {
        const { keys: keyDefs, values: valueDefs } = this;
        const scopes = /* @__PURE__ */ new Set();
        for (const valueDef of valueDefs){
            if (!valueDef.scopes) continue;
            for (const scope of valueDef.scopes){
                scopes.add(scope);
            }
        }
        const dataDomain = /* @__PURE__ */ new Map();
        const processorFns = /* @__PURE__ */ new Map();
        let allScopesHaveSameDefs = true;
        const initDataDomain = ()=>{
            for (const def of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["iterate"])(keyDefs, valueDefs)){
                if (def.valueType === "category") {
                    dataDomain.set(def, new DiscreteDomain());
                } else {
                    var _def_scopes;
                    dataDomain.set(def, new ContinuousDomain());
                    var _def_scopes_length;
                    allScopesHaveSameDefs && (allScopesHaveSameDefs = ((_def_scopes_length = (_def_scopes = def.scopes) === null || _def_scopes === void 0 ? void 0 : _def_scopes.length) !== null && _def_scopes_length !== void 0 ? _def_scopes_length : 0) === scopes.size);
                }
            }
        };
        initDataDomain();
        const accessors = this.buildAccessors((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["iterate"])(keyDefs, valueDefs));
        const reusableResult = {
            value: void 0,
            missing: false,
            valid: false
        };
        const processValue = (def, datum, idx, valueScopes)=>{
            var _def_validation, _dataDomain_get;
            let valueInDatum;
            let value;
            if (accessors.has(def.property)) {
                try {
                    value = accessors.get(def.property)(datum);
                } catch (e) {}
                valueInDatum = value != null;
            } else {
                valueInDatum = def.property in datum;
                value = valueInDatum ? datum[def.property] : def.missingValue;
            }
            if (def.forceValue != null) {
                const valueNegative = valueInDatum && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNegative"])(value);
                value = valueNegative ? -1 * def.forceValue : def.forceValue;
                valueInDatum = true;
            }
            reusableResult.missing = !valueInDatum;
            const missingValueDef = "missingValue" in def;
            if (!valueInDatum && !missingValueDef) {
                if (typeof valueScopes === "string") {
                    var _def_missing_get;
                    const missCount = (_def_missing_get = def.missing.get(valueScopes)) !== null && _def_missing_get !== void 0 ? _def_missing_get : 0;
                    def.missing.set(valueScopes, missCount + 1);
                } else {
                    for (const scope of valueScopes){
                        var _def_missing_get1;
                        const missCount = (_def_missing_get1 = def.missing.get(scope)) !== null && _def_missing_get1 !== void 0 ? _def_missing_get1 : 0;
                        def.missing.set(scope, missCount + 1);
                    }
                }
            }
            if (!dataDomain.has(def)) {
                initDataDomain();
            }
            if (valueInDatum && ((_def_validation = def.validation) === null || _def_validation === void 0 ? void 0 : _def_validation.call(def, value, datum, idx)) === false) {
                reusableResult.valid = false;
                if ("invalidValue" in def) {
                    value = def.invalidValue;
                } else {
                    if (this.mode !== "integrated") {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("invalid value of type [".concat(typeof value, "] for [").concat(def.scopes, " / ").concat(def.id, "] ignored:"), "[".concat(value, "]"));
                    }
                    reusableResult.value = void 0;
                    return reusableResult;
                }
            } else {
                reusableResult.valid = true;
            }
            if (def.processor) {
                let processor = processorFns.get(def);
                if (processor == null) {
                    processor = def.processor();
                    processorFns.set(def, processor);
                }
                value = processor(value, idx);
            }
            (_dataDomain_get = dataDomain.get(def)) === null || _dataDomain_get === void 0 ? void 0 : _dataDomain_get.extend(value);
            reusableResult.value = value;
            return reusableResult;
        };
        return {
            dataDomain,
            processValue,
            initDataDomain,
            scopes,
            allScopesHaveSameDefs
        };
    }
    buildAccessors(defs) {
        const result = /* @__PURE__ */ new Map();
        if (this.suppressFieldDotNotation) {
            return result;
        }
        for (const def of defs){
            const isPath = def.property.includes(".") || def.property.includes("[");
            if (!isPath) continue;
            const components = getPathComponents(def.property);
            if (components == null) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Invalid property path [%s]", def.property);
                continue;
            }
            const accessor = createPathAccessor(components);
            result.set(def.property, accessor);
        }
        return result;
    }
    constructor(opts, mode = "standalone", suppressFieldDotNotation = false){
        this.opts = opts;
        this.mode = mode;
        this.suppressFieldDotNotation = suppressFieldDotNotation;
        this.debug = Debug.create(true, "data-model");
        this.scopeCache = /* @__PURE__ */ new Map();
        this.keys = [];
        this.values = [];
        this.aggregates = [];
        this.groupProcessors = [];
        this.propertyProcessors = [];
        this.reducers = [];
        this.processors = [];
        this.markScopeDatumInvalid = function(scopes, data, datumIndex, invalidData) {
            for (const scope of scopes){
                if (!invalidData.has(scope)) {
                    invalidData.set(scope, createArray(data.length, false));
                }
                invalidData.get(scope)[datumIndex] = true;
            }
        };
        let keys = true;
        for (const next of opts.props){
            if (next.type === "key" && !keys) {
                throw new Error("AG Charts - internal config error: keys must come before values.");
            }
            if (next.type === "value" && keys) {
                keys = false;
            }
        }
        const verifyMatchGroupId = (param)=>{
            let { matchGroupIds = [] } = param;
            for (const matchGroupId of matchGroupIds){
                if (this.values.every((def)=>def.groupId !== matchGroupId)) {
                    throw new Error("AG Charts - internal config error: matchGroupIds properties must match defined groups (".concat(matchGroupId, ")."));
                }
            }
        };
        const keyScopes = /* @__PURE__ */ new Set();
        const valueScopes = /* @__PURE__ */ new Set();
        for (const def of opts.props){
            const scopes = def.type === "key" ? keyScopes : valueScopes;
            if (isScoped(def)) {
                var _def_scopes;
                (_def_scopes = def.scopes) === null || _def_scopes === void 0 ? void 0 : _def_scopes.forEach((s)=>scopes.add(s));
            }
            switch(def.type){
                case "key":
                    this.keys.push({
                        ...def,
                        index: this.keys.length,
                        missing: /* @__PURE__ */ new Map()
                    });
                    break;
                case "value":
                    if (def.property == null) {
                        throw new Error("AG Charts - internal config error: no properties specified for value definitions: ".concat(JSON.stringify(def)));
                    }
                    this.values.push({
                        ...def,
                        index: this.values.length,
                        missing: /* @__PURE__ */ new Map()
                    });
                    break;
                case "aggregate":
                    verifyMatchGroupId(def);
                    this.aggregates.push({
                        ...def,
                        index: this.aggregates.length
                    });
                    break;
                case "group-value-processor":
                    verifyMatchGroupId(def);
                    this.groupProcessors.push({
                        ...def,
                        index: this.groupProcessors.length
                    });
                    break;
                case "property-value-processor":
                    this.propertyProcessors.push({
                        ...def,
                        index: this.propertyProcessors.length
                    });
                    break;
                case "reducer":
                    this.reducers.push({
                        ...def,
                        index: this.reducers.length
                    });
                    break;
                case "processor":
                    this.processors.push({
                        ...def,
                        index: this.processors.length
                    });
                    break;
            }
        }
        if (!!this.opts.groupByKeys || this.opts.groupByFn != null) {
            const ungroupedScopes = new Set(valueScopes.values());
            keyScopes.forEach((s)=>ungroupedScopes.delete(s));
            if (ungroupedScopes.size > 0) {
                throw new Error("AG Charts - scopes missing key for grouping, illegal configuration: ".concat([
                    ...ungroupedScopes.values()
                ]));
            }
        }
    }
};
function logProcessedData(processedData) {
    const logValues = (name, data)=>{
        if (data.length > 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].log("DataModel.processData() - ".concat(name));
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].table(data);
        }
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].log("DataModel.processData() - processedData", processedData);
    logValues("Key Domains", processedData.domain.keys);
    var _processedData_domain_groups;
    logValues("Group Domains", (_processedData_domain_groups = processedData.domain.groups) !== null && _processedData_domain_groups !== void 0 ? _processedData_domain_groups : []);
    logValues("Value Domains", processedData.domain.values);
    var _processedData_domain_aggValues;
    logValues("Aggregate Domains", (_processedData_domain_aggValues = processedData.domain.aggValues) !== null && _processedData_domain_aggValues !== void 0 ? _processedData_domain_aggValues : []);
}
// packages/ag-charts-community/src/chart/data/dataController.ts
var _DataController = class _DataController {
    async request(id, data, opts) {
        if (this.status !== "setup") {
            throw new Error("AG Charts - data request after data setup phase.");
        }
        return new Promise((resolve, reject)=>{
            this.requested.push({
                id,
                opts,
                data,
                resolve,
                reject
            });
        });
    }
    execute(cachedData) {
        if (this.status !== "setup") {
            throw new Error("AG Charts - data request after data setup phase.");
        }
        this.status = "executed";
        this.debug("DataController.execute() - requested", this.requested);
        const valid = this.validateRequests(this.requested);
        this.debug("DataController.execute() - validated", valid);
        const merged = this.mergeRequested(valid);
        this.debug("DataController.execute() - merged", merged);
        if (this.debug.check()) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])().processedData = [];
        }
        const nextCachedData = [];
        for (const { data, ids, opts, resolves, rejects } of merged){
            const reusableCache = cachedData === null || cachedData === void 0 ? void 0 : cachedData.find((cacheItem)=>canReuseCachedData(cacheItem, data, ids, opts));
            let dataModel;
            let processedData;
            if (reusableCache == null) {
                try {
                    dataModel = new DataModel(opts, this.mode, this.suppressFieldDotNotation);
                    const sources = new Map(valid.map((v)=>[
                            v.id,
                            v.data
                        ]));
                    processedData = dataModel.processData(sources);
                } catch (error) {
                    rejects.forEach((cb)=>cb(error));
                    continue;
                }
            } else {
                ({ dataModel, processedData } = reusableCache);
            }
            nextCachedData.push({
                opts,
                data,
                ids,
                dataModel,
                processedData
            });
            if (this.debug.check()) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])("processedData").push(processedData);
            }
            if ((processedData === null || processedData === void 0 ? void 0 : processedData.partialValidDataCount) === 0) {
                resolves.forEach((resolve)=>resolve({
                        dataModel,
                        processedData
                    }));
            } else if (processedData) {
                this.splitResult(dataModel, processedData, ids, resolves);
            } else {
                rejects.forEach((cb)=>cb(new Error("AG Charts - no processed data generated")));
            }
        }
        return nextCachedData;
    }
    validateRequests(requested) {
        const valid = [];
        for (const [index, request] of requested.entries()){
            if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false && request.opts.groupByKeys === false) {
                request.reject(new Error("all series[].data arrays must be of the same length and have matching keys."));
            } else {
                valid.push(request);
            }
        }
        return valid;
    }
    mergeRequested(requested) {
        const grouped = [];
        for (const request of requested){
            const match = grouped.find(_DataController.groupMatch(request));
            if (match) {
                match.push(request);
            } else {
                grouped.push([
                    request
                ]);
            }
        }
        return grouped.map(_DataController.mergeRequests);
    }
    splitResult(dataModel, processedData, scopes, resolves) {
        for(let i = 0; i < scopes.length; i++){
            const resolve = resolves[i];
            resolve({
                dataModel,
                processedData
            });
        }
    }
    static groupMatch(param) {
        let { data, opts } = param;
        function keys(props2) {
            return props2.filter((p)=>p.type === "key").map((p)=>p.property).join(";");
        }
        const { groupByData, groupByKeys = false, groupByFn, props } = opts;
        const propsKeys = keys(props);
        return (param)=>{
            let [group] = param;
            var _group_opts_groupByKeys;
            return (groupByData === false || group.data === data) && ((_group_opts_groupByKeys = group.opts.groupByKeys) !== null && _group_opts_groupByKeys !== void 0 ? _group_opts_groupByKeys : false) === groupByKeys && group.opts.groupByFn === groupByFn && keys(group.opts.props) === propsKeys;
        };
    }
    static mergeRequests(requests) {
        const result = {
            ids: [],
            rejects: [],
            resolves: [],
            data: requests[0].data,
            opts: {
                ...requests[0].opts,
                props: []
            }
        };
        const optsByTypeAndDataId = /* @__PURE__ */ new Map();
        const dataIds = /* @__PURE__ */ new Map();
        let nextDataId = 0;
        for (const request of requests){
            const { id, data, resolve, reject, opts: { props, ...opts } } = request;
            result.ids.push(id);
            result.rejects.push(reject);
            result.resolves.push(resolve);
            var _result_data;
            (_result_data = result.data) !== null && _result_data !== void 0 ? _result_data : result.data = data;
            var _result_opts;
            (_result_opts = result.opts) !== null && _result_opts !== void 0 ? _result_opts : result.opts = {
                ...opts,
                props: []
            };
            for (const prop of props){
                var _clone2_idsMap;
                const clone2 = {
                    ...prop,
                    scopes: [
                        id
                    ],
                    data
                };
                _DataController.createIdsMap(id, clone2);
                let dataId;
                if (_DataController.crossScopeMergableTypes.has(clone2.type)) {
                    dataId = -1;
                } else if (dataIds.has(data)) {
                    dataId = dataIds.get(data);
                } else {
                    dataId = nextDataId++;
                    dataIds.set(data, dataId);
                }
                const matchKey = "".concat(clone2.type, "-").concat(dataId, "-").concat(clone2.groupId);
                const matches = optsByTypeAndDataId.get(matchKey);
                const match = matches === null || matches === void 0 ? void 0 : matches.find((existing)=>_DataController.deepEqual(existing, clone2));
                if (matches == null) {
                    result.opts.props.push(clone2);
                    optsByTypeAndDataId.set(matchKey, [
                        clone2
                    ]);
                    continue;
                } else if (match == null) {
                    result.opts.props.push(clone2);
                    matches.push(clone2);
                    continue;
                }
                if (clone2.scopes != null) {
                    var _match_scopes;
                    (_match_scopes = match.scopes) !== null && _match_scopes !== void 0 ? _match_scopes : match.scopes = [];
                    match.scopes.push(...clone2.scopes);
                }
                if ((match.type === "key" || match.type === "value") && ((_clone2_idsMap = clone2.idsMap) === null || _clone2_idsMap === void 0 ? void 0 : _clone2_idsMap.size)) {
                    var _match_idsMap;
                    (_match_idsMap = match.idsMap) !== null && _match_idsMap !== void 0 ? _match_idsMap : match.idsMap = /* @__PURE__ */ new Map();
                    _DataController.mergeIdsMap(clone2.idsMap, match.idsMap);
                }
            }
        }
        return result;
    }
    static mergeIdsMap(fromMap, toMap) {
        for (const [scope, ids] of fromMap){
            const toMapValue = toMap.get(scope);
            if (toMapValue == null) {
                toMap.set(scope, new Set(ids));
            } else {
                for (const id of ids){
                    toMapValue.add(id);
                }
            }
        }
    }
    static createIdsMap(scope, prop) {
        if (prop.id == null) return;
        var _prop_idsMap;
        (_prop_idsMap = prop.idsMap) !== null && _prop_idsMap !== void 0 ? _prop_idsMap : prop.idsMap = /* @__PURE__ */ new Map();
        if (prop.idsMap.has(scope)) {
            prop.idsMap.get(scope).add(prop.id);
        } else {
            prop.idsMap.set(scope, /* @__PURE__ */ new Set([
                prop.id
            ]));
        }
    }
    static deepEqual(a, b) {
        if (a === b) {
            return true;
        }
        if (a && b && typeof a == "object" && typeof b == "object") {
            if (a.constructor !== b.constructor) {
                return false;
            }
            let i, length2;
            if (Array.isArray(a)) {
                length2 = a.length;
                if (length2 !== b.length) {
                    return false;
                }
                for(i = length2 - 1; i >= 0; i--){
                    if (!_DataController.deepEqual(a[i], b[i])) {
                        return false;
                    }
                }
                return true;
            }
            const keys = Object.keys(a);
            length2 = keys.length;
            if (length2 !== Object.keys(b).length) {
                return false;
            }
            for(i = length2 - 1; i >= 0; i--){
                const key = keys[i];
                if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    constructor(mode, suppressFieldDotNotation){
        this.mode = mode;
        this.suppressFieldDotNotation = suppressFieldDotNotation;
        this.debug = Debug.create(true, "data-model");
        this.requested = [];
        this.status = "setup";
    }
};
_DataController.crossScopeMergableTypes = /* @__PURE__ */ new Set([
    "key",
    "group-value-processor"
]);
// optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times
_DataController.skipKeys = /* @__PURE__ */ new Set([
    "id",
    "idsMap",
    "type",
    "scopes",
    "data"
]);
var DataController = _DataController;
// packages/ag-charts-community/src/chart/factory/axisRegistry.ts
var AxisRegistry = class {
    register(axisType, module) {
        this.axesMap.set(axisType, module.moduleFactory);
        if (module.themeTemplate) {
            this.setThemeTemplate(axisType, module.themeTemplate);
        }
    }
    create(axisType, moduleContext) {
        const axisFactory = this.axesMap.get(axisType);
        if (axisFactory) {
            return axisFactory(moduleContext);
        }
        throw new Error("AG Charts - unknown axis type: ".concat(axisType));
    }
    has(axisType) {
        return this.axesMap.has(axisType);
    }
    keys() {
        return this.axesMap.keys();
    }
    setThemeTemplate(axisType, themeTemplate) {
        this.themeTemplates.set(axisType, themeTemplate);
        return this;
    }
    getThemeTemplate(axisType) {
        return this.themeTemplates.get(axisType);
    }
    constructor(){
        this.axesMap = /* @__PURE__ */ new Map();
        this.themeTemplates = /* @__PURE__ */ new Map();
    }
};
var axisRegistry = new AxisRegistry();
// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts
var EXPECTED_ENTERPRISE_MODULES = [
    {
        type: "root",
        optionsKey: "animation",
        chartTypes: [
            "cartesian",
            "polar",
            "topology",
            "standalone"
        ]
    },
    {
        type: "root",
        optionsKey: "annotations",
        chartTypes: [
            "cartesian"
        ]
    },
    {
        type: "root",
        optionsKey: "background",
        chartTypes: [
            "cartesian",
            "polar",
            "topology",
            "standalone"
        ],
        optionsInnerKey: "image"
    },
    {
        type: "root",
        optionsKey: "foreground",
        chartTypes: [
            "cartesian",
            "polar",
            "topology",
            "standalone"
        ],
        optionsInnerKey: "image"
    },
    {
        type: "root",
        optionsKey: "chartToolbar",
        chartTypes: [
            "cartesian"
        ]
    },
    {
        type: "root",
        optionsKey: "contextMenu",
        chartTypes: [
            "cartesian",
            "polar",
            "topology",
            "standalone"
        ]
    },
    {
        type: "root",
        optionsKey: "statusBar",
        chartTypes: [
            "cartesian"
        ],
        identifier: "status-bar"
    },
    {
        type: "root",
        optionsKey: "dataSource",
        chartTypes: [
            "cartesian",
            "polar",
            "topology",
            "standalone"
        ]
    },
    {
        type: "root",
        optionsKey: "sync",
        chartTypes: [
            "cartesian"
        ]
    },
    {
        type: "root",
        optionsKey: "zoom",
        chartTypes: [
            "cartesian",
            "topology"
        ]
    },
    {
        type: "root",
        optionsKey: "ranges",
        chartTypes: [
            "cartesian"
        ]
    },
    {
        type: "legend",
        optionsKey: "gradientLegend",
        chartTypes: [
            "cartesian",
            "polar",
            "topology",
            "standalone"
        ],
        identifier: "gradient"
    },
    {
        type: "root",
        optionsKey: "navigator",
        chartTypes: [
            "cartesian"
        ]
    },
    {
        type: "axis",
        optionsKey: "axes[]",
        chartTypes: [
            "polar"
        ],
        identifier: "angle-category"
    },
    {
        type: "axis",
        optionsKey: "axes[]",
        chartTypes: [
            "polar"
        ],
        identifier: "angle-number"
    },
    {
        type: "axis",
        optionsKey: "axes[]",
        chartTypes: [
            "polar"
        ],
        identifier: "radius-category"
    },
    {
        type: "axis",
        optionsKey: "axes[]",
        chartTypes: [
            "polar"
        ],
        identifier: "radius-number"
    },
    {
        type: "axis",
        optionsKey: "axes[]",
        chartTypes: [
            "cartesian"
        ],
        identifier: "ordinal-time"
    },
    {
        type: "axis-option",
        optionsKey: "crosshair",
        chartTypes: [
            "cartesian"
        ]
    },
    {
        type: "axis-option",
        optionsKey: "bandHighlight",
        chartTypes: [
            "cartesian"
        ]
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "cartesian"
        ],
        identifier: "box-plot"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "cartesian"
        ],
        identifier: "candlestick"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "cartesian"
        ],
        identifier: "cone-funnel"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "cartesian"
        ],
        identifier: "funnel"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "cartesian"
        ],
        identifier: "ohlc"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "cartesian"
        ],
        identifier: "heatmap"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "cartesian"
        ],
        identifier: "range-area"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "cartesian"
        ],
        identifier: "range-bar"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "cartesian"
        ],
        identifier: "waterfall"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "polar"
        ],
        identifier: "nightingale"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "polar"
        ],
        identifier: "radar-area"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "polar"
        ],
        identifier: "radar-line"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "polar"
        ],
        identifier: "radial-bar"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "polar"
        ],
        identifier: "radial-column"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "topology"
        ],
        identifier: "map-shape"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "topology"
        ],
        identifier: "map-line"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "topology"
        ],
        identifier: "map-marker"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "topology"
        ],
        identifier: "map-shape-background"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "topology"
        ],
        identifier: "map-line-background"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "standalone"
        ],
        identifier: "pyramid"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "standalone"
        ],
        identifier: "linear-gauge"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "standalone"
        ],
        identifier: "radial-gauge"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "standalone"
        ],
        identifier: "sunburst"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "standalone"
        ],
        identifier: "treemap"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "standalone"
        ],
        identifier: "chord"
    },
    {
        type: "series",
        optionsKey: "series[]",
        chartTypes: [
            "standalone"
        ],
        identifier: "sankey"
    },
    {
        type: "series-option",
        optionsKey: "errorBar",
        chartTypes: [
            "cartesian"
        ],
        identifier: "error-bars"
    },
    {
        type: "context",
        contextKey: "sharedToolbar",
        chartTypes: [
            "cartesian"
        ]
    }
];
function getEnterpriseSeriesChartTypes(type) {
    var _EXPECTED_ENTERPRISE_MODULES_find;
    return (_EXPECTED_ENTERPRISE_MODULES_find = EXPECTED_ENTERPRISE_MODULES.find((s)=>s.type === "series" && s.identifier === type)) === null || _EXPECTED_ENTERPRISE_MODULES_find === void 0 ? void 0 : _EXPECTED_ENTERPRISE_MODULES_find.chartTypes;
}
function isEnterpriseCartesian(seriesType) {
    var _getEnterpriseSeriesChartTypes;
    const type = (_getEnterpriseSeriesChartTypes = getEnterpriseSeriesChartTypes(seriesType)) === null || _getEnterpriseSeriesChartTypes === void 0 ? void 0 : _getEnterpriseSeriesChartTypes.find((v)=>v === "cartesian");
    return type === "cartesian";
}
function isEnterprisePolar(seriesType) {
    var _getEnterpriseSeriesChartTypes;
    const type = (_getEnterpriseSeriesChartTypes = getEnterpriseSeriesChartTypes(seriesType)) === null || _getEnterpriseSeriesChartTypes === void 0 ? void 0 : _getEnterpriseSeriesChartTypes.find((v)=>v === "polar");
    return type === "polar";
}
function isEnterpriseTopology(seriesType) {
    var _getEnterpriseSeriesChartTypes;
    const type = (_getEnterpriseSeriesChartTypes = getEnterpriseSeriesChartTypes(seriesType)) === null || _getEnterpriseSeriesChartTypes === void 0 ? void 0 : _getEnterpriseSeriesChartTypes.find((v)=>v === "topology");
    return type === "topology";
}
function isEnterpriseStandalone(seriesType) {
    var _getEnterpriseSeriesChartTypes;
    const type = (_getEnterpriseSeriesChartTypes = getEnterpriseSeriesChartTypes(seriesType)) === null || _getEnterpriseSeriesChartTypes === void 0 ? void 0 : _getEnterpriseSeriesChartTypes.find((v)=>v === "standalone");
    return type === "standalone";
}
function isEnterpriseModule(module) {
    return module.packageType === "enterprise";
}
function verifyIfModuleExpected(module) {
    if (!isEnterpriseModule(module)) {
        throw new Error("AG Charts - internal configuration error, only enterprise modules need verification.");
    }
    const stub = EXPECTED_ENTERPRISE_MODULES.find((s)=>{
        return s.type === module.type && ("optionsKey" in s && "optionsKey" in module ? s.optionsKey === module.optionsKey : true) && ("contextKey" in s && "contextKey" in module ? s.contextKey === module.contextKey : true) && s.identifier === module.identifier && module.chartTypes.every((t)=>s.chartTypes.includes(t));
    });
    if (stub) {
        var _stub_useCount;
        (_stub_useCount = stub.useCount) !== null && _stub_useCount !== void 0 ? _stub_useCount : stub.useCount = 0;
        stub.useCount++;
    }
    return stub != null;
}
function getUnusedExpectedModules() {
    return EXPECTED_ENTERPRISE_MODULES.filter((param)=>{
        let { useCount } = param;
        return useCount == null || useCount === 0;
    });
}
// packages/ag-charts-community/src/chart/factory/legendRegistry.ts
var LegendRegistry = class {
    register(legendType, param) {
        let { optionsKey, moduleFactory, themeTemplate } = param;
        this.legendMap.set(legendType, {
            optionsKey,
            moduleFactory
        });
        this.themeTemplates.set(optionsKey, themeTemplate);
    }
    create(legendType, moduleContext) {
        var _this_legendMap_get;
        const legendFactory = (_this_legendMap_get = this.legendMap.get(legendType)) === null || _this_legendMap_get === void 0 ? void 0 : _this_legendMap_get.moduleFactory;
        if (legendFactory) {
            return legendFactory(moduleContext);
        }
        throw new Error("AG Charts - unknown legend type: ".concat(legendType));
    }
    getThemeTemplates() {
        return Object.fromEntries(this.themeTemplates);
    }
    getKeys() {
        return Array.from(this.legendMap.entries()).reduce((result, param)=>{
            let [legendType, record] = param;
            result[legendType] = record.optionsKey;
            return result;
        }, {});
    }
    constructor(){
        this.legendMap = /* @__PURE__ */ new Map();
        this.themeTemplates = /* @__PURE__ */ new Map();
    }
};
var legendRegistry = new LegendRegistry();
// packages/ag-charts-community/src/chart/factory/chartTypes.ts
var ChartTypes = class extends Map {
    get(seriesType) {
        var _super_get;
        return (_super_get = super.get(seriesType)) !== null && _super_get !== void 0 ? _super_get : "unknown";
    }
    isCartesian(seriesType) {
        return this.get(seriesType) === "cartesian";
    }
    isPolar(seriesType) {
        return this.get(seriesType) === "polar";
    }
    isTopology(seriesType) {
        return this.get(seriesType) === "topology";
    }
    isStandalone(seriesType) {
        return this.get(seriesType) === "standalone";
    }
    get seriesTypes() {
        return Array.from(this.keys());
    }
    get cartesianTypes() {
        return this.seriesTypes.filter((t)=>this.isCartesian(t));
    }
    get polarTypes() {
        return this.seriesTypes.filter((t)=>this.isPolar(t));
    }
    get topologyTypes() {
        return this.seriesTypes.filter((t)=>this.isTopology(t));
    }
    get standaloneTypes() {
        return this.seriesTypes.filter((t)=>this.isStandalone(t));
    }
};
var ChartDefaults = class extends Map {
    set(chartType, defaults) {
        return super.set(chartType, mergeDefaults(defaults, this.get(chartType)));
    }
};
var chartTypes2 = new ChartTypes();
var publicChartTypes = new ChartTypes();
var chartDefaults = new ChartDefaults();
// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts
var SeriesRegistry = class {
    register(seriesType, param) {
        let { chartTypes: [chartType], moduleFactory, defaultAxes, themeTemplate, solo, stackable, groupable, stackedByDefault, hidden } = param;
        this.setThemeTemplate(seriesType, themeTemplate);
        this.seriesMap.set(seriesType, {
            moduleFactory,
            defaultAxes,
            solo,
            stackable,
            groupable,
            stackedByDefault
        });
        chartTypes2.set(seriesType, chartType);
        if (!hidden) {
            publicChartTypes.set(seriesType, chartType);
        }
    }
    create(seriesType, moduleContext) {
        var _this_seriesMap_get;
        const seriesFactory = (_this_seriesMap_get = this.seriesMap.get(seriesType)) === null || _this_seriesMap_get === void 0 ? void 0 : _this_seriesMap_get.moduleFactory;
        if (seriesFactory) {
            return seriesFactory(moduleContext);
        }
        throw new Error("AG Charts - unknown series type: ".concat(seriesType));
    }
    cloneDefaultAxes(seriesType) {
        var _this_seriesMap_get;
        const defaultAxes = (_this_seriesMap_get = this.seriesMap.get(seriesType)) === null || _this_seriesMap_get === void 0 ? void 0 : _this_seriesMap_get.defaultAxes;
        if (defaultAxes == null) return null;
        return {
            axes: deepClone(defaultAxes)
        };
    }
    setThemeTemplate(seriesType, themeTemplate) {
        const currentTemplate = this.themeTemplates.get(seriesType);
        this.themeTemplates.set(seriesType, mergeDefaults(themeTemplate, currentTemplate));
    }
    getThemeTemplate(seriesType) {
        return this.themeTemplates.get(seriesType);
    }
    isSolo(seriesType) {
        var _this_seriesMap_get;
        var _this_seriesMap_get_solo;
        return (_this_seriesMap_get_solo = (_this_seriesMap_get = this.seriesMap.get(seriesType)) === null || _this_seriesMap_get === void 0 ? void 0 : _this_seriesMap_get.solo) !== null && _this_seriesMap_get_solo !== void 0 ? _this_seriesMap_get_solo : false;
    }
    isGroupable(seriesType) {
        var _this_seriesMap_get;
        var _this_seriesMap_get_groupable;
        return (_this_seriesMap_get_groupable = (_this_seriesMap_get = this.seriesMap.get(seriesType)) === null || _this_seriesMap_get === void 0 ? void 0 : _this_seriesMap_get.groupable) !== null && _this_seriesMap_get_groupable !== void 0 ? _this_seriesMap_get_groupable : false;
    }
    isStackable(seriesType) {
        var _this_seriesMap_get;
        var _this_seriesMap_get_stackable;
        return (_this_seriesMap_get_stackable = (_this_seriesMap_get = this.seriesMap.get(seriesType)) === null || _this_seriesMap_get === void 0 ? void 0 : _this_seriesMap_get.stackable) !== null && _this_seriesMap_get_stackable !== void 0 ? _this_seriesMap_get_stackable : false;
    }
    isStackedByDefault(seriesType) {
        var _this_seriesMap_get;
        var _this_seriesMap_get_stackedByDefault;
        return (_this_seriesMap_get_stackedByDefault = (_this_seriesMap_get = this.seriesMap.get(seriesType)) === null || _this_seriesMap_get === void 0 ? void 0 : _this_seriesMap_get.stackedByDefault) !== null && _this_seriesMap_get_stackedByDefault !== void 0 ? _this_seriesMap_get_stackedByDefault : false;
    }
    constructor(){
        this.seriesMap = /* @__PURE__ */ new Map();
        this.themeTemplates = /* @__PURE__ */ new Map();
    }
};
var seriesRegistry = new SeriesRegistry();
// packages/ag-charts-community/src/chart/interaction/syncManager.ts
var _SyncManager = class _SyncManager {
    subscribe() {
        let groupId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _SyncManager.DEFAULT_GROUP;
        let syncGroup = this.get(groupId);
        if (!syncGroup) {
            syncGroup = {
                members: /* @__PURE__ */ new Set()
            };
            _SyncManager.chartsGroups.set(groupId, syncGroup);
        }
        syncGroup.members.add(this.chart);
        return this;
    }
    unsubscribe() {
        let groupId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _SyncManager.DEFAULT_GROUP;
        var _groupState_domains_x_sources, _groupState_domains_x, _groupState_domains, _groupState_domains_y_sources, _groupState_domains_y, _groupState_domains1;
        const groupState = this.get(groupId);
        groupState === null || groupState === void 0 ? void 0 : groupState.members.delete(this.chart);
        groupState === null || groupState === void 0 ? true : (_groupState_domains = groupState.domains) === null || _groupState_domains === void 0 ? true : (_groupState_domains_x = _groupState_domains.x) === null || _groupState_domains_x === void 0 ? true : (_groupState_domains_x_sources = _groupState_domains_x.sources) === null || _groupState_domains_x_sources === void 0 ? true : delete _groupState_domains_x_sources[this.chart.id];
        groupState === null || groupState === void 0 ? true : (_groupState_domains1 = groupState.domains) === null || _groupState_domains1 === void 0 ? true : (_groupState_domains_y = _groupState_domains1.y) === null || _groupState_domains_y === void 0 ? true : (_groupState_domains_y_sources = _groupState_domains_y.sources) === null || _groupState_domains_y_sources === void 0 ? true : delete _groupState_domains_y_sources[this.chart.id];
        return this;
    }
    getChart() {
        return this.chart;
    }
    getGroupState() {
        let groupId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _SyncManager.DEFAULT_GROUP;
        return this.get(groupId);
    }
    getGroupMembers() {
        let groupId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _SyncManager.DEFAULT_GROUP;
        const syncGroup = this.get(groupId);
        return syncGroup ? Array.from(syncGroup.members) : [];
    }
    getGroupSiblings() {
        let groupId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _SyncManager.DEFAULT_GROUP;
        return this.getGroupMembers(groupId).filter((chart)=>chart !== this.chart);
    }
    getGroupSyncMode() {
        let groupId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _SyncManager.DEFAULT_GROUP;
        if (this.getGroupMembers(groupId).some((c)=>c.series.length > 1)) {
            return "multi-series";
        }
        return "single-series";
    }
    get(groupId) {
        return _SyncManager.chartsGroups.get(groupId);
    }
    constructor(chart){
        this.chart = chart;
    }
};
_SyncManager.chartsGroups = /* @__PURE__ */ new Map();
_SyncManager.DEFAULT_GROUP = Symbol("sync-group-default");
var SyncManager = _SyncManager;
// packages/ag-charts-community/src/chart/keyboard.ts
var Keyboard = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.enabled = false;
    }
};
__decorateClass([
    Property
], Keyboard.prototype, "enabled", 2);
__decorateClass([
    Property
], Keyboard.prototype, "tabIndex", 2);
;
// packages/ag-charts-community/src/motion/fromToMotion.ts
var fromToMotion_exports = {};
__export(fromToMotion_exports, {
    NODE_UPDATE_STATE_TO_PHASE_MAPPING: ()=>NODE_UPDATE_STATE_TO_PHASE_MAPPING,
    fromToMotion: ()=>fromToMotion,
    staticFromToMotion: ()=>staticFromToMotion
});
var NODE_UPDATE_STATE_TO_PHASE_MAPPING = {
    added: "add",
    updated: "update",
    removed: "remove",
    unknown: "initial",
    "no-op": "none"
};
function fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff2) {
    const { fromFn, toFn, applyFn = (node, props)=>node.setProperties(props) } = fns;
    const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
    const processNodes = (liveNodes, subNodes)=>{
        let prevFromProps;
        let liveNodeIndex = 0;
        let nodeIndex = 0;
        for (const node of subNodes){
            const isLive = liveNodes[liveNodeIndex] === node;
            const ctx = {
                last: nodeIndex >= subNodes.length - 1,
                lastLive: liveNodeIndex >= liveNodes.length - 1,
                prev: subNodes[nodeIndex - 1],
                prevFromProps,
                prevLive: liveNodes[liveNodeIndex - 1],
                next: subNodes[nodeIndex + 1],
                nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]
            };
            const animationId = "".concat(groupId, "_").concat(subId, "_").concat(node.id);
            animationManager.stopByAnimationId(animationId);
            let status = "unknown";
            if (!isLive) {
                status = "removed";
            } else if (getDatumId && diff2) {
                status = calculateStatus(node, node.datum, getDatumId, diff2);
            }
            node.transitionOut = status === "removed";
            const { phase, start: start2, finish, delay, duration, ...from3 } = fromFn(node, node.datum, status, ctx);
            const { phase: toPhase, start: toStart, finish: toFinish, delay: toDelay, duration: toDuration, ...to } = toFn(node, node.datum, status, ctx);
            const collapsable = finish == null;
            var _ref;
            animationManager.animate({
                id: animationId,
                groupId,
                phase: (_ref = phase !== null && phase !== void 0 ? phase : toPhase) !== null && _ref !== void 0 ? _ref : "update",
                duration: duration !== null && duration !== void 0 ? duration : toDuration,
                delay: delay !== null && delay !== void 0 ? delay : toDelay,
                from: from3,
                to,
                ease: easeOut,
                collapsable,
                onPlay: ()=>{
                    const startProps = {
                        ...start2,
                        ...toStart,
                        ...from3
                    };
                    applyFn(node, startProps, "start");
                },
                onUpdate (props) {
                    applyFn(node, props, "update");
                },
                onStop: ()=>{
                    const endProps = {
                        ...start2,
                        ...toStart,
                        ...from3,
                        ...to,
                        ...finish,
                        ...toFinish
                    };
                    applyFn(node, endProps, "end");
                }
            });
            if (isLive) {
                liveNodeIndex++;
            }
            nodeIndex++;
            prevFromProps = from3;
        }
    };
    let selectionIndex = 0;
    for (const selection of selections){
        const selectionNodes = selection.nodes();
        const liveNodes = selectionNodes.filter((n)=>!selection.isGarbage(n));
        processNodes(liveNodes, selectionNodes);
        animationManager.animate({
            id: "".concat(groupId, "_").concat(subId, "_selection_").concat(selectionIndex),
            groupId,
            phase: "end",
            from: 0,
            to: 1,
            ease: easeOut,
            onStop () {
                selection.cleanup();
            }
        });
        selectionIndex++;
    }
    processNodes(nodes, nodes);
}
function staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from3, to, extraOpts) {
    const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
    const { start: start2, finish, phase } = extraOpts;
    animationManager.animate({
        id: "".concat(groupId, "_").concat(subId),
        groupId,
        phase: phase !== null && phase !== void 0 ? phase : "update",
        from: from3,
        to,
        ease: easeOut,
        onPlay: ()=>{
            if (!start2) return;
            for (const node of nodes){
                node.setProperties(start2);
            }
            for (const selection of selections){
                for (const node of selection.nodes()){
                    node.setProperties(start2);
                }
            }
        },
        onUpdate (props) {
            for (const node of nodes){
                node.setProperties(props);
            }
            for (const selection of selections){
                for (const node of selection.nodes()){
                    node.setProperties(props);
                }
            }
        },
        onStop: ()=>{
            for (const node of nodes){
                node.setProperties({
                    ...to,
                    ...finish
                });
            }
            for (const selection of selections){
                for (const node of selection.nodes()){
                    node.setProperties({
                        ...to,
                        ...finish
                    });
                }
                selection.cleanup();
            }
        }
    });
}
function calculateStatus(node, datum, getDatumId, diff2) {
    const id = getDatumId(node, datum);
    if (diff2.added.has(id)) {
        return "added";
    }
    if (diff2.removed.has(id)) {
        return "removed";
    }
    if (node.previousDatum == null && node.datum != null) {
        return "added";
    }
    if (node.previousDatum != null && node.datum == null) {
        return "removed";
    }
    return "updated";
}
// packages/ag-charts-community/src/motion/resetMotion.ts
var resetMotion_exports = {};
__export(resetMotion_exports, {
    resetMotion: ()=>resetMotion
});
function resetMotion(selectionsOrNodes, propsFn) {
    const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
    for (const selection of selections){
        for (const node of selection.nodes()){
            const from3 = propsFn(node, node.datum);
            node.setProperties(from3);
        }
        selection.cleanup();
    }
    for (const node of nodes){
        const from3 = propsFn(node, node.datum);
        node.setProperties(from3);
    }
}
// packages/ag-charts-community/src/scene/selection.ts
var Selection = class _Selection {
    static select(parent, classOrFactory) {
        let garbageCollection = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
        return new _Selection(parent, classOrFactory, garbageCollection);
    }
    static selectAll(parent, predicate) {
        const results = [];
        const traverse = (node)=>{
            if (predicate(node)) {
                results.push(node);
            }
            if (node instanceof Group) {
                for (const child of node.children()){
                    traverse(child);
                }
            }
        };
        traverse(parent);
        return results;
    }
    static selectByClass(node) {
        for(var _len = arguments.length, Classes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            Classes[_key - 1] = arguments[_key];
        }
        return _Selection.selectAll(node, (n)=>Classes.some((C2)=>n instanceof C2));
    }
    static selectByTag(node, tag) {
        return _Selection.selectAll(node, (n)=>n.tag === tag);
    }
    createNode(datum, initializer, idx) {
        const node = this.nodeFactory(datum);
        node.datum = datum;
        initializer === null || initializer === void 0 ? void 0 : initializer(node);
        if (idx == null) {
            this._nodes.push(node);
        } else {
            this._nodes.splice(idx, 0, node);
        }
        this.parentNode.appendChild(node);
        return node;
    }
    /**
   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to
   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end
   * of the array.
   */ update(data, initializer, getDatumId) {
        if (this.garbageBin.size > 0) {
            this.debug("Selection - update() called with pending garbage", data);
        }
        if (getDatumId) {
            const dataMap = /* @__PURE__ */ new Map();
            const duplicateMap = /* @__PURE__ */ new Map();
            for(let idx = 0; idx < data.length; idx++){
                const datum = data[idx];
                let id = getDatumId(datum);
                if (dataMap.has(id)) {
                    var _duplicateMap_get;
                    const index = ((_duplicateMap_get = duplicateMap.get(id)) !== null && _duplicateMap_get !== void 0 ? _duplicateMap_get : 0) + 1;
                    duplicateMap.set(id, index);
                    id = "".concat(id, ":").concat(index);
                }
                dataMap.set(id, idx);
            }
            for (const [node, datumId] of this._nodesMap.entries()){
                const idx = dataMap.get(datumId);
                if (idx == null) {
                    this.garbageBin.add(node);
                } else {
                    node.datum = data[idx];
                    this.garbageBin.delete(node);
                    dataMap.delete(datumId);
                }
            }
            for (const [datumId, idx] of dataMap.entries()){
                const datum = data[idx];
                this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);
            }
        } else {
            const maxLength = Math.max(data.length, this.data.length);
            for(let i = 0; i < maxLength; i++){
                if (i >= data.length) {
                    this.garbageBin.add(this._nodes[i]);
                } else if (i >= this._nodes.length) {
                    this.createNode(data[i], initializer);
                } else {
                    this._nodes[i].datum = data[i];
                    this.garbageBin.delete(this._nodes[i]);
                }
            }
        }
        this.data = data.slice();
        if (this.autoCleanup) {
            this.cleanup();
        }
        return this;
    }
    cleanup() {
        if (this.garbageBin.size === 0) {
            return this;
        }
        this._nodes = this._nodes.filter((node)=>{
            if (this.garbageBin.has(node)) {
                this._nodesMap.delete(node);
                this.garbageBin.delete(node);
                node.destroy();
                return false;
            }
            return true;
        });
        return this;
    }
    clear() {
        this.update([]);
        return this;
    }
    isGarbage(node) {
        return this.garbageBin.has(node);
    }
    each(iterate3) {
        for (const entry of this._nodes.entries()){
            iterate3(entry[1], entry[1].datum, entry[0]);
        }
        return this;
    }
    *[Symbol.iterator]() {
        for(let index = 0; index < this._nodes.length; index++){
            const node = this._nodes[index];
            yield {
                node,
                datum: node.datum,
                index
            };
        }
    }
    select(predicate) {
        return _Selection.selectAll(this.parentNode, predicate);
    }
    selectByClass(Class) {
        return _Selection.selectByClass(this.parentNode, Class);
    }
    selectByTag(tag) {
        return _Selection.selectByTag(this.parentNode, tag);
    }
    nodes() {
        return this._nodes;
    }
    at(index) {
        return this._nodes.at(index);
    }
    get length() {
        return this._nodes.length;
    }
    constructor(parentNode, classOrFactory, autoCleanup = true){
        this.parentNode = parentNode;
        this.autoCleanup = autoCleanup;
        this.garbageBin = /* @__PURE__ */ new Set();
        this._nodesMap = /* @__PURE__ */ new Map();
        this._nodes = [];
        this.data = [];
        this.debug = Debug.create(true, "scene", "scene:selections");
        this.nodeFactory = Object.prototype.isPrototypeOf.call(Node2, classOrFactory) ? ()=>new classOrFactory() : classOrFactory;
    }
};
;
var Line = class extends Shape {
    set x(value) {
        this.x1 = value;
        this.x2 = value;
    }
    set y(value) {
        this.y1 = value;
        this.y2 = value;
    }
    get midPoint() {
        return {
            x: (this.x1 + this.x2) / 2,
            y: (this.y1 + this.y2) / 2
        };
    }
    computeBBox() {
        return new BBox(Math.min(this.x1, this.x2), Math.min(this.y1, this.y2), Math.abs(this.x2 - this.x1), Math.abs(this.y2 - this.y1));
    }
    isPointInPath(x, y) {
        if (this.x1 === this.x2 || this.y1 === this.y2) {
            return this.getBBox().clone().grow(this.strokeWidth / 2).containsPoint(x, y);
        }
        return false;
    }
    distanceSquared(px, py) {
        const { x1, y1, x2, y2 } = this;
        return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);
    }
    render(renderCtx) {
        var _this_fillShadow;
        const { ctx, devicePixelRatio } = renderCtx;
        let { x1, y1, x2, y2 } = this;
        if (x1 === x2) {
            const { strokeWidth } = this;
            const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
            x1 = x;
            x2 = x;
        } else if (y1 === y2) {
            const { strokeWidth } = this;
            const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
            y1 = y;
            y2 = y;
        }
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        this.fillStroke(ctx);
        (_this_fillShadow = this.fillShadow) === null || _this_fillShadow === void 0 ? void 0 : _this_fillShadow.markClean();
        super.render(renderCtx);
    }
    toSVG() {
        if (!this.visible) return;
        const element2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("line");
        element2.setAttribute("x1", String(this.x1));
        element2.setAttribute("y1", String(this.y1));
        element2.setAttribute("x2", String(this.x2));
        element2.setAttribute("y2", String(this.y2));
        this.applySvgStrokeAttributes(element2);
        return {
            elements: [
                element2
            ]
        };
    }
    constructor(opts = {}){
        super(opts);
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
        this.fill = void 0;
        this.strokeWidth = 1;
    }
};
Line.className = "Line";
__decorateClass([
    SceneChangeDetection()
], Line.prototype, "x1", 2);
__decorateClass([
    SceneChangeDetection()
], Line.prototype, "y1", 2);
__decorateClass([
    SceneChangeDetection()
], Line.prototype, "x2", 2);
__decorateClass([
    SceneChangeDetection()
], Line.prototype, "y2", 2);
// packages/ag-charts-community/src/util/stateMachine.ts
var debugColor = "color: green";
var debugQuietColor = "color: grey";
function StateMachineProperty() {
    return addObserverToInstanceProperty(()=>{});
}
function applyProperties(parentState, childState) {
    const childProperties = listDecoratedProperties(childState);
    if (childProperties.length === 0) return;
    const properties = extractDecoratedProperties(parentState);
    for (const property of childProperties){
        if (property in properties) {
            childState[property] = properties[property];
        }
    }
}
var AbstractStateMachine = class {
    transitionRoot(event, data) {
        if (this.parent) {
            this.parent.transitionRoot(event, data);
        } else {
            this.transition(event, data);
        }
    }
};
var _StateMachine = class _StateMachine extends AbstractStateMachine {
    // TODO: handle events which do not require data without requiring `undefined` to be passed as as parameter, while
    // also still requiring data to be passed to those events which do require it.
    transition(event, data) {
        var _this_enterEach, _this;
        const shouldTransitionSelf = this.transitionChild(event, data);
        if (!shouldTransitionSelf || this.state === _StateMachine.child || this.state === _StateMachine.parent) {
            return;
        }
        const currentState = this.state;
        const currentStateConfig = this.states[this.state];
        let destination = currentStateConfig[event];
        const debugPrefix = "%c".concat(this.constructor.name, " | ").concat(this.state, " -> ").concat(event, " ->");
        if (Array.isArray(destination)) {
            destination = destination.find((transition)=>{
                if (!transition.guard) return true;
                const valid = transition.guard(data);
                if (!valid) {
                    this.debug("".concat(debugPrefix, " (guarded)"), transition.target, debugQuietColor);
                }
                return valid;
            });
        } else if (typeof destination === "object" && !(destination instanceof _StateMachine) && destination.guard && !destination.guard(data)) {
            this.debug("".concat(debugPrefix, " (guarded)"), destination.target, debugQuietColor);
            return;
        }
        if (!destination) {
            this.debug("".concat(debugPrefix, " ").concat(this.state), debugQuietColor);
            return;
        }
        const destinationState = this.getDestinationState(destination);
        const exitFn = destinationState === this.state ? void 0 : currentStateConfig.onExit;
        this.debug("".concat(debugPrefix, " ").concat(destinationState), debugColor);
        this.state = destinationState;
        if (typeof destination === "function") {
            destination(data);
        } else if (typeof destination === "object" && !(destination instanceof _StateMachine)) {
            var _destination_action;
            (_destination_action = destination.action) === null || _destination_action === void 0 ? void 0 : _destination_action.call(destination, data);
        }
        exitFn === null || exitFn === void 0 ? void 0 : exitFn();
        (_this_enterEach = (_this = this).enterEach) === null || _this_enterEach === void 0 ? void 0 : _this_enterEach.call(_this, currentState, destinationState);
        if (destinationState !== currentState && destinationState !== _StateMachine.child && destinationState !== _StateMachine.parent) {
            var _this_states_destinationState_onEnter, _this_states_destinationState;
            (_this_states_destinationState_onEnter = (_this_states_destinationState = this.states[destinationState]).onEnter) === null || _this_states_destinationState_onEnter === void 0 ? void 0 : _this_states_destinationState_onEnter.call(_this_states_destinationState, currentState, data);
        }
    }
    transitionAsync(event, data) {
        setTimeout(()=>{
            this.transition(event, data);
        }, 0);
    }
    is(value) {
        if (this.state === _StateMachine.child && this.childState) {
            return this.childState.is(value);
        }
        return this.state === value;
    }
    resetHierarchy() {
        this.debug("%c".concat(this.constructor.name, " | ").concat(this.state, " -> [resetHierarchy] -> ").concat(this.defaultState), "color: green");
        this.state = this.defaultState;
    }
    transitionChild(event, data) {
        var _this_states_this_state_onEnter, _this_states_this_state;
        if (this.state !== _StateMachine.child || !this.childState) return true;
        applyProperties(this, this.childState);
        this.childState.transition(event, data);
        if (!this.childState.is(_StateMachine.parent)) return true;
        this.debug("%c".concat(this.constructor.name, " | ").concat(this.state, " -> ").concat(event, " -> ").concat(this.defaultState), debugColor);
        this.state = this.defaultState;
        (_this_states_this_state_onEnter = (_this_states_this_state = this.states[this.state]).onEnter) === null || _this_states_this_state_onEnter === void 0 ? void 0 : _this_states_this_state_onEnter.call(_this_states_this_state);
        this.childState.resetHierarchy();
        return false;
    }
    getDestinationState(destination) {
        let state = this.state;
        if (typeof destination === "string") {
            state = destination;
        } else if (destination instanceof _StateMachine) {
            this.childState = destination;
            this.childState.parent = this;
            state = _StateMachine.child;
        } else if (typeof destination === "object") {
            if (destination.target instanceof _StateMachine) {
                this.childState = destination.target;
                this.childState.parent = this;
                state = _StateMachine.child;
            } else if (destination.target != null) {
                state = destination.target;
            }
        }
        return state;
    }
    constructor(defaultState, states, enterEach){
        super();
        this.defaultState = defaultState;
        this.states = states;
        this.enterEach = enterEach;
        this.debug = Debug.create(true, "animation");
        this.state = defaultState;
        this.debug("%c".concat(this.constructor.name, " | init -> ").concat(defaultState), debugColor);
    }
};
_StateMachine.child = "__child";
_StateMachine.parent = "__parent";
var StateMachine = _StateMachine;
var ParallelStateMachine = class extends AbstractStateMachine {
    transition(event, data) {
        for (const stateMachine of this.stateMachines){
            applyProperties(this, stateMachine);
            stateMachine.transition(event, data);
        }
    }
    transitionAsync(event, data) {
        for (const stateMachine of this.stateMachines){
            applyProperties(this, stateMachine);
            stateMachine.transitionAsync(event, data);
        }
    }
    constructor(...stateMachines){
        super();
        this.stateMachines = stateMachines;
        for (const stateMachine of stateMachines){
            stateMachine.parent = this;
        }
    }
};
;
// packages/ag-charts-community/src/util/time/duration.ts
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;
// packages/ag-charts-community/src/util/time/encoding.ts
var tzOffset = /* @__PURE__ */ new Date().getTimezoneOffset() * durationMinute;
var unitEncoding = {
    millisecond: {
        milliseconds: 1,
        hierarchy: "day",
        encode (date5) {
            return date5.getTime();
        },
        decode (encoded) {
            return new Date(encoded);
        }
    },
    second: {
        milliseconds: durationSecond,
        hierarchy: "day",
        encode (date5, utc) {
            const offset = utc ? 0 : tzOffset;
            return Math.floor((date5.getTime() - offset) / durationSecond);
        },
        decode (encoded, utc) {
            const offset = utc ? 0 : tzOffset;
            return new Date(offset + encoded * durationSecond);
        }
    },
    minute: {
        milliseconds: durationMinute,
        hierarchy: "day",
        encode (date5, utc) {
            const offset = utc ? 0 : tzOffset;
            return Math.floor((date5.getTime() - offset) / durationMinute);
        },
        decode (encoded, utc) {
            const offset = utc ? 0 : tzOffset;
            return new Date(offset + encoded * durationMinute);
        }
    },
    hour: {
        milliseconds: durationHour,
        hierarchy: "day",
        encode (date5, utc) {
            const offset = utc ? 0 : tzOffset;
            return Math.floor((date5.getTime() - offset) / durationHour);
        },
        decode (encoded, utc) {
            const offset = utc ? 0 : tzOffset;
            return new Date(offset + encoded * durationHour);
        }
    },
    day: {
        milliseconds: durationDay,
        hierarchy: "month",
        encode (date5, utc) {
            const tzOffsetMs = utc ? 0 : date5.getTimezoneOffset() * durationMinute;
            return Math.floor((date5.getTime() - tzOffsetMs) / durationDay);
        },
        decode (encoded, utc) {
            let d;
            if (utc) {
                d = /* @__PURE__ */ new Date(0);
                d.setUTCDate(d.getUTCDate() + encoded);
                d.setUTCHours(0, 0, 0, 0);
            } else {
                d = new Date(1970, 0, 1);
                d.setDate(d.getDate() + encoded);
            }
            return d;
        }
    },
    month: {
        milliseconds: durationMonth,
        hierarchy: "year",
        encode (date5, utc) {
            if (utc) {
                return date5.getUTCFullYear() * 12 + date5.getUTCMonth();
            } else {
                return date5.getFullYear() * 12 + date5.getMonth();
            }
        },
        decode (encoded, utc) {
            if (utc) {
                const year = Math.floor(encoded / 12);
                const m = encoded - year * 12;
                return new Date(Date.UTC(year, m, 1));
            } else {
                const y = Math.floor(encoded / 12);
                const month = encoded - y * 12;
                return new Date(y, month, 1);
            }
        }
    },
    year: {
        milliseconds: durationYear,
        hierarchy: void 0,
        encode (date5, utc) {
            if (utc) {
                return date5.getUTCFullYear();
            } else {
                return date5.getFullYear();
            }
        },
        decode (encoded, utc) {
            let d;
            if (utc) {
                d = /* @__PURE__ */ new Date();
                d.setUTCFullYear(encoded);
                d.setUTCMonth(0, 1);
                d.setUTCHours(0, 0, 0, 0);
            } else {
                d = new Date(encoded, 0, 1, 0, 0, 0, 0);
            }
            return d;
        }
    }
};
// packages/ag-charts-community/src/util/time/range.ts
function timeInterval(interval) {
    var _interval_step, _interval_utc;
    return typeof interval === "string" ? {
        unit: interval,
        step: 1,
        epoch: void 0,
        utc: false
    } : {
        unit: interval.unit,
        step: (_interval_step = interval.step) !== null && _interval_step !== void 0 ? _interval_step : 1,
        epoch: interval.epoch,
        utc: (_interval_utc = interval.utc) !== null && _interval_utc !== void 0 ? _interval_utc : false
    };
}
function getOffset(unit, step, epoch, utc) {
    if (epoch == null) return 0;
    const encoding = unitEncoding[unit];
    return Math.floor(encoding.encode(new Date(epoch), utc)) % step;
}
function encode(d, unit, step, utc, offset) {
    const encoding = unitEncoding[unit];
    return Math.floor((encoding.encode(new Date(d), utc) - offset) / step);
}
function decode(encoded, unit, step, utc, offset) {
    const encoding = unitEncoding[unit];
    return encoding.decode(encoded * step + offset, utc);
}
function encodingFloor(date5, unit, step, utc, offset) {
    const d = new Date(date5);
    const e = encode(d, unit, step, utc, offset);
    return decode(e, unit, step, utc, offset);
}
function encodingCeil(date5, unit, step, utc, offset) {
    const d = new Date(Number(date5) - 1);
    const e = encode(d, unit, step, utc, offset);
    return decode(e + 1, unit, step, utc, offset);
}
function intervalFloor(interval, date5) {
    const { unit, step, epoch, utc } = timeInterval(interval);
    const offset = getOffset(unit, step, epoch, utc);
    return encodingFloor(date5, unit, step, utc, offset);
}
function intervalCeil(interval, date5) {
    const { unit, step, epoch, utc } = timeInterval(interval);
    const offset = getOffset(unit, step, epoch, utc);
    return encodingCeil(date5, unit, step, utc, offset);
}
function intervalPrevious(interval, date5) {
    const { unit, step, epoch, utc } = timeInterval(interval);
    const offset = getOffset(unit, step, epoch, utc);
    return decode(encode(encodingCeil(date5, unit, step, utc, offset), unit, step, utc, offset) - 1, unit, step, utc, offset);
}
function intervalNext(interval, date5) {
    const { unit, step, epoch, utc } = timeInterval(interval);
    const offset = getOffset(unit, step, epoch, utc);
    return decode(encode(encodingFloor(date5, unit, step, utc, offset), unit, step, utc, offset) + 1, unit, step, utc, offset);
}
function intervalExtent(start2, stop, visibleRange) {
    if (start2.valueOf() > stop.valueOf()) {
        [start2, stop] = [
            stop,
            start2
        ];
        if (visibleRange != null) {
            visibleRange = [
                1 - visibleRange[1],
                1 - visibleRange[0]
            ];
        }
    }
    if (visibleRange != null) {
        const delta3 = stop.valueOf() - start2.valueOf();
        const t0 = start2.valueOf();
        start2 = new Date(t0 + visibleRange[0] * delta3);
        stop = new Date(t0 + visibleRange[1] * delta3);
    }
    return [
        new Date(start2),
        new Date(stop)
    ];
}
function rangeData(interval, start2, stop) {
    let { extend = false, visibleRange = [
        0,
        1
    ], limit, defaultAlignment = "start" } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const params = timeInterval(interval);
    const { unit, step, utc } = params;
    let epoch;
    if (params.epoch != null) {
        epoch = params.epoch;
    } else if (defaultAlignment === "interval") {
        epoch = void 0;
    } else if (start2.valueOf() > stop.valueOf()) {
        epoch = stop;
    } else {
        epoch = start2;
    }
    const offset = getOffset(params.unit, params.step, epoch, params.utc);
    let [d0, d1] = intervalExtent(start2, stop, visibleRange);
    d0 = extend ? encodingFloor(d0, unit, step, utc, offset) : encodingCeil(d0, unit, step, utc, offset);
    d1 = extend ? encodingCeil(d1, unit, step, utc, offset) : encodingFloor(d1, unit, step, utc, offset);
    const e0 = encode(d0, unit, step, utc, offset);
    let e1 = encode(d1, unit, step, utc, offset);
    if (limit != null && e1 - e0 > limit) {
        e1 = e0 + limit;
    }
    return {
        range: [
            e0,
            e1
        ],
        unit,
        step,
        utc,
        offset
    };
}
function intervalRangeCount(interval, start2, stop, params) {
    const { range: [e0, e1] } = rangeData(interval, start2, stop, params);
    return Math.abs(e1 - e0);
}
function intervalRange(interval, start2, stop, params) {
    const { range: [e0, e1], unit, step, utc, offset } = rangeData(interval, start2, stop, params);
    const values = [];
    for(let e = e0; e <= e1; e += 1){
        const d = decode(e, unit, step, utc, offset);
        values.push(d);
    }
    return values;
}
function intervalRangeStartIndex(interval, start2, stop) {
    let { extend, visibleRange, limit, defaultAlignment } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const { range: [s] } = rangeData(interval, start2, stop, {
        extend,
        visibleRange,
        limit,
        defaultAlignment
    });
    const { range: [s0] } = rangeData(interval, start2, stop, {
        extend,
        limit,
        defaultAlignment
    });
    return s - s0;
}
// packages/ag-charts-community/src/util/time/index.ts
function intervalUnit(interval) {
    return typeof interval === "string" ? interval : interval.unit;
}
function intervalStep(interval) {
    var _interval_step;
    return typeof interval === "string" ? 1 : (_interval_step = interval.step) !== null && _interval_step !== void 0 ? _interval_step : 1;
}
function intervalEpoch(interval) {
    return typeof interval === "string" ? void 0 : interval.epoch;
}
function intervalHierarchy(interval) {
    return unitEncoding[intervalUnit(interval)].hierarchy;
}
function intervalMilliseconds(interval) {
    const step = intervalStep(interval);
    return step * unitEncoding[intervalUnit(interval)].milliseconds;
}
// packages/ag-charts-community/src/chart/label.ts
var LabelBorder = class {
    constructor(){
        this.enabled = true;
    }
};
__decorateClass([
    Property
], LabelBorder.prototype, "enabled", 2);
__decorateClass([
    Property
], LabelBorder.prototype, "stroke", 2);
__decorateClass([
    Property
], LabelBorder.prototype, "strokeWidth", 2);
__decorateClass([
    Property
], LabelBorder.prototype, "strokeOpacity", 2);
var Label = class extends BaseProperties {
    formatValue(formatWithContext, type, value, params) {
        const { formatter: formatter2, format } = this;
        let result;
        if (formatter2 != null) {
            result !== null && result !== void 0 ? result : result = formatWithContext(formatter2, params);
        }
        if (format != null) {
            var _cachedFormatter_formatter;
            let cachedFormatter = this._cachedFormatter;
            if (cachedFormatter == null || cachedFormatter.type !== type || cachedFormatter.format !== format) {
                cachedFormatter = {
                    type,
                    format,
                    formatter: FormatManager.getFormatter(type, format)
                };
                this._cachedFormatter = cachedFormatter;
            }
            result !== null && result !== void 0 ? result : result = (_cachedFormatter_formatter = cachedFormatter.formatter) === null || _cachedFormatter_formatter === void 0 ? void 0 : _cachedFormatter_formatter.call(cachedFormatter, value);
        }
        return result != null ? String(result) : void 0;
    }
    constructor(){
        super(...arguments);
        this.enabled = true;
        this.border = new LabelBorder();
        this._cachedFormatter = void 0;
    }
};
__decorateClass([
    Property
], Label.prototype, "enabled", 2);
__decorateClass([
    Property
], Label.prototype, "border", 2);
__decorateClass([
    Property
], Label.prototype, "color", 2);
__decorateClass([
    Property
], Label.prototype, "cornerRadius", 2);
__decorateClass([
    Property
], Label.prototype, "fill", 2);
__decorateClass([
    Property
], Label.prototype, "fillOpacity", 2);
__decorateClass([
    Property
], Label.prototype, "fontStyle", 2);
__decorateClass([
    Property
], Label.prototype, "fontWeight", 2);
__decorateClass([
    Property
], Label.prototype, "fontSize", 2);
__decorateClass([
    Property
], Label.prototype, "fontFamily", 2);
__decorateClass([
    Property
], Label.prototype, "formatter", 2);
__decorateClass([
    Property
], Label.prototype, "format", 2);
__decorateClass([
    Property
], Label.prototype, "padding", 2);
__decorateClass([
    Property
], Label.prototype, "itemStyler", 2);
function expandLabelPadding(label) {
    var _label_border;
    const { enabled: borderEnabled = false, stroke: borderStroke } = (_label_border = label === null || label === void 0 ? void 0 : label.border) !== null && _label_border !== void 0 ? _label_border : {};
    const hasBoxing = (label === null || label === void 0 ? void 0 : label.fill) != null || borderEnabled && borderStroke != null;
    const padding2 = hasBoxing ? label === null || label === void 0 ? void 0 : label.padding : null;
    if (padding2 == null) {
        return {
            bottom: 0,
            left: 0,
            right: 0,
            top: 0
        };
    } else if (typeof padding2 === "number") {
        return {
            bottom: padding2,
            left: padding2,
            right: padding2,
            top: padding2
        };
    } else {
        const { bottom = 0, left = 0, right = 0, top = 0 } = padding2;
        return {
            bottom,
            left,
            right,
            top
        };
    }
}
function calculateLabelRotation(rotation, parallel) {
    let regularFlipRotation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, parallelFlipRotation = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const configuredRotation = normalizeAngle360FromDegrees(rotation);
    const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;
    const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;
    let defaultRotation = 0;
    if (parallel) {
        defaultRotation = parallelFlipFlag * Math.PI / 2;
    } else if (regularFlipFlag === -1) {
        defaultRotation = Math.PI;
    }
    return {
        configuredRotation,
        defaultRotation,
        parallelFlipFlag,
        regularFlipFlag
    };
}
function getLabelSpacing(minSpacing, rotated) {
    if (minSpacing != null) {
        return minSpacing;
    }
    return rotated ? 0 : 10;
}
function getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {
    if (parallel && !labelRotation) {
        return sideFlag * parallelFlipFlag === -1 ? "top" : "bottom";
    }
    return "middle";
}
function getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {
    const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;
    const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;
    const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;
    if (parallel) {
        if (labelRotation || labelAutoRotation) {
            if (sideFlag * alignFlag === -1) {
                return "end";
            }
        } else {
            return "center";
        }
    } else if (sideFlag * regularFlipFlag === -1) {
        return "end";
    }
    return "start";
}
function labelSpecifier(format, timeInterval3) {
    if (format == null) return;
    if (typeof format === "string") {
        return format;
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(format) && timeInterval3 != null) {
        return format[intervalUnit(timeInterval3)];
    }
}
function timeIntervalMaxLabelSize(label, primaryLabel, domain, timeInterval3, textMeasurer) {
    var _labelSpecifier;
    const specifier = (_labelSpecifier = labelSpecifier(label.format, timeInterval3)) !== null && _labelSpecifier !== void 0 ? _labelSpecifier : typeof label.format === "string" ? label.format : void 0;
    if (specifier == null) return {
        width: 0,
        height: 0
    };
    const labelFormatter = buildDateFormatter(specifier);
    const hierarchy = timeInterval3 ? intervalHierarchy(timeInterval3) : void 0;
    const primarySpecifier = labelSpecifier(primaryLabel === null || primaryLabel === void 0 ? void 0 : primaryLabel.format, hierarchy);
    const primaryLabelFormatter = primarySpecifier ? buildDateFormatter(primarySpecifier) : labelFormatter;
    const d0 = new Date(domain[0]);
    const d1 = new Date(domain[domain.length - 1]);
    const hierarchyRange = hierarchy ? intervalRange(hierarchy, new Date(domain[0]), new Date(domain[domain.length - 1]), {
        extend: true
    }) : void 0;
    let maxWidth = 0;
    let maxHeight = 0;
    if (labelFormatter != null) {
        const padding2 = expandLabelPadding(label);
        const xPadding = padding2.left + padding2.right;
        const yPadding = padding2.top + padding2.bottom;
        let l0;
        let l1;
        if (hierarchyRange != null && hierarchyRange.length > 1) {
            l0 = hierarchyRange[0];
            l1 = hierarchyRange[1];
        } else {
            l0 = d0;
            l1 = d1;
        }
        const labelRange = intervalRange(timeInterval3, l0, l1, {
            limit: 50
        });
        for (const date5 of labelRange){
            const text = labelFormatter(date5);
            const { width: width2, height: height2 } = textMeasurer.measureLines(text);
            maxWidth = Math.max(maxWidth, width2 + xPadding);
            maxHeight = Math.max(maxHeight, height2 + yPadding);
        }
    }
    if (primaryLabelFormatter != null && hierarchyRange != null) {
        const padding2 = expandLabelPadding(primaryLabel);
        const xPadding = padding2.left + padding2.right;
        const yPadding = padding2.top + padding2.bottom;
        for (const date5 of hierarchyRange){
            const text = primaryLabelFormatter(date5);
            const { width: width2, height: height2 } = textMeasurer.measureLines(text);
            maxWidth = Math.max(maxWidth, width2 + xPadding);
            maxHeight = Math.max(maxHeight, height2 + yPadding);
        }
    }
    return {
        width: Math.ceil(maxWidth),
        height: Math.ceil(maxHeight)
    };
}
function createLabelData(tickData, labelX, labelMatrix, textMeasurer, label) {
    const padding2 = expandLabelPadding(label);
    const xPadding = padding2.left + padding2.right;
    const yPadding = padding2.top + padding2.bottom;
    const labelData = [];
    for (const { tickLabel: text, translation } of tickData){
        if (!text) continue;
        const { x, y } = labelMatrix.transformBBox(new BBox(labelX, translation, 0, 0));
        const metrics = textMeasurer.measureLines(text);
        const width2 = metrics.width + xPadding;
        const height2 = metrics.height + yPadding;
        labelData.push({
            point: {
                x,
                y
            },
            label: {
                text,
                width: width2,
                height: height2
            }
        });
    }
    return labelData;
}
function createFixedLabelData(param, labelX, labelMatrix) {
    let { width: width2, height: height2, spacing } = param;
    const labelData = [];
    for (const translationY of [
        0,
        spacing
    ]){
        const { x, y } = labelMatrix.transformBBox(new BBox(labelX, translationY, 0, 0));
        labelData.push({
            point: {
                x,
                y
            },
            label: {
                text: void 0,
                width: width2,
                height: height2
            }
        });
    }
    return labelData;
}
;
;
var ModuleMap = class {
    *modules() {
        for (const m of this.moduleMap.values()){
            yield m.moduleInstance;
        }
    }
    addModule(module, moduleFactory) {
        if (this.moduleMap.has(module.optionsKey)) {
            throw new Error("AG Charts - module already initialised: ".concat(module.optionsKey));
        }
        this.moduleMap.set(module.optionsKey, {
            module,
            moduleInstance: moduleFactory(module)
        });
    }
    removeModule(module) {
        var _this_moduleMap_get;
        const moduleKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(module) ? module : module.optionsKey;
        (_this_moduleMap_get = this.moduleMap.get(moduleKey)) === null || _this_moduleMap_get === void 0 ? void 0 : _this_moduleMap_get.moduleInstance.destroy();
        this.moduleMap.delete(moduleKey);
    }
    getModule(module) {
        var _this_moduleMap_get;
        return (_this_moduleMap_get = this.moduleMap.get((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(module) ? module : module.optionsKey)) === null || _this_moduleMap_get === void 0 ? void 0 : _this_moduleMap_get.moduleInstance;
    }
    isEnabled(module) {
        return this.moduleMap.has((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(module) ? module : module.optionsKey);
    }
    mapModules(callback8) {
        return Array.from(this.moduleMap.values(), (m, i)=>callback8(m.moduleInstance, i));
    }
    destroy() {
        for (const moduleKey of this.moduleMap.keys()){
            var _this_moduleMap_get;
            (_this_moduleMap_get = this.moduleMap.get(moduleKey)) === null || _this_moduleMap_get === void 0 ? void 0 : _this_moduleMap_get.moduleInstance.destroy();
        }
        this.moduleMap.clear();
    }
    constructor(){
        this.moduleMap = /* @__PURE__ */ new Map();
    }
};
;
// packages/ag-charts-community/src/scene/shape/range.ts
var Range = class extends Shape {
    computeBBox() {
        return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
    }
    isPointInPath(_x, _y) {
        return false;
    }
    render(renderCtx) {
        var _this_fillShadow;
        const { ctx } = renderCtx;
        let { x1, y1, x2, y2 } = this;
        x1 = this.align(x1);
        y1 = this.align(y1);
        x2 = this.align(x2);
        y2 = this.align(y2);
        const { fill, horizontal } = this;
        const { globalAlpha } = ctx;
        if (fill != null) {
            this.applyFillAndAlpha(ctx);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x1, y2);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = globalAlpha;
        }
        const { stroke: stroke2, strokeWidth, startLine, endLine } = this;
        const strokeActive = !!((startLine || endLine) && stroke2 && strokeWidth);
        if (strokeActive) {
            const { lineDash, lineDashOffset, lineCap, lineJoin } = this;
            this.applyStrokeAndAlpha(ctx);
            ctx.lineWidth = strokeWidth;
            if (lineDash) {
                ctx.setLineDash([
                    ...lineDash
                ]);
            }
            if (lineDashOffset) {
                ctx.lineDashOffset = lineDashOffset;
            }
            if (lineCap) {
                ctx.lineCap = lineCap;
            }
            if (lineJoin) {
                ctx.lineJoin = lineJoin;
            }
            ctx.beginPath();
            if (startLine) {
                ctx.moveTo(x1, y1);
                if (horizontal) {
                    ctx.lineTo(x1, y2);
                } else {
                    ctx.lineTo(x2, y1);
                }
            }
            if (endLine) {
                ctx.moveTo(x2, y2);
                if (horizontal) {
                    ctx.lineTo(x2, y1);
                } else {
                    ctx.lineTo(x1, y2);
                }
            }
            ctx.stroke();
            ctx.globalAlpha = globalAlpha;
        }
        (_this_fillShadow = this.fillShadow) === null || _this_fillShadow === void 0 ? void 0 : _this_fillShadow.markClean();
        super.render(renderCtx);
    }
    constructor(opts = {}){
        super(opts);
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
        this.startLine = false;
        this.endLine = false;
        this.horizontal = false;
        this.strokeWidth = 1;
    }
};
Range.className = "Range";
__decorateClass([
    SceneChangeDetection()
], Range.prototype, "x1", 2);
__decorateClass([
    SceneChangeDetection()
], Range.prototype, "y1", 2);
__decorateClass([
    SceneChangeDetection()
], Range.prototype, "x2", 2);
__decorateClass([
    SceneChangeDetection()
], Range.prototype, "y2", 2);
__decorateClass([
    SceneChangeDetection()
], Range.prototype, "startLine", 2);
__decorateClass([
    SceneChangeDetection()
], Range.prototype, "endLine", 2);
__decorateClass([
    SceneChangeDetection()
], Range.prototype, "horizontal", 2);
;
function isStringObject(value) {
    return value != null && Object.hasOwn(value, "toString") && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(value.toString());
}
function isNumberObject(value) {
    return value != null && Object.hasOwn(value, "valueOf") && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(value.valueOf());
}
function isContinuous(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(value) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidDate"])(value) || isNumberObject(value);
}
function checkDatum(value, isContinuousScale) {
    return value != null && (!isContinuousScale || isContinuous(value));
}
function transformIntegratedCategoryValue(value) {
    if (isStringObject(value) && Object.hasOwn(value, "id")) {
        return value.id;
    }
    return value;
}
// packages/ag-charts-community/src/chart/crossline/crossLine.ts
function getCrossLineValue(crossLine) {
    switch(crossLine.type){
        case "line":
            return crossLine.value;
        case "range":
            return crossLine.range;
    }
}
function validateCrossLineValue(crossLine, scale2) {
    const value = getCrossLineValue(crossLine);
    if (value == null) {
        return false;
    }
    const isContinuous2 = ContinuousScale.is(scale2) || DiscreteTimeScale.is(scale2);
    const validValue = (val)=>checkDatum(val, isContinuous2) && !isNaN(scale2.convert(val, {
            clamp: true
        }));
    if (crossLine.type === "range") {
        const [start2, end2] = value;
        return validValue(start2) && validValue(end2);
    } else {
        return validValue(value);
    }
}
// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts
var horizontalLineAnchors = {
    top: {
        rangeH: 0,
        rangeV: -1,
        labelH: 0,
        labelV: 1
    },
    "inside-top": {
        rangeH: 0,
        rangeV: -1,
        labelH: 0,
        labelV: 1
    },
    "top-left": {
        rangeH: -1,
        rangeV: -1,
        labelH: -1,
        labelV: 1
    },
    "inside-top-left": {
        rangeH: -1,
        rangeV: -1,
        labelH: -1,
        labelV: 1
    },
    left: {
        rangeH: -1,
        rangeV: 0,
        labelH: 1,
        labelV: 0
    },
    "inside-left": {
        rangeH: -1,
        rangeV: 0,
        labelH: -1,
        labelV: 0
    },
    "bottom-left": {
        rangeH: -1,
        rangeV: 1,
        labelH: -1,
        labelV: -1
    },
    "inside-bottom-left": {
        rangeH: -1,
        rangeV: 1,
        labelH: -1,
        labelV: -1
    },
    bottom: {
        rangeH: 0,
        rangeV: 1,
        labelH: 0,
        labelV: -1
    },
    "inside-bottom": {
        rangeH: 0,
        rangeV: 1,
        labelH: 0,
        labelV: -1
    },
    "bottom-right": {
        rangeH: 1,
        rangeV: 1,
        labelH: 1,
        labelV: -1
    },
    "inside-bottom-right": {
        rangeH: 1,
        rangeV: 1,
        labelH: 1,
        labelV: -1
    },
    right: {
        rangeH: 1,
        rangeV: 0,
        labelH: -1,
        labelV: 0
    },
    "inside-right": {
        rangeH: 1,
        rangeV: 0,
        labelH: 1,
        labelV: 0
    },
    "top-right": {
        rangeH: 1,
        rangeV: -1,
        labelH: 1,
        labelV: 1
    },
    "inside-top-right": {
        rangeH: 1,
        rangeV: -1,
        labelH: 1,
        labelV: 1
    },
    inside: {
        rangeH: 0,
        rangeV: 0,
        labelH: 0,
        labelV: 0
    }
};
var verticalLineAnchors = {
    top: {
        rangeH: 0,
        rangeV: -1,
        labelH: 0,
        labelV: 1
    },
    "inside-top": {
        rangeH: 0,
        rangeV: -1,
        labelH: 0,
        labelV: -1
    },
    "top-left": {
        rangeH: -1,
        rangeV: -1,
        labelH: 1,
        labelV: -1
    },
    "inside-top-left": {
        rangeH: -1,
        rangeV: -1,
        labelH: 1,
        labelV: -1
    },
    left: {
        rangeH: -1,
        rangeV: 0,
        labelH: 1,
        labelV: 0
    },
    "inside-left": {
        rangeH: -1,
        rangeV: 0,
        labelH: 1,
        labelV: 0
    },
    "bottom-left": {
        rangeH: -1,
        rangeV: 1,
        labelH: 1,
        labelV: 1
    },
    "inside-bottom-left": {
        rangeH: -1,
        rangeV: 1,
        labelH: 1,
        labelV: 1
    },
    bottom: {
        rangeH: 0,
        rangeV: 1,
        labelH: 0,
        labelV: -1
    },
    "inside-bottom": {
        rangeH: 0,
        rangeV: 1,
        labelH: 0,
        labelV: 1
    },
    "bottom-right": {
        rangeH: 1,
        rangeV: 1,
        labelH: -1,
        labelV: 1
    },
    "inside-bottom-right": {
        rangeH: 1,
        rangeV: 1,
        labelH: -1,
        labelV: 1
    },
    right: {
        rangeH: 1,
        rangeV: 0,
        labelH: -1,
        labelV: 0
    },
    "inside-right": {
        rangeH: 1,
        rangeV: 0,
        labelH: -1,
        labelV: 0
    },
    "top-right": {
        rangeH: 1,
        rangeV: -1,
        labelH: -1,
        labelV: -1
    },
    "inside-top-right": {
        rangeH: -1,
        rangeV: -1,
        labelH: -1,
        labelV: -1
    },
    inside: {
        rangeH: 0,
        rangeV: 0,
        labelH: 0,
        labelV: 0
    }
};
var horizontalRangeAnchors = {
    top: {
        rangeH: 0,
        rangeV: -1,
        labelH: 0,
        labelV: 1
    },
    "inside-top": {
        rangeH: 0,
        rangeV: -1,
        labelH: 0,
        labelV: -1
    },
    "top-left": {
        rangeH: -1,
        rangeV: -1,
        labelH: -1,
        labelV: 1
    },
    "inside-top-left": {
        rangeH: -1,
        rangeV: -1,
        labelH: -1,
        labelV: -1
    },
    left: {
        rangeH: -1,
        rangeV: 0,
        labelH: 1,
        labelV: 0
    },
    "inside-left": {
        rangeH: -1,
        rangeV: 0,
        labelH: -1,
        labelV: 0
    },
    "bottom-left": {
        rangeH: -1,
        rangeV: 1,
        labelH: -1,
        labelV: -1
    },
    "inside-bottom-left": {
        rangeH: -1,
        rangeV: 1,
        labelH: -1,
        labelV: 1
    },
    bottom: {
        rangeH: 0,
        rangeV: 1,
        labelH: 0,
        labelV: -1
    },
    "inside-bottom": {
        rangeH: 0,
        rangeV: 1,
        labelH: 0,
        labelV: 1
    },
    "bottom-right": {
        rangeH: 1,
        rangeV: 1,
        labelH: 1,
        labelV: -1
    },
    "inside-bottom-right": {
        rangeH: 1,
        rangeV: 1,
        labelH: 1,
        labelV: 1
    },
    right: {
        rangeH: 1,
        rangeV: 0,
        labelH: -1,
        labelV: 0
    },
    "inside-right": {
        rangeH: 1,
        rangeV: 0,
        labelH: 1,
        labelV: 0
    },
    "top-right": {
        rangeH: 1,
        rangeV: -1,
        labelH: 1,
        labelV: 1
    },
    "inside-top-right": {
        rangeH: 1,
        rangeV: -1,
        labelH: 1,
        labelV: -1
    },
    inside: {
        rangeH: 0,
        rangeV: 0,
        labelH: 0,
        labelV: 0
    }
};
var verticalRangeAnchors = {
    top: {
        rangeH: 0,
        rangeV: -1,
        labelH: 0,
        labelV: 1
    },
    "inside-top": {
        rangeH: 0,
        rangeV: -1,
        labelH: 0,
        labelV: -1
    },
    "top-left": {
        rangeH: -1,
        rangeV: -1,
        labelH: 1,
        labelV: -1
    },
    "inside-top-left": {
        rangeH: -1,
        rangeV: -1,
        labelH: -1,
        labelV: -1
    },
    left: {
        rangeH: -1,
        rangeV: 0,
        labelH: 1,
        labelV: 0
    },
    "inside-left": {
        rangeH: -1,
        rangeV: 0,
        labelH: -1,
        labelV: 0
    },
    "bottom-left": {
        rangeH: -1,
        rangeV: 1,
        labelH: 1,
        labelV: 1
    },
    "inside-bottom-left": {
        rangeH: -1,
        rangeV: 1,
        labelH: -1,
        labelV: 1
    },
    bottom: {
        rangeH: 0,
        rangeV: 1,
        labelH: 0,
        labelV: -1
    },
    "inside-bottom": {
        rangeH: 0,
        rangeV: 1,
        labelH: 0,
        labelV: 1
    },
    "bottom-right": {
        rangeH: 1,
        rangeV: 1,
        labelH: -1,
        labelV: 1
    },
    "inside-bottom-right": {
        rangeH: 1,
        rangeV: 1,
        labelH: 1,
        labelV: 1
    },
    right: {
        rangeH: 1,
        rangeV: 0,
        labelH: -1,
        labelV: 0
    },
    "inside-right": {
        rangeH: 1,
        rangeV: 0,
        labelH: 1,
        labelV: 0
    },
    "top-right": {
        rangeH: 1,
        rangeV: -1,
        labelH: -1,
        labelV: -1
    },
    "inside-top-right": {
        rangeH: 1,
        rangeV: -1,
        labelH: 1,
        labelV: -1
    },
    inside: {
        rangeH: 0,
        rangeV: 0,
        labelH: 0,
        labelV: 0
    }
};
var CartesianCrossLineLabel = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.fontSize = 14 /* LARGE */ ;
        this.fontFamily = "Verdana, sans-serif";
        this.padding = 5;
        this.color = "rgba(87, 87, 87, 1)";
    }
};
__decorateClass([
    Property
], CartesianCrossLineLabel.prototype, "enabled", 2);
__decorateClass([
    Property
], CartesianCrossLineLabel.prototype, "text", 2);
__decorateClass([
    Property
], CartesianCrossLineLabel.prototype, "fontStyle", 2);
__decorateClass([
    Property
], CartesianCrossLineLabel.prototype, "fontWeight", 2);
__decorateClass([
    Property
], CartesianCrossLineLabel.prototype, "fontSize", 2);
__decorateClass([
    Property
], CartesianCrossLineLabel.prototype, "fontFamily", 2);
__decorateClass([
    Property
], CartesianCrossLineLabel.prototype, "padding", 2);
__decorateClass([
    Property
], CartesianCrossLineLabel.prototype, "color", 2);
__decorateClass([
    Property
], CartesianCrossLineLabel.prototype, "position", 2);
__decorateClass([
    Property
], CartesianCrossLineLabel.prototype, "rotation", 2);
__decorateClass([
    Property
], CartesianCrossLineLabel.prototype, "parallel", 2);
var CartesianCrossLine = class extends BaseProperties {
    get defaultLabelPosition() {
        return "top";
    }
    update(visible) {
        const { enabled, type, data, scale: scale2 } = this;
        if (!scale2 || !enabled || !visible || !validateCrossLineValue(this, scale2) || data == null) {
            this.rangeGroup.visible = false;
            this.lineGroup.visible = false;
            this.labelGroup.visible = false;
            return;
        }
        this.rangeGroup.visible = visible;
        this.lineGroup.visible = visible;
        this.labelGroup.visible = visible;
        this.updateNodes();
        const isRange = type === "range";
        if (isRange !== this._isRange) {
            if (isRange) {
                this.rangeGroup.appendChild(this.crossLineRange);
            } else {
                this.lineGroup.appendChild(this.crossLineRange);
            }
        }
        this._isRange = isRange;
    }
    calculateLayout(visible) {
        this.data = void 0;
        if (!visible) return;
        const { type, range: range3, value, scale: scale2, clippedRange, strokeWidth = 0 } = this;
        if (!scale2) return;
        var _scale2_bandwidth;
        const bandwidth = (_scale2_bandwidth = scale2.bandwidth) !== null && _scale2_bandwidth !== void 0 ? _scale2_bandwidth : 0;
        var _scale2_step;
        const step = (_scale2_step = scale2.step) !== null && _scale2_step !== void 0 ? _scale2_step : 0;
        const rangePadding = scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0;
        let [clippedRange0, clippedRange1] = findMinMax(clippedRange);
        clippedRange0 -= bandwidth;
        clippedRange1 += bandwidth;
        let yStart;
        let yEnd;
        let clampedYStart;
        let clampedYEnd;
        if (type === "line") {
            const offset = bandwidth / 2;
            yStart = scale2.convert(value) + offset;
            yEnd = NaN;
            clampedYStart = scale2.convert(value, {
                clamp: true
            }) + offset;
            clampedYEnd = NaN;
            if (clampedYStart >= clippedRange1 || clampedYStart <= clippedRange0) {
                return;
            }
        } else if (range3) {
            const [r0, r1] = range3;
            const [startAlignment, endAlignment] = rangeAlignment(r0, r1);
            yStart = scale2.convert(r0, {
                alignment: startAlignment
            });
            yEnd = scale2.convert(r1, {
                alignment: endAlignment
            });
            clampedYStart = scale2.convert(r0, {
                clamp: true,
                alignment: startAlignment
            });
            clampedYEnd = scale2.convert(r1, {
                clamp: true,
                alignment: endAlignment
            });
            if (clampedYStart > clampedYEnd) {
                [clampedYStart, clampedYEnd] = [
                    clampedYEnd,
                    clampedYStart
                ];
                [yStart, yEnd] = [
                    yEnd,
                    yStart
                ];
            }
            if (clampedYStart >= clippedRange1 || clampedYEnd <= clippedRange0) {
                return;
            }
            if (Number.isFinite(yStart)) {
                clampedYStart -= rangePadding;
            }
            if (Number.isFinite(yEnd)) {
                yEnd += bandwidth;
                clampedYEnd += bandwidth + rangePadding;
            }
        } else {
            return;
        }
        clampedYStart = clampArray(clampedYStart, clippedRange);
        clampedYEnd = clampArray(clampedYEnd, clippedRange);
        if (yStart - rangePadding >= clampedYStart) yStart -= rangePadding;
        if (yEnd + rangePadding <= clampedYEnd) yEnd += rangePadding;
        this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + rangePadding;
        this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - rangePadding && yEnd <= clampedYEnd;
        this.data = [
            clampedYStart,
            clampedYEnd
        ];
        if (this.label.enabled === false || !this.label.text) return;
    }
    updateNodes() {
        const { position, data: [r0, r1] = [
            0,
            0
        ], gridLength } = this;
        const dr = Number.isFinite(r1) ? r1 - r0 : 0;
        let bounds;
        switch(position){
            case "top":
            case "bottom":
                bounds = new BBox(r0, position === "top" ? 0 : -gridLength, dr, gridLength);
                break;
            case "left":
            case "right":
                bounds = new BBox(position === "left" ? 0 : -gridLength, r0, gridLength, dr);
        }
        this.updateRangeNode(bounds);
        const { label } = this;
        if (label.enabled !== false && label.text) {
            this.updateLabel();
            this.positionLabel(bounds);
        }
    }
    updateRangeNode(bounds) {
        const { type, position, crossLineRange, startLine, endLine, fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash } = this;
        crossLineRange.x1 = bounds.x;
        crossLineRange.x2 = bounds.x + bounds.width;
        crossLineRange.y1 = bounds.y;
        crossLineRange.y2 = bounds.y + bounds.height;
        crossLineRange.horizontal = position === "top" || position === "bottom";
        crossLineRange.startLine = startLine;
        crossLineRange.endLine = endLine;
        crossLineRange.fill = type === "range" ? fill : void 0;
        crossLineRange.fillOpacity = fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1;
        crossLineRange.stroke = stroke2;
        crossLineRange.strokeWidth = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 1;
        crossLineRange.strokeOpacity = strokeOpacity !== null && strokeOpacity !== void 0 ? strokeOpacity : 1;
        crossLineRange.lineDash = lineDash;
    }
    updateLabel() {
        const { crossLineLabel, label } = this;
        if (!label.text) return;
        crossLineLabel.fontStyle = label.fontStyle;
        crossLineLabel.fontWeight = label.fontWeight;
        crossLineLabel.fontSize = label.fontSize;
        crossLineLabel.fontFamily = label.fontFamily;
        crossLineLabel.fill = label.color;
        crossLineLabel.text = label.text;
    }
    get anchor() {
        const horizontal = this.position === "left" || this.position === "right";
        const range3 = this.type === "range";
        const { position = this.defaultLabelPosition } = this.label;
        if (range3) {
            const anchors = horizontal ? horizontalRangeAnchors : verticalRangeAnchors;
            return anchors[position];
        } else {
            const anchors = horizontal ? horizontalLineAnchors : verticalLineAnchors;
            return anchors[position];
        }
    }
    positionLabel(bounds) {
        const { crossLineLabel, label, anchor } = this;
        var _label_rotation;
        crossLineLabel.rotation = toRadians((_label_rotation = label.rotation) !== null && _label_rotation !== void 0 ? _label_rotation : 0);
        crossLineLabel.textBaseline = "middle";
        crossLineLabel.textAlign = "center";
        const bbox = crossLineLabel.getBBox();
        if (!bbox) return;
        const { width: width2, height: height2 } = bbox;
        const xOffset = label.padding + width2 / 2;
        const yOffset = label.padding + height2 / 2;
        const x = bounds.x + bounds.width * (anchor.rangeH + 1) / 2 - xOffset * anchor.labelH;
        const y = bounds.y + bounds.height * (anchor.rangeV + 1) / 2 - yOffset * anchor.labelV;
        crossLineLabel.x = x;
        crossLineLabel.y = y;
        crossLineLabel.rotationCenterX = x;
        crossLineLabel.rotationCenterY = y;
    }
    computeLabelSize() {
        const { label } = this;
        if (label.enabled === false || !label.text) return;
        const tempText = new TransformableText();
        tempText.fontFamily = label.fontFamily;
        tempText.fontSize = label.fontSize;
        tempText.fontStyle = label.fontStyle;
        tempText.fontWeight = label.fontWeight;
        tempText.text = label.text;
        var _label_rotation;
        tempText.rotation = toRadians((_label_rotation = label.rotation) !== null && _label_rotation !== void 0 ? _label_rotation : 0);
        tempText.textBaseline = "middle";
        tempText.textAlign = "center";
        const bbox = tempText.getBBox();
        if (!bbox) return;
        const { width: width2, height: height2 } = bbox;
        return {
            width: width2,
            height: height2
        };
    }
    calculatePadding(into) {
        const { label, anchor } = this;
        const size = this.computeLabelSize();
        if (!size) return;
        const { width: width2, height: height2 } = size;
        const xOffset = label.padding + width2;
        const yOffset = label.padding + height2;
        const horizontal = this.position === "left" || this.position === "right";
        if (horizontal) {
            if (anchor.rangeH === -1 && anchor.labelH === 1) {
                var _into_left;
                into.left = Math.max((_into_left = into.left) !== null && _into_left !== void 0 ? _into_left : 0, xOffset);
            } else if (anchor.rangeH === 1 && anchor.labelH === -1) {
                var _into_right;
                into.right = Math.max((_into_right = into.right) !== null && _into_right !== void 0 ? _into_right : 0, xOffset);
            }
        }
        if (!horizontal) {
            if (anchor.rangeV === -1 && anchor.labelV === 1) {
                var _into_top;
                into.top = Math.max((_into_top = into.top) !== null && _into_top !== void 0 ? _into_top : 0, yOffset);
            } else if (anchor.rangeV === 1 && anchor.labelV === -1) {
                var _into_bottom;
                into.bottom = Math.max((_into_bottom = into.bottom) !== null && _into_bottom !== void 0 ? _into_bottom : 0, yOffset);
            }
        }
    }
    constructor(){
        super();
        this.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createId"])(this);
        this.defaultColorRange = [];
        this.fill = "#c16068";
        this.label = new CartesianCrossLineLabel();
        this.scale = void 0;
        this.clippedRange = [
            -Infinity,
            Infinity
        ];
        this.gridLength = 0;
        this.position = "top";
        this.rangeGroup = new Group({
            name: this.id
        });
        this.lineGroup = new Group({
            name: this.id
        });
        this.labelGroup = new Group({
            name: this.id
        });
        this.crossLineRange = new Range();
        this.crossLineLabel = new TransformableText();
        this.data = void 0;
        this.startLine = false;
        this.endLine = false;
        this._isRange = void 0;
        this.lineGroup.append(this.crossLineRange);
        this.labelGroup.append(this.crossLineLabel);
        this.crossLineRange.pointerEvents = 1 /* None */ ;
    }
};
CartesianCrossLine.className = "CrossLine";
__decorateClass([
    Property
], CartesianCrossLine.prototype, "enabled", 2);
__decorateClass([
    Property
], CartesianCrossLine.prototype, "type", 2);
__decorateClass([
    Property
], CartesianCrossLine.prototype, "range", 2);
__decorateClass([
    Property
], CartesianCrossLine.prototype, "value", 2);
__decorateClass([
    Property
], CartesianCrossLine.prototype, "defaultColorRange", 2);
__decorateClass([
    Property
], CartesianCrossLine.prototype, "fill", 2);
__decorateClass([
    Property
], CartesianCrossLine.prototype, "fillOpacity", 2);
__decorateClass([
    Property
], CartesianCrossLine.prototype, "stroke", 2);
__decorateClass([
    Property
], CartesianCrossLine.prototype, "strokeWidth", 2);
__decorateClass([
    Property
], CartesianCrossLine.prototype, "strokeOpacity", 2);
__decorateClass([
    Property
], CartesianCrossLine.prototype, "lineDash", 2);
__decorateClass([
    Property
], CartesianCrossLine.prototype, "label", 2);
// packages/ag-charts-community/src/chart/axis/axisGridLine.ts
var AxisGridLine = class {
    constructor(){
        this.enabled = true;
        this.width = 1;
        this.style = [
            {
                fill: void 0,
                fillOpacity: 1,
                stroke: void 0,
                strokeWidth: void 0,
                lineDash: []
            }
        ];
    }
};
__decorateClass([
    Property
], AxisGridLine.prototype, "enabled", 2);
__decorateClass([
    Property
], AxisGridLine.prototype, "width", 2);
__decorateClass([
    Property
], AxisGridLine.prototype, "style", 2);
// packages/ag-charts-community/src/chart/axis/axisInterval.ts
var AxisInterval = class extends BaseProperties {
};
__decorateClass([
    Property
], AxisInterval.prototype, "placement", 2);
__decorateClass([
    Property
], AxisInterval.prototype, "step", 2);
__decorateClass([
    Property
], AxisInterval.prototype, "values", 2);
__decorateClass([
    Property
], AxisInterval.prototype, "minSpacing", 2);
__decorateClass([
    Property
], AxisInterval.prototype, "maxSpacing", 2);
// packages/ag-charts-community/src/chart/axis/axisLabel.ts
var AxisLabel = class extends BaseProperties {
    /**
   * The side of the axis line to position the labels on.
   * -1 = left (default)
   * 1 = right
   */ getSideFlag() {
        return this.mirrored ? 1 : -1;
    }
    formatValue(callWithContext2, params, index) {
        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
            dateStyle: "long",
            truncateDate: void 0
        };
        const { formatter: formatter2, format } = this;
        const { type, value, domain, boundSeries } = params;
        const fractionDigits = params.type === "number" ? params.fractionDigits : void 0;
        const unit = params.type === "date" ? params.unit : void 0;
        let result;
        if (formatter2 != null) {
            const step = params.type === "date" ? params.step : void 0;
            result = callWithContext2(formatter2, {
                value,
                index,
                domain,
                fractionDigits,
                unit,
                step,
                boundSeries
            });
        }
        if (format != null && result == null) {
            var _valueFormatter_formatter;
            const { specifier, dateStyle, truncateDate } = options;
            const cacheKey = "".concat(dateStyle, ":").concat(truncateDate !== null && truncateDate !== void 0 ? truncateDate : "none");
            let valueFormatter = this._formatters[cacheKey];
            const mergedFormat = FormatManager.mergeSpecifiers(specifier, format);
            if (valueFormatter == null || valueFormatter.type !== type || valueFormatter.unit !== unit || !objectsEqual(valueFormatter.mergedFormat, mergedFormat)) {
                valueFormatter = {
                    type,
                    mergedFormat,
                    unit,
                    formatter: FormatManager.getFormatter(type, mergedFormat, unit, dateStyle, options)
                };
                this._formatters[cacheKey] = valueFormatter;
            }
            result = (_valueFormatter_formatter = valueFormatter.formatter) === null || _valueFormatter_formatter === void 0 ? void 0 : _valueFormatter_formatter.call(valueFormatter, value, fractionDigits);
        }
        return result != null ? String(result) : void 0;
    }
    constructor(){
        super(...arguments);
        this.enabled = true;
        this.border = new LabelBorder();
        this.wrapping = "never";
        this.truncate = false;
        this.spacing = 5;
        this.color = "#575757";
        this.avoidCollisions = true;
        this.mirrored = false;
        this.parallel = false;
        this._formatters = {
            "component:year": void 0,
            "component:month": void 0,
            "component:day": void 0,
            "component:none": void 0,
            "long:year": void 0,
            "long:month": void 0,
            "long:day": void 0,
            "long:none": void 0
        };
    }
};
__decorateClass([
    Property
], AxisLabel.prototype, "enabled", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "border", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "cornerRadius", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "fill", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "fillOpacity", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "fontStyle", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "fontWeight", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "fontSize", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "fontFamily", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "wrapping", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "truncate", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "spacing", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "minSpacing", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "color", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "rotation", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "avoidCollisions", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "mirrored", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "padding", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "parallel", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "itemStyler", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "formatter", 2);
__decorateClass([
    Property
], AxisLabel.prototype, "format", 2);
// packages/ag-charts-community/src/chart/axis/axisLine.ts
var AxisLine = class {
    constructor(){
        this.enabled = true;
        this.width = 1;
        this.stroke = void 0;
    }
};
__decorateClass([
    Property
], AxisLine.prototype, "enabled", 2);
__decorateClass([
    Property
], AxisLine.prototype, "width", 2);
__decorateClass([
    Property
], AxisLine.prototype, "stroke", 2);
// packages/ag-charts-community/src/chart/axis/axisTick.ts
var AxisTick = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.enabled = true;
        this.width = 1;
        this.size = 6;
    }
};
__decorateClass([
    Property
], AxisTick.prototype, "enabled", 2);
__decorateClass([
    Property
], AxisTick.prototype, "width", 2);
__decorateClass([
    Property
], AxisTick.prototype, "size", 2);
__decorateClass([
    Property
], AxisTick.prototype, "stroke", 2);
// packages/ag-charts-community/src/chart/axis/axisTitle.ts
var AxisTitle = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.caption = new Caption();
        this.enabled = false;
        this.spacing = Caption.SMALL_PADDING;
        this.fontSize = 10 /* SMALLER */ ;
        this.fontFamily = "sans-serif";
        this.wrapping = "always";
    }
};
__decorateClass([
    Property
], AxisTitle.prototype, "enabled", 2);
__decorateClass([
    Property
], AxisTitle.prototype, "text", 2);
__decorateClass([
    Property
], AxisTitle.prototype, "spacing", 2);
__decorateClass([
    Property
], AxisTitle.prototype, "fontStyle", 2);
__decorateClass([
    Property
], AxisTitle.prototype, "fontWeight", 2);
__decorateClass([
    Property
], AxisTitle.prototype, "fontSize", 2);
__decorateClass([
    Property
], AxisTitle.prototype, "fontFamily", 2);
__decorateClass([
    Property
], AxisTitle.prototype, "color", 2);
__decorateClass([
    Property
], AxisTitle.prototype, "wrapping", 2);
__decorateClass([
    Property
], AxisTitle.prototype, "formatter", 2);
// packages/ag-charts-community/src/chart/axis/axisUtil.ts
var NiceMode = /* @__PURE__ */ ((NiceMode2)=>{
    NiceMode2[NiceMode2["TickAndDomain"] = 0] = "TickAndDomain";
    NiceMode2[NiceMode2["TicksOnly"] = 1] = "TicksOnly";
    NiceMode2[NiceMode2["Off"] = 2] = "Off";
    return NiceMode2;
})(NiceMode || {});
function prepareAxisAnimationContext(axis) {
    const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);
    const min = Math.floor(requestedRangeMin);
    const max = Math.ceil(requestedRangeMax);
    return {
        min,
        max,
        visible: min !== max
    };
}
var fullCircle = Math.PI * 2;
var halfCircle = fullCircle / 2;
function normaliseEndRotation(start2, end2) {
    const directDistance = Math.abs(end2 - start2);
    if (directDistance < halfCircle) {
        return end2;
    } else if (start2 > end2) {
        return end2 + fullCircle;
    }
    return end2 - fullCircle;
}
function prepareAxisAnimationFunctions(ctx) {
    const { min, max } = ctx;
    const outOfBounds = (y)=>{
        return y < min || y > max;
    };
    const tick = {
        fromFn (node, datum, status) {
            let { x1, x2, y1, y2 } = node;
            let opacity = node.opacity;
            if (status === "added" || outOfBounds(datum.offset)) {
                ({ x1, x2, y1, y2 } = datum);
                opacity = 0;
            }
            return {
                x1,
                x2,
                y1,
                y2,
                opacity,
                phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
            };
        },
        toFn (_node, datum, status) {
            const { x1, x2, y1, y2 } = datum;
            let opacity = 1;
            if (status === "removed") {
                opacity = 0;
            }
            return {
                x1,
                x2,
                y1,
                y2,
                opacity
            };
        },
        applyFn (node, props) {
            node.setProperties(props);
            node.visible = !outOfBounds(node.y);
        }
    };
    const label = {
        fromFn (node, newDatum, status) {
            var _node_previousDatum;
            const datum = (_node_previousDatum = node.previousDatum) !== null && _node_previousDatum !== void 0 ? _node_previousDatum : newDatum;
            let { x, y, rotationCenterX, rotationCenterY, rotation } = datum;
            let opacity = node.opacity;
            if (status === "removed" || outOfBounds(datum.y)) {
                rotation = newDatum.rotation;
            } else if (status === "added" || outOfBounds(node.datum.y)) {
                ({ x, y, rotationCenterX, rotationCenterY, rotation } = newDatum);
                opacity = 0;
            }
            return {
                x,
                y,
                rotationCenterX,
                rotationCenterY,
                rotation,
                opacity,
                phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
            };
        },
        toFn (node, datum, status) {
            const { x, y, rotationCenterX, rotationCenterY } = datum;
            let rotation = 0;
            let opacity = 1;
            if (status === "added") {
                rotation = datum.rotation;
            } else if (status === "removed") {
                opacity = 0;
                rotation = datum.rotation;
            } else {
                var _node_previousDatum;
                var _node_previousDatum_rotation;
                rotation = normaliseEndRotation((_node_previousDatum_rotation = (_node_previousDatum = node.previousDatum) === null || _node_previousDatum === void 0 ? void 0 : _node_previousDatum.rotation) !== null && _node_previousDatum_rotation !== void 0 ? _node_previousDatum_rotation : datum.rotation, datum.rotation);
            }
            return {
                x,
                y,
                rotationCenterX,
                rotationCenterY,
                rotation,
                opacity,
                finish: {
                    rotation: datum.rotation
                }
            };
        }
    };
    const line = {
        fromFn (node, datum) {
            var _node_previousDatum;
            const { x1, x2, y1, y2 } = (_node_previousDatum = node.previousDatum) !== null && _node_previousDatum !== void 0 ? _node_previousDatum : datum;
            return {
                x1,
                x2,
                y1,
                y2,
                phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
            };
        },
        toFn (_node, datum) {
            const { x1, x2, y1, y2 } = datum;
            return {
                x1,
                x2,
                y1,
                y2
            };
        }
    };
    const group = {
        fromFn (node, _datum) {
            const { translationX, translationY } = node;
            return {
                translationX,
                translationY,
                phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
            };
        },
        toFn (_node, datum) {
            const { translationX, translationY } = datum;
            return {
                translationX,
                translationY
            };
        }
    };
    return {
        tick,
        line,
        label,
        group
    };
}
function resetAxisGroupFn() {
    return (_node, datum)=>{
        return {
            translationX: datum.translationX,
            translationY: datum.translationY
        };
    };
}
function resetAxisLabelSelectionFn() {
    return (_node, datum)=>{
        return {
            x: datum.x,
            y: datum.y,
            rotationCenterX: datum.rotationCenterX,
            rotationCenterY: datum.rotationCenterY,
            rotation: datum.rotation
        };
    };
}
function resetAxisLineSelectionFn() {
    return (_node, datum)=>{
        const { x1, x2, y1, y2 } = datum;
        return {
            x1,
            x2,
            y1,
            y2
        };
    };
}
function resetAxisFillSelectionFn() {
    return (_node, datum)=>{
        const { x1, x2, y1, y2 } = datum;
        return {
            x: x1,
            y: y1,
            width: x2 - x1,
            height: y2 - y1
        };
    };
}
// packages/ag-charts-community/src/chart/axis/axis.ts
var AxisGroupZIndexMap = /* @__PURE__ */ ((AxisGroupZIndexMap2)=>{
    AxisGroupZIndexMap2[AxisGroupZIndexMap2["TickLines"] = 0] = "TickLines";
    AxisGroupZIndexMap2[AxisGroupZIndexMap2["AxisLine"] = 1] = "AxisLine";
    AxisGroupZIndexMap2[AxisGroupZIndexMap2["TickLabels"] = 2] = "TickLabels";
    return AxisGroupZIndexMap2;
})(AxisGroupZIndexMap || {});
function tickLayoutCacheValid(a, b) {
    var _a_initialPrimaryTickCount, _b_initialPrimaryTickCount, _a_initialPrimaryTickCount1, _b_initialPrimaryTickCount1;
    return a.domain === b.domain && a.rangeExtent === b.rangeExtent && a.nice === b.nice && a.gridLength === b.gridLength && a.visibleRange[0] === b.visibleRange[0] && a.visibleRange[1] === b.visibleRange[1] && ((_a_initialPrimaryTickCount = a.initialPrimaryTickCount) === null || _a_initialPrimaryTickCount === void 0 ? void 0 : _a_initialPrimaryTickCount.unzoomed) === ((_b_initialPrimaryTickCount = b.initialPrimaryTickCount) === null || _b_initialPrimaryTickCount === void 0 ? void 0 : _b_initialPrimaryTickCount.unzoomed) && ((_a_initialPrimaryTickCount1 = a.initialPrimaryTickCount) === null || _a_initialPrimaryTickCount1 === void 0 ? void 0 : _a_initialPrimaryTickCount1.zoomed) === ((_b_initialPrimaryTickCount1 = b.initialPrimaryTickCount) === null || _b_initialPrimaryTickCount1 === void 0 ? void 0 : _b_initialPrimaryTickCount1.zoomed);
}
var _Axis = class _Axis {
    set crossLines(value) {
        const { CrossLineConstructor } = this.constructor;
        this._crossLines.forEach((crossLine)=>this.detachCrossLine(crossLine));
        this._crossLines = value.map((crossLine)=>{
            const instance = new CrossLineConstructor();
            instance.set(crossLine);
            return instance;
        });
        this._crossLines.forEach((crossLine)=>{
            this.attachCrossLine(crossLine);
            this.initCrossLine(crossLine);
        });
    }
    get crossLines() {
        return this._crossLines;
    }
    get type() {
        var _this_constructor_type;
        return (_this_constructor_type = this.constructor.type) !== null && _this_constructor_type !== void 0 ? _this_constructor_type : "";
    }
    get primaryLabel() {
        return void 0;
    }
    get primaryTick() {
        return void 0;
    }
    isCategoryLike() {
        return false;
    }
    resetAnimation(_phase) {}
    onMouseMove(event) {
        const node = this.tickLabelGroup.pickNode(event.currentX, event.currentY);
        const datum = node === null || node === void 0 ? void 0 : node.datum;
        const { textUntruncated: title = void 0 } = datum !== null && datum !== void 0 ? datum : {};
        if (title != null) {
            this.moduleCtx.tooltipManager.updateTooltip(this.id, {
                canvasX: event.currentX,
                canvasY: event.currentY,
                showArrow: false
            }, [
                {
                    type: "structured",
                    title
                }
            ]);
            this.isHovering = true;
        } else if (this.isHovering) {
            this.moduleCtx.tooltipManager.removeTooltip(this.id);
            this.isHovering = false;
        }
    }
    attachCrossLine(crossLine) {
        this.crossLineRangeGroup.appendChild(crossLine.rangeGroup);
        this.crossLineLineGroup.appendChild(crossLine.lineGroup);
        this.crossLineLabelGroup.appendChild(crossLine.labelGroup);
    }
    detachCrossLine(crossLine) {
        this.crossLineRangeGroup.removeChild(crossLine.rangeGroup);
        this.crossLineLineGroup.removeChild(crossLine.lineGroup);
        this.crossLineLabelGroup.removeChild(crossLine.labelGroup);
    }
    destroy() {
        this.moduleMap.destroy();
        this.cleanup.flush();
    }
    setScaleRange(visibleRange) {
        const { range: rr, scale: scale2 } = this;
        const span = (rr[1] - rr[0]) / (visibleRange[1] - visibleRange[0]);
        const shift = span * visibleRange[0];
        const start2 = rr[0] - shift;
        scale2.range = [
            start2,
            start2 + span
        ];
    }
    updateScale() {
        const { range: [r0, r1] } = this;
        this.setScaleRange(this.visibleRange);
        this.crossLines.forEach((crossLine)=>{
            crossLine.clippedRange = [
                r0,
                r1
            ];
        });
    }
    setCrossLinesVisible(visible) {
        this.crossLineRangeGroup.visible = visible;
        this.crossLineLineGroup.visible = visible;
        this.crossLineLabelGroup.visible = visible;
    }
    attachAxis(groups) {
        groups.gridNode.appendChild(this.gridGroup);
        groups.axisNode.appendChild(this.axisGroup);
        groups.labelNode.appendChild(this.labelGroup);
        groups.crossLineRangeNode.appendChild(this.crossLineRangeGroup);
        groups.crossLineLineNode.appendChild(this.crossLineLineGroup);
        groups.crossLineLabelNode.appendChild(this.crossLineLabelGroup);
    }
    detachAxis(groups) {
        groups.gridNode.removeChild(this.gridGroup);
        groups.axisNode.removeChild(this.axisGroup);
        groups.labelNode.removeChild(this.labelGroup);
        groups.crossLineRangeNode.removeChild(this.crossLineRangeGroup);
        groups.crossLineLineNode.removeChild(this.crossLineLineGroup);
        groups.crossLineLabelNode.removeChild(this.crossLineLabelGroup);
    }
    attachLabel(axisLabelNode) {
        this.labelGroup.append(axisLabelNode);
    }
    /**
   * Checks if a point or an object is in range.
   * @param value A point (or object's starting point).
   * @param tolerance Expands the range on both ends by this amount.
   */ inRange(value) {
        let tolerance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        const [min, max] = findMinMax(this.range);
        return value >= min - tolerance && value <= max + tolerance;
    }
    /**
   * Get a point's overflow on the range, expanded to include the non-visible range.
   * @param value Point
   * @returns Overflow
   */ getRangeOverflow(value) {
        const { range: rr, visibleRange: vr } = this;
        const size = (rr[1] - rr[0]) / (vr[1] - vr[0]);
        const [min, max] = findMinMax([
            rr[0] - size * vr[0],
            rr[0] - size * vr[0] + size
        ]);
        if (value < min) return value - min;
        if (value > max) return value - max;
        return 0;
    }
    createDatumFormatter(_domain, _ticks) {
        return;
    }
    onGridLengthChange(value, prevValue) {
        if (prevValue ^ value) {
            this.onGridVisibilityChange();
        }
        this.crossLines.forEach((crossLine)=>this.initCrossLine(crossLine));
    }
    onGridVisibilityChange() {}
    createLabel() {
        return new AxisLabel();
    }
    /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   */ update() {
        this.formatterBoundSeries.clear();
        this.updatePosition();
        this.updateSelections();
        this.tickLineGroup.visible = this.tick.enabled;
        this.gridLineGroup.visible = this.gridLine.enabled;
        this.tickLabelGroup.visible = this.label.enabled;
        this.updateLabels();
        this.updateCrossLines();
    }
    getLabelStyles(params, additionalStyles) {
        let label = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.label;
        const defaultStyle = {
            border: label.border,
            color: label.color,
            cornerRadius: label.cornerRadius,
            fill: label.fill,
            fillOpacity: label.fillOpacity,
            fontFamily: label.fontFamily,
            fontSize: label.fontSize,
            fontStyle: label.fontStyle,
            fontWeight: label.fontWeight,
            padding: label.padding,
            spacing: label.spacing
        };
        let stylerOutput;
        if (label.itemStyler) {
            stylerOutput = this.cachedCallWithContext(label.itemStyler, {
                ...params,
                ...defaultStyle
            });
        }
        const merged = mergeDefaults(stylerOutput, additionalStyles, defaultStyle);
        return {
            border: merged.border,
            color: merged.color,
            cornerRadius: merged.cornerRadius,
            fill: merged.fill,
            fillOpacity: merged.fillOpacity,
            fontFamily: merged.fontFamily,
            fontSize: merged.fontSize,
            fontStyle: merged.fontStyle,
            fontWeight: merged.fontWeight,
            padding: merged.padding,
            spacing: merged.spacing
        };
    }
    getTickSize() {
        let tick = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.tick;
        return tick.enabled ? tick.size : 0;
    }
    processData() {
        this.invalidateLayoutCache();
        const { includeInvisibleDomains, boundSeries, direction } = this;
        const visibleSeries = includeInvisibleDomains ? boundSeries : boundSeries.filter((s)=>s.isEnabled());
        const domains = visibleSeries.map((series)=>series.getDomain(direction));
        this.setDomains(...domains);
    }
    setDomains() {
        for(var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++){
            domains[_key] = arguments[_key];
        }
        let domain;
        let animatable;
        if (domains.length > 0) {
            ({ domain, animatable } = this.scale.normalizeDomains(...domains));
        } else {
            domain = [];
            animatable = true;
        }
        this.dataDomain = this.normaliseDataDomain(domain);
        if (this.reverse) {
            this.dataDomain.domain.reverse();
        }
        this.animatable = animatable;
    }
    calculateDomain(initialPrimaryTickCount) {
        const { dataDomain: { domain }, range: range3, nice, scale: scale2, gridLength } = this;
        const rangeExtent = findRangeExtent(range3);
        const visibleRange = [
            0,
            1
        ];
        this.updateScale();
        const { unzoomedTickLayoutCache } = this;
        let unzoomedTickLayout;
        if (unzoomedTickLayoutCache == null || !tickLayoutCacheValid(unzoomedTickLayoutCache, {
            domain,
            rangeExtent,
            nice,
            gridLength,
            visibleRange,
            initialPrimaryTickCount
        })) {
            const scaleRange = scale2.range;
            this.setScaleRange([
                0,
                1
            ]);
            const niceMode = nice ? 0 /* TickAndDomain */  : 2 /* Off */ ;
            unzoomedTickLayout = this.calculateTickLayout(domain, niceMode, [
                0,
                1
            ], initialPrimaryTickCount);
            scale2.range = scaleRange;
            this.unzoomedTickLayoutCache = {
                domain,
                rangeExtent,
                nice,
                gridLength,
                visibleRange,
                initialPrimaryTickCount,
                tickLayout: unzoomedTickLayout
            };
        } else {
            unzoomedTickLayout = unzoomedTickLayoutCache.tickLayout;
        }
        this.updateScale();
        scale2.domain = unzoomedTickLayout.niceDomain;
        return {
            unzoomedTickLayout,
            domain: scale2.domain
        };
    }
    calculateLayout(initialPrimaryTickCount, chartLayout) {
        this.chartLayout = chartLayout;
        const { visibleRange, nice } = this;
        const unzoomed = visibleRange[0] === 0 && visibleRange[1] === 1;
        const { unzoomedTickLayout, domain } = this.calculateDomain(initialPrimaryTickCount);
        let tickLayout;
        if (unzoomed) {
            tickLayout = unzoomedTickLayout;
        } else {
            const { range: range3, gridLength } = this;
            const rangeExtent = findRangeExtent(range3);
            const niceMode = nice ? 1 /* TicksOnly */  : 2 /* Off */ ;
            const { tickLayoutCache } = this;
            if (tickLayoutCache == null || !tickLayoutCacheValid(tickLayoutCache, {
                domain,
                rangeExtent,
                nice,
                gridLength,
                visibleRange,
                initialPrimaryTickCount
            })) {
                tickLayout = this.calculateTickLayout(domain, niceMode, visibleRange, initialPrimaryTickCount);
                this.tickLayoutCache = {
                    domain,
                    rangeExtent,
                    nice,
                    gridLength,
                    visibleRange,
                    initialPrimaryTickCount,
                    tickLayout
                };
            } else {
                tickLayout = tickLayoutCache.tickLayout;
            }
        }
        const { rawTickCount: zoomedTickCount = 0, fractionDigits, bbox } = tickLayout;
        var _unzoomedTickLayout_rawTickCount;
        const unzoomedTickCount = (_unzoomedTickLayout_rawTickCount = unzoomedTickLayout.rawTickCount) !== null && _unzoomedTickLayout_rawTickCount !== void 0 ? _unzoomedTickLayout_rawTickCount : 0;
        const primaryTickCount = zoomedTickCount !== 0 && unzoomedTickCount !== 0 ? {
            zoomed: zoomedTickCount,
            unzoomed: unzoomedTickCount
        } : void 0;
        this.tickLayout = tickLayout.layout;
        this.layout.label = {
            fractionDigits,
            spacing: this.label.spacing,
            format: this.label.format
        };
        this.layoutCrossLines();
        return {
            primaryTickCount,
            bbox
        };
    }
    invalidateLayoutCache() {
        this.unzoomedTickLayoutCache = void 0;
        this.tickLayoutCache = void 0;
        this.tickLayout = void 0;
    }
    updateCrossLines() {
        const crosslinesVisible = this.hasDefinedDomain() || this.hasVisibleSeries();
        this.crossLines.forEach((crossLine)=>{
            crossLine.update(crosslinesVisible);
        });
    }
    updatePosition() {
        const { crossLineRangeGroup, crossLineLineGroup, crossLineLabelGroup, gridGroup, translation } = this;
        const translationX = Math.floor(translation.x);
        const translationY = Math.floor(translation.y);
        gridGroup.setProperties({
            translationX,
            translationY
        });
        crossLineRangeGroup.setProperties({
            translationX,
            translationY
        });
        crossLineLineGroup.setProperties({
            translationX,
            translationY
        });
        crossLineLabelGroup.setProperties({
            translationX,
            translationY
        });
    }
    // For formatting (nice rounded) tick values.
    tickFormatter(domain, ticks, primary, inputFractionDigits, inputTimeInterval) {
        let dateStyle = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "long";
        const { moduleCtx, label } = this;
        const { formatManager } = moduleCtx;
        const primaryLabel = primary ? this.primaryLabel : void 0;
        const tickFormatParams = this.tickFormatParams(domain, ticks, inputFractionDigits, inputTimeInterval);
        const boundSeries = this.formatterBoundSeries.get();
        let fractionDigits;
        let timeInterval3;
        let truncateDate;
        if (tickFormatParams.type === "number") {
            fractionDigits = tickFormatParams.fractionDigits;
        } else if (tickFormatParams.type === "date") {
            const { unit, step, epoch } = tickFormatParams;
            timeInterval3 = {
                unit,
                step,
                epoch
            };
            truncateDate = tickFormatParams.truncateDate;
        }
        const f = this.uncachedCallWithContext.bind(this);
        const params = {
            datum: void 0,
            seriesId: void 0,
            legendItemName: void 0,
            key: void 0,
            source: "axis-label",
            property: this.direction,
            domain,
            boundSeries
        };
        const currentLabel = primaryLabel !== null && primaryLabel !== void 0 ? primaryLabel : label;
        const specifier = primary ? label.format : void 0;
        const options = {
            specifier: FormatManager.mergeSpecifiers(primaryLabel === null || primaryLabel === void 0 ? void 0 : primaryLabel.format, label.format),
            truncateDate
        };
        return (value, index)=>{
            const formatParams = this.datumFormatParams(value, params, fractionDigits, timeInterval3, dateStyle);
            formatParams.value = value;
            var _currentLabel_formatValue, _ref;
            return (_ref = (_currentLabel_formatValue = currentLabel.formatValue(f, formatParams, index, {
                specifier,
                dateStyle,
                truncateDate
            })) !== null && _currentLabel_formatValue !== void 0 ? _currentLabel_formatValue : formatManager.format(f, formatParams, options)) !== null && _ref !== void 0 ? _ref : formatManager.defaultFormat(formatParams, options);
        };
    }
    formatDatum(contextProvider, input, source, seriesId, legendItemName, datum, key, domain, label, params) {
        if (input == null) return "";
        const { moduleCtx, direction, dataDomain } = this;
        domain !== null && domain !== void 0 ? domain : domain = dataDomain.domain;
        const { formatManager } = moduleCtx;
        const boundSeries = this.formatterBoundSeries.get();
        let inputFractionDigits;
        switch(source){
            case "crosshair":
            case "annotation-label":
                inputFractionDigits = this.layout.label.fractionDigits + 1;
                break;
            case "series-label":
                inputFractionDigits = 2;
                break;
            case "tooltip":
                inputFractionDigits = 3;
                break;
            case "legend-label":
                inputFractionDigits = void 0;
                break;
        }
        const formatParams = this.datumFormatParams(input, {
            source,
            datum,
            seriesId,
            legendItemName,
            key,
            property: direction,
            domain,
            boundSeries
        }, inputFractionDigits, void 0, "long");
        const { type, value } = formatParams;
        const f = this.createCallWithContext(contextProvider);
        var _label_formatValue, _ref, _ref1;
        const result = (_ref1 = (_ref = (_label_formatValue = label === null || label === void 0 ? void 0 : label.formatValue(f, type, value, params !== null && params !== void 0 ? params : formatParams)) !== null && _label_formatValue !== void 0 ? _label_formatValue : formatManager.format(f, formatParams)) !== null && _ref !== void 0 ? _ref : this.label.formatValue(f, formatParams, NaN)) !== null && _ref1 !== void 0 ? _ref1 : formatManager.defaultFormat(formatParams);
        return String(result);
    }
    getBBox() {
        return this.axisGroup.getBBox();
    }
    initCrossLine(crossLine) {
        crossLine.scale = this.scale;
        crossLine.gridLength = this.gridLength;
    }
    hasVisibleSeries() {
        return this.boundSeries.some((s)=>s.isEnabled());
    }
    clipTickLines(x, y, width2, height2) {
        this.tickLineGroup.setClipRect(new BBox(x, y, width2, height2));
    }
    clipGrid(x, y, width2, height2) {
        this.gridGroup.setClipRect(new BBox(x, y, width2, height2));
    }
    getTitleFormatterParams(domain) {
        var _this_title;
        const { direction } = this;
        const boundSeries = this.formatterBoundSeries.get();
        return {
            domain,
            direction,
            boundSeries,
            defaultValue: (_this_title = this.title) === null || _this_title === void 0 ? void 0 : _this_title.text
        };
    }
    normaliseDataDomain(d) {
        return {
            domain: [
                ...d
            ],
            clipped: false
        };
    }
    getLayoutState() {
        return {
            id: this.id,
            rect: this.getBBox(),
            gridPadding: this.gridPadding,
            seriesAreaPadding: this.seriesAreaPadding,
            tickSize: this.getTickSize(),
            direction: this.direction,
            domain: this.dataDomain.domain,
            scale: this.scale,
            ...this.layout
        };
    }
    getModuleMap() {
        return this.moduleMap;
    }
    createModuleContext() {
        var _this_axisContext;
        (_this_axisContext = this.axisContext) !== null && _this_axisContext !== void 0 ? _this_axisContext : this.axisContext = this.createAxisContext();
        return {
            ...this.moduleCtx,
            parent: this.axisContext
        };
    }
    createAxisContext() {
        const { scale: scale2 } = this;
        return {
            axisId: this.id,
            scale: this.scale,
            direction: this.direction,
            continuous: ContinuousScale.is(scale2) || DiscreteTimeScale.is(scale2),
            getCanvasBounds: ()=>{
                return Transformable.toCanvas(this.axisGroup);
            },
            seriesKeyProperties: ()=>this.boundSeries.reduce((keys, series)=>{
                    const seriesKeys = series.getKeyProperties(this.direction);
                    seriesKeys.forEach((key)=>keys.add(key));
                    return keys;
                }, /* @__PURE__ */ new Set()),
            seriesIds: ()=>this.boundSeries.map((series)=>series.id),
            scaleInvert: (val)=>scale2.invert(val, true),
            scaleInvertNearest: (val)=>scale2.invert(val, true),
            formatScaleValue: (value, source, label)=>this.formatDatum(void 0, value, source, void 0, void 0, void 0, void 0, void 0, label),
            attachLabel: (node)=>this.attachLabel(node),
            inRange: (value, tolerance)=>this.inRange(value, tolerance),
            getRangeOverflow: (value)=>this.getRangeOverflow(value),
            pickBand: (point)=>this.pickBand(point)
        };
    }
    pickBand(point) {
        if (!BandScale.is(this.scale)) {
            return;
        }
        const { scale: scale2, range: range3 } = this;
        const value = scale2.invert(this.isVertical() ? point.y : point.x, true);
        var _scale2_bandwidth;
        const bandwidth = (_scale2_bandwidth = scale2.bandwidth) !== null && _scale2_bandwidth !== void 0 ? _scale2_bandwidth : 0;
        var _scale2_step;
        const step = (_scale2_step = scale2.step) !== null && _scale2_step !== void 0 ? _scale2_step : 0;
        const offset = (step - bandwidth) / 2;
        const position = scale2.convert(value);
        const start2 = position - offset;
        const end2 = position + bandwidth + offset;
        return {
            id: this.id,
            value,
            band: [
                clampArray(start2, range3),
                clampArray(end2, range3)
            ],
            position
        };
    }
    isVertical() {
        return this.direction === "y" /* Y */ ;
    }
    isReversed() {
        return this.reverse;
    }
    cachedCallWithContext(fn) {
        for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            params[_key - 1] = arguments[_key];
        }
        const { callbackCache, chartService } = this.moduleCtx;
        return callbackCache.call([
            this,
            chartService
        ], fn, ...params);
    }
    uncachedCallWithContext(fn) {
        for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            params[_key - 1] = arguments[_key];
        }
        const { chartService } = this.moduleCtx;
        return callWithContext([
            this,
            chartService
        ], fn, ...params);
    }
    createCallWithContext(contextProvider) {
        var _this = this;
        const { chartService } = this.moduleCtx;
        return function(fn) {
            for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                params[_key - 1] = arguments[_key];
            }
            return callWithContext([
                contextProvider,
                _this,
                chartService
            ], fn, ...params);
        };
    }
    constructor(moduleCtx, scale2){
        this.moduleCtx = moduleCtx;
        this.scale = scale2;
        this.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createId"])(this);
        this._crossLines = [];
        this.nice = true;
        this.reverse = false;
        this.keys = [];
        this.interval = new AxisInterval();
        this.dataDomain = {
            domain: [],
            clipped: false
        };
        this.title = new AxisTitle();
        this.gridLength = 0;
        /**
     * The distance between the grid ticks and the axis ticks.
     */ this.gridPadding = 0;
        /**
     * Is used to avoid collisions between axis labels and series.
     */ this.seriesAreaPadding = 0;
        this.layoutConstraints = {
            stacked: true,
            align: "start",
            width: 100,
            unit: "percent"
        };
        this.boundSeries = [];
        this.includeInvisibleDomains = false;
        this.interactionEnabled = true;
        this.axisGroup = new Group({
            name: "".concat(this.id, "-axis")
        });
        // Order is important to apply the correct z-index.
        this.tickLineGroup = this.axisGroup.appendChild(new TransformableGroup({
            name: "".concat(this.id, "-Axis-tick-lines"),
            zIndex: 0 /* TickLines */ 
        }));
        this.tickLabelGroup = this.axisGroup.appendChild(new TransformableGroup({
            name: "".concat(this.id, "-Axis-tick-labels"),
            zIndex: 2 /* TickLabels */ 
        }));
        this.labelGroup = new Group({
            name: "".concat(this.id, "-Labels"),
            zIndex: 11 /* SERIES_ANNOTATION */ 
        });
        this.gridGroup = new TranslatableGroup({
            name: "".concat(this.id, "-Axis-grid"),
            zIndex: 2 /* AXIS_GRID */ 
        });
        this.gridFillGroup = this.gridGroup.appendChild(new Group({
            name: "".concat(this.id, "-gridFills")
        }));
        this.gridLineGroup = this.gridGroup.appendChild(new Group({
            name: "".concat(this.id, "-gridLines")
        }));
        this.crossLineRangeGroup = new TransformableGroup({
            name: "".concat(this.id, "-CrossLines-Range"),
            zIndex: 6 /* SERIES_CROSSLINE_RANGE */ 
        });
        this.crossLineLineGroup = new TransformableGroup({
            name: "".concat(this.id, "-CrossLines-Line"),
            zIndex: 10 /* SERIES_CROSSLINE_LINE */ 
        });
        this.crossLineLabelGroup = new TransformableGroup({
            name: "".concat(this.id, "-CrossLines-Label"),
            zIndex: 15 /* SERIES_LABEL */ 
        });
        this.tickLabelGroupSelection = Selection.select(this.tickLabelGroup, TransformableText, false);
        this.line = new AxisLine();
        this.tick = new AxisTick();
        this.gridLine = new AxisGridLine();
        this.label = this.createLabel();
        this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;
        this.translation = {
            x: 0,
            y: 0
        };
        this.layout = {
            label: {
                fractionDigits: 0,
                spacing: this.label.spacing,
                format: this.label.format
            }
        };
        this.axisContext = void 0;
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        // AG-15360 Avoid calling removeTooltip() if no tooltip is shown. This avoid a laggy tooltips caused by interference
        // with SeriesAreaManager's tooltip updates.
        this.isHovering = false;
        this.range = [
            0,
            1
        ];
        this.visibleRange = [
            0,
            1
        ];
        this.animatable = true;
        this.tickLayout = void 0;
        this.formatterBoundSeries = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WeakCache"](()=>{
            const { direction, boundSeries } = this;
            return deepFreeze(boundSeries.flatMap((series)=>series.getFormatterContext(direction)));
        });
        this.moduleMap = new ModuleMap();
        this.range = this.scale.range.slice();
        this.crossLines.forEach((crossLine)=>this.initCrossLine(crossLine));
        this.cleanup.register(this.moduleCtx.widgets.containerWidget.addListener("mousemove", (e)=>this.onMouseMove(e)));
    }
};
_Axis.defaultTickMinSpacing = 50;
_Axis.CrossLineConstructor = CartesianCrossLine;
__decorateClass([
    Property
], _Axis.prototype, "nice", 2);
__decorateClass([
    Property
], _Axis.prototype, "reverse", 2);
__decorateClass([
    Property
], _Axis.prototype, "keys", 2);
__decorateClass([
    Property
], _Axis.prototype, "interval", 2);
__decorateClass([
    Property
], _Axis.prototype, "title", 2);
__decorateClass([
    ObserveChanges((target, value, oldValue)=>target.onGridLengthChange(value, oldValue))
], _Axis.prototype, "gridLength", 2);
var Axis = _Axis;
;
;
// packages/ag-charts-community/src/util/timeFormatDefaults.ts
function dateToNumber(value) {
    return value instanceof Date ? value.getTime() : value;
}
function lowestGranularityForInterval(interval) {
    if (interval < durationSecond) {
        return "millisecond";
    } else if (interval < durationMinute) {
        return "second";
    } else if (interval < durationHour) {
        return "minute";
    } else if (interval < durationHour * 23) {
        return "hour";
    } else if (interval < 28 * durationDay) {
        return "day";
    } else if (interval < durationYear) {
        return "month";
    } else {
        return "year";
    }
}
function lowestGranularityUnitForTicks(ticks) {
    if (ticks.length === 0) {
        return "millisecond";
    } else if (ticks.length === 1) {
        return lowestGranularityUnitForValue(ticks[0]);
    }
    let minInterval = Infinity;
    for(let i = 1; i < ticks.length; i++){
        minInterval = Math.min(minInterval, Math.abs(ticks[i].valueOf() - ticks[i - 1].valueOf()));
    }
    return lowestGranularityForInterval(minInterval);
}
function lowestGranularityUnitForValue(value) {
    if (intervalFloor("second", value) < value) {
        return "millisecond";
    } else if (intervalFloor("minute", value) < value) {
        return "second";
    } else if (intervalFloor("hour", value) < value) {
        return "minute";
    } else if (intervalFloor("day", value) < value) {
        return "hour";
    } else if (intervalFloor("month", value) < value) {
        return "day";
    } else if (intervalFloor("year", value) < value) {
        return "month";
    }
    return "year";
}
function dateTruncationForDomain(domain) {
    const [d0, d1] = domain.length === 0 ? [
        0,
        0
    ] : findMinMax([
        domain[0].valueOf(),
        domain[domain.length - 1].valueOf()
    ]);
    const startYear = new Date(d0).getFullYear();
    const stopYear = new Date(d1).getFullYear();
    if (startYear !== stopYear) return;
    const startMonth = new Date(d0).getMonth();
    const stopMonth = new Date(d1).getMonth();
    if (startMonth !== stopMonth) return "year";
    const startDate = new Date(d0).getDate();
    const stopDate = new Date(d1).getDate();
    if (startDate !== stopDate) return "month";
    return "day";
}
;
function filterVisibleTicks(ticks, reversed, visibleRange) {
    if (visibleRange == null || visibleRange[0] === 0 && visibleRange[1] === 1) {
        return {
            ticks,
            count: ticks.length,
            firstTickIndex: 0
        };
    }
    const vt0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, Math.floor(visibleRange[0] * ticks.length), ticks.length);
    const vt1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, Math.ceil(visibleRange[1] * ticks.length), ticks.length);
    const t0 = reversed ? ticks.length - vt1 : vt0;
    const t1 = reversed ? ticks.length - vt0 : vt1;
    return {
        ticks: ticks.slice(t0, t1),
        count: ticks.length,
        firstTickIndex: t0
    };
}
// packages/ag-charts-community/src/scale/categoryScale.ts
var CategoryScale = class _CategoryScale extends BandScale {
    static is(value) {
        return value instanceof _CategoryScale;
    }
    set domain(values) {
        if (this._domain === values) return;
        this.invalid = true;
        this._domain = values;
        this.index.clear();
        this.indexInitialized = false;
    }
    get domain() {
        return this._domain;
    }
    get bands() {
        return this._domain;
    }
    normalizeDomains() {
        for(var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++){
            domains[_key] = arguments[_key];
        }
        let normalizedDomain = void 0;
        const seenDomains = /* @__PURE__ */ new Set();
        let animatable = true;
        for (const domain of domains){
            if (seenDomains.has(domain)) continue;
            seenDomains.add(domain);
            if (normalizedDomain == null) {
                normalizedDomain = deduplicateCategories(domain);
            } else {
                animatable && (animatable = domainOrderedToNormalizedDomain(domain, normalizedDomain));
                normalizedDomain = deduplicateCategories([
                    ...normalizedDomain,
                    ...domain
                ]);
            }
        }
        normalizedDomain !== null && normalizedDomain !== void 0 ? normalizedDomain : normalizedDomain = [];
        return {
            domain: normalizedDomain,
            animatable
        };
    }
    toDomain(_value) {
        return void 0;
    }
    invert(position) {
        let nearest = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        this.refresh();
        const offset = nearest ? this.bandwidth / 2 : 0;
        const index = this.invertNearestIndex(Math.max(0, position - offset));
        const matches = nearest || position === this.ordinalRange(index);
        return matches ? this.domain[index] : void 0;
    }
    ticks(params) {
        let domain = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.domain, visibleRange = arguments.length > 2 ? arguments[2] : void 0;
        const { bands } = this;
        let { tickCount } = params;
        if (tickCount === 0) {
            const firstTickIndex2 = bands.length > 1 ? 1 : 0;
            return {
                ticks: [
                    bands[firstTickIndex2]
                ],
                count: void 0,
                firstTickIndex: firstTickIndex2
            };
        }
        let step = tickCount != null && tickCount !== 0 ? bands.length / tickCount | 0 : 1;
        step = previousPowerOf2(step);
        if (step <= 1) {
            return filterVisibleTicks(domain, false, visibleRange);
        }
        tickCount = bands.length / step | 0;
        const span = step * tickCount;
        const inset = previousPowerOf2((bands.length - span) / 2 | 0);
        var _visibleRange_;
        const vt0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, Math.floor(((_visibleRange_ = visibleRange === null || visibleRange === void 0 ? void 0 : visibleRange[0]) !== null && _visibleRange_ !== void 0 ? _visibleRange_ : 0) * bands.length), bands.length);
        var _visibleRange_1;
        const vt1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, Math.ceil(((_visibleRange_1 = visibleRange === null || visibleRange === void 0 ? void 0 : visibleRange[1]) !== null && _visibleRange_1 !== void 0 ? _visibleRange_1 : 1) * bands.length), bands.length);
        const i0 = Math.floor((vt0 - inset) / step) * step + inset;
        const i1 = Math.ceil((vt1 - inset) / step) * step + inset;
        const ticks = [];
        for(let i = i0; i < i1; i += step){
            if (i >= 0 && i < bands.length) {
                ticks.push(bands[i]);
            }
        }
        let firstTickIndex = ticks.length > 0 ? this.findIndex(ticks[0]) : void 0;
        if (firstTickIndex != null) {
            firstTickIndex = Math.floor((firstTickIndex - inset) / step);
        }
        return {
            ticks,
            count: void 0,
            firstTickIndex
        };
    }
    findIndex(value) {
        const { index, indexInitialized } = this;
        if (!indexInitialized) {
            const { domain } = this;
            for(let i = 0; i < domain.length; i++){
                index.set(dateToNumber(domain[i]), i);
            }
            this.indexInitialized = true;
        }
        return index.get(dateToNumber(value));
    }
    constructor(){
        super(...arguments);
        this.type = "category";
        this.defaultTickCount = 0;
        /**
     * Maps datum to its index in the {@link domain} array.
     * Used to check for duplicate data (not allowed).
     */ this.index = /* @__PURE__ */ new Map();
        this.indexInitialized = false;
        /**
     * Contains unique data only.
     */ this._domain = [];
    }
};
function deduplicateCategories(d) {
    let domain;
    const uniqueValues = /* @__PURE__ */ new Set();
    for (const value of d){
        const key = dateToNumber(value);
        const lastSize = uniqueValues.size;
        uniqueValues.add(key);
        const isUniqueValue = uniqueValues.size !== lastSize;
        if (isUniqueValue) {
            domain === null || domain === void 0 ? void 0 : domain.push(value);
        } else {
            domain !== null && domain !== void 0 ? domain : domain = d.slice(0, uniqueValues.size);
        }
    }
    return domain !== null && domain !== void 0 ? domain : d;
}
function domainOrderedToNormalizedDomain(domain, normalizedDomain) {
    let normalizedIndex = -1;
    for (const value of domain){
        const normalizedNextIndex = normalizedDomain.indexOf(value);
        if (normalizedNextIndex === -1) {
            normalizedIndex = Infinity;
        } else if (normalizedNextIndex <= normalizedIndex) {
            return false;
        } else {
            normalizedIndex = normalizedNextIndex;
        }
    }
    return true;
}
// packages/ag-charts-community/src/util/date.ts
function compareDates(a, b) {
    return a.valueOf() - b.valueOf();
}
function deduplicateSortedArray(values) {
    let v0 = NaN;
    const out = [];
    for (const v of values){
        const v1 = v.valueOf();
        if (v0 !== v1) out.push(v);
        v0 = v1;
    }
    return out;
}
function sortAndUniqueDates(values) {
    const sortedValues = values.slice().sort(compareDates);
    return datesSortOrder(sortedValues) == null ? deduplicateSortedArray(sortedValues) : sortedValues;
}
function datesSortOrder(d) {
    if (d.length === 0) return 1;
    const sign = Number(d[d.length - 1]) > Number(d[0]) ? 1 : -1;
    let v0 = -Infinity * sign;
    for (const v of d){
        const v1 = v.valueOf();
        if (Math.sign(v1 - v0) !== sign) return;
        v0 = v1;
    }
    return sign;
}
;
;
var tInterval = (timeInterval3, step)=>({
        duration: intervalMilliseconds(timeInterval3) * step,
        timeInterval: timeInterval3,
        step
    });
var TickIntervals = [
    tInterval({
        unit: "second"
    }, 1),
    tInterval({
        unit: "second"
    }, 5),
    tInterval({
        unit: "second"
    }, 15),
    tInterval({
        unit: "second"
    }, 30),
    tInterval({
        unit: "minute"
    }, 1),
    tInterval({
        unit: "minute"
    }, 5),
    tInterval({
        unit: "minute"
    }, 15),
    tInterval({
        unit: "minute"
    }, 30),
    tInterval({
        unit: "hour"
    }, 1),
    tInterval({
        unit: "hour"
    }, 3),
    tInterval({
        unit: "hour"
    }, 6),
    tInterval({
        unit: "hour"
    }, 12),
    tInterval({
        unit: "day"
    }, 1),
    tInterval({
        unit: "day"
    }, 2),
    tInterval({
        unit: "day",
        step: 7
    }, 1),
    tInterval({
        unit: "day",
        step: 7
    }, 2),
    tInterval({
        unit: "day",
        step: 7
    }, 3),
    tInterval({
        unit: "month"
    }, 1),
    tInterval({
        unit: "month"
    }, 2),
    tInterval({
        unit: "month"
    }, 3),
    tInterval({
        unit: "month"
    }, 4),
    tInterval({
        unit: "month"
    }, 6),
    tInterval({
        unit: "year"
    }, 1)
];
var TickMultipliers = [
    1,
    2,
    5,
    10
];
function isCloseToInteger(n, delta3) {
    return Math.abs(Math.round(n) - n) < delta3;
}
function countTicks(d0, d1, step) {
    const extent2 = Math.abs(d1 - d0);
    return extent2 >= step ? Math.abs(d1 - d0) / step + 1 : 1;
}
function createTicks(start2, stop, count, minCount, maxCount, visibleRange) {
    if (start2 === stop) return {
        ticks: [
            start2
        ],
        count: 1,
        firstTickIndex: 0
    };
    if (count < 2) return {
        ticks: [
            start2,
            stop
        ],
        count: 2,
        firstTickIndex: 0
    };
    const step = tickStep(start2, stop, count, minCount, maxCount);
    if (!Number.isFinite(step)) return {
        ticks: [],
        count: 0,
        firstTickIndex: void 0
    };
    let d0 = start2;
    let d1 = stop;
    if (!isCloseToInteger(d0 / step, 1e-12)) {
        d0 = Math.ceil(d0 / step) * step;
    }
    if (!isCloseToInteger(d1 / step, 1e-12)) {
        d1 = Math.floor(d1 / step) * step;
    }
    if (visibleRange != null) {
        const dr = d1 - d0;
        const vr = stop - start2;
        const vd0 = start2 + vr * visibleRange[0];
        const vd1 = start2 + vr * visibleRange[1];
        visibleRange = [
            (vd0 - d0) / dr,
            (vd1 - d0) / dr
        ];
    }
    const { ticks } = range(d0, d1, step, visibleRange);
    const firstTick = ticks.at(0);
    return {
        ticks,
        count: countTicks(d0, d1, step),
        firstTickIndex: firstTick == null ? void 0 : Math.round((firstTick - d0) / step)
    };
}
var minPrimaryTickRatio = Math.floor(2 * durationWeek / durationMonth * 10) / 10;
function isPrimaryTickInterval(param) {
    let { timeInterval: timeInterval3, step } = param;
    const milliseconds = intervalMilliseconds(timeInterval3) * step;
    const hierarchy = intervalHierarchy(timeInterval3);
    const hierarchyMilliseconds = hierarchy ? intervalMilliseconds(hierarchy) : void 0;
    return milliseconds <= (hierarchyMilliseconds !== null && hierarchyMilliseconds !== void 0 ? hierarchyMilliseconds : Infinity) * minPrimaryTickRatio;
}
function defaultEpoch(timeInterval3, param) {
    let { weekStart } = param;
    if (timeInterval3.unit === "day" && timeInterval3.step === 7) {
        return weekStart;
    }
}
function getTickTimeInterval(start2, stop, count, minCount, maxCount, param) {
    let { weekStart, primaryOnly = false, targetInterval } = param;
    if (count <= 0) return;
    const target = targetInterval !== null && targetInterval !== void 0 ? targetInterval : Math.abs(stop - start2) / Math.max(count, 1);
    const i0 = TickIntervals.findLast((t)=>(!primaryOnly || isPrimaryTickInterval(t)) && target > t.duration);
    const i1 = TickIntervals.find((t)=>(!primaryOnly || isPrimaryTickInterval(t)) && target <= t.duration);
    if (i0 == null) {
        const step2 = Math.max(tickStep(start2, stop, count, minCount, maxCount), 1);
        return {
            unit: "millisecond",
            step: step2
        };
    } else if (i1 == null) {
        const step2 = targetInterval == null ? tickStep(start2 / durationYear, stop / durationYear, count, minCount, maxCount) : 1;
        return {
            unit: "year",
            step: step2
        };
    }
    const { timeInterval: timeInterval3, step } = target - i0.duration < i1.duration - target ? i0 : i1;
    return {
        unit: timeInterval3.unit,
        step: intervalStep(timeInterval3) * step,
        epoch: defaultEpoch(timeInterval3, {
            weekStart
        })
    };
}
function tickStep(start2, end2, count) {
    let minCount = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, maxCount = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Infinity;
    if (start2 === end2) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(1, minCount, maxCount);
    } else if (count < 1) {
        return NaN;
    }
    const extent2 = Math.abs(end2 - start2);
    const step = 10 ** Math.floor(Math.log10(extent2 / count));
    let m = NaN, minDiff = Infinity, isInBounds = false;
    for (const multiplier of TickMultipliers){
        const c = Math.ceil(extent2 / (multiplier * step));
        const validBounds = c >= minCount && c <= maxCount;
        if (isInBounds && !validBounds) continue;
        const diffCount = Math.abs(c - count);
        if (minDiff > diffCount || isInBounds !== validBounds) {
            isInBounds || (isInBounds = validBounds);
            minDiff = diffCount;
            m = multiplier;
        }
    }
    return m * step;
}
function decimalPlaces(decimal) {
    for(let i = decimal.length - 1; i >= 0; i -= 1){
        if (decimal[i] !== "0") {
            return i + 1;
        }
    }
    return 0;
}
function tickFormat(ticks, format) {
    const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNumberFormat"])(format !== null && format !== void 0 ? format : ",f");
    if (options == null) return;
    if (options.precision == null || isNaN(options.precision)) {
        if (!options.type || "eEFgGnprs".includes(options.type)) {
            options.precision = Math.max(...ticks.map((x)=>{
                if (!Number.isFinite(x)) return 0;
                const [integer, decimal] = x.toExponential((options.type ? 6 : 12) - 1).split(/[.e]/g);
                return (integer !== "1" && integer !== "-1" ? 1 : 0) + decimalPlaces(decimal) + 1;
            }));
        } else if ("f%".includes(options.type)) {
            options.precision = Math.max(...ticks.map((x)=>{
                if (!Number.isFinite(x) || x === 0) return 0;
                const l = Math.floor(Math.log10(Math.abs(x)));
                const digits = options.type ? 6 : 12;
                const decimal = x.toExponential(digits - 1).split(/[.e]/g)[1];
                const decimalLength = decimalPlaces(decimal);
                return Math.max(0, decimalLength - l);
            }));
        }
    }
    const formatter2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createNumberFormatter"])(options);
    return (n)=>formatter2(Number(n));
}
function range(start2, end2, step, visibleRange) {
    if (!Number.isFinite(step) || step <= 0) {
        return {
            ticks: [],
            count: 0,
            firstTickIndex: void 0
        };
    } else if (start2 === end2) {
        return {
            ticks: [
                start2
            ],
            count: 1,
            firstTickIndex: 0
        };
    }
    const f = 10 ** (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["countFractionDigits"])(step);
    const d0 = Math.min(start2, end2);
    const d1 = Math.max(start2, end2);
    let vd0;
    let vd1;
    if (visibleRange != null && (visibleRange[0] !== 0 || visibleRange[1] !== 1)) {
        const rangeExtent = end2 - start2;
        const adjustedStart = start2 + rangeExtent * visibleRange[0];
        const adjustedEnd = end2 - rangeExtent * (1 - visibleRange[1]);
        vd0 = Math.min(adjustedStart, adjustedEnd);
        vd1 = Math.max(adjustedStart, adjustedEnd);
    } else {
        vd0 = d0;
        vd1 = d1;
    }
    vd0 = Math.floor(vd0 * f) / f;
    vd1 = Math.ceil(vd1 * f) / f;
    const ticks = [];
    for(let i = 0;; i += 1){
        const p = Math.round((d0 + step * i) * f) / f;
        if (p > d1) break;
        if (p >= vd0 && p <= vd1) {
            ticks.push(p);
        }
    }
    const firstTick = ticks.at(0);
    return {
        ticks,
        count: countTicks(d0, d1, step),
        firstTickIndex: firstTick == null ? void 0 : Math.round((firstTick - d0) / step)
    };
}
function isDenseInterval(count, availableRange) {
    if (count >= availableRange) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration");
        return true;
    }
    return false;
}
function niceTicksDomain(start2, end2) {
    const extent2 = Math.abs(end2 - start2);
    const step = 10 ** Math.floor(Math.log10(extent2));
    let minError = Infinity, ticks = [
        start2,
        end2
    ];
    for (const multiplier of TickMultipliers){
        const m = multiplier * step;
        const d0 = Math.floor(start2 / m) * m;
        const d1 = Math.ceil(end2 / m) * m;
        const error = 1 - extent2 / Math.abs(d1 - d0);
        if (minError > error) {
            minError = error;
            ticks = [
                d0,
                d1
            ];
        }
    }
    return ticks;
}
function estimateTickCount(rangeExtent, zoomExtent, minSpacing, maxSpacing, defaultTickCount, defaultMinSpacing) {
    if (rangeExtent <= 0) {
        return {
            minTickCount: 0,
            maxTickCount: 0,
            tickCount: 0
        };
    }
    defaultMinSpacing = Math.max(defaultMinSpacing, rangeExtent / (defaultTickCount + 1));
    minSpacing !== null && minSpacing !== void 0 ? minSpacing : minSpacing = defaultMinSpacing;
    maxSpacing !== null && maxSpacing !== void 0 ? maxSpacing : maxSpacing = rangeExtent;
    if (minSpacing > maxSpacing) {
        if (minSpacing === defaultMinSpacing) {
            minSpacing = maxSpacing;
        } else {
            maxSpacing = minSpacing;
        }
    }
    minSpacing = Math.max(minSpacing, 1);
    const maxTickCount = Math.max(1, Math.floor(rangeExtent / (zoomExtent * minSpacing)));
    const minTickCount = Math.min(maxTickCount, Math.ceil(rangeExtent / (zoomExtent * maxSpacing)));
    const tickCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(minTickCount, Math.floor(defaultTickCount / zoomExtent), maxTickCount);
    return {
        minTickCount,
        maxTickCount,
        tickCount
    };
}
// packages/ag-charts-community/src/scale/timeScale.ts
var sunday = new Date(1970, 0, 4);
var TimeScale = class _TimeScale extends ContinuousScale {
    static is(value) {
        return value instanceof _TimeScale;
    }
    toDomain(d) {
        return new Date(d);
    }
    convert(value, options) {
        var _value_valueOf;
        return super.convert((_value_valueOf = value === null || value === void 0 ? void 0 : value.valueOf()) !== null && _value_valueOf !== void 0 ? _value_valueOf : NaN, options);
    }
    invert(value) {
        return new Date(super.invert(value));
    }
    niceDomain(ticks) {
        let domain = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.domain;
        if (domain.length < 2) return [];
        let [d0, d1] = domain;
        const maxAttempts = 4;
        const availableRange = this.getPixelRange();
        for(let i = 0; i < maxAttempts; i++){
            const [n0, n1] = updateNiceDomainIteration(d0, d1, ticks, availableRange);
            if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {
                break;
            }
            d0 = n0;
            d1 = n1;
        }
        return [
            d0,
            d1
        ];
    }
    /**
   * Returns uniformly-spaced dates that represent the scale's domain.
   */ ticks(params) {
        let domain = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.domain, visibleRange = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [
            0,
            1
        ], { extend = false } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const { nice, interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount } = params;
        if (domain.length < 2) return;
        const timestamps = domain.map(dateToNumber);
        const start2 = timestamps[0];
        const stop = timestamps[timestamps.length - 1];
        if (interval != null) {
            const availableRange = this.getPixelRange();
            var _getDateTicksForInterval;
            return {
                ticks: (_getDateTicksForInterval = getDateTicksForInterval({
                    start: start2,
                    stop,
                    interval,
                    availableRange,
                    visibleRange,
                    extend
                })) !== null && _getDateTicksForInterval !== void 0 ? _getDateTicksForInterval : getDefaultDateTicks({
                    start: start2,
                    stop,
                    tickCount,
                    minTickCount,
                    maxTickCount,
                    visibleRange,
                    extend
                }),
                count: void 0
            };
        } else if (nice && tickCount === 2) {
            return {
                ticks: domain,
                count: void 0
            };
        } else if (nice && tickCount === 1) {
            return {
                ticks: domain.slice(0, 1),
                count: void 0
            };
        }
        const timeInterval3 = getTickTimeInterval(start2, stop, tickCount, minTickCount, maxTickCount, {
            weekStart: sunday
        });
        if (timeInterval3 == null) return;
        const ticks = intervalRange(timeInterval3, new Date(start2), new Date(stop), {
            visibleRange,
            extend
        });
        const firstTickIndex = intervalRangeStartIndex(timeInterval3, new Date(start2), new Date(stop), {
            visibleRange,
            extend
        });
        return {
            ticks,
            count: void 0,
            firstTickIndex,
            timeInterval: timeInterval3
        };
    }
    constructor(){
        super([], [
            0,
            1
        ]);
        this.type = "time";
    }
};
function getDefaultDateTicks(param) {
    let { start: start2, stop, tickCount, minTickCount, maxTickCount, visibleRange, extend } = param;
    const t = getTickTimeInterval(start2, stop, tickCount, minTickCount, maxTickCount, {
        weekStart: sunday
    });
    return t ? intervalRange(t, new Date(start2), new Date(stop), {
        visibleRange,
        extend
    }) : [];
}
function getDateTicksForInterval(param) {
    let { start: start2, stop, interval, availableRange, visibleRange, extend } = param;
    if (!interval) {
        return [];
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(interval) || typeof interval === "string") {
        const ticks2 = intervalRange(interval, new Date(start2), new Date(stop), {
            visibleRange,
            extend
        });
        if (isDenseInterval(ticks2.length, availableRange)) {
            return;
        }
        return ticks2;
    }
    const absInterval = Math.abs(interval);
    if (isDenseInterval(Math.abs(stop - start2) / absInterval, availableRange)) return;
    const tickInterval = TickIntervals.findLast((t)=>absInterval % t.duration === 0);
    if (tickInterval) {
        const { timeInterval: timeInterval3, step, duration } = tickInterval;
        const alignedInterval = {
            ...timeInterval3,
            step: step * intervalStep(timeInterval3) * Math.round(absInterval / duration),
            epoch: defaultEpoch(timeInterval3, {
                weekStart: sunday
            })
        };
        return intervalRange(alignedInterval, new Date(start2), new Date(stop), {
            visibleRange,
            extend
        });
    }
    let date5 = new Date(Math.min(start2, stop));
    const stopDate = new Date(Math.max(start2, stop));
    const ticks = [];
    while(date5 <= stopDate){
        ticks.push(date5);
        date5 = new Date(date5);
        date5.setMilliseconds(date5.getMilliseconds() + absInterval);
    }
    return ticks;
}
function updateNiceDomainIteration(d0, d1, ticks, availableRange) {
    const { interval } = ticks;
    const start2 = Math.min(dateToNumber(d0), dateToNumber(d1));
    const stop = Math.max(dateToNumber(d0), dateToNumber(d1));
    let i;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(interval) || typeof interval === "string") {
        i = interval;
    } else {
        let tickCount;
        if (typeof interval === "number") {
            tickCount = (stop - start2) / Math.max(interval, 1);
            if (isDenseInterval(tickCount, availableRange)) {
                tickCount = void 0;
            }
        }
        var _ticks_tickCount;
        tickCount !== null && tickCount !== void 0 ? tickCount : tickCount = (_ticks_tickCount = ticks.tickCount) !== null && _ticks_tickCount !== void 0 ? _ticks_tickCount : ContinuousScale.defaultTickCount;
        i = getTickTimeInterval(start2, stop, tickCount, ticks.minTickCount, ticks.maxTickCount, {
            weekStart: sunday
        });
    }
    if (i == null) return [
        d0,
        d1
    ];
    const domain = intervalRange(i, new Date(start2), new Date(stop), {
        extend: true
    });
    if (domain == null || domain.length < 2) return [
        d0,
        d1
    ];
    const r0 = domain[0];
    const r1 = domain[domain.length - 1];
    return d0 <= d1 ? [
        r0,
        r1
    ] : [
        r1,
        r0
    ];
}
// packages/ag-charts-community/src/scale/ordinalTimeScale.ts
var OrdinalTimeScale = class _OrdinalTimeScale extends DiscreteTimeScale {
    static is(value) {
        return value instanceof _OrdinalTimeScale;
    }
    set domain(domain) {
        if (domain === this._domain) return;
        this.invalid = true;
        this._domain = domain;
        this._bands = void 0;
        this.isReversed = domainReversed(domain);
    }
    get domain() {
        return this._domain;
    }
    get bands() {
        var _this__bands;
        (_this__bands = this._bands) !== null && _this__bands !== void 0 ? _this__bands : this._bands = this.isReversed ? this.domain.slice().reverse() : this.domain;
        return this._bands;
    }
    normalizeDomains() {
        for(var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++){
            domains[_key] = arguments[_key];
        }
        const sortedDomains = domains.filter((domain)=>domain.length > 0);
        if (sortedDomains.length === 0) {
            return {
                domain: [],
                animatable: false
            };
        } else if (sortedDomains.length === 1) {
            let domain = sortedDomains[0];
            const sortOrder = datesSortOrder(domain);
            if (sortOrder === -1) {
                domain = domain.slice().reverse();
            } else if (sortOrder == null) {
                domain = sortAndUniqueDates(domain.slice());
            }
            return {
                domain,
                animatable: true
            };
        }
        return {
            domain: sortAndUniqueDates(sortedDomains.flat()),
            animatable: true
        };
    }
    ticks(params, domain) {
        let visibleRange = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [
            0,
            1
        ], { extend = false, dropInitial = false } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const { interval, maxTickCount, tickCount = maxTickCount } = params;
        const { bands } = this;
        if (!bands.length) return;
        this.refresh();
        if (interval == null) {
            const { ticks: ticks2, tickOffset, tickEvery } = this.getDefaultTicks(domain, tickCount, visibleRange, extend);
            let firstTickIndex = ticks2.length > 0 ? this.findIndex(ticks2[0]) : void 0;
            firstTickIndex = firstTickIndex != null ? Math.floor((firstTickIndex - tickOffset) / tickEvery) : void 0;
            return {
                ticks: ticks2,
                count: void 0,
                firstTickIndex
            };
        }
        let start2;
        let stop;
        if (domain && domain.length >= 2) {
            start2 = domain[0].valueOf();
            stop = domain[domain.length - 1].valueOf();
        } else {
            start2 = bands[0].valueOf();
            stop = bands[bands.length - 1].valueOf();
        }
        const [r0, r1] = this.range;
        const availableRange = Math.abs(r1 - r0);
        var _getDateTicksForInterval;
        const dateTicks = (_getDateTicksForInterval = getDateTicksForInterval({
            start: start2,
            stop,
            interval,
            availableRange,
            visibleRange,
            extend
        })) !== null && _getDateTicksForInterval !== void 0 ? _getDateTicksForInterval : this.getDefaultTicks(domain, tickCount, visibleRange, extend).ticks;
        const ticks = [];
        let lastIndex = -1;
        for (const dateTick of dateTicks){
            var _this_findIndex;
            const index = (_this_findIndex = this.findIndex(dateTick, 1 /* Trailing */ )) !== null && _this_findIndex !== void 0 ? _this_findIndex : -1;
            const duplicated = index === lastIndex;
            lastIndex = index;
            if (!(dropInitial && index === 0) && index !== -1 && !duplicated) {
                ticks.push(bands[index]);
            }
        }
        return {
            ticks,
            count: void 0,
            firstTickIndex: void 0
        };
    }
    stepTicks(bandStep, domain) {
        let visibleRange = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [
            0,
            1
        ], dropLast = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
        const bandIndices = domain ? this.bandDomainIndices(domain) : void 0;
        const ticks = this.ticksEvery(bandIndices, visibleRange, bandStep, 0, false);
        const lastTick = ticks.at(-1);
        const lastBandIndex = dropLast && bandStep > 1 ? bandIndices === null || bandIndices === void 0 ? void 0 : bandIndices[1] : void 0;
        const lastTickIndex = lastBandIndex != null && lastTick != null ? this.findIndex(lastTick) : void 0;
        if (lastTickIndex != null && lastBandIndex != null && lastBandIndex - lastTickIndex < bandStep) {
            ticks.pop();
        }
        return ticks;
    }
    bandCount() {
        let visibleRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [
            0,
            1
        ];
        const { domain } = this;
        const startIndex = Math.floor(visibleRange[0] * domain.length);
        const endIndex = Math.ceil(visibleRange[1] * domain.length);
        return endIndex - startIndex;
    }
    getDefaultTicks(domain, maxTickCount, visibleRange, extend) {
        const { bands } = this;
        const tickEvery = Math.ceil(bands.length / maxTickCount);
        const tickOffset = Math.floor(tickEvery / 2);
        const bandIndices = domain ? this.bandDomainIndices(domain) : void 0;
        return {
            ticks: this.ticksEvery(bandIndices, visibleRange, tickEvery, tickOffset, extend),
            tickOffset,
            tickEvery
        };
    }
    bandDomainIndices(domain) {
        const isReversed = domainReversed(domain);
        var _this_findIndex;
        const i0 = (_this_findIndex = this.findIndex(domain[isReversed ? domain.length - 1 : 0], 1 /* Trailing */ )) !== null && _this_findIndex !== void 0 ? _this_findIndex : 0;
        var _this_findIndex1;
        const i1 = (_this_findIndex1 = this.findIndex(domain[isReversed ? 0 : domain.length - 1], 1 /* Trailing */ )) !== null && _this_findIndex1 !== void 0 ? _this_findIndex1 : this.bands.length - 1;
        return [
            i0,
            i1
        ];
    }
    ticksEvery() {
        let [i0, i1] = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [
            0,
            this.bands.length
        ], visibleRange = arguments.length > 1 ? arguments[1] : void 0, tickEvery = arguments.length > 2 ? arguments[2] : void 0, tickOffset = arguments.length > 3 ? arguments[3] : void 0, extend = arguments.length > 4 ? arguments[4] : void 0;
        const { bands } = this;
        const offset = i0;
        const span = i1 - i0 + 1;
        let startIndex = offset + Math.floor(visibleRange[0] * span);
        let endIndex = offset + Math.ceil(visibleRange[1] * span);
        if (extend) {
            startIndex -= tickEvery;
            endIndex += tickEvery;
        }
        startIndex = Math.max(startIndex, 0);
        endIndex = Math.min(endIndex, bands.length);
        let ticks;
        if (tickEvery <= 1) {
            ticks = bands.slice(startIndex, endIndex);
        } else {
            ticks = [];
            for(let index = startIndex; index < endIndex; index += 1){
                if ((index - offset + tickOffset) % tickEvery === 0) {
                    ticks.push(bands[index]);
                }
            }
        }
        return ticks;
    }
    constructor(){
        super(...arguments);
        this.type = "ordinal-time";
        this.defaultTickCount = ContinuousScale.defaultTickCount;
        this._domain = [];
        this.isReversed = false;
    }
};
function domainReversed(domain) {
    return domain.length > 0 && domain[0] > domain[domain.length - 1];
}
;
var MAX_BANDS = 5e7;
var UnitTimeScale = class _UnitTimeScale extends DiscreteTimeScale {
    static is(value) {
        return value instanceof _UnitTimeScale;
    }
    static supportsInterval(domain, interval) {
        return supportsInterval(domain, interval);
    }
    set domain(domain) {
        if (domain === this._domain) return;
        this._domain = domain;
        this._bands = void 0;
    }
    get domain() {
        return this._domain;
    }
    get interval() {
        return this._interval;
    }
    set interval(interval) {
        if (this._interval === interval) return;
        this._interval = interval;
        this._bands = void 0;
    }
    get bands() {
        var _this__bands;
        (_this__bands = this._bands) !== null && _this__bands !== void 0 ? _this__bands : this._bands = this.calculateBands(this._domain, [
            0,
            1
        ]).bands;
        return this._bands;
    }
    normalizeDomains() {
        for(var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++){
            domains[_key] = arguments[_key];
        }
        return normalizeContinuousDomains(...domains);
    }
    convert(value, options) {
        if (!(value instanceof Date)) value = new Date(value);
        const { domain, interval } = this;
        if (domain.length < 2) return NaN;
        if ((options === null || options === void 0 ? void 0 : options.clamp) !== true && interval != null) {
            const t = value.valueOf();
            const [start2, stop] = calculateBandRange(domain, interval);
            const d0 = Math.min(start2.valueOf(), stop.valueOf());
            const d1 = Math.max(start2.valueOf(), stop.valueOf());
            if (t < d0 || t >= d1 + intervalMilliseconds(interval)) return NaN;
        }
        return super.convert(value, options);
    }
    calculateBands(domain, visibleRange) {
        let extend = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        if (domain === this.domain && visibleRange[0] === 0 && visibleRange[1] === 1 && !extend && this._bands != null) {
            return {
                bands: this._bands,
                firstBandIndex: 0
            };
        }
        if (domain.length < 2) return {
            bands: [],
            firstBandIndex: void 0
        };
        const { interval } = this;
        if (interval == null) return {
            bands: [],
            firstBandIndex: void 0
        };
        const rangeParams = {
            visibleRange,
            extend
        };
        if (!supportsInterval(domain, interval, rangeParams)) return {
            bands: [],
            firstBandIndex: void 0
        };
        const [start2, stop] = calculateBandRange(domain, interval);
        if (intervalRangeCount(interval, start2, stop, rangeParams) > MAX_BANDS) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("the configured unit results in too many bands, ignoring. Supply a larger unit.");
            return {
                bands: [],
                firstBandIndex: void 0
            };
        }
        const bands = intervalRange(interval, start2, stop, rangeParams);
        const firstBandIndex = intervalRangeStartIndex(interval, start2, stop, rangeParams);
        return {
            bands,
            firstBandIndex
        };
    }
    ticks(param) {
        let { interval } = param, domain = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.domain, visibleRange = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [
            0,
            1
        ], { extend = false } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        if (domain.length < 2) return;
        const { bands, firstBandIndex } = this.calculateBands(domain, visibleRange, extend);
        const milliseconds = this.interval ? intervalMilliseconds(this.interval) : Infinity;
        if (interval == null) return {
            ticks: bands,
            count: void 0,
            firstTickIndex: firstBandIndex
        };
        const d0 = Math.min(domain[0].valueOf(), domain[1].valueOf());
        const d1 = Math.max(domain[0].valueOf(), domain[1].valueOf());
        let intervalTicks;
        let intervalStartIndex;
        let intervalEndIndex;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(interval) || typeof interval === "string") {
            intervalTicks = intervalRange(interval, domain[0], domain[1], {
                extend: true,
                visibleRange
            });
            intervalStartIndex = 0;
            intervalEndIndex = intervalTicks.length - 1;
        } else {
            intervalTicks = bands;
            var _findMaxIndex3;
            intervalStartIndex = (_findMaxIndex3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMaxIndex"])(0, bands.length - 1, (index)=>bands[index].valueOf() <= d0)) !== null && _findMaxIndex3 !== void 0 ? _findMaxIndex3 : 0;
            var _findMaxIndex31;
            intervalEndIndex = (_findMaxIndex31 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMaxIndex"])(0, bands.length - 1, (index)=>bands[index].valueOf() <= d1)) !== null && _findMaxIndex31 !== void 0 ? _findMaxIndex31 : bands.length - 1;
        }
        const ticks = [];
        let lastIndex;
        for(let i = intervalStartIndex; i <= intervalEndIndex; i++){
            const intervalTickValue = intervalTicks[i].valueOf();
            const bandIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMaxIndex"])(0, bands.length - 1, (index)=>bands[index].valueOf() <= intervalTickValue);
            const tick = bandIndex != null && bandIndex != lastIndex ? bands[bandIndex] : void 0;
            lastIndex = bandIndex;
            if (tick != null && intervalTickValue - tick.getTime() <= milliseconds) ticks.push(tick);
        }
        let bandStart;
        let bandEnd;
        if (this.interval) {
            const bandRange = calculateBandRange([
                new Date(d0),
                new Date(d1)
            ], this.interval);
            bandStart = bandRange[0].valueOf();
            bandEnd = bandRange[1].valueOf();
        } else {
            bandStart = d0;
            bandEnd = d1;
        }
        var _findMinIndex3;
        let firstTickIndex = (_findMinIndex3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMinIndex"])(0, ticks.length - 1, (i)=>ticks[i].valueOf() >= bandStart)) !== null && _findMinIndex3 !== void 0 ? _findMinIndex3 : 0;
        var _findMaxIndex32;
        let lastTickIndex = (_findMaxIndex32 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMaxIndex"])(0, ticks.length - 1, (i)=>ticks[i].valueOf() <= bandEnd)) !== null && _findMaxIndex32 !== void 0 ? _findMaxIndex32 : ticks.length - 1;
        if (extend) {
            firstTickIndex = Math.max(firstTickIndex - 1, 0);
            lastTickIndex = Math.min(lastTickIndex + 1, ticks.length - 1);
        }
        return {
            ticks: ticks.slice(firstTickIndex, lastTickIndex + 1),
            count: ticks.length,
            firstTickIndex: firstBandIndex
        };
    }
    constructor(){
        super(...arguments);
        this.type = "unit-time";
        this.defaultTickCount = 12;
        this._domain = [];
        /* eslint-enable */ this._bands = void 0;
    }
};
function supportsInterval(domain, interval, rangeParams) {
    const [start2, stop] = calculateBandRange(domain, interval);
    return intervalRangeCount(interval, start2, stop, rangeParams) <= MAX_BANDS;
}
function calculateBandRange(domain, interval) {
    const start2 = intervalFloor(interval, domain[0]);
    const stop = intervalFloor(interval, domain[1]);
    return [
        start2,
        stop
    ];
}
;
function calculateNiceSecondaryAxis(scale2, domain, primaryTickCount, reverse, visibleRange) {
    let [d0, d1] = findMinMax(domain.map(Number));
    const unzoomedTickCount = Math.floor(primaryTickCount.unzoomed);
    if (unzoomedTickCount <= 1) {
        const [start3, stop2] = domainWithOddTickCount(d0, d1);
        const tickCount = 5 * Math.pow(2, -Math.ceil(Math.log2(visibleRange[1] - visibleRange[0])));
        const { ticks: ticks2 } = createTicks(start3, stop2, tickCount, void 0, void 0, visibleRange);
        const d2 = [
            scale2.toDomain(start3),
            scale2.toDomain(stop2)
        ];
        if (reverse) d2.reverse();
        return {
            domain: d2,
            ticks: ticks2
        };
    }
    if (d0 === d1) {
        const order = Math.floor(Math.log10(d0));
        const magnitude = Math.pow(10, order);
        const rangeOffsetStep = Math.min(magnitude, 1);
        const rangeOffset = unzoomedTickCount - 1;
        d0 -= rangeOffsetStep * Math.floor(rangeOffset / 2);
        d1 = d0 + rangeOffsetStep * rangeOffset;
    }
    let start2 = d0;
    let stop = d1;
    start2 = calculateNiceStart(start2, stop, unzoomedTickCount);
    const baseStep = getTickStep(start2, stop, unzoomedTickCount);
    const segments = unzoomedTickCount - 1;
    stop = start2 + segments * baseStep;
    const stepAlignedStart = Math.floor(start2 / baseStep) * baseStep;
    const stepAlignedStop = Math.floor(stop / baseStep) * baseStep;
    if (stepAlignedStart <= d0 && stepAlignedStop >= d1) {
        start2 = stepAlignedStart;
        stop = stepAlignedStop;
    }
    const d = [
        scale2.toDomain(start2),
        scale2.toDomain(stop)
    ];
    if (reverse) d.reverse();
    const step = baseStep * ((primaryTickCount.unzoomed - 1) / (primaryTickCount.zoomed - 1));
    const ticks = getTicks(start2, step, Math.floor(primaryTickCount.zoomed));
    return {
        domain: d,
        ticks
    };
}
function domainWithOddTickCount(d0, d1) {
    let start2 = d0;
    let stop = d1;
    let iterations = 0;
    do {
        [start2, stop] = niceTicksDomain(start2, stop);
        const { ticks } = createTicks(start2, stop, 5);
        if (ticks.length % 2 === 1) return [
            start2,
            stop
        ];
        start2 -= 1;
        stop += 1;
    }while (iterations++ < 10)
    return [
        d0,
        d1
    ];
}
function calculateNiceStart(a, b, count) {
    a = Math.floor(a);
    const rawStep = Math.abs(b - a) / (count - 1);
    const order = Math.floor(Math.log10(rawStep));
    const magnitude = Math.pow(10, order);
    return Math.floor(a / magnitude) * magnitude;
}
function getTicks(start2, step, count) {
    const fractionDigits = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["countFractionDigits"])(step);
    const f = Math.pow(10, fractionDigits);
    const ticks = [];
    for(let i = 0; i < count; i++){
        const tick = start2 + step * i;
        ticks.push(Math.round(tick * f) / f);
    }
    return ticks;
}
function getTickStep(start2, stop, count) {
    const segments = count - 1;
    const rawStep = (stop - start2) / segments;
    return calculateNextNiceStep(rawStep);
}
function calculateNextNiceStep(rawStep) {
    const order = Math.floor(Math.log10(rawStep));
    const magnitude = Math.pow(10, order);
    const step = rawStep / magnitude;
    if (step > 0 && step <= 1) return magnitude;
    if (step > 1 && step <= 2) return 2 * magnitude;
    if (step > 2 && step <= 5) return 5 * magnitude;
    if (step > 5 && step <= 10) return 10 * magnitude;
    return rawStep;
}
// packages/ag-charts-community/src/util/tempUtils.ts
function createIdsGenerator() {
    const idsCounter = /* @__PURE__ */ new Map();
    return (name)=>{
        const counter = idsCounter.get(name);
        if (counter) {
            idsCounter.set(name, counter + 1);
            return "".concat(name, "_").concat(counter);
        }
        idsCounter.set(name, 1);
        return name;
    };
}
// packages/ag-charts-community/src/chart/axis/axisTickGenerator.ts
var DENSE_TICK_COUNT = 18;
var TICK_STEP_VALUES = [
    1,
    2,
    3,
    4,
    6,
    8,
    9,
    10,
    12
];
var sunday2 = new Date(1970, 0, 4);
var AxisTickGenerator = class {
    estimateTickCount(domain, range3, visibleRange, defaultTickMinSpacing, minSpacing, maxSpacing) {
        const { scale: scale2, label } = this.axis;
        const { defaultTickCount } = scale2;
        const rangeExtent = findRangeExtent(range3);
        const zoomExtent = findRangeExtent(visibleRange);
        if (CategoryScale.is(scale2)) {
            const maxTickCount = domain.length;
            let estimatedTickCount = Math.ceil(rangeExtent / (zoomExtent * label.fontSize));
            estimatedTickCount = Math.min(estimatedTickCount, maxTickCount);
            return {
                minTickCount: 0,
                maxTickCount,
                tickCount: estimatedTickCount
            };
        }
        return estimateTickCount(rangeExtent, zoomExtent, minSpacing, maxSpacing, defaultTickCount, defaultTickMinSpacing);
    }
    generateTicks(param) {
        let { range: range3, domain, reverse, primaryTickCount, defaultTickMinSpacing, visibleRange, niceMode, parallelFlipRotation, regularFlipRotation, labelX, sideFlag, removeOverflowLabels, removeOverflowThreshold = 0, sizeLimit } = param;
        const { label, primaryLabel, interval: { minSpacing, maxSpacing } } = this.axis;
        const { parallel, fontFamily, fontSize, fontStyle, fontWeight } = label;
        const secondaryAxis = primaryTickCount !== void 0;
        const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation(label.rotation, parallel, regularFlipRotation, parallelFlipRotation);
        const { maxTickCount } = this.estimateTickCount(domain, range3, visibleRange, defaultTickMinSpacing, minSpacing, maxSpacing);
        const maxIterations = Number.isFinite(maxTickCount) ? maxTickCount : 10;
        const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);
        const font2 = {
            fontFamily,
            fontSize,
            fontStyle,
            fontWeight
        };
        const textMeasurer = CachedTextMeasurerPool.getMeasurer({
            font: font2
        });
        const checkLabelOverlap = label.enabled && label.avoidCollisions;
        const initialRotation = configuredRotation + defaultRotation;
        const labelMatrix = new Matrix();
        const updateLabelMatrix = (iterationRotation)=>{
            const labelRotation = initialRotation + iterationRotation;
            Matrix.updateTransformMatrix(labelMatrix, 1, 1, labelRotation, 0, 0);
        };
        const getLabelData = (param, iterationRotation)=>{
            let { ticks } = param;
            updateLabelMatrix(iterationRotation);
            return createLabelData(ticks, labelX, labelMatrix, textMeasurer, label);
        };
        const getTimeLabelData = (tickData2, iterationRotation)=>{
            const { niceDomain, ticks, timeInterval: timeInterval3 } = tickData2;
            if (timeInterval3 == null) return [];
            updateLabelMatrix(iterationRotation);
            const spacing = ticksSpacing(ticks);
            const { width: width2, height: height2 } = timeIntervalMaxLabelSize(label, primaryLabel, niceDomain !== null && niceDomain !== void 0 ? niceDomain : domain, timeInterval3, textMeasurer);
            return createFixedLabelData({
                width: width2,
                height: height2,
                spacing
            }, labelX, labelMatrix);
        };
        const getLabelOverlap = (tickData2, iterationRotation)=>{
            if (!checkLabelOverlap) return false;
            const rotated = configuredRotation !== 0 || iterationRotation !== 0;
            const labelSpacing = getLabelSpacing(label.minSpacing, rotated);
            return axisLabelsOverlap(getTimeLabelData(tickData2, iterationRotation), labelSpacing) || axisLabelsOverlap(getLabelData(tickData2, iterationRotation), labelSpacing);
        };
        let tickData = {
            tickDomain: [],
            niceDomain: domain,
            ticks: [],
            rawTicks: [],
            rawTickCount: void 0,
            timeInterval: void 0,
            fractionDigits: 0
        };
        let index = 0;
        let autoRotation = 0;
        let labelOverlap = true;
        let terminate = false;
        while(!terminate && labelOverlap && index <= maxIterations){
            autoRotation = 0;
            for (const strategy of this.getTickStrategies({
                domain,
                range: range3,
                reverse,
                niceMode,
                secondaryAxis,
                sizeLimit
            })){
                ({ tickData, index, autoRotation, terminate } = strategy({
                    index,
                    tickData,
                    terminate,
                    primaryTickCount,
                    defaultTickMinSpacing,
                    visibleRange,
                    labelsOverlap () {
                        return getLabelOverlap(tickData, autoRotation);
                    }
                }));
            }
            labelOverlap = getLabelOverlap(tickData, autoRotation);
        }
        const textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);
        const rotation = configuredRotation + autoRotation;
        if (removeOverflowLabels && tickData.ticks.length > 2) {
            const labelData = getLabelData(tickData, autoRotation);
            const lastTick = tickData.ticks.at(-1);
            const lastLabel = labelData.at(-1);
            if (lastTick != null && lastLabel != null && lastTick.translation + lastLabel.label.width / 2 > range3[1] + removeOverflowThreshold) {
                lastTick.tickLabel = void 0;
                if (visibleRange[0] === 0 && visibleRange[1] === 1) {
                    tickData.ticks[0].tickLabel = void 0;
                }
            }
        }
        return {
            tickData,
            rotation,
            textBaseline,
            textAlign
        };
    }
    getTickStrategies(param) {
        let { domain, range: range3, reverse, niceMode, secondaryAxis, sizeLimit } = param;
        const { label, interval } = this.axis;
        const avoidLabelCollisions = label.enabled && label.avoidCollisions;
        const autoRotate = label.autoRotate === true && label.rotation === void 0;
        const strategies = [];
        let tickGenerationType;
        if (interval.values) {
            tickGenerationType = 2 /* VALUES */ ;
        } else if (secondaryAxis) {
            tickGenerationType = 1 /* CREATE_SECONDARY */ ;
        } else {
            tickGenerationType = 0 /* CREATE */ ;
        }
        const tickGenerationStrategy = (param)=>{
            let { index, tickData, primaryTickCount, defaultTickMinSpacing, visibleRange, terminate } = param;
            return this.createTickData(domain, range3, reverse, niceMode, visibleRange, primaryTickCount, defaultTickMinSpacing, tickGenerationType, index, tickData, terminate, sizeLimit);
        };
        strategies.push(tickGenerationStrategy);
        if (avoidLabelCollisions && autoRotate) {
            const autoRotateStrategy = (param)=>{
                let { index, tickData, labelsOverlap, terminate } = param;
                return {
                    index,
                    tickData,
                    autoRotation: labelsOverlap() ? normalizeAngle360FromDegrees(label.autoRotateAngle) : 0,
                    terminate
                };
            };
            strategies.push(autoRotateStrategy);
        }
        return strategies;
    }
    createTickData(domain, range3, reverse, niceMode, visibleRange, primaryTickCount, defaultTickMinSpacing, tickGenerationType, index, previousTickData, terminate, sizeLimit) {
        const { interval } = this.axis;
        const { step, values, minSpacing, maxSpacing } = interval;
        const { maxTickCount, minTickCount, tickCount } = this.estimateTickCount(domain, range3, visibleRange, defaultTickMinSpacing, minSpacing, maxSpacing);
        const maxIterations = tickCount - minTickCount;
        const countTicks2 = (i)=>Math.max(tickCount - i, minTickCount);
        const previousTicks = previousTickData.rawTicks;
        const regenerateTicks = step == null && values == null && countTicks2(index) > minTickCount;
        const getTickParams = {
            domain,
            reverse,
            niceMode,
            visibleRange,
            primaryTickCount,
            tickGenerationType,
            minTickCount,
            maxTickCount,
            tickCount: 0
        };
        getTickParams.tickCount = countTicks2(index);
        let nextTicks = this.getTicks(getTickParams);
        if (regenerateTicks && ticksEqual(nextTicks.rawTicks, previousTicks)) {
            let lowerBound = index;
            let upperBound = maxIterations;
            while(lowerBound <= upperBound){
                index = (lowerBound + upperBound) / 2 | 0;
                getTickParams.tickCount = countTicks2(index);
                const nextTicksCandidate = this.getTicks(getTickParams);
                if (ticksEqual(nextTicksCandidate.rawTicks, previousTicks)) {
                    lowerBound = index + 1;
                } else {
                    nextTicks = nextTicksCandidate;
                    upperBound = index - 1;
                }
            }
        }
        const { tickDomain, niceDomain, rawTicks, rawTickCount, rawFirstTickIndex, generatePrimaryTicks, primaryTicksIndices, alignment, fractionDigits, timeInterval: timeInterval3 } = nextTicks;
        const ticks = this.formatTicks({
            range: range3,
            niceDomain,
            rawTicks,
            rawFirstTickIndex,
            generatePrimaryTicks,
            primaryTicksIndices,
            alignment,
            fractionDigits,
            timeInterval: timeInterval3,
            sizeLimit
        });
        const tickData = {
            tickDomain,
            niceDomain,
            rawTicks,
            rawTickCount,
            timeInterval: timeInterval3,
            fractionDigits,
            ticks
        };
        index += 1;
        terminate || (terminate = step != null || values != null);
        return {
            tickData,
            index,
            autoRotation: 0,
            terminate
        };
    }
    getTimeIntervalTicks(visibleRange, tickCount, maxTickCount, tickParams, timeInterval3, reverse) {
        const parentInterval = intervalHierarchy(timeInterval3);
        if (parentInterval == null) return;
        const { scale: scale2 } = this.axis;
        if (!TimeScale.is(scale2) && !DiscreteTimeScale.is(scale2)) return;
        if (reverse) {
            visibleRange = [
                1 - visibleRange[1],
                1 - visibleRange[0]
            ];
        }
        const dv0 = Math.min(scale2.domain[0].valueOf(), scale2.domain[scale2.domain.length - 1].valueOf());
        const dv1 = Math.max(scale2.domain[0].valueOf(), scale2.domain[scale2.domain.length - 1].valueOf());
        let [dp0, dp1] = intervalExtent(new Date(dv0), new Date(dv1), visibleRange);
        dp0 = intervalFloor(parentInterval, dp0);
        if (dp0.valueOf() >= dv0) dp0 = intervalPrevious(parentInterval, dp0);
        dp1 = intervalCeil(parentInterval, dp1);
        if (dp1.valueOf() <= dv1) dp1 = intervalNext(parentInterval, dp1);
        const primaryTicks = intervalRange(parentInterval, dp0, dp1);
        const milliseconds = intervalMilliseconds(timeInterval3);
        let primaryTicksIndices = /* @__PURE__ */ new Set();
        const skipFirstPrimaryTick = OrdinalTimeScale.is(scale2);
        const ticks = [];
        const intervalTickParams = {
            ...tickParams,
            interval: timeInterval3
        };
        let parentLevelMode;
        let alignment;
        let ordinalTickStep = 0;
        if (OrdinalTimeScale.is(scale2)) {
            const minimumTimeGranularity = this.axis.minimumTimeGranularity;
            const timeIntervalGranularity = intervalUnit(timeInterval3);
            parentLevelMode = minimumTimeGranularity != null && intervalMilliseconds(minimumTimeGranularity) >= intervalMilliseconds(timeIntervalGranularity) ? 2 /* OrdinalTimeStepTicks */  : 3 /* OrdinalTimeScaleTicks */ ;
            alignment = 1 /* Trailing */ ;
            const tickDensity = tickCount / maxTickCount;
            const baseTickStep = scale2.bandCount(visibleRange) / (tickDensity * DENSE_TICK_COUNT);
            var _TICK_STEP_VALUES_findLast;
            ordinalTickStep = (_TICK_STEP_VALUES_findLast = TICK_STEP_VALUES.findLast((t)=>baseTickStep >= t)) !== null && _TICK_STEP_VALUES_findLast !== void 0 ? _TICK_STEP_VALUES_findLast : 1;
        } else if (UnitTimeScale.is(scale2) && (scale2.interval == null || intervalMilliseconds(scale2.interval) >= milliseconds)) {
            parentLevelMode = 1 /* UnitTimeScaleTicks */ ;
        } else {
            parentLevelMode = 0 /* ContinuousTimeScaleTicks */ ;
            alignment = 2 /* Interpolate */ ;
        }
        for(let i = 0; i < primaryTicks.length - 1; i += 1){
            const p0 = primaryTicks[i];
            const p1 = primaryTicks[i + 1];
            const first2 = i === 0;
            const last = i === primaryTicks.length - 2;
            const dp = p1.valueOf() - p0.valueOf();
            const pVisibleRange = [
                Math.max((dv0 - p0.valueOf()) / dp, 0),
                Math.min((dv1 - p0.valueOf()) / dp, 1)
            ];
            let intervalTicks;
            switch(parentLevelMode){
                case 0 /* ContinuousTimeScaleTicks */ :
                    intervalTicks = createTimeScaleTicks(intervalTickParams.interval, [
                        p0,
                        p1
                    ], pVisibleRange, true).ticks;
                    break;
                case 1 /* UnitTimeScaleTicks */ :
                case 3 /* OrdinalTimeScaleTicks */ :
                    const scaleTicks = scale2.ticks(intervalTickParams, [
                        p0,
                        p1
                    ], pVisibleRange, {
                        extend: true,
                        dropInitial: true
                    });
                    var _scaleTicks_ticks;
                    intervalTicks = (_scaleTicks_ticks = scaleTicks === null || scaleTicks === void 0 ? void 0 : scaleTicks.ticks) !== null && _scaleTicks_ticks !== void 0 ? _scaleTicks_ticks : [];
                    break;
                case 2 /* OrdinalTimeStepTicks */ :
                    intervalTicks = scale2.stepTicks(ordinalTickStep, [
                        p0,
                        p1
                    ], void 0, !last);
                    break;
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dropFirstWhile"])(intervalTicks, (firstTick2)=>firstTick2.valueOf() < p0.valueOf());
            if (!last) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dropLastWhile"])(intervalTicks, (lastTick)=>{
                    switch(parentLevelMode){
                        case 0 /* ContinuousTimeScaleTicks */ :
                        case 3 /* OrdinalTimeScaleTicks */ :
                            return lastTick.valueOf() + milliseconds > p1.valueOf();
                        case 1 /* UnitTimeScaleTicks */ :
                        case 2 /* OrdinalTimeStepTicks */ :
                            return lastTick.valueOf() >= p1.valueOf();
                    }
                });
            }
            if (intervalTicks.length === 0) continue;
            const firstTick = intervalTicks[0];
            const firstTickDiff = compareDates(firstTick, p0);
            const firstPrimary = parentLevelMode === 0 /* ContinuousTimeScaleTicks */  ? firstTickDiff === 0 : firstTickDiff <= milliseconds;
            if (firstPrimary && (!skipFirstPrimaryTick || !first2)) {
                primaryTicksIndices.add(ticks.length);
            }
            ticks.push(...intervalTicks);
        }
        if (primaryTicksIndices.size === 0 || // If there's only one primary tick and it's the first tick, don't show primary ticks
        primaryTicksIndices.size === 1 && primaryTicksIndices.has(0)) {
            primaryTicksIndices = void 0;
        }
        let firstTickIndex;
        return {
            ticks,
            tickCount: void 0,
            firstTickIndex,
            primaryTicksIndices,
            alignment
        };
    }
    getTicks(param) {
        let { domain, reverse, niceMode, visibleRange, tickGenerationType, tickCount, minTickCount, maxTickCount, primaryTickCount } = param;
        const { axis } = this;
        const { primaryLabel, scale: scale2, interval } = axis;
        const domainParams = {
            nice: niceMode === 0 /* TickAndDomain */ ,
            interval: interval.step,
            tickCount,
            minTickCount,
            maxTickCount
        };
        const tickParams = {
            ...domainParams,
            nice: niceMode === 0 /* TickAndDomain */  || niceMode === 1 /* TicksOnly */ 
        };
        let secondaryAxisTicks;
        if (tickGenerationType === 1 /* CREATE_SECONDARY */  && primaryTickCount != null && ContinuousScale.is(scale2)) {
            secondaryAxisTicks = calculateNiceSecondaryAxis(scale2, domain, primaryTickCount, reverse, visibleRange);
        }
        var _secondaryAxisTicks_domain;
        const niceDomain = niceMode === 0 /* TickAndDomain */  ? (_secondaryAxisTicks_domain = secondaryAxisTicks === null || secondaryAxisTicks === void 0 ? void 0 : secondaryAxisTicks.domain) !== null && _secondaryAxisTicks_domain !== void 0 ? _secondaryAxisTicks_domain : scale2.niceDomain(domainParams, domain) : domain;
        let tickDomain = niceDomain;
        let rawTicks;
        let rawTickCount;
        let rawFirstTickIndex;
        let timeInterval3;
        let primaryTicksIndices;
        let alignment;
        const generatePrimaryTicks = (primaryLabel === null || primaryLabel === void 0 ? void 0 : primaryLabel.enabled) === true && tickParams.interval == null;
        const scaleDomain = scale2.domain;
        scale2.domain = niceDomain;
        switch(tickGenerationType){
            case 2 /* VALUES */ :
                tickDomain = interval.values;
                rawTicks = interval.values;
                rawTickCount = rawTicks.length;
                if (OrdinalTimeScale.is(scale2)) {
                    alignment = 1 /* Trailing */ ;
                } else if (UnitTimeScale.is(scale2)) {
                    alignment = 2 /* Interpolate */ ;
                }
                if (ContinuousScale.is(scale2)) {
                    const [d0, d1] = findMinMax(niceDomain.map(Number));
                    rawTicks = rawTicks.filter((value)=>Number(value) >= d0 && Number(value) <= d1).sort((a, b)=>Number(a) - Number(b));
                }
                break;
            case 1 /* CREATE_SECONDARY */ :
                if (secondaryAxisTicks) {
                    rawTicks = secondaryAxisTicks.ticks;
                    rawTickCount = secondaryAxisTicks.ticks.length;
                } else {
                    const tickGeneration = scale2.ticks(tickParams, niceDomain, visibleRange);
                    var _tickGeneration_ticks;
                    rawTicks = (_tickGeneration_ticks = tickGeneration === null || tickGeneration === void 0 ? void 0 : tickGeneration.ticks) !== null && _tickGeneration_ticks !== void 0 ? _tickGeneration_ticks : [];
                    rawTickCount = tickGeneration === null || tickGeneration === void 0 ? void 0 : tickGeneration.count;
                }
                break;
            default:
                {
                    if (niceDomain.length > 0 && tickParams.interval == null && (UnitTimeScale.is(scale2) || generatePrimaryTicks && (TimeScale.is(scale2) || OrdinalTimeScale.is(scale2)))) {
                        const dates = niceDomain;
                        const start2 = Math.min(dates[0].valueOf(), dates[dates.length - 1].valueOf());
                        const end2 = Math.max(dates[0].valueOf(), dates[dates.length - 1].valueOf());
                        timeInterval3 = getTickTimeInterval(start2, end2, tickCount, minTickCount, maxTickCount, {
                            weekStart: primaryLabel == null ? sunday2 : void 0,
                            primaryOnly: true
                        });
                    }
                    let minTimeInterval;
                    if (OrdinalTimeScale.is(scale2)) {
                        minTimeInterval = axis.minimumTimeGranularity;
                    } else if (UnitTimeScale.is(scale2)) {
                        minTimeInterval = scale2.interval;
                    }
                    if (minTimeInterval != null && timeInterval3 != null && // Prefer UnitTimeAxis.unit over this interval, because the user may have defined an epoch
                    intervalMilliseconds(minTimeInterval) >= intervalMilliseconds(timeInterval3)) {
                        timeInterval3 = minTimeInterval;
                    }
                    const intervalTicks = timeInterval3 ? this.getTimeIntervalTicks(visibleRange, tickCount, maxTickCount, tickParams, timeInterval3, reverse) : void 0;
                    if (intervalTicks) {
                        ({ ticks: rawTicks, tickCount: rawTickCount, firstTickIndex: rawFirstTickIndex, primaryTicksIndices, alignment } = intervalTicks);
                    } else {
                        const intervalTickParams = UnitTimeScale.is(scale2) && tickParams.interval == null && timeInterval3 != null ? {
                            ...tickParams,
                            interval: timeInterval3
                        } : tickParams;
                        const tickGeneration = scale2.ticks(intervalTickParams, niceDomain, visibleRange);
                        var _tickGeneration_ticks1;
                        rawTicks = (_tickGeneration_ticks1 = tickGeneration === null || tickGeneration === void 0 ? void 0 : tickGeneration.ticks) !== null && _tickGeneration_ticks1 !== void 0 ? _tickGeneration_ticks1 : [];
                        rawTickCount = tickGeneration === null || tickGeneration === void 0 ? void 0 : tickGeneration.count;
                        rawFirstTickIndex = tickGeneration === null || tickGeneration === void 0 ? void 0 : tickGeneration.firstTickIndex;
                        if (TimeScale.is(scale2) || DiscreteTimeScale.is(scale2)) {
                            const timeTickParams = tickParams;
                            const paramsInterval = typeof timeTickParams.interval === "number" ? lowestGranularityForInterval(timeTickParams.interval) : timeTickParams.interval;
                            timeInterval3 !== null && timeInterval3 !== void 0 ? timeInterval3 : timeInterval3 = paramsInterval !== null && paramsInterval !== void 0 ? paramsInterval : tickGeneration === null || tickGeneration === void 0 ? void 0 : tickGeneration.timeInterval;
                        }
                    }
                }
        }
        const fractionDigits = rawTicks.reduce((max, tick)=>Math.max(max, typeof tick === "number" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["countFractionDigits"])(tick) : 0), 0);
        if (!generatePrimaryTicks) {
            primaryTicksIndices = void 0;
        }
        scale2.domain = scaleDomain;
        return {
            tickDomain,
            niceDomain,
            rawTicks,
            rawTickCount,
            rawFirstTickIndex,
            generatePrimaryTicks,
            primaryTicksIndices,
            alignment,
            fractionDigits,
            timeInterval: timeInterval3
        };
    }
    formatTicks(param) {
        let { niceDomain, range: range3, rawTicks, rawFirstTickIndex = 0, generatePrimaryTicks, primaryTicksIndices, alignment, fractionDigits, timeInterval: timeInterval3, sizeLimit = Infinity } = param;
        const { axis } = this;
        const { label, scale: scale2 } = axis;
        const scaleDomain = scale2.domain;
        scale2.domain = niceDomain;
        const dateStyle = generatePrimaryTicks ? "component" : "long";
        const axisTickFormatter = label.enabled ? axis.tickFormatter(niceDomain, rawTicks, false, fractionDigits, timeInterval3, dateStyle) : void 0;
        const parentInterval = timeInterval3 != null ? intervalHierarchy(timeInterval3) : void 0;
        const axisPrimaryTickFormatter = generatePrimaryTicks ? axis.tickFormatter(niceDomain, rawTicks, true, fractionDigits, parentInterval, dateStyle) : void 0;
        var _scale2_bandwidth;
        const halfBandwidth = ((_scale2_bandwidth = scale2.bandwidth) !== null && _scale2_bandwidth !== void 0 ? _scale2_bandwidth : 0) / 2;
        const ticks = [];
        const continuous = TimeScale.is(scale2) || DiscreteTimeScale.is(scale2);
        const idGenerator = createIdsGenerator();
        const isVertical = axis.direction === "y" /* Y */ ;
        var _ref;
        const maxBand = (_ref = BandScale.is(scale2) ? scale2.bandwidth : null) !== null && _ref !== void 0 ? _ref : Infinity;
        const wrapOptions = {
            font: label,
            maxWidth: isVertical ? sizeLimit : maxBand,
            maxHeight: isVertical ? maxBand : sizeLimit,
            overflow: label.truncate ? "ellipsis" : "hide",
            textWrap: label.wrapping
        };
        for(let i = 0; i < rawTicks.length; i++){
            const tick = rawTicks[i];
            const translation = scale2.convert(tick, {
                alignment
            }) + halfBandwidth;
            if (range3.length > 0 && !axis.inRange(translation, 1e-3)) continue;
            var _primaryTicksIndices_has;
            const primary = (_primaryTicksIndices_has = primaryTicksIndices === null || primaryTicksIndices === void 0 ? void 0 : primaryTicksIndices.has(i)) !== null && _primaryTicksIndices_has !== void 0 ? _primaryTicksIndices_has : false;
            let tickLabel = primary ? axisPrimaryTickFormatter === null || axisPrimaryTickFormatter === void 0 ? void 0 : axisPrimaryTickFormatter(tick, i) : axisTickFormatter === null || axisTickFormatter === void 0 ? void 0 : axisTickFormatter(tick, i);
            const inputText = tickLabel !== null && tickLabel !== void 0 ? tickLabel : String(tick);
            if (label.avoidCollisions) {
                tickLabel = TextWrapper.wrapText(inputText, wrapOptions) || tickLabel;
            }
            let tickId;
            const continuousValue = continuous ? tick === null || tick === void 0 ? void 0 : tick.valueOf() : void 0;
            if (Number.isFinite(continuousValue)) {
                tickId = idGenerator("v:".concat(continuousValue));
            } else {
                tickId = idGenerator("l:".concat(tickLabel));
            }
            ticks.push({
                index: i + rawFirstTickIndex,
                tick,
                tickId,
                tickLabel,
                textUntruncated: tickLabel != null && inputText !== tickLabel ? inputText : void 0,
                translation: Math.floor(translation),
                primary
            });
        }
        scale2.domain = scaleDomain;
        return ticks;
    }
    constructor(axis){
        this.axis = axis;
    }
};
function axisLabelsOverlap(data) {
    let padding2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const result = [];
    for (const datum of data){
        const { x, y } = datum.point;
        let { width: width2, height: height2 } = datum.label;
        width2 += padding2;
        height2 += padding2;
        if (result.some((l)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boxCollides"])(l, x, y, width2, height2))) {
            return true;
        }
        result.push({
            x,
            y,
            width: width2,
            height: height2
        });
    }
    return false;
}
function createTimeScaleTicks(interval, domain, visibleRange, extend) {
    if (interval == null) {
        return {
            ticks: domain,
            firstTickIndex: void 0
        };
    }
    const d0 = domain[0].valueOf();
    const d1 = domain[1].valueOf();
    if (typeof interval !== "number") {
        const epoch = domain[0];
        const alignedInterval = typeof interval === "string" ? {
            unit: interval,
            epoch
        } : {
            ...interval,
            epoch
        };
        const ticks2 = intervalRange(alignedInterval, domain[0], domain[1], {
            visibleRange,
            extend
        });
        const firstTickIndex = intervalRangeStartIndex(alignedInterval, domain[0], domain[1], {
            visibleRange,
            extend
        });
        return {
            ticks: ticks2,
            firstTickIndex
        };
    }
    const ticks = [];
    for(let intervalTickTime = d0; intervalTickTime <= d1; intervalTickTime += interval){
        ticks.push(new Date(intervalTickTime));
    }
    return {
        ticks,
        firstTickIndex: void 0
    };
}
function ticksEqual(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for(let i = 0; i < a.length; i += 1){
        var _a_i, _b_i;
        if (((_a_i = a[i]) === null || _a_i === void 0 ? void 0 : _a_i.valueOf()) !== ((_b_i = b[i]) === null || _b_i === void 0 ? void 0 : _b_i.valueOf())) {
            return false;
        }
    }
    return true;
}
function ticksSpacing(ticks) {
    if (ticks.length < 2) return Infinity;
    let spacing = 0;
    let y0 = ticks[0].translation;
    for(let i = 1; i < ticks.length; i++){
        const y1 = ticks[i].translation;
        const delta3 = Math.abs(y1 - y0);
        spacing = Math.max(spacing, delta3);
        y0 = y1;
    }
    return spacing;
}
// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts
var CartesianAxisLabel = class extends AxisLabel {
    constructor(){
        super(...arguments);
        this.autoRotateAngle = 335;
    }
};
__decorateClass([
    Property
], CartesianAxisLabel.prototype, "autoRotate", 2);
__decorateClass([
    Property
], CartesianAxisLabel.prototype, "autoRotateAngle", 2);
// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts
var _CartesianAxis = class _CartesianAxis extends Axis {
    static is(value) {
        return value instanceof _CartesianAxis;
    }
    get horizontal() {
        return this.position === "top" || this.position === "bottom";
    }
    onGridVisibilityChange() {
        this.gridLineGroupSelection.clear();
        this.gridFillGroupSelection.clear();
    }
    resetAnimation(phase) {
        if (phase === "initial") {
            this.animationState.transition("reset");
        }
    }
    get direction() {
        return this.position === "top" || this.position === "bottom" ? "x" /* X */  : "y" /* Y */ ;
    }
    createAxisContext() {
        return {
            ...super.createAxisContext(),
            position: this.position
        };
    }
    createLabel() {
        return new CartesianAxisLabel();
    }
    updateDirection() {
        switch(this.position){
            case "top":
                this.label.mirrored = true;
                this.label.parallel = true;
                break;
            case "right":
                this.label.mirrored = true;
                this.label.parallel = false;
                break;
            case "bottom":
                this.label.mirrored = false;
                this.label.parallel = true;
                break;
            case "left":
                this.label.mirrored = false;
                this.label.parallel = false;
                break;
        }
        if (this.axisContext) {
            this.axisContext.position = this.position;
            this.axisContext.direction = this.direction;
        }
    }
    calculateLayout(primaryTickCount, chartLayout) {
        this.updateDirection();
        return super.calculateLayout(primaryTickCount, chartLayout);
    }
    layoutCrossLines() {
        const crosslinesVisible = this.hasDefinedDomain() || this.hasVisibleSeries();
        this.crossLines.forEach((crossLine)=>{
            var _crossLine_calculateLayout;
            (_crossLine_calculateLayout = crossLine.calculateLayout) === null || _crossLine_calculateLayout === void 0 ? void 0 : _crossLine_calculateLayout.call(crossLine, crosslinesVisible);
        });
    }
    calculateTickLayout(domain, niceMode, visibleRange, initialPrimaryTickCount) {
        var _this_chartLayout, _this_chartLayout1;
        const sideFlag = this.label.getSideFlag();
        const rotation = this.horizontal ? -0.5 * Math.PI : 0;
        const parallelFlipRotation = normalizeAngle360(rotation);
        const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);
        const labelX = sideFlag * (this.getTickSize() + this.label.spacing + this.seriesAreaPadding);
        if (niceMode === 2 /* Off */  && this.label.enabled === false && this.tick.enabled === false && this.gridLine.enabled === false) {
            const { bbox: bbox2, spacing: spacing2 } = this.tickBBox(domain, [], []);
            const layout2 = {
                ticks: [],
                tickLines: [],
                gridLines: [],
                gridFills: [],
                labels: [],
                spacing: spacing2
            };
            return {
                ticks: [],
                rawTickCount: 0,
                tickDomain: domain,
                niceDomain: domain,
                fractionDigits: 0,
                timeInterval: void 0,
                bbox: bbox2,
                layout: layout2
            };
        }
        const { range: range3, reverse, defaultTickMinSpacing } = this;
        const removeOverflowLabels = this.label.avoidCollisions && this.horizontal && (ContinuousScale.is(this.scale) || DiscreteTimeScale.is(this.scale));
        const tickGenerationResult = this.tickGenerator.generateTicks({
            domain,
            range: range3,
            reverse,
            niceMode,
            visibleRange,
            primaryTickCount: initialPrimaryTickCount,
            defaultTickMinSpacing,
            parallelFlipRotation,
            regularFlipRotation,
            labelX,
            sideFlag,
            sizeLimit: (_this_chartLayout = this.chartLayout) === null || _this_chartLayout === void 0 ? void 0 : _this_chartLayout.sizeLimit,
            removeOverflowLabels,
            removeOverflowThreshold: (_this_chartLayout1 = this.chartLayout) === null || _this_chartLayout1 === void 0 ? void 0 : _this_chartLayout1.padding.right
        });
        const { tickData } = tickGenerationResult;
        const { ticks, tickDomain, rawTicks, rawTickCount, fractionDigits, timeInterval: timeInterval3, niceDomain } = tickData;
        const labels = ticks.map((d)=>this.getTickLabelProps(d, tickGenerationResult));
        const { position, gridPadding, gridLength } = this;
        const direction = position === "bottom" || position === "right" ? -1 : 1;
        const p1 = direction * gridPadding;
        const p2 = direction * (gridLength + gridPadding);
        const gridLines = this.calculateGridLines(ticks, p1, p2);
        const gridFills = this.calculateGridFills(ticks, p1, p2);
        const tickLines = this.calculateTickLines(ticks, direction);
        const { bbox, spacing } = this.tickBBox(tickDomain, ticks, labels);
        const layout = {
            ticks,
            gridLines,
            gridFills,
            tickLines,
            labels,
            spacing
        };
        return {
            ticks: rawTicks,
            rawTickCount,
            tickDomain,
            niceDomain,
            fractionDigits,
            timeInterval: timeInterval3,
            bbox,
            layout
        };
    }
    calculateGridLines(ticks, p1, p2) {
        return ticks.map((tick, index)=>this.calculateGridLine(tick, index, p1, p2, ticks));
    }
    calculateGridLine(param, _index, p1, p2, _ticks) {
        let { index: tickIndex, tickId, translation: offset } = param;
        const { gridLine, horizontal } = this;
        const [x1, y1, x2, y2] = horizontal ? [
            offset,
            p1,
            offset,
            p2
        ] : [
            p1,
            offset,
            p2,
            offset
        ];
        const { style } = gridLine;
        var _style_;
        const { stroke: stroke2, strokeWidth = 0, lineDash } = (_style_ = style[tickIndex % style.length]) !== null && _style_ !== void 0 ? _style_ : {};
        return {
            tickId,
            offset,
            x1,
            y1,
            x2,
            y2,
            stroke: stroke2,
            strokeWidth,
            lineDash
        };
    }
    calculateGridFills(ticks, p1, p2) {
        const { horizontal, range: range3, type } = this;
        const gridFills = [];
        if (ticks.length == 0) return gridFills;
        let gridFillIndexOffset = 0;
        const isVerticalUnitTime = !horizontal && type === "unit-time";
        const firstFillOffCanvas = isVerticalUnitTime && ticks[0].translation < range3[0] || !isVerticalUnitTime && ticks[0].translation > range3[0];
        if (firstFillOffCanvas) {
            const injectedTick = {
                tickId: "before:".concat(ticks[0].tickId),
                translation: range3[0]
            };
            gridFills.push(this.calculateGridFill(injectedTick, -1, ticks[0].index, p1, p2, ticks));
            gridFillIndexOffset = 1;
        }
        gridFills.push(...ticks.map((tick, index)=>this.calculateGridFill(tick, index, tick.index + gridFillIndexOffset, p1, p2, ticks)));
        return gridFills;
    }
    calculateGridFill(param, index, gridFillIndex, p1, p2, ticks) {
        let { tickId, translation } = param;
        const { gridLine, horizontal, range: range3 } = this;
        const nextTick = ticks[index + 1];
        const startOffset = translation;
        const endOffset = nextTick ? nextTick.translation : range3[1];
        const [x1, y1, x2, y2] = horizontal ? [
            startOffset,
            Math.max(p1, p2),
            endOffset,
            Math.min(p1, p2)
        ] : [
            Math.min(p1, p2),
            Math.min(startOffset, endOffset),
            Math.max(p1, p2),
            Math.max(startOffset, endOffset)
        ];
        var _gridLine_style_;
        const { fill, fillOpacity } = (_gridLine_style_ = gridLine.style[gridFillIndex % gridLine.style.length]) !== null && _gridLine_style_ !== void 0 ? _gridLine_style_ : {};
        return {
            tickId,
            x1,
            y1,
            x2,
            y2,
            fill,
            fillOpacity
        };
    }
    calculateTickLines(ticks, direction) {
        return ticks.map((tick)=>this.calculateTickLine(tick, tick.index, direction, ticks));
    }
    calculateTickLine(param, _index, direction, _ticks) {
        let { primary, tickId, translation: offset } = param;
        const { horizontal, tick, primaryTick } = this;
        const datumTick = primary && (primaryTick === null || primaryTick === void 0 ? void 0 : primaryTick.enabled) ? primaryTick : tick;
        const h = -direction * this.getTickSize(datumTick);
        const [x1, y1, x2, y2] = horizontal ? [
            offset,
            0,
            offset,
            h
        ] : [
            0,
            offset,
            h,
            offset
        ];
        const { stroke: stroke2, width: strokeWidth } = datumTick;
        const lineDash = void 0;
        return {
            tickId,
            offset,
            x1,
            y1,
            x2,
            y2,
            stroke: stroke2,
            strokeWidth,
            lineDash
        };
    }
    update() {
        var _this_primaryTick, _this_primaryTick1;
        this.updateDirection();
        const previousTicksIds = Array.from(this.tickLabelGroupSelection.nodes(), (node)=>node.datum.tickId);
        super.update();
        var _this_primaryTick_enabled;
        this.tickLineGroup.visible = this.tick.enabled || ((_this_primaryTick_enabled = (_this_primaryTick = this.primaryTick) === null || _this_primaryTick === void 0 ? void 0 : _this_primaryTick.enabled) !== null && _this_primaryTick_enabled !== void 0 ? _this_primaryTick_enabled : false);
        var _this_primaryTick_enabled1;
        this.tickLabelGroup.visible = this.label.enabled || ((_this_primaryTick_enabled1 = (_this_primaryTick1 = this.primaryTick) === null || _this_primaryTick1 === void 0 ? void 0 : _this_primaryTick1.enabled) !== null && _this_primaryTick_enabled1 !== void 0 ? _this_primaryTick_enabled1 : false);
        const { tickLayout } = this;
        var _tickLayout_spacing;
        this.updateTitle(this.scale.domain, (_tickLayout_spacing = tickLayout === null || tickLayout === void 0 ? void 0 : tickLayout.spacing) !== null && _tickLayout_spacing !== void 0 ? _tickLayout_spacing : 0);
        if (!this.animatable) {
            this.moduleCtx.animationManager.skipCurrentBatch();
        }
        if (tickLayout) {
            const { ticks } = tickLayout;
            if (this.animationManager.isSkipped()) {
                this.resetSelectionNodes();
            } else {
                const tickIds = ticks.map((datum)=>datum.tickId);
                const diff2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["diffArrays"])(previousTicksIds, tickIds);
                this.animationState.transition("update", diff2);
            }
        }
        const { enabled, stroke: stroke2, width: width2 } = this.line;
        this.lineNode.setProperties({
            stroke: stroke2,
            strokeWidth: enabled ? width2 : 0
        });
        this.updateTickLines();
        this.updateGridLines();
        this.updateGridFills();
    }
    getAxisTransform() {
        return {
            translationX: Math.floor(this.translation.x),
            translationY: Math.floor(this.translation.y)
        };
    }
    updatePosition() {
        super.updatePosition();
        const axisTransform = this.getAxisTransform();
        this.tickLineGroup.datum = axisTransform;
        this.tickLabelGroup.datum = axisTransform;
        this.lineNodeGroup.datum = axisTransform;
        this.headingLabelGroup.datum = axisTransform;
    }
    getAxisLineCoordinates() {
        const { horizontal } = this;
        const [c1, c2] = findMinMax(this.range);
        return horizontal ? {
            x1: c1,
            x2: c2,
            y1: 0,
            y2: 0
        } : {
            x1: 0,
            x2: 0,
            y1: c1,
            y2: c2
        };
    }
    getTickLineBBox(datum) {
        const { translation } = datum;
        const { position, primaryTick } = this;
        let tickSize = this.getTickSize();
        if (primaryTick === null || primaryTick === void 0 ? void 0 : primaryTick.enabled) {
            tickSize = Math.max(tickSize, this.getTickSize(primaryTick));
        }
        switch(position){
            case "top":
                return new BBox(translation, -tickSize, translation, tickSize);
            case "bottom":
                return new BBox(translation, 0, translation, tickSize);
            case "left":
                return new BBox(-tickSize, translation, tickSize, translation);
            case "right":
                return new BBox(0, translation, tickSize, translation);
        }
    }
    lineNodeBBox() {
        const { position, seriesAreaPadding } = this;
        const { y1, y2 } = this.getAxisLineCoordinates();
        const dy = y2 - y1;
        switch(position){
            case "top":
                return new BBox(y1, -seriesAreaPadding, dy, seriesAreaPadding);
            case "bottom":
                return new BBox(y1, 0, dy, seriesAreaPadding);
            case "left":
                return new BBox(-seriesAreaPadding, y1, seriesAreaPadding, dy);
            case "right":
                return new BBox(0, y1, seriesAreaPadding, dy);
        }
    }
    titleBBox(domain, spacing) {
        const { tempCaption } = this;
        tempCaption.node.setProperties(this.titleProps(tempCaption, domain, spacing));
        return tempCaption.node.getBBox();
    }
    tickBBox(domain, ticks, labels) {
        const { tick, primaryTick, label, primaryLabel, title, position, horizontal, seriesAreaPadding } = this;
        const boxes = [];
        boxes.push(this.lineNodeBBox());
        if (tick.enabled || (primaryTick === null || primaryTick === void 0 ? void 0 : primaryTick.enabled)) {
            for (const datum of ticks){
                boxes.push(this.getTickLineBBox(datum));
            }
        }
        const { tempText } = this;
        if (label.enabled) {
            for (const datum of labels){
                if (!datum.visible) continue;
                tempText.setProperties(datum);
                const box = tempText.getBBox(false);
                if (box) {
                    boxes.push(box);
                }
            }
        }
        if ((primaryLabel === null || primaryLabel === void 0 ? void 0 : primaryLabel.enabled) && position === "bottom") {
            const inexactMeasurementPadding = 2;
            boxes.push(new BBox(0, TextUtils.getLineHeight(label.fontSize) + inexactMeasurementPadding, 1, this.getTickSize(tick) + label.spacing + seriesAreaPadding));
            if (primaryLabel.format != null) {
                const { format } = primaryLabel;
                const formats = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(format) ? Object.values(format) : [
                    format
                ];
                const maxLines = formats.reduce((m, f)=>Math.max(m, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["countLines"])(f)), 0);
                boxes.push(new BBox(0, this.getTickSize(primaryTick !== null && primaryTick !== void 0 ? primaryTick : tick) + primaryLabel.spacing + seriesAreaPadding, 1, maxLines * TextUtils.getLineHeight(primaryLabel.fontSize) + inexactMeasurementPadding));
            }
        }
        let spacing = 0;
        if (title.enabled) {
            const combined = BBox.merge(boxes);
            spacing = horizontal ? combined.height : combined.width;
            boxes.push(this.titleBBox(domain, spacing));
        }
        const bbox = BBox.merge(boxes);
        return {
            bbox,
            spacing
        };
    }
    titleProps(caption, domain, spacing) {
        const { title } = this;
        if (!title.enabled) {
            caption.enabled = false;
            return {
                visible: false,
                text: "",
                textBaseline: "bottom",
                x: 0,
                y: 0,
                rotationCenterX: 0,
                rotationCenterY: 0,
                rotation: 0
            };
        }
        caption.enabled = true;
        caption.color = title.color;
        caption.fontFamily = title.fontFamily;
        caption.fontSize = title.fontSize;
        caption.fontStyle = title.fontStyle;
        caption.fontWeight = title.fontWeight;
        caption.wrapping = title.wrapping;
        var _title_spacing;
        const padding2 = ((_title_spacing = title.spacing) !== null && _title_spacing !== void 0 ? _title_spacing : 0) + spacing;
        const { range: range3 } = this;
        const midOffset = (range3[0] + range3[1]) / 2;
        let x;
        let y;
        let rotation;
        let textBaseline;
        switch(this.position){
            case "top":
                x = midOffset;
                y = -padding2;
                rotation = 0;
                textBaseline = "bottom";
                break;
            case "bottom":
                x = midOffset;
                y = padding2;
                rotation = 0;
                textBaseline = "top";
                break;
            case "left":
                x = -padding2;
                y = midOffset;
                rotation = -0.5 * Math.PI;
                textBaseline = "bottom";
                break;
            case "right":
                x = padding2;
                y = midOffset;
                rotation = 0.5 * Math.PI;
                textBaseline = "bottom";
                break;
        }
        const { formatter: formatter2 = (p)=>p.defaultValue } = title;
        const text = this.cachedCallWithContext(formatter2, this.getTitleFormatterParams(domain));
        caption.text = text;
        return {
            visible: true,
            text,
            textBaseline,
            x,
            y,
            rotationCenterX: x,
            rotationCenterY: y,
            rotation
        };
    }
    getLabelBorderOffset(label) {
        const padding2 = expandLabelPadding(label);
        function unreachable(a) {
            return a;
        }
        switch(this.position){
            case "top":
                return padding2.bottom;
            case "right":
                return padding2.left;
            case "bottom":
                return padding2.top;
            case "left":
                return padding2.right;
            default:
                unreachable(this.position);
        }
    }
    getTickLabelProps(datum, tickGenerationResult) {
        const { horizontal, primaryLabel, primaryTick, seriesAreaPadding, scale: scale2 } = this;
        const { tickId, tickLabel: text = "", translation, primary, textUntruncated } = datum;
        const label = primary && (primaryLabel === null || primaryLabel === void 0 ? void 0 : primaryLabel.enabled) ? primaryLabel : this.label;
        const tick = primary && (primaryTick === null || primaryTick === void 0 ? void 0 : primaryTick.enabled) ? primaryTick : this.tick;
        const { rotation, textBaseline, textAlign } = tickGenerationResult;
        const { range: range3 } = scale2;
        const sideFlag = this.label.getSideFlag();
        const borderOffset = -this.getLabelBorderOffset(label);
        const labelOffset = sideFlag * (this.getTickSize(tick) + label.spacing + seriesAreaPadding) + borderOffset;
        const visible = text !== "";
        const x = horizontal ? translation : labelOffset;
        const y = horizontal ? -labelOffset : translation;
        return {
            ...this.getLabelStyles({
                value: text
            }, void 0, label),
            tickId,
            rotation,
            text,
            textAlign,
            textBaseline,
            textUntruncated,
            visible,
            x,
            y,
            rotationCenterX: x,
            rotationCenterY: y,
            range: range3
        };
    }
    updateSelections() {
        if (!this.tickLayout) return;
        const lineData = this.getAxisLineCoordinates();
        const { tickLines, gridLines, gridFills, labels } = this.tickLayout;
        const getDatumId = (datum)=>datum.tickId;
        this.lineNode.datum = lineData;
        this.gridLineGroupSelection.update(this.gridLine.enabled ? gridLines : [], void 0, getDatumId);
        this.gridFillGroupSelection.update(this.gridLine.enabled ? gridFills : [], void 0, getDatumId);
        this.tickLineGroupSelection.update(tickLines, void 0, getDatumId);
        this.tickLabelGroupSelection.update(labels, void 0, getDatumId);
    }
    updateGridLines() {
        this.gridLineGroupSelection.each((line, datum)=>{
            line.stroke = datum.stroke;
            line.strokeWidth = datum.strokeWidth;
            line.lineDash = datum.lineDash;
        });
    }
    updateGridFills() {
        this.gridFillGroupSelection.each((rect, datum)=>{
            rect.fill = datum.fill;
            var _datum_fillOpacity;
            rect.fillOpacity = (_datum_fillOpacity = datum.fillOpacity) !== null && _datum_fillOpacity !== void 0 ? _datum_fillOpacity : 1;
        });
    }
    updateTickLines() {
        this.tickLineGroupSelection.each((line, datum)=>{
            line.stroke = datum.stroke;
            line.strokeWidth = datum.strokeWidth;
            line.lineDash = datum.lineDash;
        });
    }
    updateTitle(domain, spacing) {
        const { caption } = this.title;
        const titleProps = this.titleProps(caption, domain, spacing);
        caption.node.visible = titleProps.visible;
        caption.node.text = titleProps.text;
        caption.node.textBaseline = titleProps.textBaseline;
        caption.node.datum = titleProps;
    }
    updateLabels() {
        if (!this.label.enabled) return;
        this.tickLabelGroupSelection.each((node, datum)=>{
            node.fill = datum.color;
            node.text = datum.text;
            node.textBaseline = datum.textBaseline;
            var _datum_textAlign;
            node.textAlign = (_datum_textAlign = datum.textAlign) !== null && _datum_textAlign !== void 0 ? _datum_textAlign : "center";
            node.pointerEvents = datum.textUntruncated == null ? 1 /* None */  : 0 /* All */ ;
            node.setFont(datum);
            node.setBoxing(datum);
        });
    }
    animateReadyUpdate(diff2) {
        const { animationManager } = this.moduleCtx;
        const selectionCtx = prepareAxisAnimationContext(this);
        const fns = prepareAxisAnimationFunctions(selectionCtx);
        fromToMotion(this.id, "axis-group", animationManager, [
            this.lineNodeGroup,
            this.tickLabelGroup,
            this.tickLineGroup,
            this.headingLabelGroup
        ], fns.group);
        fromToMotion(this.id, "line", animationManager, [
            this.lineNode
        ], fns.line);
        fromToMotion(this.id, "line-paths", animationManager, [
            this.gridLineGroupSelection,
            this.tickLineGroupSelection
        ], fns.tick, (_, d)=>d.tickId, diff2);
        fromToMotion(this.id, "tick-labels", animationManager, [
            this.tickLabelGroupSelection
        ], fns.label, (_, d)=>d.tickId, diff2);
        fromToMotion(this.id, "title", animationManager, [
            this.title.caption.node
        ], fns.label, (_, d)=>d.tickId, diff2);
    }
    resetSelectionNodes() {
        resetMotion([
            this.lineNodeGroup,
            this.tickLabelGroup,
            this.tickLineGroup,
            this.headingLabelGroup
        ], resetAxisGroupFn());
        resetMotion([
            this.gridLineGroupSelection,
            this.tickLineGroupSelection
        ], resetAxisLineSelectionFn());
        resetMotion([
            this.gridFillGroupSelection
        ], resetAxisFillSelectionFn());
        resetMotion([
            this.tickLabelGroupSelection
        ], resetAxisLabelSelectionFn());
        resetMotion([
            this.title.caption.node
        ], resetAxisLabelSelectionFn());
        resetMotion([
            this.lineNode
        ], resetAxisLineSelectionFn());
    }
    constructor(moduleCtx, scale2){
        super(moduleCtx, scale2);
        this.maxThicknessRatio = 0.3;
        this.headingLabelGroup = this.axisGroup.appendChild(new TranslatableGroup({
            name: "".concat(this.id, "-Axis-heading")
        }));
        this.lineNodeGroup = this.axisGroup.appendChild(new TranslatableGroup({
            name: "".concat(this.id, "-Axis-line")
        }));
        this.lineNode = this.lineNodeGroup.appendChild(new Line({
            zIndex: 1 /* AxisLine */ 
        }));
        this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);
        this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);
        this.gridFillGroupSelection = Selection.select(this.gridFillGroup, Rect, false);
        this.tempText = new TransformableText({
            debugDirty: false
        });
        this.tempCaption = new Caption();
        this.tickGenerator = new AxisTickGenerator(this);
        this.animationManager = moduleCtx.animationManager;
        this.animationState = new StateMachine("empty", {
            empty: {
                update: {
                    target: "ready",
                    action: ()=>this.resetSelectionNodes()
                },
                reset: "empty"
            },
            ready: {
                update: (data)=>this.animateReadyUpdate(data),
                resize: ()=>this.resetSelectionNodes(),
                reset: "empty"
            }
        });
        this.headingLabelGroup.appendChild(this.title.caption.node);
        let previousSize = void 0;
        this.cleanup.register(moduleCtx.eventsHub.on("layout:complete", (e)=>{
            const size = [
                e.chart.width,
                e.chart.height
            ];
            if (previousSize != null && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraysEqual"])(size, previousSize)) {
                this.animationState.transition("resize");
            }
            previousSize = size;
        }), this.title.caption.registerInteraction(this.moduleCtx, "afterend"));
    }
};
__decorateClass([
    Property
], _CartesianAxis.prototype, "thickness", 2);
__decorateClass([
    Property
], _CartesianAxis.prototype, "maxThicknessRatio", 2);
__decorateClass([
    Property
], _CartesianAxis.prototype, "position", 2);
var CartesianAxis = _CartesianAxis;
// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts
var CartesianAxisPositions = [
    "top",
    "right",
    "bottom",
    "left"
];
function isAxisPosition(position) {
    return typeof position === "string" && CartesianAxisPositions.includes(position);
}
function guessInvalidPositions(axes) {
    const invalidAxes = [];
    const usedPositions = [];
    const guesses = [
        ...CartesianAxisPositions
    ];
    for (const axis of axes){
        if (axis instanceof CartesianAxis) {
            if (isAxisPosition(axis.position)) {
                usedPositions.push(axis.position);
            } else {
                invalidAxes.push(axis);
            }
        }
    }
    for (const axis of invalidAxes){
        let nextGuess;
        do {
            nextGuess = guesses.pop();
        }while (nextGuess && usedPositions.includes(nextGuess))
        if (nextGuess == null) break;
        axis.position = nextGuess;
    }
}
// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts
var MATCHING_KEYS = [
    "direction",
    "xKey",
    "yKey",
    "sizeKey",
    "angleKey",
    "radiusKey",
    "normalizedTo"
];
function matchSeriesOptions(series, optSeries, oldOptsSeries) {
    const generateKey = (type, i, opts)=>{
        const result = [
            type
        ];
        for (const key of MATCHING_KEYS){
            if (key in i && i[key] != null) result.push("".concat(key, "=").concat(i[key]));
        }
        if (opts === null || opts === void 0 ? void 0 : opts.seriesGrouping) {
            result.push("seriesGrouping.groupId=".concat(opts === null || opts === void 0 ? void 0 : opts.seriesGrouping.groupId));
        }
        return result.join(";");
    };
    const seriesMap = /* @__PURE__ */ new Map();
    let idx = 0;
    for (const s of series){
        var _seriesMap_get;
        const key = generateKey(s.type, s.properties, oldOptsSeries === null || oldOptsSeries === void 0 ? void 0 : oldOptsSeries[idx]);
        if (!seriesMap.has(key)) {
            seriesMap.set(key, []);
        }
        (_seriesMap_get = seriesMap.get(key)) === null || _seriesMap_get === void 0 ? void 0 : _seriesMap_get.push([
            s,
            idx++
        ]);
    }
    const optsMap = /* @__PURE__ */ new Map();
    idx = 0;
    for (const o of optSeries){
        var _optsMap_get;
        const key = generateKey(o.type, o, o);
        if (!optsMap.has(key)) {
            optsMap.set(key, []);
        }
        (_optsMap_get = optsMap.get(key)) === null || _optsMap_get === void 0 ? void 0 : _optsMap_get.push([
            o,
            idx++
        ]);
    }
    const overlap = [
        ...seriesMap.keys()
    ].some((k)=>optsMap.has(k));
    if (!overlap) {
        return {
            status: "no-overlap",
            oldKeys: seriesMap.keys(),
            newKeys: optsMap.keys()
        };
    }
    const changes = [];
    for (const [key, optsTuples] of optsMap.entries()){
        for (const [opts, targetIdx] of optsTuples){
            const seriesArray = seriesMap.get(key);
            if (seriesArray == null || seriesArray.length < 1) {
                changes.push({
                    opts,
                    targetIdx,
                    idx: targetIdx,
                    status: "add"
                });
                seriesMap.delete(key);
                continue;
            }
            const [outputSeries, currentIdx] = seriesArray.shift();
            var _oldOptsSeries_currentIdx;
            const previousOpts = (_oldOptsSeries_currentIdx = oldOptsSeries === null || oldOptsSeries === void 0 ? void 0 : oldOptsSeries[currentIdx]) !== null && _oldOptsSeries_currentIdx !== void 0 ? _oldOptsSeries_currentIdx : {};
            const diff2 = jsonDiff(previousOpts, opts !== null && opts !== void 0 ? opts : {});
            var _diff2_seriesGrouping;
            const { groupIndex, stackIndex } = (_diff2_seriesGrouping = diff2 === null || diff2 === void 0 ? void 0 : diff2.seriesGrouping) !== null && _diff2_seriesGrouping !== void 0 ? _diff2_seriesGrouping : {};
            if (groupIndex != null || stackIndex != null) {
                changes.push({
                    opts,
                    series: outputSeries,
                    diff: diff2,
                    targetIdx,
                    idx: currentIdx,
                    status: "series-grouping"
                });
            } else if (diff2) {
                changes.push({
                    opts,
                    series: outputSeries,
                    diff: diff2,
                    targetIdx,
                    idx: currentIdx,
                    status: "update"
                });
            } else {
                changes.push({
                    opts,
                    series: outputSeries,
                    targetIdx,
                    idx: currentIdx,
                    status: "no-op"
                });
            }
            if (seriesArray.length === 0) {
                seriesMap.delete(key);
            }
        }
    }
    for (const seriesArray of seriesMap.values()){
        for (const [outputSeries, currentIdx] of seriesArray){
            changes.push({
                series: outputSeries,
                idx: currentIdx,
                targetIdx: -1,
                status: "remove"
            });
        }
    }
    return {
        status: "overlap",
        changes
    };
}
// packages/ag-charts-community/src/chart/mapping/types.ts
function optionsType(input) {
    var _series_;
    const { series } = input;
    var _series__type;
    return (_series__type = series === null || series === void 0 ? void 0 : (_series_ = series[0]) === null || _series_ === void 0 ? void 0 : _series_.type) !== null && _series__type !== void 0 ? _series__type : "line";
}
function isAgCartesianChartOptions(input) {
    const specifiedType = optionsType(input);
    return chartTypes2.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);
}
function isAgPolarChartOptions(input) {
    const specifiedType = optionsType(input);
    return chartTypes2.isPolar(specifiedType) || isEnterprisePolar(specifiedType);
}
function isAgTopologyChartOptions(input) {
    const specifiedType = optionsType(input);
    return chartTypes2.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);
}
function isAgStandaloneChartOptions(input) {
    const specifiedType = optionsType(input);
    return chartTypes2.isStandalone(specifiedType) || isEnterpriseStandalone(specifiedType);
}
// packages/ag-charts-community/src/chart/modulesManager.ts
var ModulesManager = class extends ModuleMap {
    applyOptions(options) {
        for (const m of this.moduleMap.values()){
            if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {
                m.moduleInstance.set(options[m.module.optionsKey]);
            }
        }
    }
    *legends() {
        for (const { module, moduleInstance } of this.moduleMap.values()){
            if (module.type !== "legend") continue;
            yield {
                legendType: module.identifier,
                legend: moduleInstance
            };
        }
    }
};
;
var DEFAULT_OVERLAY_CLASS = "ag-charts-overlay";
var DEFAULT_OVERLAY_DARK_CLASS = "ag-charts-dark-overlay";
var Overlay = class extends BaseProperties {
    getText(localeManager) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(this.text)) {
            return this.text.map((s)=>s.text).join("");
        }
        var _this_text;
        return localeManager.t((_this_text = this.text) !== null && _this_text !== void 0 ? _this_text : this.defaultMessageId);
    }
    getElement(callers, animationManager, localeManager, rect) {
        var _this_content;
        (_this_content = this.content) === null || _this_content === void 0 ? void 0 : _this_content.remove();
        this.focusBox = rect;
        if (this.renderer) {
            const params = {};
            const htmlContent = callWithContext(callers, this.renderer, params);
            if (htmlContent instanceof HTMLElement) {
                this.content = htmlContent;
            } else {
                const tempDiv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div");
                tempDiv.innerHTML = htmlContent;
                const { firstElementChild } = tempDiv;
                if (firstElementChild instanceof HTMLElement && tempDiv.childElementCount === 1) {
                    this.content = firstElementChild;
                } else {
                    this.content = tempDiv;
                }
            }
        } else {
            const content = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div", {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                boxSizing: "border-box",
                height: "100%",
                margin: "8px",
                fontFamily: "var(--ag-charts-font-family)",
                fontSize: "var(--ag-charts-font-size)",
                fontWeight: "var(--ag-charts-font-weight)"
            });
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(this.text)) {
                const container = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div");
                for (const segment of this.text){
                    var _segment_fontFamily;
                    const el = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("span", {
                        color: segment.color,
                        fontSize: "".concat(segment.fontSize, "px"),
                        fontFamily: (_segment_fontFamily = segment.fontFamily) !== null && _segment_fontFamily !== void 0 ? _segment_fontFamily : "inherit",
                        fontWeight: String(segment.fontWeight),
                        fontStyle: segment.fontStyle
                    });
                    el.innerText = segment.text;
                    container.appendChild(el);
                }
                content.appendChild(container);
            } else {
                content.innerText = this.getText(localeManager);
            }
            this.content = content;
            animationManager === null || animationManager === void 0 ? void 0 : animationManager.animate({
                from: 0,
                to: 1,
                id: "overlay",
                phase: "add",
                groupId: "opacity",
                onUpdate (value) {
                    content.style.opacity = String(value);
                },
                onStop () {
                    content.style.opacity = "1";
                }
            });
        }
        return this.content;
    }
    removeElement() {
        let cleanup = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ()=>{
            var _this_content;
            return (_this_content = this.content) === null || _this_content === void 0 ? void 0 : _this_content.remove();
        }, animationManager = arguments.length > 1 ? arguments[1] : void 0;
        if (!this.content) return;
        if (animationManager) {
            const { content } = this;
            animationManager.animate({
                from: 1,
                to: 0,
                phase: "remove",
                id: "overlay",
                groupId: "opacity",
                onUpdate (value) {
                    content.style.opacity = String(value);
                },
                onStop () {
                    cleanup === null || cleanup === void 0 ? void 0 : cleanup();
                }
            });
        } else {
            cleanup === null || cleanup === void 0 ? void 0 : cleanup();
        }
        this.content = void 0;
        this.focusBox = void 0;
    }
    constructor(className, defaultMessageId){
        super();
        this.className = className;
        this.defaultMessageId = defaultMessageId;
        this.enabled = true;
    }
};
__decorateClass([
    Property
], Overlay.prototype, "enabled", 2);
__decorateClass([
    Property
], Overlay.prototype, "text", 2);
__decorateClass([
    Property
], Overlay.prototype, "renderer", 2);
// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts
var ChartOverlays = class extends BaseProperties {
    getFocusInfo(localeManager) {
        for (const overlay of [
            this.loading,
            this.noData,
            this.noVisibleSeries,
            this.unsupportedBrowser
        ]){
            if (overlay.focusBox !== void 0) {
                return {
                    text: overlay.getText(localeManager),
                    rect: overlay.focusBox
                };
            }
        }
        return void 0;
    }
    destroy() {
        this.loading.removeElement();
        this.noData.removeElement();
        this.noVisibleSeries.removeElement();
        this.unsupportedBrowser.removeElement();
    }
    constructor(){
        super(...arguments);
        this.darkTheme = false;
        this.loading = new Overlay("ag-charts-loading-overlay", "overlayLoadingData");
        this.noData = new Overlay("ag-charts-no-data-overlay", "overlayNoData");
        this.noVisibleSeries = new Overlay("ag-charts-no-visible-series", "overlayNoVisibleSeries");
        this.unsupportedBrowser = new Overlay("ag-charts-unsupported-browser", "overlayUnsupportedBrowser");
    }
};
__decorateClass([
    Property
], ChartOverlays.prototype, "darkTheme", 2);
__decorateClass([
    Property
], ChartOverlays.prototype, "loading", 2);
__decorateClass([
    Property
], ChartOverlays.prototype, "noData", 2);
__decorateClass([
    Property
], ChartOverlays.prototype, "noVisibleSeries", 2);
__decorateClass([
    Property
], ChartOverlays.prototype, "unsupportedBrowser", 2);
;
function getLoadingSpinner(text, defaultDuration) {
    const { animationDuration } = PHASE_METADATA["add"];
    const duration = animationDuration * defaultDuration;
    const container = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div", "".concat(DEFAULT_OVERLAY_CLASS, "--loading"), {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexDirection: "column",
        height: "100%",
        boxSizing: "border-box",
        font: "13px Verdana, sans-serif",
        // FONT_SIZE.MEDIUM
        userSelect: "none",
        animation: "ag-charts-loading ".concat(duration, "ms linear 50ms both")
    });
    const matrix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("span", {
        width: "45px",
        height: "40px",
        backgroundImage: [
            "linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), ",
            "linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), ",
            "linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)"
        ].join(""),
        backgroundSize: "10px 400%",
        backgroundRepeat: "no-repeat",
        animation: "ag-charts-loading-matrix 1s infinite linear"
    });
    const label = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("p", {
        marginTop: "1em"
    });
    label.innerText = text;
    const background = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div", "".concat(DEFAULT_OVERLAY_CLASS, "__loading-background"), {
        position: "absolute",
        inset: "0",
        opacity: "0.5",
        zIndex: "-1"
    });
    const animationStyles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("style");
    animationStyles.innerText = [
        "@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }",
        "@keyframes ag-charts-loading-matrix {",
        "0% { background-position: 0% 0%, 50% 0%, 100% 0%; }",
        "100% { background-position: 0% 100%, 50% 100%, 100% 100%; }",
        "}"
    ].join(" ");
    container.replaceChildren(animationStyles, matrix, label, background);
    return container;
}
;
;
var HighlightState = /* @__PURE__ */ ((HighlightState2)=>{
    HighlightState2[HighlightState2["None"] = 0] = "None";
    HighlightState2[HighlightState2["Item"] = 1] = "Item";
    HighlightState2[HighlightState2["Series"] = 2] = "Series";
    HighlightState2[HighlightState2["OtherSeries"] = 3] = "OtherSeries";
    HighlightState2[HighlightState2["OtherItem"] = 4] = "OtherItem";
    return HighlightState2;
})(HighlightState || {});
var SeriesItemHighlightStyle = class extends BaseProperties {
};
__decorateClass([
    Property
], SeriesItemHighlightStyle.prototype, "fill", 2);
__decorateClass([
    Property
], SeriesItemHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass([
    Property
], SeriesItemHighlightStyle.prototype, "stroke", 2);
__decorateClass([
    Property
], SeriesItemHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
    Property
], SeriesItemHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass([
    Property
], SeriesItemHighlightStyle.prototype, "lineDash", 2);
__decorateClass([
    Property
], SeriesItemHighlightStyle.prototype, "lineDashOffset", 2);
var HighlightProperties = class extends BaseProperties {
    getItemHighlightStyle(highlightState) {
        switch(highlightState){
            case 1 /* Item */ :
                return this.highlightedItem;
            case 4 /* OtherItem */ :
                return this.unhighlightedItem;
            case 2 /* Series */ :
                return this.highlightedSeries;
            case 3 /* OtherSeries */ :
                return this.unhighlightedSeries;
        }
    }
    getSeriesHighlightStyle(highlightState) {
        switch(highlightState){
            case 1 /* Item */ :
            case 4 /* OtherItem */ :
            case 2 /* Series */ :
                return this.highlightedSeries;
            case 3 /* OtherSeries */ :
                return this.unhighlightedSeries;
        }
    }
    getStyle(highlightState) {
        return mergeDefaults(this.getItemHighlightStyle(highlightState), this.getSeriesHighlightStyle(highlightState));
    }
    constructor(){
        super(...arguments);
        this.enabled = true;
        this.range = "tooltip";
        this.bringToFront = false;
        this.highlightedItem = {};
        this.unhighlightedItem = {};
        this.highlightedSeries = {};
        this.unhighlightedSeries = {};
    }
};
__decorateClass([
    Property
], HighlightProperties.prototype, "enabled", 2);
__decorateClass([
    Property
], HighlightProperties.prototype, "range", 2);
__decorateClass([
    Property
], HighlightProperties.prototype, "bringToFront", 2);
__decorateClass([
    Property
], HighlightProperties.prototype, "highlightedItem", 2);
__decorateClass([
    Property
], HighlightProperties.prototype, "unhighlightedItem", 2);
__decorateClass([
    Property
], HighlightProperties.prototype, "highlightedSeries", 2);
__decorateClass([
    Property
], HighlightProperties.prototype, "unhighlightedSeries", 2);
var SeriesHighlightStyle = class extends BaseProperties {
};
__decorateClass([
    Property
], SeriesHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
    Property
], SeriesHighlightStyle.prototype, "dimOpacity", 2);
__decorateClass([
    Property
], SeriesHighlightStyle.prototype, "enabled", 2);
var TextHighlightStyle = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.color = "black";
    }
};
__decorateClass([
    Property
], TextHighlightStyle.prototype, "color", 2);
var FillGradientDefaults = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.type = "gradient";
        this.colorStops = [];
        this.bounds = "item";
        this.gradient = "linear";
        this.rotation = 0;
        this.reverse = false;
    }
};
__decorateClass([
    Property
], FillGradientDefaults.prototype, "type", 2);
__decorateClass([
    Property
], FillGradientDefaults.prototype, "colorStops", 2);
__decorateClass([
    Property
], FillGradientDefaults.prototype, "bounds", 2);
__decorateClass([
    Property
], FillGradientDefaults.prototype, "gradient", 2);
__decorateClass([
    Property
], FillGradientDefaults.prototype, "rotation", 2);
__decorateClass([
    Property
], FillGradientDefaults.prototype, "reverse", 2);
var FillPatternDefaults = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.type = "pattern";
        this.colorStops = [];
        this.bounds = "item";
        this.gradient = "linear";
        this.rotation = 0;
        this.scale = 1;
        this.reverse = false;
        this.pattern = "forward-slanted-lines";
        this.width = 26;
        this.height = 26;
        this.padding = 6;
        this.fill = "black";
        this.fillOpacity = 1;
        this.backgroundFill = "white";
        this.backgroundFillOpacity = 1;
        this.stroke = "black";
        this.strokeOpacity = 1;
        this.strokeWidth = 0;
    }
};
__decorateClass([
    Property
], FillPatternDefaults.prototype, "type", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "colorStops", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "bounds", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "gradient", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "rotation", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "scale", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "reverse", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "path", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "pattern", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "width", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "height", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "padding", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "fill", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "fillOpacity", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "backgroundFill", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "backgroundFillOpacity", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "stroke", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "strokeOpacity", 2);
__decorateClass([
    Property
], FillPatternDefaults.prototype, "strokeWidth", 2);
var FillImageDefaults = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.type = "image";
        this.url = "";
        this.rotation = 0;
        this.scale = 1;
        this.backgroundFill = "black";
        this.backgroundFillOpacity = 1;
        this.repeat = "no-repeat";
        this.fit = "contain";
    }
};
__decorateClass([
    Property
], FillImageDefaults.prototype, "type", 2);
__decorateClass([
    Property
], FillImageDefaults.prototype, "url", 2);
__decorateClass([
    Property
], FillImageDefaults.prototype, "rotation", 2);
__decorateClass([
    Property
], FillImageDefaults.prototype, "scale", 2);
__decorateClass([
    Property
], FillImageDefaults.prototype, "backgroundFill", 2);
__decorateClass([
    Property
], FillImageDefaults.prototype, "backgroundFillOpacity", 2);
__decorateClass([
    Property
], FillImageDefaults.prototype, "repeat", 2);
__decorateClass([
    Property
], FillImageDefaults.prototype, "fit", 2);
var HighlightStyle = class extends BaseProperties {
    set(properties) {
        if (this.deprecated) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("highlightStyle is deprecated, use highlight instead.");
        }
        return super.set(properties);
    }
    constructor(deprecated = true){
        super();
        this.deprecated = deprecated;
        this.item = new SeriesItemHighlightStyle();
        this.series = new SeriesHighlightStyle();
        this.text = new TextHighlightStyle();
    }
};
__decorateClass([
    Property
], HighlightStyle.prototype, "item", 2);
__decorateClass([
    Property
], HighlightStyle.prototype, "series", 2);
__decorateClass([
    Property
], HighlightStyle.prototype, "text", 2);
var SeriesProperties = class extends BaseProperties {
    handleUnknownProperties(unknownKeys, properties) {
        if ("context" in properties) {
            this.context = properties.context;
            unknownKeys.delete("context");
        }
    }
    constructor(){
        super(...arguments);
        this.visible = true;
        this.focusPriority = Infinity;
        this.showInLegend = true;
        this.cursor = "default";
        this.nodeClickRange = "exact";
        this.highlight = new HighlightProperties();
        this.highlightStyle = new HighlightStyle();
    }
};
__decorateClass([
    Property
], SeriesProperties.prototype, "id", 2);
__decorateClass([
    Property
], SeriesProperties.prototype, "visible", 2);
__decorateClass([
    Property
], SeriesProperties.prototype, "focusPriority", 2);
__decorateClass([
    Property
], SeriesProperties.prototype, "showInLegend", 2);
__decorateClass([
    Property
], SeriesProperties.prototype, "cursor", 2);
__decorateClass([
    Property
], SeriesProperties.prototype, "nodeClickRange", 2);
__decorateClass([
    Property
], SeriesProperties.prototype, "highlight", 2);
__decorateClass([
    Property
], SeriesProperties.prototype, "highlightStyle", 2);
// packages/ag-charts-community/src/chart/series/seriesZIndexMap.ts
var SeriesZIndexMap = /* @__PURE__ */ ((SeriesZIndexMap2)=>{
    SeriesZIndexMap2[SeriesZIndexMap2["BACKGROUND"] = 0] = "BACKGROUND";
    SeriesZIndexMap2[SeriesZIndexMap2["ANY_CONTENT"] = 1] = "ANY_CONTENT";
    return SeriesZIndexMap2;
})(SeriesZIndexMap || {});
var SeriesContentZIndexMap = /* @__PURE__ */ ((SeriesContentZIndexMap2)=>{
    SeriesContentZIndexMap2[SeriesContentZIndexMap2["FOREGROUND"] = 0] = "FOREGROUND";
    SeriesContentZIndexMap2[SeriesContentZIndexMap2["HIGHLIGHT"] = 1] = "HIGHLIGHT";
    SeriesContentZIndexMap2[SeriesContentZIndexMap2["LABEL"] = 2] = "LABEL";
    return SeriesContentZIndexMap2;
})(SeriesContentZIndexMap || {});
// packages/ag-charts-community/src/chart/series/shapeUtil.ts
function getShapeFill(fill, defaultGradient, defaultPattern, defaultImage) {
    if (isGradientFill(fill)) {
        var _fill_gradient, _fill_colorStops, _fill_bounds, _fill_rotation, _fill_reverse;
        return {
            type: "gradient",
            gradient: (_fill_gradient = fill.gradient) !== null && _fill_gradient !== void 0 ? _fill_gradient : defaultGradient.gradient,
            colorStops: (_fill_colorStops = fill.colorStops) !== null && _fill_colorStops !== void 0 ? _fill_colorStops : defaultGradient.colorStops,
            bounds: (_fill_bounds = fill.bounds) !== null && _fill_bounds !== void 0 ? _fill_bounds : defaultGradient.bounds,
            rotation: (_fill_rotation = fill.rotation) !== null && _fill_rotation !== void 0 ? _fill_rotation : defaultGradient.rotation,
            reverse: (_fill_reverse = fill.reverse) !== null && _fill_reverse !== void 0 ? _fill_reverse : defaultGradient.reverse
        };
    }
    if (isPatternFill(fill)) {
        var _fill_pattern;
        const pattern = (_fill_pattern = fill.pattern) !== null && _fill_pattern !== void 0 ? _fill_pattern : defaultPattern.pattern;
        let strokeWidth = fill.strokeWidth;
        if (pattern === "backward-slanted-lines" || pattern === "forward-slanted-lines" || pattern === "horizontal-lines" || pattern === "vertical-lines") {
            strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : strokeWidth = defaultPattern.strokeWidth;
        } else {
            strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : strokeWidth = 0;
        }
        var _fill_width, _ref;
        const width2 = (_ref = (_fill_width = fill.width) !== null && _fill_width !== void 0 ? _fill_width : fill.height) !== null && _ref !== void 0 ? _ref : defaultPattern.width;
        var _fill_height, _ref1;
        const height2 = (_ref1 = (_fill_height = fill.height) !== null && _fill_height !== void 0 ? _fill_height : fill.width) !== null && _ref1 !== void 0 ? _ref1 : defaultPattern.height;
        var _fill_padding, _fill_fill, _fill_fillOpacity, _fill_backgroundFill, _fill_backgroundFillOpacity, _fill_stroke, _fill_strokeOpacity, _fill_rotation1, _fill_scale;
        return {
            type: "pattern",
            pattern,
            width: width2,
            height: height2,
            path: fill.path,
            padding: (_fill_padding = fill.padding) !== null && _fill_padding !== void 0 ? _fill_padding : defaultPattern.padding,
            fill: (_fill_fill = fill.fill) !== null && _fill_fill !== void 0 ? _fill_fill : defaultPattern.fill,
            fillOpacity: (_fill_fillOpacity = fill.fillOpacity) !== null && _fill_fillOpacity !== void 0 ? _fill_fillOpacity : defaultPattern.fillOpacity,
            backgroundFill: (_fill_backgroundFill = fill.backgroundFill) !== null && _fill_backgroundFill !== void 0 ? _fill_backgroundFill : defaultPattern.backgroundFill,
            backgroundFillOpacity: (_fill_backgroundFillOpacity = fill.backgroundFillOpacity) !== null && _fill_backgroundFillOpacity !== void 0 ? _fill_backgroundFillOpacity : defaultPattern.backgroundFillOpacity,
            stroke: (_fill_stroke = fill.stroke) !== null && _fill_stroke !== void 0 ? _fill_stroke : defaultPattern.stroke,
            strokeOpacity: (_fill_strokeOpacity = fill.strokeOpacity) !== null && _fill_strokeOpacity !== void 0 ? _fill_strokeOpacity : defaultPattern.strokeOpacity,
            strokeWidth,
            rotation: (_fill_rotation1 = fill.rotation) !== null && _fill_rotation1 !== void 0 ? _fill_rotation1 : defaultPattern.rotation,
            scale: (_fill_scale = fill.scale) !== null && _fill_scale !== void 0 ? _fill_scale : defaultPattern.scale
        };
    }
    if (isImageFill(fill)) {
        var _fill_backgroundFill1, _fill_backgroundFillOpacity1, _fill_rotation2, _fill_repeat, _fill_fit;
        return {
            type: "image",
            url: fill.url,
            width: fill.width,
            height: fill.height,
            backgroundFill: (_fill_backgroundFill1 = fill.backgroundFill) !== null && _fill_backgroundFill1 !== void 0 ? _fill_backgroundFill1 : defaultImage.backgroundFill,
            backgroundFillOpacity: (_fill_backgroundFillOpacity1 = fill.backgroundFillOpacity) !== null && _fill_backgroundFillOpacity1 !== void 0 ? _fill_backgroundFillOpacity1 : defaultImage.backgroundFillOpacity,
            rotation: (_fill_rotation2 = fill.rotation) !== null && _fill_rotation2 !== void 0 ? _fill_rotation2 : defaultImage.rotation,
            repeat: (_fill_repeat = fill.repeat) !== null && _fill_repeat !== void 0 ? _fill_repeat : defaultImage.repeat,
            fit: (_fill_fit = fill.fit) !== null && _fill_fit !== void 0 ? _fill_fit : defaultImage.fit
        };
    }
    return fill;
}
function getShapeStyle(style, defaultGradient, defaultPattern, defaultImage) {
    if (!isGradientFill(style === null || style === void 0 ? void 0 : style.fill) && !isPatternFill(style === null || style === void 0 ? void 0 : style.fill) && !isImageFill(style === null || style === void 0 ? void 0 : style.fill)) return style;
    return {
        ...style,
        fill: getShapeFill(style.fill, defaultGradient, defaultPattern, defaultImage)
    };
}
function applyShapeFillBBox(shape, fill, fillBBox, fillParams) {
    if (fillBBox == null || !isGradientFill(fill) || fill.bounds == null || fill.bounds === "item") {
        shape.fillBBox = void 0;
    } else {
        shape.fillBBox = fillBBox[fill.bounds];
    }
    shape.fillParams = fillParams;
}
function applyShapeStyle(shape, style, fillBBox, fillParams) {
    var _style_opacity;
    const opacity = (_style_opacity = style === null || style === void 0 ? void 0 : style.opacity) !== null && _style_opacity !== void 0 ? _style_opacity : 1;
    shape.fill = style === null || style === void 0 ? void 0 : style.fill;
    applyShapeFillBBox(shape, shape.fill, fillBBox, fillParams);
    var _style_fillOpacity;
    shape.fillOpacity = ((_style_fillOpacity = style === null || style === void 0 ? void 0 : style.fillOpacity) !== null && _style_fillOpacity !== void 0 ? _style_fillOpacity : 1) * opacity;
    shape.stroke = style === null || style === void 0 ? void 0 : style.stroke;
    var _style_strokeOpacity;
    shape.strokeOpacity = ((_style_strokeOpacity = style === null || style === void 0 ? void 0 : style.strokeOpacity) !== null && _style_strokeOpacity !== void 0 ? _style_strokeOpacity : 1) * opacity;
    var _style_strokeWidth;
    shape.strokeWidth = (_style_strokeWidth = style === null || style === void 0 ? void 0 : style.strokeWidth) !== null && _style_strokeWidth !== void 0 ? _style_strokeWidth : 0;
    shape.lineDash = style === null || style === void 0 ? void 0 : style.lineDash;
    var _style_lineDashOffset;
    shape.lineDashOffset = (_style_lineDashOffset = style === null || style === void 0 ? void 0 : style.lineDashOffset) !== null && _style_lineDashOffset !== void 0 ? _style_lineDashOffset : 0;
}
// packages/ag-charts-community/src/chart/series/series.ts
var SeriesNodePickMode = /* @__PURE__ */ ((SeriesNodePickMode2)=>{
    SeriesNodePickMode2[SeriesNodePickMode2["EXACT_SHAPE_MATCH"] = 0] = "EXACT_SHAPE_MATCH";
    SeriesNodePickMode2[SeriesNodePickMode2["NEAREST_NODE"] = 1] = "NEAREST_NODE";
    SeriesNodePickMode2[SeriesNodePickMode2["AXIS_ALIGNED"] = 2] = "AXIS_ALIGNED";
    return SeriesNodePickMode2;
})(SeriesNodePickMode || {});
var CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR = 0.25;
var CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR = 0.125;
var SeriesNodeEvent = class {
    preventDefault() {
        this.defaultPrevented = true;
    }
    constructor(type, event, nodeDatum, series){
        this.type = type;
        this.event = event;
        this.defaultPrevented = false;
        this.datum = nodeDatum.datum;
        this.seriesId = series.id;
    }
};
var SeriesGroupingChangedEvent = class {
    constructor(series, seriesGrouping){
        this.series = series;
        this.seriesGrouping = seriesGrouping;
        this.type = "groupingChanged";
    }
};
function propertyAxisDirection(property) {
    switch(property){
        case "x":
            return "x" /* X */ ;
        case "y":
            return "y" /* Y */ ;
        case "angle":
            return "angle" /* Angle */ ;
        case "radius":
            return "radius" /* Radius */ ;
    }
}
function axisDirectionProperty(direction) {
    switch(direction){
        case "x" /* X */ :
            return "x";
        case "y" /* Y */ :
            return "y";
        case "angle" /* Angle */ :
            return "angle";
        case "radius" /* Radius */ :
            return "radius";
    }
}
var _point_size, _ref;
var Series = class extends Observable {
    get pickModeAxis() {
        return "main";
    }
    get id() {
        var _this_properties;
        var _this_properties_id;
        return (_this_properties_id = (_this_properties = this.properties) === null || _this_properties === void 0 ? void 0 : _this_properties.id) !== null && _this_properties_id !== void 0 ? _this_properties_id : this.internalId;
    }
    get type() {
        var _this_constructor_type;
        return (_this_constructor_type = this.constructor.type) !== null && _this_constructor_type !== void 0 ? _this_constructor_type : "";
    }
    get focusable() {
        return true;
    }
    get data() {
        var _this__data;
        return (_this__data = this._data) !== null && _this__data !== void 0 ? _this__data : this._chartData;
    }
    set visible(newVisibility) {
        this.properties.visible = newVisibility;
        this.ctx.legendManager.toggleItem(newVisibility, this.id);
        this.ctx.legendManager.update();
        this.visibleMaybeChanged();
    }
    get visible() {
        var _this_ctx_legendManager_getSeriesEnabled;
        return (_this_ctx_legendManager_getSeriesEnabled = this.ctx.legendManager.getSeriesEnabled(this.id)) !== null && _this_ctx_legendManager_getSeriesEnabled !== void 0 ? _this_ctx_legendManager_getSeriesEnabled : this.properties.visible;
    }
    get hasData() {
        return this.data != null && this.data.length > 0;
    }
    get tooltipEnabled() {
        var _this_properties_tooltip;
        return (_this_properties_tooltip = this.properties.tooltip) === null || _this_properties_tooltip === void 0 ? void 0 : _this_properties_tooltip.enabled;
    }
    onDataChange() {
        this.nodeDataRefresh = true;
        this._pickNodeCache.clear();
    }
    setOptionsData(input) {
        this._data = input;
        this.onDataChange();
    }
    setChartData(input) {
        this._chartData = input;
        if (this.data === input) {
            this.onDataChange();
        }
    }
    onSeriesGroupingChange(prev, next) {
        const { internalId, type, visible } = this;
        if (prev) {
            this.ctx.seriesStateManager.deregisterSeries(this);
        }
        if (next) {
            this.ctx.seriesStateManager.registerSeries({
                internalId,
                type,
                visible,
                seriesGrouping: next
            });
        }
        this.fireEvent(new SeriesGroupingChangedEvent(this, next));
    }
    getBandScalePadding() {
        return {
            inner: 1,
            outer: 0
        };
    }
    attachSeries(seriesContentNode, seriesNode, annotationNode) {
        seriesContentNode.appendChild(this.contentGroup);
        seriesNode.appendChild(this.highlightGroup);
        seriesNode.appendChild(this.labelGroup);
        annotationNode === null || annotationNode === void 0 ? void 0 : annotationNode.appendChild(this.annotationGroup);
    }
    detachSeries(seriesContentNode, seriesNode, annotationNode) {
        seriesContentNode === null || seriesContentNode === void 0 ? void 0 : seriesContentNode.removeChild(this.contentGroup);
        seriesNode.removeChild(this.highlightGroup);
        seriesNode.removeChild(this.labelGroup);
        annotationNode === null || annotationNode === void 0 ? void 0 : annotationNode.removeChild(this.annotationGroup);
    }
    setSeriesIndex(index) {
        let forceUpdate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        const bringToFront = this.bringToFront();
        if (!forceUpdate && index === this.declarationOrder && bringToFront === this._broughtToFront) return false;
        this.declarationOrder = index;
        this._broughtToFront = bringToFront;
        this.setZIndex(bringToFront ? Number.MAX_VALUE : index);
        this.fireEvent(new SeriesGroupingChangedEvent(this, this.seriesGrouping));
        return true;
    }
    setZIndex(zIndex) {
        this.contentGroup.zIndex = [
            1 /* ANY_CONTENT */ ,
            zIndex,
            0 /* FOREGROUND */ 
        ];
        this.highlightGroup.zIndex = [
            1 /* ANY_CONTENT */ ,
            zIndex,
            1 /* HIGHLIGHT */ 
        ];
        this.labelGroup.zIndex = [
            1 /* ANY_CONTENT */ ,
            zIndex,
            2 /* LABEL */ 
        ];
        this.annotationGroup.zIndex = zIndex;
    }
    renderToOffscreenCanvas() {
        return false;
    }
    addEventListener(type, listener) {
        return super.addEventListener(type, listener);
    }
    removeEventListener(type, listener) {
        return super.removeEventListener(type, listener);
    }
    hasEventListener(type) {
        return super.hasEventListener(type);
    }
    addChartEventListeners() {
        return;
    }
    updatedDomains() {}
    destroy() {
        this.cleanup.flush();
        this.resetDatumCallbackCache();
        this.ctx.seriesStateManager.deregisterSeries(this);
    }
    getPropertyValues(property, properties) {
        const direction = propertyAxisDirection(property);
        const resolvedProperty = direction != null ? axisDirectionProperty(this.resolveKeyDirection(direction)) : property;
        const keys = properties === null || properties === void 0 ? void 0 : properties[resolvedProperty];
        const values = [];
        if (!keys) {
            return values;
        }
        const addValues = function() {
            for(var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++){
                items[_key] = arguments[_key];
            }
            for (const value of items){
                if (Array.isArray(value)) {
                    addValues(...value);
                } else if (typeof value === "object") {
                    addValues(...Object.values(value));
                } else {
                    values.push(value);
                }
            }
        };
        addValues(...keys.map((key)=>this.properties[key]));
        return values;
    }
    getKeys(direction) {
        return this.getPropertyValues(axisDirectionProperty(direction), this.propertyKeys);
    }
    getKeyProperties(direction) {
        var _this_propertyKeys_this_resolveKeyDirection;
        return (_this_propertyKeys_this_resolveKeyDirection = this.propertyKeys[this.resolveKeyDirection(direction)]) !== null && _this_propertyKeys_this_resolveKeyDirection !== void 0 ? _this_propertyKeys_this_resolveKeyDirection : [];
    }
    getNames(direction) {
        return this.getPropertyValues(axisDirectionProperty(direction), this.propertyNames);
    }
    getFormatterContext(property) {
        const { id: seriesId } = this;
        const keys = this.getPropertyValues(property, this.propertyKeys);
        const names = this.getPropertyValues(property, this.propertyNames);
        const out = [];
        for(let idx = 0; idx < keys.length; idx++){
            out.push({
                seriesId,
                key: keys[idx],
                name: names[idx]
            });
        }
        return out;
    }
    resolveKeyDirection(direction) {
        return direction;
    }
    // The union of the series domain ('community') and series-option domains ('enterprise').
    getDomain(direction) {
        const seriesDomain = this.getSeriesDomain(direction);
        const moduleDomains = this.moduleMap.mapModules((module)=>module.getDomain(direction)).flat();
        return moduleDomains.length !== 0 ? seriesDomain.concat(moduleDomains) : seriesDomain;
    }
    getRange(direction, visibleRange) {
        return this.getSeriesRange(direction, visibleRange);
    }
    getVisibleItems(_xVisibleRange, _yVisibleRange, _minVisibleItems) {
        return Infinity;
    }
    // Indicate that something external changed and we should recalculate nodeData.
    markNodeDataDirty() {
        this.nodeDataRefresh = true;
        this._pickNodeCache.clear();
        this.visibleMaybeChanged();
    }
    visibleMaybeChanged() {
        this.ctx.seriesStateManager.updateSeries(this);
    }
    getOpacity() {
        const defaultOpacity = 1;
        if (!this.properties.highlight) {
            return defaultOpacity;
        }
        const { opacity = defaultOpacity } = this.getHighlightStyle();
        return opacity;
    }
    getHighlightState(datum, isHighlight, datumIndex, legendItemValues) {
        if (isHighlight) {
            return 1 /* Item */ ;
        }
        if ((datum === null || datum === void 0 ? void 0 : datum.series) == null) {
            return 0 /* None */ ;
        }
        if (this.isSeriesHighlighted(datum, legendItemValues)) {
            const itemHighlighted = this.isItemHighlighted(datum, datumIndex);
            if (itemHighlighted == null) {
                return 2 /* Series */ ;
            }
            if (itemHighlighted) {
                return 2 /* Series */ ;
            }
            return 4 /* OtherItem */ ;
        }
        return 3 /* OtherSeries */ ;
    }
    getHighlightStateString(datum, isHighlight, datumIndex, legendItemValues) {
        const state = this.getHighlightState(datum, isHighlight, datumIndex, legendItemValues);
        switch(state){
            case 1 /* Item */ :
                return "highlighted-item";
            case 4 /* OtherItem */ :
                return "unhighlighted-item";
            case 2 /* Series */ :
                return "highlighted-series";
            case 3 /* OtherSeries */ :
                return "unhighlighted-series";
            case 0 /* None */ :
            default:
                return "none";
        }
    }
    onChangeHighlight(event) {
        const previousHighlightedDatum = event.previousHighlight;
        const currentHighlightedDatum = event.currentHighlight;
        const currentHighlightState = this.getHighlightState(currentHighlightedDatum);
        const previousHighlightState = this.getHighlightState(previousHighlightedDatum);
        this.setSeriesIndex(this.declarationOrder);
        if (currentHighlightState === previousHighlightState) {
            this.hasChangesOnHighlight = false;
            return;
        }
        const { highlightedSeries, unhighlightedItem, unhighlightedSeries } = this.properties.highlight;
        const hasItemStylers = this.hasItemStylers();
        this.hasChangesOnHighlight = hasItemStylers || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyObject"])(highlightedSeries) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyObject"])(unhighlightedItem) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyObject"])(unhighlightedSeries);
    }
    bringToFront() {
        return this.properties.highlight.bringToFront && this.isSeriesHighlighted(this.ctx.highlightManager.getActiveHighlight());
    }
    isSeriesHighlighted(highlightedDatum, _legendItemValues) {
        return (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this;
    }
    isItemHighlighted(highlightedDatum, datumIndex) {
        if ((highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.datumIndex) == null || datumIndex == null) return;
        return highlightedDatum.datumIndex === datumIndex;
    }
    getHighlightStyle(isHighlight, datumIndex, legendItemValues) {
        var _this_ctx_highlightManager;
        const highlightedDatum = (_this_ctx_highlightManager = this.ctx.highlightManager) === null || _this_ctx_highlightManager === void 0 ? void 0 : _this_ctx_highlightManager.getActiveHighlight();
        const highlightState = this.getHighlightState(highlightedDatum, isHighlight, datumIndex, legendItemValues);
        return this.properties.highlight.getStyle(highlightState);
    }
    getModuleTooltipParams() {
        return this.moduleMap.mapModules((module)=>module.getTooltipParams()).reduce((total, current)=>Object.assign(total, current), {});
    }
    pickNodes(point, intent) {
        let exactMatchOnly = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        const { pickModes, pickModeAxis, visible, contentGroup } = this;
        if (!visible || !contentGroup.visible) return;
        if (intent === "highlight" && !this.properties.highlight.enabled) return;
        if (intent === "highlight-tooltip" && !this.properties.highlight.enabled) return;
        let maxDistance = Infinity;
        if (intent === "tooltip" || intent === "highlight-tooltip") {
            const { tooltip } = this.properties;
            maxDistance = typeof tooltip.range === "number" ? tooltip.range : Infinity;
            exactMatchOnly || (exactMatchOnly = tooltip.range === "exact");
        } else if (intent === "event" || intent === "context-menu") {
            const { nodeClickRange } = this.properties;
            maxDistance = typeof nodeClickRange === "number" ? nodeClickRange : Infinity;
            exactMatchOnly || (exactMatchOnly = nodeClickRange === "exact");
        }
        const selectedPickModes = pickModes.filter((m)=>!exactMatchOnly || m === 0 /* EXACT_SHAPE_MATCH */ );
        const { x, y } = point;
        const key = JSON.stringify({
            x,
            y,
            maxDistance,
            selectedPickModes
        });
        if (this._pickNodeCache.has(key)) {
            return this._pickNodeCache.get(key);
        }
        for (const pickMode of selectedPickModes){
            let result;
            switch(pickMode){
                case 0 /* EXACT_SHAPE_MATCH */ :
                    {
                        const exact = this.pickNodesExactShape(point);
                        result = exact.length === 0 ? void 0 : {
                            datums: exact,
                            distance: 0
                        };
                        break;
                    }
                case 1 /* NEAREST_NODE */ :
                    {
                        const closest = this.pickNodeClosestDatum(point);
                        const exact = (closest === null || closest === void 0 ? void 0 : closest.distance) === 0 ? this.pickNodesExactShape(point) : void 0;
                        if (exact != null && exact.length !== 0) {
                            result = {
                                datums: exact,
                                distance: 0
                            };
                        } else if (closest) {
                            result = {
                                datums: [
                                    closest.datum
                                ],
                                distance: closest.distance
                            };
                        } else {
                            result = void 0;
                        }
                        break;
                    }
                case 2 /* AXIS_ALIGNED */ :
                    {
                        const closest = pickModeAxis != null ? this.pickNodeMainAxisFirst(point, pickModeAxis === "main-category") : void 0;
                        result = closest != null ? {
                            datums: [
                                closest.datum
                            ],
                            distance: closest.distance
                        } : void 0;
                        break;
                    }
            }
            if (result && result.distance <= maxDistance) {
                return this._pickNodeCache.set(key, {
                    pickMode,
                    datums: result.datums,
                    distance: result.distance
                });
            }
        }
        return this._pickNodeCache.set(key, void 0);
    }
    pickNodesExactShape(point) {
        const datums = [];
        for (const node of this.contentGroup.pickNodes(point.x, point.y)){
            const datum = node.closestDatum();
            if (datum != null && datum.missing !== true) {
                datums.push(datum);
            }
        }
        return datums;
    }
    pickNodeClosestDatum(_point) {
        throw new Error("AG Charts - Series.pickNodeClosestDatum() not implemented");
    }
    pickNodeNearestDistantObject(point, items) {
        var _match_nearest;
        const match = nearestSquared(point.x, point.y, items);
        const datum = (_match_nearest = match.nearest) === null || _match_nearest === void 0 ? void 0 : _match_nearest.closestDatum();
        if (datum != null && datum.missing !== true) {
            return {
                datum,
                distance: Math.sqrt(match.distanceSquared)
            };
        }
    }
    pickNodeMainAxisFirst(_point, _requireCategoryAxis) {
        throw new Error("AG Charts - Series.pickNodeMainAxisFirst() not implemented");
    }
    getLabelData() {
        return [];
    }
    updatePlacedLabelData(_labels) {
        return;
    }
    fireEvent(event) {
        callWithContext([
            this.properties,
            this.ctx.chartService
        ], this.fireEventWrapper, event);
    }
    fireNodeClickEvent(event, datum) {
        const clickEvent = new this.NodeEvent("seriesNodeClick", event, datum, this);
        this.fireEvent(clickEvent);
        return !clickEvent.defaultPrevented;
    }
    fireNodeDoubleClickEvent(event, datum) {
        const clickEvent = new this.NodeEvent("seriesNodeDoubleClick", event, datum, this);
        this.fireEvent(clickEvent);
        return !clickEvent.defaultPrevented;
    }
    createNodeContextMenuActionEvent(event, datum) {
        return new this.NodeEvent("nodeContextMenuAction", event, datum, this);
    }
    onLegendInitialState(legendType, initialState) {
        const { visible = true, itemId, legendItemName } = initialState !== null && initialState !== void 0 ? initialState : {};
        this.toggleSeriesItem(visible, legendType, itemId, legendItemName);
    }
    onLegendItemClick(event) {
        const { enabled, itemId, series, legendType } = event;
        const legendItemName = "legendItemName" in this.properties ? this.properties.legendItemName : void 0;
        const legendItemKey = "legendItemKey" in this.properties ? this.properties.legendItemKey : void 0;
        const matchedLegendItemName = legendItemName != void 0 && legendItemName === event.legendItemName;
        if (series.id === this.id || matchedLegendItemName || legendItemKey != void 0) {
            this.toggleSeriesItem(enabled, legendType, itemId, legendItemName, event);
        }
    }
    onLegendItemDoubleClick(event) {
        const { enabled, itemId, series, numVisibleItems, legendType } = event;
        const legendItemName = "legendItemName" in this.properties ? this.properties.legendItemName : void 0;
        const legendItemKey = "legendItemKey" in this.properties ? this.properties.legendItemKey : void 0;
        const matchedLegendItemName = legendItemName != void 0 && legendItemName === event.legendItemName;
        if (series.id === this.id || matchedLegendItemName || legendItemKey != void 0) {
            this.toggleSeriesItem(true, legendType, itemId, legendItemName, event);
        } else if (enabled && numVisibleItems === 1) {
            this.toggleSeriesItem(true, legendType, void 0, legendItemName);
        } else {
            this.toggleSeriesItem(false, legendType, void 0, legendItemName);
        }
    }
    toggleSeriesItem(enabled, legendType, itemId, legendItemName, legendEvent) {
        const seriesId = this.id;
        if (enabled || legendType !== "category") {
            this.visible = enabled;
        }
        this.nodeDataRefresh = true;
        this._pickNodeCache.clear();
        var _legendEvent_legendItemName;
        const event = {
            type: "seriesVisibilityChange",
            seriesId,
            itemId,
            legendItemName: (_legendEvent_legendItemName = legendEvent === null || legendEvent === void 0 ? void 0 : legendEvent.legendItemName) !== null && _legendEvent_legendItemName !== void 0 ? _legendEvent_legendItemName : legendItemName,
            visible: enabled
        };
        this.fireEvent(event);
        this.ctx.legendManager.toggleItem(enabled, seriesId, itemId, legendItemName);
    }
    isEnabled() {
        return this.visible;
    }
    getModuleMap() {
        return this.moduleMap;
    }
    createModuleContext() {
        return {
            ...this.ctx,
            series: this
        };
    }
    getAxisValueText(axis, source, value, datum, key, legendItemName) {
        const { id: seriesId, properties } = this;
        return axis.formatDatum(properties, value, source, seriesId, legendItemName, datum, key);
    }
    getLabelText(value, datum, key, property, domain, label, baseParams) {
        if (value == null) return "";
        const { axes, canHaveAxes, ctx, id: seriesId, properties } = this;
        const source = "series-label";
        const legendItemName = "legendItemName" in properties ? properties.legendItemName : void 0;
        const params = {
            seriesId: this.id,
            ...baseParams
        };
        const direction = canHaveAxes ? propertyAxisDirection(property) : void 0;
        const axis = direction != null ? axes[this.resolveKeyDirection(direction)] : void 0;
        if (axis != null) {
            return axis.formatDatum(properties, value, source, seriesId, legendItemName, datum, key, domain, label, params);
        }
        const { formatManager } = ctx;
        const formatInContext = this.callWithContext.bind(this);
        const format = (formatParams)=>{
            var _label_formatValue, _ref;
            return (_ref = (_label_formatValue = label.formatValue(formatInContext, formatParams.type, formatParams.value, params)) !== null && _label_formatValue !== void 0 ? _label_formatValue : formatManager.format(formatInContext, formatParams)) !== null && _ref !== void 0 ? _ref : String(value);
        };
        const boundSeries = this.getFormatterContext(property);
        switch(property){
            case "y":
            case "color":
            case "size":
                {
                    const fractionDigits = void 0;
                    return format({
                        type: "number",
                        value,
                        datum,
                        seriesId,
                        legendItemName,
                        key,
                        source,
                        property,
                        domain,
                        boundSeries,
                        fractionDigits
                    });
                }
            case "x":
            case "radius":
            case "angle":
            case "label":
            case "secondaryLabel":
            case "calloutLabel":
            case "sectorLabel":
            case "legendItem":
                return format({
                    type: "category",
                    value,
                    datum,
                    seriesId,
                    legendItemName,
                    key,
                    source,
                    property,
                    domain,
                    boundSeries
                });
        }
    }
    getMarkerStyle(marker, param, params) {
        let { datumIndex, datum, point } = param, isHighlight = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, defaultOverrideStyle = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
            size: (_ref = (_point_size = point === null || point === void 0 ? void 0 : point.size) !== null && _point_size !== void 0 ? _point_size : marker.size) !== null && _ref !== void 0 ? _ref : 0
        }, inheritedStyle = arguments.length > 5 ? arguments[5] : void 0, checkForHighlight = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : true;
        const { itemStyler, fillGradientDefaults: fillGradientDefaults2, fillPatternDefaults: fillPatternDefaults2, fillImageDefaults: fillImageDefaults2 } = marker;
        const highlightStyle = checkForHighlight ? this.getHighlightStyle(isHighlight, datumIndex) : void 0;
        const baseStyle = mergeDefaults(highlightStyle, defaultOverrideStyle, marker.getStyle(), inheritedStyle);
        let markerStyle = getShapeStyle(baseStyle, fillGradientDefaults2, fillPatternDefaults2, fillImageDefaults2);
        if (itemStyler && params) {
            var _this_ctx_highlightManager;
            const highlight5 = (_this_ctx_highlightManager = this.ctx.highlightManager) === null || _this_ctx_highlightManager === void 0 ? void 0 : _this_ctx_highlightManager.getActiveHighlight();
            const highlightState = this.getHighlightStateString(highlight5, isHighlight, datumIndex);
            const style = this.cachedCallWithContext(itemStyler, {
                seriesId: this.id,
                ...markerStyle,
                ...params,
                highlighted: isHighlight,
                highlightState,
                datum
            });
            markerStyle = getShapeStyle(mergeDefaults(style, markerStyle), fillGradientDefaults2, fillPatternDefaults2, fillImageDefaults2);
        }
        return markerStyle;
    }
    applyMarkerStyle(style, markerNode, point, fillBBox) {
        let { applyTranslation = true, selected = true } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
        const { shape, size = 0 } = style;
        const visible = this.visible && size > 0 && point && !isNaN(point.x) && !isNaN(point.y);
        applyShapeStyle(markerNode, style, fillBBox);
        if (applyTranslation) {
            markerNode.setProperties({
                visible,
                shape,
                size,
                x: point === null || point === void 0 ? void 0 : point.x,
                y: point === null || point === void 0 ? void 0 : point.y,
                scalingCenterX: point === null || point === void 0 ? void 0 : point.x,
                scalingCenterY: point === null || point === void 0 ? void 0 : point.y
            });
        } else {
            markerNode.setProperties({
                visible,
                shape,
                size
            });
        }
        if (!selected) {
            markerNode.fillOpacity *= CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR;
            markerNode.strokeOpacity *= CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR;
        }
        if (typeof shape === "function" && !markerNode.dirtyPath) {
            markerNode.path.clear(true);
            markerNode.updatePath();
            markerNode.checkPathDirty();
            const bb = markerNode.getBBox();
            if (point != null && bb.isFinite()) {
                const center2 = bb.computeCenter();
                const [dx, dy] = [
                    "x",
                    "y"
                ].map((key)=>{
                    var _style_strokeWidth;
                    return ((_style_strokeWidth = style.strokeWidth) !== null && _style_strokeWidth !== void 0 ? _style_strokeWidth : 0) + Math.abs(center2[key] - point[key]);
                });
                point.focusSize = Math.max(bb.width + dx, bb.height + dy);
            }
        }
    }
    get nodeDataDependencies() {
        var _this__nodeDataDependencies;
        return (_this__nodeDataDependencies = this._nodeDataDependencies) !== null && _this__nodeDataDependencies !== void 0 ? _this__nodeDataDependencies : {
            seriesRectWidth: NaN,
            seriesRectHeight: NaN
        };
    }
    checkResize(newSeriesRect) {
        const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect !== null && newSeriesRect !== void 0 ? newSeriesRect : {
            width: NaN,
            height: NaN
        };
        const newNodeDataDependencies = newSeriesRect ? {
            seriesRectWidth,
            seriesRectHeight
        } : void 0;
        const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
        if (resize) {
            this._nodeDataDependencies = newNodeDataDependencies;
            this.markNodeDataDirty();
        }
        return resize;
    }
    pickFocus(_opts) {
        return void 0;
    }
    resetDatumCallbackCache() {
        this.datumCallbackCache.clear();
    }
    cachedDatumCallback(id, fn) {
        const { datumCallbackCache } = this;
        const existing = datumCallbackCache.get(id);
        if (existing != null) return existing;
        try {
            const value = fn();
            datumCallbackCache.set(id, value);
            return value;
        } catch (error) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].error(String(error));
        }
    }
    cachedCallWithContext(fn) {
        for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            params[_key - 1] = arguments[_key];
        }
        return this.ctx.callbackCache.call([
            this.properties,
            this.ctx.chartService
        ], fn, ...params);
    }
    callWithContext(fn) {
        for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            params[_key - 1] = arguments[_key];
        }
        return callWithContext([
            this.properties,
            this.ctx.chartService
        ], fn, ...params);
    }
    formatTooltipWithContext(tooltip, content, params) {
        return tooltip.formatTooltip([
            this.properties,
            this.ctx.chartService
        ], content, params);
    }
    // @todo(AG-13777) - Remove this function (see CartesianSeries.ts)
    minTimeInterval() {
        return;
    }
    constructor(seriesOpts){
        var _this_ctx;
        super();
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.usesPlacedLabels = false;
        this.hasChangesOnHighlight = false;
        this.seriesGrouping = void 0;
        this.NodeEvent = SeriesNodeEvent;
        this.internalId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createId"])(this);
        // The group node that contains the series rendering in its default (non-highlighted) state.
        this.contentGroup = new TranslatableGroup({
            name: "".concat(this.internalId, "-content"),
            zIndex: 1 /* ANY_CONTENT */ 
        });
        // The group node that contains all highlighted series items. This is a performance optimisation
        // for large-scale data-sets, where the only thing that routinely varies is the currently
        // highlighted node.
        this.highlightGroup = new TranslatableGroup({
            name: "".concat(this.internalId, "-highlight"),
            zIndex: 1 /* ANY_CONTENT */ 
        });
        // Error bars etc.
        this.annotationGroup = new TranslatableGroup({
            name: "".concat(this.internalId, "-annotation")
        });
        // Lazily initialised labelGroup for label presentation.
        this.labelGroup = new TranslatableGroup({
            name: "".concat(this.internalId, "-series-labels")
        });
        this.axes = {};
        this.directions = [
            "x" /* X */ ,
            "y" /* Y */ 
        ];
        // Flag to determine if we should recalculate node data.
        this.nodeDataRefresh = true;
        this.moduleMap = new ModuleMap();
        this.datumCallbackCache = /* @__PURE__ */ new Map();
        this.connectsToYAxis = false;
        this.declarationOrder = -1;
        this._broughtToFront = false;
        this.events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventEmitter"]();
        this._pickNodeCache = new LRUCache();
        // Use a wrapper to comply with the @typescript-eslint/unbound-method rule.
        this.fireEventWrapper = (event)=>super.fireEvent(event);
        const { moduleCtx, pickModes, propertyKeys = {}, propertyNames = {}, canHaveAxes = false, usesPlacedLabels = false } = seriesOpts;
        this.ctx = moduleCtx;
        this.propertyKeys = propertyKeys;
        this.propertyNames = propertyNames;
        this.canHaveAxes = canHaveAxes;
        this.usesPlacedLabels = usesPlacedLabels;
        this.pickModes = pickModes;
        this.cleanup.register((_this_ctx = this.ctx) === null || _this_ctx === void 0 ? void 0 : _this_ctx.eventsHub.on("highlight:change", (event)=>this.onChangeHighlight(event)));
    }
};
__decorateClass([
    ActionOnSet({
        changeValue: function(newVal, oldVal) {
            this.onSeriesGroupingChange(oldVal, newVal);
        }
    })
], Series.prototype, "seriesGrouping", 2);
;
;
var FocusIndicator = class {
    clear() {}
    update(focus, rect, clip) {
        if (rect == null) return;
        if (focus instanceof Path) {
            const transform = (localX, localY)=>{
                let { x, y } = Transformable.toCanvasPoint(focus, localX, localY);
                var _rect_x;
                x -= (_rect_x = rect.x) !== null && _rect_x !== void 0 ? _rect_x : 0;
                var _rect_y;
                y -= (_rect_y = rect.y) !== null && _rect_y !== void 0 ? _rect_y : 0;
                return {
                    x,
                    y
                };
            };
            const d = focus.svgPathData(transform);
            this.outerPath.setAttribute("d", d);
            this.innerPath.setAttribute("d", d);
            this.show(this.svg);
        } else {
            let bbox;
            if (clip) {
                const x0 = Math.max(focus.x - rect.x, 0);
                const y0 = Math.max(focus.y - rect.y, 0);
                const x1 = Math.min(focus.x + focus.width - rect.x, rect.width);
                const y1 = Math.min(focus.y + focus.height - rect.y, rect.height);
                bbox = new BBox(x0, y0, x1 - x0, y1 - y0);
            } else {
                bbox = new BBox(focus.x - rect.x, focus.y - rect.y, focus.width, focus.height);
            }
            setElementBBox(this.div, bbox);
            this.show(this.div);
        }
    }
    onSwap(newParent) {
        if (newParent === this.element.parentElement) return;
        this.element.remove();
        newParent.appendChild(this.element);
        this.overrideFocusVisible(this.focusVisible);
    }
    show(child) {
        this.hasBeenActivated = true;
        this.element.innerHTML = "";
        this.element.append(child);
    }
    overrideFocusVisible(focusVisible) {
        this.focusVisible = focusVisible;
        const opacity = {
            true: "1",
            false: "0",
            undefined: ""
        };
        const parent = this.element.parentElement;
        parent === null || parent === void 0 ? void 0 : parent.style.setProperty("opacity", opacity["".concat(focusVisible)]);
    }
    // Get the `:focus-visible` CSS state.
    isFocusVisible() {
        let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (!force && !this.hasBeenActivated) return false;
        const parent = this.element.parentElement;
        return parent != null && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])().getComputedStyle(parent).opacity === "1";
    }
    constructor(swapChain){
        this.swapChain = swapChain;
        this.hasBeenActivated = false;
        this.div = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div");
        this.svg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("svg");
        this.outerPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("path");
        this.innerPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSvgElement"])("path");
        this.svg.append(this.outerPath);
        this.svg.append(this.innerPath);
        this.outerPath.classList.add("ag-charts-focus-svg-outer-path");
        this.innerPath.classList.add("ag-charts-focus-svg-inner-path");
        this.element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div", "ag-charts-focus-indicator");
        this.element.ariaHidden = "true";
        this.element.append(this.svg);
        this.swapChain.addListener("swap", (parent)=>this.onSwap(parent));
    }
};
;
var FocusSwapChain = class {
    createAnnouncer(role) {
        const announcer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div");
        announcer.role = role;
        announcer.className = "ag-charts-swapchain";
        announcer.addEventListener("blur", this.onBlur);
        announcer.addEventListener("focus", this.onFocus);
        return announcer;
    }
    destroy() {
        for (const announcer of [
            this.activeAnnouncer,
            this.inactiveAnnouncer
        ]){
            announcer.removeEventListener("blur", this.onBlur);
            announcer.removeEventListener("focus", this.onFocus);
            announcer.remove();
        }
    }
    focus(opts) {
        this.focusOptions = opts;
        this.activeAnnouncer.focus(opts);
        this.focusOptions = void 0;
    }
    update(newLabel) {
        this.skipDispatch = true;
        this.swap(newLabel);
        if (this.hasFocus) {
            this.activeAnnouncer.focus(this.focusOptions);
        }
        this.skipDispatch = false;
    }
    addListener(type, handler) {
        this.listeners[type].push(handler);
        if (type === "swap") {
            const swapHandler = handler;
            swapHandler(this.activeAnnouncer);
        }
    }
    dispatch(type, param) {
        if (type === "focus") this.hasFocus = true;
        else if (type === "blur") this.hasFocus = false;
        this.listeners[type].forEach((fn)=>fn(param));
    }
    swap(newLabel) {
        const userTabIndex = this.activeAnnouncer.tabIndex;
        this.label2.textContent = newLabel;
        [this.inactiveAnnouncer, this.activeAnnouncer] = [
            this.activeAnnouncer,
            this.inactiveAnnouncer
        ];
        [this.label1, this.label2] = [
            this.label2,
            this.label1
        ];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttributes"])(this.inactiveAnnouncer, {
            "aria-labelledby": this.label1.id,
            "aria-hidden": true,
            tabindex: void 0
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttributes"])(this.activeAnnouncer, {
            "aria-labelledby": this.label1.id,
            "aria-hidden": false,
            tabindex: userTabIndex
        });
        this.dispatch("swap", this.activeAnnouncer);
    }
    constructor(label1, label2, announcerRole, initialAltText){
        this.label1 = label1;
        this.label2 = label2;
        this.hasFocus = false;
        this.skipDispatch = false;
        this.listeners = {
            blur: [],
            focus: [],
            swap: []
        };
        this.onBlur = (e)=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setElementStyle"])(e.target, "pointer-events", void 0);
            return !this.skipDispatch && this.dispatch("blur", e);
        };
        this.onFocus = (e)=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setElementStyle"])(e.target, "pointer-events", "auto");
            return !this.skipDispatch && this.dispatch("focus", e);
        };
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.label1, "id", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementId"])());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.label2, "id", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementId"])());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setElementStyle"])(this.label1, "display", "none");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setElementStyle"])(this.label2, "display", "none");
        this.label1.textContent = initialAltText;
        this.label2.textContent = initialAltText;
        this.activeAnnouncer = this.createAnnouncer(announcerRole);
        this.inactiveAnnouncer = this.createAnnouncer(announcerRole);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.activeAnnouncer, "tabindex", 0);
        this.label2.insertAdjacentElement("afterend", this.activeAnnouncer);
        this.label2.insertAdjacentElement("afterend", this.inactiveAnnouncer);
        this.swap(initialAltText);
    }
};
;
var KEY_BINDINGS = {
    arrowdown: {
        bindings: [
            {
                code: "ArrowDown"
            }
        ]
    },
    arrowleft: {
        bindings: [
            {
                code: "ArrowLeft"
            }
        ]
    },
    arrowright: {
        bindings: [
            {
                code: "ArrowRight"
            }
        ]
    },
    arrowup: {
        bindings: [
            {
                code: "ArrowUp"
            }
        ]
    },
    delete: {
        bindings: [
            {
                key: "Backspace"
            },
            {
                key: "Delete"
            }
        ],
        activatesFocusIndicator: false
    },
    redo: {
        bindings: [
            {
                key: "y",
                ctrlOrMeta: true
            },
            {
                key: "z",
                ctrlOrMeta: true,
                shift: true
            }
        ],
        activatesFocusIndicator: false
    },
    undo: {
        bindings: [
            {
                key: "z",
                ctrlOrMeta: true
            }
        ],
        activatesFocusIndicator: false
    },
    submit: {
        bindings: [
            {
                key: "Enter"
            },
            {
                code: "Enter"
            },
            {
                code: "Space"
            }
        ]
    },
    zoomin: {
        bindings: [
            {
                key: "+"
            },
            {
                code: "ZoomIn"
            },
            {
                code: "Add"
            }
        ],
        activatesFocusIndicator: false
    },
    zoomout: {
        bindings: [
            {
                key: "-"
            },
            {
                code: "ZoomOut"
            },
            {
                code: "Substract"
            }
        ],
        activatesFocusIndicator: false
    }
};
function matchesKeyBinding(e, bindings) {
    for (const kb of bindings){
        if ("code" in kb) {
            if (kb.code === e.code) return true;
        } else {
            const matches = kb.key === e.key && (kb.shift === void 0 || kb.shift === e.shiftKey) && (kb.ctrlOrMeta === void 0 || kb.ctrlOrMeta === e.ctrlKey || kb.ctrlOrMeta === e.metaKey);
            if (matches) return true;
        }
    }
    return false;
}
function mapKeyboardEventToAction(event) {
    for (const [actionName, { activatesFocusIndicator = true, bindings }] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entries"])(KEY_BINDINGS)){
        if (matchesKeyBinding(event, bindings)) {
            return {
                name: actionName,
                activatesFocusIndicator
            };
        }
    }
    return void 0;
}
// packages/ag-charts-community/src/chart/keyboardUtil.ts
function computeCenter(series, hoverRect, pick2) {
    const refPoint = getDatumRefPoint(series, pick2.datum, pick2.movedBounds);
    if (refPoint != null) return {
        x: refPoint.canvasX,
        y: refPoint.canvasY
    };
    const bboxOrPath = pick2.bounds;
    if (bboxOrPath == null) return;
    if (bboxOrPath instanceof BBox) {
        const { x: centerX, y: centerY } = bboxOrPath.computeCenter();
        return {
            x: hoverRect.x + centerX,
            y: hoverRect.y + centerY
        };
    }
    return Transformable.toCanvas(bboxOrPath).computeCenter();
}
function getPickedFocusBBox(param) {
    let { bounds } = param;
    if (bounds instanceof BBox) return bounds;
    if (bounds != null) return Transformable.toCanvas(bounds);
    return BBox.NaN;
}
function makeKeyboardPointerEvent(series, hoverRect, pick2) {
    var _computeCenter;
    const { x: canvasX, y: canvasY } = (_computeCenter = computeCenter(series, hoverRect, pick2)) !== null && _computeCenter !== void 0 ? _computeCenter : {};
    if (canvasX !== void 0 && canvasY !== void 0) {
        return {
            type: "keyboard",
            canvasX,
            canvasY
        };
    }
    return void 0;
}
;
// packages/ag-charts-community/src/util/placement.ts
function calculatePlacement(naturalWidth, naturalHeight, container, bounds) {
    let { top, right, bottom, left, width: width2, height: height2 } = bounds;
    if (left != null) {
        if (width2 != null) {
            right = container.width - left + width2;
        } else if (right != null) {
            width2 = container.width - left - right;
        }
    } else if (right != null && width2 != null) {
        left = container.width - right - width2;
    }
    if (top != null) {
        if (height2 != null) {
            bottom = container.height - top - height2;
        } else if (bottom != null) {
            height2 = container.height - bottom - top;
        }
    } else if (bottom != null && height2 != null) {
        top = container.height - bottom - height2;
    }
    if (width2 == null) {
        if (height2 == null) {
            height2 = naturalHeight;
            width2 = naturalWidth;
        } else {
            width2 = Math.ceil(naturalWidth * height2 / naturalHeight);
        }
    } else {
        height2 !== null && height2 !== void 0 ? height2 : height2 = Math.ceil(naturalHeight * width2 / naturalWidth);
    }
    if (left == null) {
        if (right == null) {
            left = Math.floor((container.width - width2) / 2);
        } else {
            left = container.width - right - width2;
        }
    }
    if (top == null) {
        if (bottom == null) {
            top = Math.floor((container.height - height2) / 2);
        } else {
            top = container.height - height2 - bottom;
        }
    }
    return {
        x: left,
        y: top,
        width: width2,
        height: height2
    };
}
;
var M = 0.1;
var K = 200;
var C = 12;
var DELTA = 0.5;
var SpringAnimation = class {
    reset() {
        this.x = NaN;
        this.y = NaN;
        if (this.animationFrameHandle != null) {
            cancelAnimationFrame(this.animationFrameHandle);
            this.animationFrameHandle = void 0;
        }
    }
    update(x, y) {
        if (Number.isNaN(this.x) || Number.isNaN(this.y)) {
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.emitUpdate();
            if (this.animationFrameHandle != null) {
                cancelAnimationFrame(this.animationFrameHandle);
                this.animationFrameHandle = void 0;
            }
            return;
        }
        this.x1 = x;
        this.y1 = y;
        this.t0 = Date.now();
        var _this_animationFrameHandle;
        (_this_animationFrameHandle = this.animationFrameHandle) !== null && _this_animationFrameHandle !== void 0 ? _this_animationFrameHandle : this.animationFrameHandle = requestAnimationFrame(this.onFrame.bind(this));
    }
    onFrame() {
        this.animationFrameHandle = void 0;
        const { x1, y1, t0 } = this;
        const t1 = Date.now();
        const dt = t1 - t0;
        this.t0 = t1;
        const stepT = 1e-3;
        const iterations = Math.ceil(dt / (stepT * 1e3)) | 0;
        let { x, y, vx, vy } = this;
        for(let i = 0; i < iterations; i += 1){
            const dx = x - x1;
            const dy = y - y1;
            const ax = -(K * dx + C * vx) / M;
            const ay = -(K * dy + C * vy) / M;
            vx += ax * stepT;
            vy += ay * stepT;
            x += vx * stepT;
            y += vy * stepT;
        }
        if (Math.hypot(x - x1, y - y1) < DELTA) {
            this.x = this.x1;
            this.y = this.y1;
            this.vx = 0;
            this.vy = 0;
        } else {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.animationFrameHandle = requestAnimationFrame(this.onFrame.bind(this));
        }
        this.emitUpdate();
    }
    emitUpdate() {
        this.events.emit("update", {
            x: this.x,
            y: this.y
        });
    }
    constructor(){
        this.events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventEmitter"]();
        this.x1 = NaN;
        this.y1 = NaN;
        this.x = NaN;
        this.y = NaN;
        this.vx = 0;
        this.vy = 0;
        this.t0 = NaN;
        this.animationFrameHandle = void 0;
    }
};
;
var element = null;
function sanitizeHtml(text) {
    if (text === "") {
        return "";
    }
    element !== null && element !== void 0 ? element : element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div");
    element.textContent = String(text);
    return element.innerHTML.replace(/\n/g, "<br>");
}
// packages/ag-charts-community/src/chart/marker/shapes.ts
function drawMarkerUnitPolygon(params, moves) {
    const { path, size } = params;
    const { x: x0, y: y0 } = params;
    path.clear();
    let didMove = false;
    for (const [dx, dy] of moves){
        const x = x0 + (dx - 0.5) * size;
        const y = y0 + (dy - 0.5) * size;
        if (didMove) {
            path.lineTo(x, y);
        } else {
            path.moveTo(x, y);
        }
        didMove = true;
    }
    path.closePath();
}
var MARKER_SHAPES = {
    circle (param) {
        let { path, x, y, size } = param;
        const r = size / 2;
        path.arc(x, y, r, 0, Math.PI * 2);
        path.closePath();
    },
    cross (params) {
        drawMarkerUnitPolygon(params, [
            [
                0.25,
                0
            ],
            [
                0.5,
                0.25
            ],
            [
                0.75,
                0
            ],
            [
                1,
                0.25
            ],
            [
                0.75,
                0.5
            ],
            [
                1,
                0.75
            ],
            [
                0.75,
                1
            ],
            [
                0.5,
                0.75
            ],
            [
                0.25,
                1
            ],
            [
                0,
                0.75
            ],
            [
                0.25,
                0.5
            ],
            [
                0,
                0.25
            ]
        ]);
    },
    diamond (params) {
        drawMarkerUnitPolygon(params, [
            [
                0.5,
                0
            ],
            [
                1,
                0.5
            ],
            [
                0.5,
                1
            ],
            [
                0,
                0.5
            ]
        ]);
    },
    heart (param) {
        let { path, x, y, size } = param;
        const r = size / 4;
        y = y + r / 2;
        path.arc(x - r, y - r, r, toRadians(130), toRadians(330));
        path.arc(x + r, y - r, r, toRadians(220), toRadians(50));
        path.lineTo(x, y + r);
        path.closePath();
    },
    pin (param) {
        let { path, x, y, size: s } = param;
        const cx = 0.5;
        const cy = 0.5;
        path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);
        path.cubicCurveTo(x + (0.15625 - cx) * s, y + (0.151491 - cy) * s, x + (0.307741 - cx) * s, y + (0 - cy) * s, x + (0.5 - cx) * s, y + (0 - cy) * s);
        path.cubicCurveTo(x + (0.692259 - cx) * s, y + (0 - cy) * s, x + (0.84375 - cx) * s, y + (0.151491 - cy) * s, x + (0.84375 - cx) * s, y + (0.34375 - cy) * s);
        path.cubicCurveTo(x + (0.84375 - cx) * s, y + (0.493824 - cy) * s, x + (0.784625 - cx) * s, y + (0.600181 - cy) * s, x + (0.716461 - cx) * s, y + (0.695393 - cy) * s);
        path.cubicCurveTo(x + (0.699009 - cx) * s, y + (0.719769 - cy) * s, x + (0.681271 - cx) * s, y + (0.743104 - cy) * s, x + (0.663785 - cx) * s, y + (0.766105 - cy) * s);
        path.cubicCurveTo(x + (0.611893 - cx) * s, y + (0.834367 - cy) * s, x + (0.562228 - cx) * s, y + (0.899699 - cy) * s, x + (0.528896 - cx) * s, y + (0.980648 - cy) * s);
        path.cubicCurveTo(x + (0.524075 - cx) * s, y + (0.992358 - cy) * s, x + (0.512663 - cx) * s, y + (1 - cy) * s, x + (0.5 - cx) * s, y + (1 - cy) * s);
        path.cubicCurveTo(x + (0.487337 - cx) * s, y + (1 - cy) * s, x + (0.475925 - cx) * s, y + (0.992358 - cy) * s, x + (0.471104 - cx) * s, y + (0.980648 - cy) * s);
        path.cubicCurveTo(x + (0.487337 - cx) * s, y + (1 - cy) * s, x + (0.475925 - cx) * s, y + (0.992358 - cy) * s, x + (0.471104 - cx) * s, y + (0.980648 - cy) * s);
        path.cubicCurveTo(x + (0.437772 - cx) * s, y + (0.899699 - cy) * s, x + (0.388107 - cx) * s, y + (0.834367 - cy) * s, x + (0.336215 - cx) * s, y + (0.766105 - cy) * s);
        path.cubicCurveTo(x + (0.318729 - cx) * s, y + (0.743104 - cy) * s, x + (0.300991 - cx) * s, y + (0.719769 - cy) * s, x + (0.283539 - cx) * s, y + (0.695393 - cy) * s);
        path.cubicCurveTo(x + (0.215375 - cx) * s, y + (0.600181 - cy) * s, x + (0.15625 - cx) * s, y + (0.493824 - cy) * s, x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);
        path.closePath();
    },
    plus (params) {
        drawMarkerUnitPolygon(params, [
            [
                1 / 3,
                0
            ],
            [
                2 / 3,
                0
            ],
            [
                2 / 3,
                1 / 3
            ],
            [
                1,
                1 / 3
            ],
            [
                1,
                2 / 3
            ],
            [
                2 / 3,
                2 / 3
            ],
            [
                2 / 3,
                1
            ],
            [
                1 / 3,
                1
            ],
            [
                1 / 3,
                2 / 3
            ],
            [
                0,
                2 / 3
            ],
            [
                0,
                1 / 3
            ],
            [
                1 / 3,
                1 / 3
            ]
        ]);
    },
    square (param) {
        let { path, x, y, size, pixelRatio } = param;
        const hs = size / 2;
        path.moveTo(align(pixelRatio, x - hs), align(pixelRatio, y - hs));
        path.lineTo(align(pixelRatio, x + hs), align(pixelRatio, y - hs));
        path.lineTo(align(pixelRatio, x + hs), align(pixelRatio, y + hs));
        path.lineTo(align(pixelRatio, x - hs), align(pixelRatio, y + hs));
        path.closePath();
    },
    star (param) {
        let { path, x, y, size } = param;
        const spikes = 5;
        const outerRadius = size / 2;
        const innerRadius = outerRadius / 2;
        const rotation = Math.PI / 2;
        for(let i = 0; i < spikes * 2; i++){
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle2 = i * Math.PI / spikes - rotation;
            const xCoordinate = x + Math.cos(angle2) * radius;
            const yCoordinate = y + Math.sin(angle2) * radius;
            path.lineTo(xCoordinate, yCoordinate);
        }
        path.closePath();
    },
    triangle (params) {
        drawMarkerUnitPolygon(params, [
            [
                0.5,
                0
            ],
            [
                1,
                0.87
            ],
            [
                0,
                0.87
            ]
        ]);
    }
};
// packages/ag-charts-community/src/chart/marker/marker.ts
var InternalMarker = class extends Path {
    isPointInPath(x, y) {
        return this.distanceSquared(x, y) <= 0;
    }
    distanceSquared(x, y) {
        const anchor = Marker.anchor(this.shape);
        return Math.max(Math.hypot(x - this.x + (anchor.x - 0.5) * this.size, y - this.y + (anchor.y - 0.5) * this.size) - this.size / 2, 0);
    }
    updatePath() {
        var _this_layerManager_canvas, _this_layerManager;
        const { path, shape, x, y, size } = this;
        var _this_layerManager_canvas_pixelRatio;
        const pixelRatio = (_this_layerManager_canvas_pixelRatio = (_this_layerManager = this.layerManager) === null || _this_layerManager === void 0 ? void 0 : (_this_layerManager_canvas = _this_layerManager.canvas) === null || _this_layerManager_canvas === void 0 ? void 0 : _this_layerManager_canvas.pixelRatio) !== null && _this_layerManager_canvas_pixelRatio !== void 0 ? _this_layerManager_canvas_pixelRatio : 1;
        const anchor = Marker.anchor(shape);
        const drawParams = {
            path,
            x: x - (anchor.x - 0.5) * size,
            y: y - (anchor.y - 0.5) * size,
            size,
            pixelRatio
        };
        path.clear();
        if (typeof shape === "string") {
            MARKER_SHAPES[shape](drawParams);
        } else if (typeof shape === "function") {
            shape(drawParams);
        }
    }
    computeBBox() {
        const { x, y, size } = this;
        const anchor = Marker.anchor(this.shape);
        return new BBox(x - size * anchor.x, y - size * anchor.y, size, size);
    }
    executeFill(ctx, path) {
        if (!path) return;
        return super.executeFill(ctx, path);
    }
    executeStroke(ctx, path) {
        if (!path) return;
        return super.executeStroke(ctx, path);
    }
    constructor(){
        super(...arguments);
        this.shape = "square";
        this.x = 0;
        this.y = 0;
        this.size = 12;
    }
};
__decorateClass([
    SceneObjectChangeDetection({
        equals: TRIPLE_EQ
    })
], InternalMarker.prototype, "shape", 2);
__decorateClass([
    SceneChangeDetection()
], InternalMarker.prototype, "x", 2);
__decorateClass([
    SceneChangeDetection()
], InternalMarker.prototype, "y", 2);
__decorateClass([
    SceneChangeDetection({
        convertor: Math.abs
    })
], InternalMarker.prototype, "size", 2);
var Marker = class extends Rotatable(Scalable(Translatable(InternalMarker))) {
    static anchor(shape) {
        if (shape === "pin") {
            return {
                x: 0.5,
                y: 1
            };
        } else if (typeof shape === "function" && "anchor" in shape) {
            return shape.anchor;
        }
        return {
            x: 0.5,
            y: 0.5
        };
    }
    constructor(options){
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.shape) != null) {
            this.shape = options.shape;
        }
    }
};
// packages/ag-charts-community/src/chart/legend/legendSymbol.ts
function legendSymbolSvg(symbol, size) {
    let lineSize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : size * (5 / 3);
    var _symbol_line;
    const group = new Group();
    var _symbol_marker_strokeWidth;
    const markerStrokeWidth = Math.min((_symbol_marker_strokeWidth = symbol.marker.strokeWidth) !== null && _symbol_marker_strokeWidth !== void 0 ? _symbol_marker_strokeWidth : 1, 2);
    var _symbol_line_strokeWidth;
    const lineStrokeWidth = Math.min((_symbol_line_strokeWidth = (_symbol_line = symbol.line) === null || _symbol_line === void 0 ? void 0 : _symbol_line.strokeWidth) !== null && _symbol_line_strokeWidth !== void 0 ? _symbol_line_strokeWidth : 0, 2);
    const width2 = Math.max(symbol.marker.enabled === false ? 0 : size, symbol.line == null ? 0 : lineSize);
    const height2 = Math.max(symbol.marker.enabled === false ? 0 : size, lineStrokeWidth);
    if (symbol.line != null) {
        const { stroke: stroke2, strokeOpacity, lineDash } = symbol.line;
        const line = new Line();
        line.x1 = 0;
        line.y1 = height2 / 2;
        line.x2 = width2;
        line.y2 = height2 / 2;
        line.stroke = stroke2;
        line.strokeOpacity = strokeOpacity;
        line.strokeWidth = lineStrokeWidth;
        line.lineDash = lineDash;
        group.append(line);
    }
    if (symbol.marker.enabled !== false) {
        const { shape, fill, fillOpacity, stroke: stroke2, strokeOpacity, lineDash, lineDashOffset } = symbol.marker;
        const marker = new Marker();
        marker.shape = shape !== null && shape !== void 0 ? shape : "square";
        marker.size = size;
        marker.fill = fill;
        marker.fillOpacity = fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1;
        marker.stroke = stroke2;
        marker.strokeOpacity = strokeOpacity !== null && strokeOpacity !== void 0 ? strokeOpacity : 1;
        marker.strokeWidth = markerStrokeWidth;
        marker.lineDash = lineDash;
        marker.lineDashOffset = lineDashOffset !== null && lineDashOffset !== void 0 ? lineDashOffset : 0;
        const anchor = Marker.anchor(shape);
        const x = width2 / 2 + (anchor.x - 0.5) * size;
        const y = height2 / 2 + (anchor.y - 0.5) * size;
        const scale2 = size / (size + markerStrokeWidth);
        marker.x = x;
        marker.y = y;
        marker.scalingCenterX = x;
        marker.scalingCenterY = y;
        marker.scalingX = scale2;
        marker.scalingY = scale2;
        group.append(marker);
    }
    return Group.toSVG(group, width2, height2);
}
// packages/ag-charts-community/src/chart/tooltip/tooltipContent.ts
var DEFAULT_TOOLTIP_CLASS = "ag-charts-tooltip";
var DEFAULT_TOOLTIP_DARK_CLASS = "ag-charts-tooltip--dark";
function aggregateTooltipContent(content) {
    const out = [];
    const groupedContents = /* @__PURE__ */ new Map();
    for (const item of content){
        if (item.type === "structured") {
            const { heading } = item;
            const insertionTarget = heading != null ? groupedContents.get(heading) : void 0;
            const groupedItem = {
                type: "structured",
                heading,
                items: [
                    item
                ]
            };
            if (insertionTarget == null) {
                groupedContents.set(heading, groupedItem);
                out.push(groupedItem);
            } else {
                insertionTarget.items.push(item);
            }
        } else {
            out.push(item);
        }
    }
    return out;
}
function tooltipContentAriaLabel(ungroupedContent) {
    const content = aggregateTooltipContent(ungroupedContent);
    const ariaLabel = [];
    content.forEach((c)=>{
        if (c.type === "raw") return "";
        if (c.heading != null) ariaLabel.push(c.heading);
        c.items.forEach((i)=>{
            var _i_data;
            if (i.title != null) ariaLabel.push(i.title);
            (_i_data = i.data) === null || _i_data === void 0 ? void 0 : _i_data.forEach((datum)=>{
                var _datum_label;
                ariaLabel.push((_datum_label = datum.label) !== null && _datum_label !== void 0 ? _datum_label : datum.fallbackLabel, datum.value);
            });
        });
    });
    return ariaLabel.join("; ");
}
function dataHtml(label, value, inline) {
    let rowHtml = "";
    if (label == null) {
        rowHtml += '<span class="'.concat(DEFAULT_TOOLTIP_CLASS, '-label">').concat(sanitizeHtml(value), "</span>");
    } else {
        rowHtml += '<span class="'.concat(DEFAULT_TOOLTIP_CLASS, '-label">').concat(sanitizeHtml(label), "</span>");
        rowHtml += " ";
        rowHtml += '<span class="'.concat(DEFAULT_TOOLTIP_CLASS, '-value">').concat(sanitizeHtml(value), "</span>");
    }
    const rowClassNames = [
        "".concat(DEFAULT_TOOLTIP_CLASS, "-row")
    ];
    if (inline) rowClassNames.push("".concat(DEFAULT_TOOLTIP_CLASS, "-row--inline"));
    rowHtml = '<div class="'.concat(rowClassNames.join(" "), '">').concat(rowHtml, "</div>");
    return rowHtml;
}
function tooltipRowContentHtml(content) {
    var _content_data, _content_data1, _content_data2, _content_data3;
    let html = "";
    if (((_content_data = content.data) === null || _content_data === void 0 ? void 0 : _content_data.length) && content.data.every((datum)=>datum.value == null || datum.value === "")) {
        return html;
    }
    const dataInline = content.title == null && ((_content_data1 = content.data) === null || _content_data1 === void 0 ? void 0 : _content_data1.length) === 1;
    const symbol = content.symbol == null ? void 0 : legendSymbolSvg(content.symbol, 12);
    if (symbol != null && (content.title != null || ((_content_data2 = content.data) === null || _content_data2 === void 0 ? void 0 : _content_data2.length))) {
        html += '<span class="'.concat(DEFAULT_TOOLTIP_CLASS, '-symbol">').concat(symbol, "</span>");
    }
    if (content.title != null) {
        html += '<span class="'.concat(DEFAULT_TOOLTIP_CLASS, '-title">').concat(sanitizeHtml(content.title), "</span>");
        html += " ";
    }
    (_content_data3 = content.data) === null || _content_data3 === void 0 ? void 0 : _content_data3.forEach((datum)=>{
        var _datum_label;
        html += dataHtml((_datum_label = datum.label) !== null && _datum_label !== void 0 ? _datum_label : datum.fallbackLabel, datum.value, dataInline);
        html += " ";
    });
    return html;
}
function tooltipPaginationContentHtml(localeManager, pagination) {
    if (localeManager == null || pagination.length === 1) return;
    const text = localeManager === null || localeManager === void 0 ? void 0 : localeManager.t("tooltipPaginationStatus", {
        index: pagination.index + 1,
        count: pagination.length
    });
    return '<div class="'.concat(DEFAULT_TOOLTIP_CLASS, '-footer">').concat(text, "</div>");
}
function tooltipContentHtml(localeManager, content, mode, pagination) {
    const singleItem = content.items.length === 1 ? content.items[0] : void 0;
    let compact;
    let compactTitle;
    let compactFallbackLabel;
    switch(mode){
        case "compact":
            compact = true;
            compactTitle = singleItem === null || singleItem === void 0 ? void 0 : singleItem.title;
            break;
        case "single":
            var _singleItem_data;
            compact = singleItem != null && (content.heading == null || singleItem.title == null) && ((_singleItem_data = singleItem.data) === null || _singleItem_data === void 0 ? void 0 : _singleItem_data.length) === 1 && singleItem.data[0].label == null && singleItem.data[0].value != null;
            var _content_heading;
            compactFallbackLabel = (_content_heading = content.heading) !== null && _content_heading !== void 0 ? _content_heading : singleItem === null || singleItem === void 0 ? void 0 : singleItem.title;
            break;
        case "shared":
            compact = false;
    }
    let html = "";
    if (compact && singleItem != null) {
        var _singleItem_data1;
        if (compactTitle != null) {
            html += dataHtml(void 0, compactTitle, false);
        }
        (_singleItem_data1 = singleItem.data) === null || _singleItem_data1 === void 0 ? void 0 : _singleItem_data1.forEach((datum)=>{
            var _datum_label;
            html += dataHtml((_datum_label = datum.label) !== null && _datum_label !== void 0 ? _datum_label : compactFallbackLabel, datum.value, false);
            html += " ";
        });
    } else {
        if (content.heading != null) {
            html += '<span class="'.concat(DEFAULT_TOOLTIP_CLASS, '-heading">').concat(sanitizeHtml(content.heading), "</span>");
            html += " ";
        }
        content.items.forEach((item)=>{
            html += tooltipRowContentHtml(item);
        });
    }
    if (html.length === 0) return;
    const paginationContent = mode !== "compact" && pagination != null ? tooltipPaginationContentHtml(localeManager, pagination) : void 0;
    if (paginationContent + null) {
        html += paginationContent;
    }
    html = '<div class="'.concat(DEFAULT_TOOLTIP_CLASS, '-content">').concat(html.trimEnd(), "</div>");
    return html;
}
function tooltipPaginationHtml(localeManager, pagination) {
    const paginationContent = pagination == null ? void 0 : tooltipPaginationContentHtml(localeManager, pagination);
    if (paginationContent == null) return "";
    return '<div class="'.concat(DEFAULT_TOOLTIP_CLASS, '-content">').concat(paginationContent, "</div>");
}
function tooltipHtml(localeManager, content, mode, pagination) {
    const aggregatedContent = aggregateTooltipContent(content);
    if (aggregatedContent.length === 0) return;
    if (aggregatedContent.length === 1 && aggregatedContent[0].type === "structured") {
        return tooltipContentHtml(localeManager, aggregatedContent[0], mode, pagination);
    } else {
        const htmlRows = aggregatedContent.map((c)=>{
            return c.type === "structured" ? tooltipContentHtml(localeManager, c, mode) : c.rawHtmlString;
        });
        if (pagination != null) {
            var _tooltipPaginationHtml;
            htmlRows.push((_tooltipPaginationHtml = tooltipPaginationHtml(localeManager, pagination)) !== null && _tooltipPaginationHtml !== void 0 ? _tooltipPaginationHtml : "");
        }
        return htmlRows.join("");
    }
}
// packages/ag-charts-community/src/chart/tooltip/tooltip.ts
var horizontalAlignments = {
    left: -1,
    "top-left": -1,
    "bottom-left": -1,
    top: 0,
    center: 0,
    bottom: 0,
    right: 1,
    "top-right": 1,
    "bottom-right": 1
};
var verticalAlignments = {
    "top-left": -1,
    top: -1,
    "top-right": -1,
    left: 0,
    center: 0,
    right: 0,
    "bottom-left": 1,
    bottom: 1,
    "bottom-right": 1
};
var arrowPositions = {
    left: 3 /* Right */ ,
    "top-left": void 0,
    "bottom-left": void 0,
    top: 2 /* Bottom */ ,
    center: void 0,
    bottom: 1 /* Top */ ,
    right: 0 /* Left */ ,
    "top-right": void 0,
    "bottom-right": void 0
};
var directionChecks = {
    top: 2 /* Vertical */ ,
    bottom: 2 /* Vertical */ ,
    left: 1 /* Horizontal */ ,
    right: 1 /* Horizontal */ ,
    "top-right": 3 /* Both */ ,
    "top-left": 3 /* Both */ ,
    "bottom-right": 3 /* Both */ ,
    "bottom-left": 3 /* Both */ ,
    center: 0 /* None */ 
};
var defaultPlacements = {
    pointer: "top",
    node: "top",
    chart: "top-left"
};
var TooltipPosition = class extends BaseProperties {
    constructor(){
        super(...arguments);
        /** The horizontal offset in pixels for the position of the tooltip. */ this.xOffset = 0;
        /** The vertical offset in pixels for the position of the tooltip. */ this.yOffset = 0;
    }
};
__decorateClass([
    Property
], TooltipPosition.prototype, "xOffset", 2);
__decorateClass([
    Property
], TooltipPosition.prototype, "yOffset", 2);
__decorateClass([
    Property
], TooltipPosition.prototype, "anchorTo", 2);
__decorateClass([
    Property
], TooltipPosition.prototype, "placement", 2);
var Tooltip = class extends BaseProperties {
    get interactive() {
        return this.enableInteraction;
    }
    setup(localeManager, domManager) {
        if ("togglePopover" in (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])().HTMLElement.prototype) {
            this.element = domManager.addChild("tooltip-container", DEFAULT_TOOLTIP_CLASS);
            this.element.setAttribute("popover", "manual");
            this.element.className = DEFAULT_TOOLTIP_CLASS;
            this.element.style.positionAnchor = domManager.anchorName;
            this.sizeMonitor.observe(this.element, (size)=>{
                this._elementSize = size;
                this.updateTooltipPosition();
            });
        }
        this.localeManager = localeManager;
        return ()=>{
            domManager.removeChild("tooltip-container", DEFAULT_TOOLTIP_CLASS);
            this.cleanup.flush();
            if (this.element) {
                this.sizeMonitor.unobserve(this.element);
            }
        };
    }
    isVisible() {
        return this._visible;
    }
    contains(node) {
        var _this_element;
        var _this_element_contains;
        return (_this_element_contains = (_this_element = this.element) === null || _this_element === void 0 ? void 0 : _this_element.contains(node)) !== null && _this_element_contains !== void 0 ? _this_element_contains : false;
    }
    updateTooltipPosition() {
        var _meta_position, _meta_position1, _meta_position2, _meta_position3;
        const { element: element2, _elementSize: elementSize, positionParams } = this;
        if (element2 == null || elementSize == null || positionParams == null) return;
        const { canvasRect, relativeRect, meta } = positionParams;
        const { x: canvasX, y: canvasY } = this.springAnimation;
        var _meta_position_anchorTo;
        const anchorTo = (_meta_position_anchorTo = (_meta_position = meta.position) === null || _meta_position === void 0 ? void 0 : _meta_position.anchorTo) !== null && _meta_position_anchorTo !== void 0 ? _meta_position_anchorTo : "pointer";
        var _meta_position_placement;
        let placements2 = (_meta_position_placement = (_meta_position1 = meta.position) === null || _meta_position1 === void 0 ? void 0 : _meta_position1.placement) !== null && _meta_position_placement !== void 0 ? _meta_position_placement : defaultPlacements[anchorTo];
        if (!Array.isArray(placements2)) {
            placements2 = [
                placements2
            ];
        }
        var _meta_position_xOffset;
        const xOffset = (_meta_position_xOffset = (_meta_position2 = meta.position) === null || _meta_position2 === void 0 ? void 0 : _meta_position2.xOffset) !== null && _meta_position_xOffset !== void 0 ? _meta_position_xOffset : 0;
        var _meta_position_yOffset;
        const yOffset = (_meta_position_yOffset = (_meta_position3 = meta.position) === null || _meta_position3 === void 0 ? void 0 : _meta_position3.yOffset) !== null && _meta_position_yOffset !== void 0 ? _meta_position_yOffset : 0;
        const minX = relativeRect.x;
        const minY = relativeRect.y;
        const maxX = relativeRect.width - elementSize.width - 1 + minX;
        const maxY = relativeRect.height - elementSize.height + minY;
        let i = 0;
        let placement;
        let position;
        let constrained = false;
        do {
            placement = placements2[i];
            i += 1;
            const tooltipBounds = this.getTooltipBounds({
                elementSize,
                placement,
                anchorTo,
                canvasX,
                canvasY,
                yOffset,
                xOffset,
                canvasRect
            });
            position = calculatePlacement(elementSize.width, elementSize.height, relativeRect, tooltipBounds);
            constrained = false;
            if (directionChecks[placement] & 1 /* Horizontal */ ) {
                constrained || (constrained = position.x < minX || position.x > maxX);
            }
            if (directionChecks[placement] & 2 /* Vertical */ ) {
                constrained || (constrained = position.y < minY || position.y > maxY);
            }
        }while (i < placements2.length && constrained)
        const left = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(minX, position.x, maxX);
        const top = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(minY, position.y, maxY);
        constrained || (constrained = left !== position.x || top !== position.y);
        const defaultShowArrow = anchorTo !== "chart" && !constrained && !xOffset && !yOffset;
        var _meta_showArrow, _ref;
        const showArrow = (_ref = (_meta_showArrow = meta.showArrow) !== null && _meta_showArrow !== void 0 ? _meta_showArrow : this.showArrow) !== null && _ref !== void 0 ? _ref : defaultShowArrow;
        this.arrowPosition = showArrow ? arrowPositions[placement] : void 0;
        this.updateClassModifiers();
        element2.style.translate = "".concat(left, "px ").concat(top, "px");
    }
    /**
   * Shows tooltip at the given event's coordinates.
   * If the `html` parameter is missing, moves the existing tooltip to the new position.
   */ show(boundingRect, canvasRect, meta, content, pagination) {
        let instantly = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
        var _meta_position;
        const { element: element2 } = this;
        if (element2 != null && content != null && content.length !== 0) {
            const html = tooltipHtml(this.localeManager, content, this.mode, this.pagination ? pagination : void 0);
            if (html == null) {
                this.toggle(false);
                return;
            }
            element2.innerHTML = html;
        } else if (element2 == null || element2.innerHTML === "") {
            this.toggle(false);
            return;
        }
        const relativeRect = {
            x: boundingRect.x - canvasRect.x,
            y: boundingRect.y - canvasRect.y,
            width: boundingRect.width,
            height: boundingRect.height
        };
        this.positionParams = {
            canvasRect,
            relativeRect,
            meta
        };
        var _meta_position_anchorTo;
        const anchorTo = (_meta_position_anchorTo = (_meta_position = meta.position) === null || _meta_position === void 0 ? void 0 : _meta_position.anchorTo) !== null && _meta_position_anchorTo !== void 0 ? _meta_position_anchorTo : "pointer";
        switch(anchorTo){
            case "node":
                var _meta_nodeCanvasX, _meta_nodeCanvasY;
                this.springAnimation.update((_meta_nodeCanvasX = meta.nodeCanvasX) !== null && _meta_nodeCanvasX !== void 0 ? _meta_nodeCanvasX : meta.canvasX, (_meta_nodeCanvasY = meta.nodeCanvasY) !== null && _meta_nodeCanvasY !== void 0 ? _meta_nodeCanvasY : meta.canvasY);
                break;
            case "pointer":
                this.springAnimation.update(meta.canvasX, meta.canvasY);
                break;
            case "chart":
                this.springAnimation.reset();
        }
        if (meta.enableInteraction) {
            this.enableInteraction = true;
            element2.style.pointerEvents = "auto";
            element2.removeAttribute("aria-hidden");
            element2.tabIndex = -1;
        } else {
            this.enableInteraction = false;
            element2.style.pointerEvents = "none";
            element2.setAttribute("aria-hidden", "true");
            element2.removeAttribute("tabindex");
        }
        element2.style.setProperty("--top", "".concat(canvasRect.top, "px"));
        element2.style.setProperty("--left", "".concat(canvasRect.left, "px"));
        this.updateClassModifiers();
        this.toggle(true, instantly);
    }
    hide() {
        this.toggle(false);
    }
    maybeEnterInteractiveTooltip(param, callback8) {
        let { relatedTarget } = param;
        const { interactive, interactiveLeave, enabled, element: element2 } = this;
        if (element2 == null) return false;
        if (interactiveLeave) return true;
        const isEntering = interactive && enabled && this.isVisible() && relatedTarget instanceof Node && this.contains(relatedTarget);
        if (isEntering) {
            this.interactiveLeave = {
                callback: callback8,
                listener: (popoverEvent)=>{
                    const isLeaving = popoverEvent.relatedTarget == null || popoverEvent.relatedTarget instanceof Node && !this.contains(popoverEvent.relatedTarget);
                    if (isLeaving) {
                        this.popInteractiveLeaveCallback();
                    }
                }
            };
            element2.addEventListener("focusout", this.interactiveLeave.listener);
            element2.addEventListener("mouseout", this.interactiveLeave.listener);
        }
        return isEntering;
    }
    popInteractiveLeaveCallback() {
        const { interactiveLeave, element: element2 } = this;
        this.interactiveLeave = void 0;
        if (interactiveLeave) {
            if (element2) {
                element2.removeEventListener("focusout", interactiveLeave.listener);
                element2.removeEventListener("mouseout", interactiveLeave.listener);
            }
            interactiveLeave.callback();
        }
    }
    toggle(visible) {
        let instantly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        const { delay } = this;
        if (visible && delay > 0 && !instantly) {
            var _this__showTimeout;
            (_this__showTimeout = this._showTimeout) !== null && _this__showTimeout !== void 0 ? _this__showTimeout : this._showTimeout = setTimeout(()=>{
                this._showTimeout = void 0;
                this.toggleCallback(true);
            }, delay);
        } else {
            clearTimeout(this._showTimeout);
            this._showTimeout = void 0;
            this.toggleCallback(visible);
        }
    }
    toggleCallback(visible) {
        var _this_element;
        if (!((_this_element = this.element) === null || _this_element === void 0 ? void 0 : _this_element.isConnected)) return;
        if (this._visible === visible) return;
        this._visible = visible;
        this.element.togglePopover(visible);
        if (visible) {
            this.updateTooltipPosition();
        } else {
            this.springAnimation.reset();
            this.popInteractiveLeaveCallback();
        }
    }
    updateClassModifiers() {
        var _this_element;
        if (!((_this_element = this.element) === null || _this_element === void 0 ? void 0 : _this_element.isConnected)) return;
        const { classList } = this.element;
        const toggleClass = (name, include)=>classList.toggle("".concat(DEFAULT_TOOLTIP_CLASS, "--").concat(name), include);
        toggleClass("no-interaction", !this.enableInteraction);
        toggleClass("arrow-top", this.arrowPosition === 1 /* Top */ );
        toggleClass("arrow-right", this.arrowPosition === 3 /* Right */ );
        toggleClass("arrow-bottom", this.arrowPosition === 2 /* Bottom */ );
        toggleClass("arrow-left", this.arrowPosition === 0 /* Left */ );
        toggleClass("compact", this.mode === "compact");
        classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);
        for (const wrapType of this.wrapTypes){
            classList.toggle("".concat(DEFAULT_TOOLTIP_CLASS, "--wrap-").concat(wrapType), wrapType === this.wrapping);
        }
    }
    getTooltipBounds(opts) {
        const { elementSize, anchorTo, placement, canvasX, canvasY, yOffset, xOffset, canvasRect } = opts;
        const { width: tooltipWidth, height: tooltipHeight } = elementSize;
        const bounds = {
            width: tooltipWidth,
            height: tooltipHeight
        };
        if (anchorTo === "node" || anchorTo === "pointer") {
            const horizontalAlignment = horizontalAlignments[placement];
            const verticalAlignment = verticalAlignments[placement];
            bounds.top = canvasY + yOffset + tooltipHeight * (verticalAlignment - 1) / 2 + 8 * verticalAlignment;
            bounds.left = canvasX + xOffset + tooltipWidth * (horizontalAlignment - 1) / 2 + 8 * horizontalAlignment;
            return bounds;
        }
        switch(placement){
            case "top":
                {
                    bounds.top = yOffset;
                    bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;
                    return bounds;
                }
            case "right":
                {
                    bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;
                    bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;
                    return bounds;
                }
            case "left":
                {
                    bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;
                    bounds.left = xOffset;
                    return bounds;
                }
            case "bottom":
                {
                    bounds.top = canvasRect.height - tooltipHeight + yOffset;
                    bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;
                    return bounds;
                }
            case "top-left":
                {
                    bounds.top = yOffset;
                    bounds.left = xOffset;
                    return bounds;
                }
            case "top-right":
                {
                    bounds.top = yOffset;
                    bounds.left = canvasRect.width - tooltipWidth + xOffset;
                    return bounds;
                }
            case "bottom-right":
                {
                    bounds.top = canvasRect.height - tooltipHeight + yOffset;
                    bounds.left = canvasRect.width - tooltipWidth + xOffset;
                    return bounds;
                }
            case "bottom-left":
                {
                    bounds.top = canvasRect.height - tooltipHeight + yOffset;
                    bounds.left = xOffset;
                    return bounds;
                }
        }
        return bounds;
    }
    constructor(){
        super();
        this.enabled = true;
        this.mode = "single";
        this.delay = 0;
        this.range = void 0;
        this.wrapping = "hyphenate";
        this.position = new TooltipPosition();
        this.pagination = false;
        this.darkTheme = false;
        this.bounds = "extended";
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.springAnimation = new SpringAnimation();
        this.enableInteraction = false;
        this.wrapTypes = [
            "always",
            "hyphenate",
            "on-space",
            "never"
        ];
        this.sizeMonitor = new SizeMonitor();
        // Reading the element size is expensive, so cache the result
        this._elementSize = void 0;
        this._showTimeout = void 0;
        this.arrowPosition = void 0;
        this._visible = false;
        this.positionParams = void 0;
        this.localeManager = void 0;
        this.cleanup.register(this.springAnimation.events.on("update", this.updateTooltipPosition.bind(this)));
    }
};
__decorateClass([
    Property
], Tooltip.prototype, "enabled", 2);
__decorateClass([
    Property
], Tooltip.prototype, "mode", 2);
__decorateClass([
    Property
], Tooltip.prototype, "showArrow", 2);
__decorateClass([
    Property
], Tooltip.prototype, "delay", 2);
__decorateClass([
    Property
], Tooltip.prototype, "range", 2);
__decorateClass([
    Property
], Tooltip.prototype, "wrapping", 2);
__decorateClass([
    Property
], Tooltip.prototype, "position", 2);
__decorateClass([
    Property
], Tooltip.prototype, "pagination", 2);
__decorateClass([
    Property
], Tooltip.prototype, "darkTheme", 2);
__decorateClass([
    Property
], Tooltip.prototype, "bounds", 2);
// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts
function pickedNodesEqual(a, b) {
    return a.series === b.series && objectsEqual(a.datumIndex, b.datumIndex);
}
var PickedNodeState = class {
    get current() {
        return this.active;
    }
    reset() {
        this.candidates.length = 0;
        this.active = void 0;
    }
    update(nextCandidates, previousActive) {
        this.candidates = nextCandidates;
        let nextIndex = previousActive != null ? nextCandidates.findIndex((c)=>pickedNodesEqual(c, previousActive)) : -1;
        if (nextIndex === -1) nextIndex = 0;
        this.active = nextCandidates[nextIndex];
        return {
            current: this.active,
            index: nextIndex,
            length: nextCandidates.length
        };
    }
    next() {
        const { candidates, active } = this;
        const hoverIndex = active == null ? -1 : candidates.findIndex((c)=>pickedNodesEqual(c, active));
        if (hoverIndex === -1) return void 0;
        let nextIndex = hoverIndex + 1;
        if (nextIndex >= candidates.length) {
            nextIndex = 0;
        }
        this.active = candidates[nextIndex];
        return {
            current: this.active,
            index: nextIndex,
            length: this.candidates.length
        };
    }
    constructor(){
        this.candidates = [];
    }
};
var SeriesAreaManager = class extends BaseManager {
    get bbox() {
        var _this_seriesRect;
        return ((_this_seriesRect = this.seriesRect) !== null && _this_seriesRect !== void 0 ? _this_seriesRect : BBox.zero).clone();
    }
    isState(allowedStates) {
        return this.chart.ctx.interactionManager.isState(allowedStates);
    }
    isIgnoredTouch(event) {
        if (event.device !== "touch" || event.type === "click") return false;
        if (this.chart.ctx.chartService.touch.dragAction === "hover") return false;
        if (this.chart.ctx.chartService.touch.dragAction === "drag") {
            if (this.isState(9 /* AnnotationsMoveable */ )) {
                return false;
            }
        }
        return true;
    }
    dataChanged() {
        var _this_focusIndicator;
        var _a;
        this.cachedTooltipContent = void 0;
        if (this.highlight.appliedHoverEvent) {
            var _stashedHoverEvent;
            (_stashedHoverEvent = (_a = this.highlight).stashedHoverEvent) !== null && _stashedHoverEvent !== void 0 ? _stashedHoverEvent : _a.stashedHoverEvent = this.highlight.appliedHoverEvent;
            this.clearHighlight();
        }
        this.chart.ctx.tooltipManager.removeTooltip(this.id);
        (_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.clear();
    }
    preSceneRender() {
        if (this.highlight.stashedHoverEvent != null) {
            this.highlight.pendingHoverEvent = this.highlight.stashedHoverEvent;
            this.highlight.stashedHoverEvent = void 0;
            this.handleHoverHighlight(true);
        }
        if (this.tooltip.lastHover != null) {
            this.handleHoverTooltip(this.tooltip.lastHover, true);
        }
    }
    updateComplete() {
        var _this_focusIndicator;
        if (this.isState(34 /* Focusable */ ) && ((_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.isFocusVisible())) {
            if (this.announceMode !== "always") {
                this.announceMode = "never";
            }
            this.handleFocus(0, 0);
        }
    }
    update(type, opts) {
        this.chart.ctx.updateService.update(type, opts);
    }
    seriesChanged(series) {
        this.focus.sortedSeries = [
            ...series
        ].sort((a, b)=>{
            var _a_properties_focusPriority;
            let fpA = (_a_properties_focusPriority = a.properties.focusPriority) !== null && _a_properties_focusPriority !== void 0 ? _a_properties_focusPriority : Infinity;
            var _b_properties_focusPriority;
            let fpB = (_b_properties_focusPriority = b.properties.focusPriority) !== null && _b_properties_focusPriority !== void 0 ? _b_properties_focusPriority : Infinity;
            if (fpA === fpB) {
                [fpA, fpB] = [
                    a.declarationOrder,
                    b.declarationOrder
                ];
            }
            if (fpA < fpB) {
                return -1;
            } else if (fpA > fpB) {
                return 1;
            }
            return 0;
        });
        this.series = series;
    }
    layoutComplete(event) {
        this.seriesRect = event.series.rect;
        this.hoverRect = event.series.rect;
        this.chart.ctx.widgets.seriesWidget.setBounds(event.series.rect);
        if (this.chart.ctx.domManager.mode === "normal") {
            this.chart.ctx.widgets.chartWidget.setBounds(event.chart);
        }
    }
    onContextMenu(event, current) {
        var _this_focusIndicator;
        const { sourceEvent } = event;
        if (sourceEvent.currentTarget != current.getElement()) return;
        if (sourceEvent.target == this.chart.ctx.widgets.containerWidget.getElement()) {
            if (this.isState(36 /* ContextMenuable */ )) {
                const { currentX: canvasX2, currentY: canvasY2 } = event;
                this.chart.ctx.contextMenuRegistry.dispatchContext("always", {
                    widgetEvent: event,
                    canvasX: canvasX2,
                    canvasY: canvasY2
                }, void 0);
            }
            return;
        }
        let pickedNode;
        let position;
        if ((_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.isFocusVisible()) {
            pickedNode = this.chart.ctx.highlightManager.getActiveHighlight();
            if (pickedNode && this.seriesRect && pickedNode.midPoint) {
                position = Transformable.toCanvasPoint(pickedNode.series.contentGroup, pickedNode.midPoint.x, pickedNode.midPoint.y);
            }
        } else if (this.isState(36 /* ContextMenuable */ )) {
            const pick2 = this.pickNodes({
                x: event.currentX,
                y: event.currentY
            }, "context-menu");
            if (pick2) {
                this.chart.ctx.highlightManager.updateHighlight(this.id);
                pickedNode = pick2.matches[0].datum;
            }
        }
        const pickedSeries = pickedNode === null || pickedNode === void 0 ? void 0 : pickedNode.series;
        this.clearAll();
        const canvasX = event.currentX + current.cssLeft();
        const canvasY = event.currentY + current.cssTop();
        if (pickedSeries && pickedNode) {
            this.chart.ctx.contextMenuRegistry.dispatchContext("series-node", {
                widgetEvent: event,
                canvasX,
                canvasY
            }, {
                pickedSeries,
                pickedNode
            }, position);
        } else {
            this.chart.ctx.contextMenuRegistry.dispatchContext("series-area", {
                widgetEvent: event,
                canvasX,
                canvasY
            }, void 0, position);
        }
    }
    onLeave(event) {
        if (!this.isState(41 /* Clickable */ )) return;
        const relatedTarget = event.sourceEvent.relatedTarget;
        if ((relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.className) === "ag-charts-text-input__textarea") {
            return;
        }
        if (this.maybeEnterInteractiveTooltip(event.sourceEvent)) {
            return;
        }
        this.chart.ctx.domManager.updateCursor(this.id);
        if (this.hoverDevice !== "keyboard") this.clearAll();
    }
    onWheel(_event) {
        var _this_focusIndicator;
        if (!this.isState(41 /* Clickable */ )) return;
        (_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.overrideFocusVisible(false);
        this.previousInputDevice = "pointer";
    }
    onDragMove(event, current) {
        var _this_focusIndicator;
        if (!this.isState(41 /* Clickable */ )) return;
        (_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.overrideFocusVisible(false);
        this.onHoverLikeEvent(event, current);
    }
    onHover(event, current) {
        if (!this.isState(41 /* Clickable */ )) return;
        this.onHoverLikeEvent(event, current);
    }
    onHoverLikeEvent(event, current) {
        if (this.isIgnoredTouch(event)) return;
        if (event.device === "touch" && this.chart.ctx.chartService.touch.dragAction === "hover") {
            event.sourceEvent.preventDefault();
        }
        if (current !== this.chart.ctx.widgets.seriesWidget) return;
        if (event.device === "touch" || excludesType(event, "drag-move")) {
            this.tooltip.lastHover = event;
        }
        this.hoverDevice = "pointer";
        this.previousInputDevice = "pointer";
        this.highlight.pendingHoverEvent = event;
        this.hoverScheduler.schedule();
        if (this.isState(32 /* Default */ )) {
            var _this_pickNodes;
            const { currentX: x, currentY: y } = event;
            const matches = (_this_pickNodes = this.pickNodes({
                x,
                y
            }, "event")) === null || _this_pickNodes === void 0 ? void 0 : _this_pickNodes.matches;
            const found = matches === null || matches === void 0 ? void 0 : matches[0];
            if ((found === null || found === void 0 ? void 0 : found.series.hasEventListener("seriesNodeClick")) || (found === null || found === void 0 ? void 0 : found.series.hasEventListener("seriesNodeDoubleClick")) || matches != null && matches.length > 1 && this.chart.tooltip.pagination) {
                this.chart.ctx.domManager.updateCursor(this.id, "pointer");
            } else {
                this.chart.ctx.domManager.updateCursor(this.id);
            }
        }
    }
    onClick(event, current) {
        var _this_focusIndicator;
        if (event.device === "keyboard") {
            return;
        }
        if (current === this.chart.ctx.widgets.seriesWidget && this.chart.ctx.animationManager.isActive()) {
            this.chart.ctx.animationManager.skipCurrentBatch();
        }
        if (event.device === "touch" && current === this.chart.ctx.widgets.seriesWidget) {
            this.swapChain.focus({
                preventScroll: true
            });
        }
        if (!this.isState(41 /* Clickable */ )) return;
        if (current === this.chart.ctx.widgets.seriesWidget) {
            if (!current.getElement().contains(event.sourceEvent.target)) {
                return;
            }
        } else if (event.sourceEvent.target != current.getElement()) {
            return;
        }
        (_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.overrideFocusVisible(false);
        this.onHoverLikeEvent(event, current);
        if (!this.isState(32 /* Default */ )) return;
        if (current == this.chart.ctx.widgets.seriesWidget && this.checkSeriesNodeClick(event)) {
            this.update(5 /* SERIES_UPDATE */ );
            event.sourceEvent.preventDefault();
            return;
        }
        const newEvent = {
            type: event.type === "click" ? "click" : "doubleClick",
            event: event.sourceEvent
        };
        this.chart.fireEvent(newEvent);
    }
    onFocus() {
        var _this_focusIndicator;
        if (!this.isState(34 /* Focusable */ )) return;
        this.hoverDevice = ((_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.isFocusVisible(true)) ? "keyboard" : "pointer";
        this.handleFocus(0, 0);
    }
    onBlur(event) {
        var _this_focusIndicator;
        if (!this.isState(34 /* Focusable */ )) return;
        this.hoverDevice = "pointer";
        if (!this.maybeEnterInteractiveTooltip(event)) {
            this.clearAll();
        }
        (_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.overrideFocusVisible(void 0);
    }
    onKeyDown(widgetEvent) {
        if (!this.isState(43 /* Keyable */ )) return;
        const action = mapKeyboardEventToAction(widgetEvent.sourceEvent);
        if ((action === null || action === void 0 ? void 0 : action.activatesFocusIndicator) === false) {
            var _this_focusIndicator;
            (_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.overrideFocusVisible(this.previousInputDevice === "keyboard");
        }
        switch(action === null || action === void 0 ? void 0 : action.name){
            case "redo":
                return this.chart.ctx.eventsHub.emit("series:redo", null);
            case "undo":
                return this.chart.ctx.eventsHub.emit("series:undo", null);
            case "zoomin":
                return this.chart.ctx.eventsHub.emit("series:keynav-zoom", {
                    delta: 1,
                    widgetEvent
                });
            case "zoomout":
                return this.chart.ctx.eventsHub.emit("series:keynav-zoom", {
                    delta: -1,
                    widgetEvent
                });
            case "arrowup":
                return this.onArrow(-1, 0, widgetEvent);
            case "arrowdown":
                return this.onArrow(1, 0, widgetEvent);
            case "arrowleft":
                return this.onArrow(0, -1, widgetEvent);
            case "arrowright":
                return this.onArrow(0, 1, widgetEvent);
            case "submit":
                return this.onSubmit(widgetEvent);
        }
    }
    onArrow(seriesIndexDelta, datumIndexDelta, event) {
        var _this_focusIndicator;
        if (!this.isState(34 /* Focusable */ )) return;
        this.hoverDevice = "keyboard";
        this.previousInputDevice = "keyboard";
        (_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.overrideFocusVisible(true);
        this.focus.seriesIndex += seriesIndexDelta;
        this.focus.datumIndex += datumIndexDelta;
        this.handleFocus(seriesIndexDelta, datumIndexDelta);
        event.sourceEvent.preventDefault();
        this.chart.ctx.eventsHub.emit("series:focus-change", null);
    }
    onSubmit(event) {
        if (!this.isState(34 /* Focusable */ )) return;
        const { series, datum } = this.focus;
        const sourceEvent = event.sourceEvent;
        if (series != null && datum != null) {
            series.fireNodeClickEvent(sourceEvent, datum);
        } else {
            this.chart.fireEvent({
                type: "click",
                event: sourceEvent
            });
        }
        sourceEvent.preventDefault();
    }
    checkSeriesNodeClick(event) {
        var _this_tooltipCandidates_update;
        var _a;
        const result = this.pickNodes({
            x: event.currentX,
            y: event.currentY
        }, "event");
        if (result == null || result.matches.length === 0) return;
        const paginationUpdate = this.chart.tooltip.pagination ? (_this_tooltipCandidates_update = this.tooltipCandidates.update(result.matches, this.tooltipCandidates.current)) === null || _this_tooltipCandidates_update === void 0 ? void 0 : _this_tooltipCandidates_update.current : void 0;
        const { series, datum } = paginationUpdate !== null && paginationUpdate !== void 0 ? paginationUpdate : result.matches[0];
        const distance2 = paginationUpdate == null ? result.distance : 0;
        if (event.type === "click") {
            const defaultBehavior = series.fireNodeClickEvent(event.sourceEvent, datum);
            const nextTooltipCandidate = defaultBehavior && this.chart.tooltip.pagination ? this.tooltipCandidates.next() : void 0;
            if (nextTooltipCandidate != null) {
                var _this_hoverRect, _this_hoverRect1;
                event.sourceEvent.preventDefault();
                const { currentX, currentY } = event;
                var _this_hoverRect_x;
                const canvasX = currentX + ((_this_hoverRect_x = (_this_hoverRect = this.hoverRect) === null || _this_hoverRect === void 0 ? void 0 : _this_hoverRect.x) !== null && _this_hoverRect_x !== void 0 ? _this_hoverRect_x : 0);
                var _this_hoverRect_y;
                const canvasY = currentY + ((_this_hoverRect_y = (_this_hoverRect1 = this.hoverRect) === null || _this_hoverRect1 === void 0 ? void 0 : _this_hoverRect1.y) !== null && _this_hoverRect_y !== void 0 ? _this_hoverRect_y : 0);
                var _pendingHoverEvent;
                (_pendingHoverEvent = (_a = this.highlight).pendingHoverEvent) !== null && _pendingHoverEvent !== void 0 ? _pendingHoverEvent : _a.pendingHoverEvent = this.highlight.appliedHoverEvent;
                this.handleHoverHighlight(false);
                this.showTooltip(nextTooltipCandidate.current, canvasX, canvasY, {
                    index: nextTooltipCandidate.index,
                    length: nextTooltipCandidate.length
                });
            }
            return true;
        }
        if (event.type === "dblclick") {
            event.preventZoomDblClick = distance2 === 0;
            series.fireNodeDoubleClickEvent(event.sourceEvent, datum);
            return true;
        }
        return false;
    }
    handleFocus(seriesIndexDelta, datumIndexDelta) {
        const overlayFocus = this.chart.overlays.getFocusInfo(this.chart.ctx.localeManager);
        if (overlayFocus == null) {
            if (this.handleSeriesFocus(seriesIndexDelta, datumIndexDelta) === 0 /* SUCCESS */ ) {
                this.announceMode = "when-changed";
            } else {
                this.announceMode = "always";
            }
        } else {
            var _this_focusIndicator;
            (_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.update(overlayFocus.rect, this.seriesRect, false);
            this.swapChain.update(overlayFocus.text);
            this.announceMode = "always";
        }
    }
    handleSeriesFocus(otherIndexDelta, datumIndexDelta) {
        if (this.chart.chartType === "standalone") {
            return this.handleSoloSeriesFocus(otherIndexDelta, datumIndexDelta);
        }
        const { focus } = this;
        const visibleSeries = focus.sortedSeries.filter((s)=>s.visible && s.focusable);
        if (visibleSeries.length === 0) return 1 /* SERIES_NOT_FOUND */ ;
        const oldDatumIndex = focus.datumIndex - datumIndexDelta;
        const oldOtherIndex = focus.seriesIndex - otherIndexDelta;
        focus.seriesIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, focus.seriesIndex, visibleSeries.length - 1);
        focus.series = visibleSeries[focus.seriesIndex];
        const datumIndex = this.focus.datumIndex;
        const otherIndex = this.focus.seriesIndex;
        return this.updatePickedFocus(datumIndex, datumIndexDelta, oldDatumIndex, otherIndex, otherIndexDelta, oldOtherIndex);
    }
    handleSoloSeriesFocus(otherIndexDelta, datumIndexDelta) {
        this.focus.series = this.focus.sortedSeries[0];
        const datumIndex = this.focus.datumIndex;
        const otherIndex = this.focus.seriesIndex;
        const oldDatumIndex = this.focus.datumIndex - datumIndexDelta;
        const oldOtherIndex = this.focus.seriesIndex - otherIndexDelta;
        return this.updatePickedFocus(datumIndex, datumIndexDelta, oldDatumIndex, otherIndex, otherIndexDelta, oldOtherIndex);
    }
    updatePickedFocus(datumIndex, datumIndexDelta, oldDatumIndex, otherIndex, otherIndexDelta, oldOtherIndex) {
        var _focus_series, _this_focusIndicator, _this_focusIndicator1;
        const { focus, hoverRect, seriesRect } = this;
        if (focus.series == null || hoverRect == null) return 1 /* SERIES_NOT_FOUND */ ;
        const pick2 = focus === null || focus === void 0 ? void 0 : (_focus_series = focus.series) === null || _focus_series === void 0 ? void 0 : _focus_series.pickFocus({
            datumIndex,
            datumIndexDelta,
            otherIndex,
            otherIndexDelta,
            seriesRect
        });
        if (!pick2) return 2 /* DATUM_NOT_FOUND */ ;
        const { datum } = pick2;
        focus.datum = datum;
        focus.datumIndex = pick2.datumIndex;
        if (pick2.otherIndex != null) {
            focus.seriesIndex = pick2.otherIndex;
        }
        if ((_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.isFocusVisible()) {
            this.chart.ctx.animationManager.reset();
            const focusBBox = getPickedFocusBBox(pick2);
            const { x, y } = focusBBox.computeCenter();
            if (!hoverRect.containsPoint(x, y)) {
                const panSuccess = this.chart.ctx.zoomManager.panToBBox(this.id, hoverRect, focusBBox);
                if (panSuccess) {
                    return 3 /* PAN_REQUIRED */ ;
                }
            }
            const { x1, x2, y1, y2 } = Vec4.from(focusBBox);
            const nw = hoverRect.containsPoint(x1, y1);
            const ne = hoverRect.containsPoint(x2, y1);
            const sw = hoverRect.containsPoint(x1, y2);
            const se = hoverRect.containsPoint(x2, y2);
            if (!(nw || ne || sw || se)) {
                const hoverBounds = Vec4.from(hoverRect);
                pick2.movedBounds = focusBBox.clone();
                if (x1 < hoverBounds.x1 && x2 < hoverBounds.x1) {
                    pick2.movedBounds.x = hoverBounds.x1 - 2;
                    pick2.movedBounds.width = 4;
                } else if (x1 > hoverBounds.x2 && x2 > hoverBounds.x2) {
                    pick2.movedBounds.x = hoverBounds.x2 - 2;
                    pick2.movedBounds.width = 4;
                }
                if (y1 < hoverBounds.y1 && y2 < hoverBounds.y1) {
                    pick2.movedBounds.y = hoverBounds.y1 - 2;
                    pick2.movedBounds.height = 4;
                } else if (y1 > hoverBounds.y2 && y2 > hoverBounds.y2) {
                    pick2.movedBounds.y = hoverBounds.y2 - 2;
                    pick2.movedBounds.height = 4;
                }
            }
        }
        var _pick2_movedBounds;
        (_this_focusIndicator1 = this.focusIndicator) === null || _this_focusIndicator1 === void 0 ? void 0 : _this_focusIndicator1.update((_pick2_movedBounds = pick2.movedBounds) !== null && _pick2_movedBounds !== void 0 ? _pick2_movedBounds : pick2.bounds, this.seriesRect, pick2.clipFocusBox);
        const keyboardEvent = makeKeyboardPointerEvent(focus.series, hoverRect, pick2);
        if (keyboardEvent != null && this.hoverDevice === "keyboard") {
            this.tooltip.lastHover = void 0;
            this.highlight.appliedHoverEvent = void 0;
            this.highlight.pendingHoverEvent = void 0;
            this.highlight.stashedHoverEvent = void 0;
            const tooltipContent = this.getTooltipContent(focus.series, datum.datumIndex, datum, "aria-label");
            const meta = TooltipManager.makeTooltipMeta(keyboardEvent, focus.series, datum, pick2.movedBounds);
            this.chart.ctx.highlightManager.updateHighlight(this.id, datum);
            if (this.isTooltipEnabled(focus.series)) {
                this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, tooltipContent);
            }
            this.maybeAnnouncePickedFocus(datumIndexDelta, oldDatumIndex, otherIndexDelta, oldOtherIndex, pick2, tooltipContent);
        }
        return 0 /* SUCCESS */ ;
    }
    maybeAnnouncePickedFocus(datumIndexDelta, oldDatumIndex, otherIndexDelta, oldOtherIndex, pick2, tooltipContent) {
        const { focus } = this;
        let mode;
        if (this.announceMode === "when-changed") {
            var _pick2_otherIndex;
            const shouldAnnouncePick = datumIndexDelta === 0 && otherIndexDelta === 0 || oldDatumIndex !== pick2.datumIndex || oldOtherIndex !== ((_pick2_otherIndex = pick2.otherIndex) !== null && _pick2_otherIndex !== void 0 ? _pick2_otherIndex : focus.seriesIndex);
            if (shouldAnnouncePick) {
                mode = "always";
            } else {
                mode = "never";
            }
        } else {
            mode = this.announceMode;
        }
        if (mode === "always") {
            this.swapChain.update(this.getDatumAriaText(pick2.datum, tooltipContent));
        }
    }
    getDatumAriaText(datum, tooltipContent) {
        var _datum_series_getDatumAriaText, _datum_series;
        const description = tooltipContent == null ? "" : tooltipContentAriaLabel(tooltipContent);
        var _datum_series_getDatumAriaText1;
        return this.chart.ctx.localeManager.t("ariaAnnounceHoverDatum", {
            datum: (_datum_series_getDatumAriaText1 = (_datum_series_getDatumAriaText = (_datum_series = datum.series).getDatumAriaText) === null || _datum_series_getDatumAriaText === void 0 ? void 0 : _datum_series_getDatumAriaText.call(_datum_series, datum, description)) !== null && _datum_series_getDatumAriaText1 !== void 0 ? _datum_series_getDatumAriaText1 : description
        });
    }
    clearHighlight() {
        this.highlight.pendingHoverEvent = void 0;
        this.highlight.appliedHoverEvent = void 0;
        this.chart.ctx.highlightManager.updateHighlight(this.id);
    }
    clearTooltip() {
        this.chart.ctx.tooltipManager.removeTooltip(this.id);
        this.tooltip.lastHover = void 0;
    }
    clearAll() {
        var _this_focusIndicator;
        this.clearHighlight();
        this.clearTooltip();
        (_this_focusIndicator = this.focusIndicator) === null || _this_focusIndicator === void 0 ? void 0 : _this_focusIndicator.clear();
    }
    handleHoverHighlight(redisplay) {
        var _this_hoverRect, _this_hoverRect1, _this_hoverRect2;
        this.highlight.appliedHoverEvent = this.highlight.pendingHoverEvent;
        this.highlight.pendingHoverEvent = void 0;
        const event = this.highlight.appliedHoverEvent;
        if (!event || !this.isState(41 /* Clickable */ )) return;
        const { currentX, currentY } = event;
        var _this_hoverRect_x;
        const canvasX = event.currentX + ((_this_hoverRect_x = (_this_hoverRect = this.hoverRect) === null || _this_hoverRect === void 0 ? void 0 : _this_hoverRect.x) !== null && _this_hoverRect_x !== void 0 ? _this_hoverRect_x : 0);
        var _this_hoverRect_y;
        const canvasY = event.currentY + ((_this_hoverRect_y = (_this_hoverRect1 = this.hoverRect) === null || _this_hoverRect1 === void 0 ? void 0 : _this_hoverRect1.y) !== null && _this_hoverRect_y !== void 0 ? _this_hoverRect_y : 0);
        if (redisplay ? this.chart.ctx.animationManager.isActive() : !((_this_hoverRect2 = this.hoverRect) === null || _this_hoverRect2 === void 0 ? void 0 : _this_hoverRect2.containsPoint(canvasX, canvasY))) {
            this.clearHighlight();
            return;
        }
        const { range: range3 } = this.chart.highlight;
        const intent = range3 === "tooltip" ? "highlight-tooltip" : "highlight";
        const pick2 = this.pickNodes({
            x: currentX,
            y: currentY
        }, intent);
        if (!pick2 || pick2.matches.length === 0) {
            this.chart.ctx.highlightManager.updateHighlight(this.id);
            return;
        }
        const { current: tooltipPick } = this.tooltipCandidates;
        const tooltipMatch = tooltipPick == null ? void 0 : pick2.matches.find((m)=>pickedNodesEqual(m, tooltipPick));
        var _tooltipMatch_datum;
        const datum = (_tooltipMatch_datum = tooltipMatch === null || tooltipMatch === void 0 ? void 0 : tooltipMatch.datum) !== null && _tooltipMatch_datum !== void 0 ? _tooltipMatch_datum : pick2.matches[0].datum;
        this.chart.ctx.highlightManager.updateHighlight(this.id, datum);
        this.hoverDevice = "pointer";
    }
    handleHoverTooltip(event, redisplay) {
        var _this_hoverRect, _this_hoverRect1, _this_hoverRect2;
        const { current: previousHover } = this.tooltipCandidates;
        this.tooltipCandidates.reset();
        if (!this.isState(41 /* Clickable */ )) return;
        const { currentX, currentY } = event;
        var _this_hoverRect_x;
        const canvasX = currentX + ((_this_hoverRect_x = (_this_hoverRect = this.hoverRect) === null || _this_hoverRect === void 0 ? void 0 : _this_hoverRect.x) !== null && _this_hoverRect_x !== void 0 ? _this_hoverRect_x : 0);
        var _this_hoverRect_y;
        const canvasY = currentY + ((_this_hoverRect_y = (_this_hoverRect1 = this.hoverRect) === null || _this_hoverRect1 === void 0 ? void 0 : _this_hoverRect1.y) !== null && _this_hoverRect_y !== void 0 ? _this_hoverRect_y : 0);
        const targetElement = event.sourceEvent.target;
        if (redisplay ? this.chart.ctx.animationManager.isActive() : !((_this_hoverRect2 = this.hoverRect) === null || _this_hoverRect2 === void 0 ? void 0 : _this_hoverRect2.containsPoint(canvasX, canvasY))) {
            if (this.hoverDevice == "pointer") this.clearTooltip();
            return;
        }
        if (targetElement && this.chart.tooltip.interactive && this.chart.ctx.domManager.isManagedChildDOMElement(targetElement, "canvas-overlay", DEFAULT_TOOLTIP_CLASS)) {
            return;
        }
        const pick2 = this.pickNodes({
            x: event.currentX,
            y: event.currentY
        }, "tooltip");
        if (!pick2 || pick2.matches.length === 0) {
            if (this.hoverDevice == "pointer") this.clearTooltip();
            return;
        }
        this.hoverDevice = "pointer";
        if (pick2.distance === 0) {
            const { current, index, length: length2 } = this.tooltipCandidates.update(pick2.matches, this.chart.tooltip.pagination ? previousHover : void 0);
            this.showTooltip(current, canvasX, canvasY, {
                index,
                length: length2
            });
        } else {
            this.showTooltip(pick2.matches[0], canvasX, canvasY);
        }
    }
    showTooltip(param, canvasX, canvasY, pagination) {
        let { series, datum, datumIndex } = param;
        const tooltipContent = this.getTooltipContent(series, datumIndex, datum, "tooltip");
        const shouldUpdateTooltip = tooltipContent != null;
        if (shouldUpdateTooltip) {
            const meta = TooltipManager.makeTooltipMeta({
                type: "pointermove",
                canvasX,
                canvasY
            }, series, datum, void 0);
            this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, tooltipContent, pagination);
        } else {
            this.chart.ctx.tooltipManager.removeTooltip(this.id);
        }
    }
    maybeEnterInteractiveTooltip(event) {
        return this.chart.tooltip.maybeEnterInteractiveTooltip(event, ()=>{
            this.tooltip.lastHover = void 0;
            this.chart.ctx.tooltipManager.removeTooltip(this.id);
            this.chart.ctx.highlightManager.updateHighlight(this.id);
        });
    }
    changeHighlightDatum(event) {
        var _event_previousHighlight, _event_currentHighlight, _event_previousHighlight1, _event_currentHighlight1;
        const lastSeries = (_event_previousHighlight = event.previousHighlight) === null || _event_previousHighlight === void 0 ? void 0 : _event_previousHighlight.series;
        const newSeries = (_event_currentHighlight = event.currentHighlight) === null || _event_currentHighlight === void 0 ? void 0 : _event_currentHighlight.series;
        if ((lastSeries === null || lastSeries === void 0 ? void 0 : lastSeries.properties.cursor) && ((_event_previousHighlight1 = event.previousHighlight) === null || _event_previousHighlight1 === void 0 ? void 0 : _event_previousHighlight1.datum)) {
            this.chart.ctx.domManager.updateCursor(lastSeries.id);
        }
        if ((newSeries === null || newSeries === void 0 ? void 0 : newSeries.properties.cursor) && newSeries.properties.cursor !== "default" && ((_event_currentHighlight1 = event.currentHighlight) === null || _event_currentHighlight1 === void 0 ? void 0 : _event_currentHighlight1.datum)) {
            this.chart.ctx.domManager.updateCursor(newSeries.id, newSeries.properties.cursor);
        }
        if (newSeries == null || lastSeries == null) {
            this.update(5 /* SERIES_UPDATE */ );
        } else {
            this.update(5 /* SERIES_UPDATE */ , {
                seriesToUpdate: new Set([
                    lastSeries,
                    newSeries
                ].filter(Boolean))
            });
        }
    }
    pickNodes(point, intent, exactMatchOnly) {
        const reverseSeries = [
            ...this.series
        ].reverse();
        let result;
        for (const series of reverseSeries){
            if (!series.visible || !series.contentGroup.visible) continue;
            const pick2 = series.pickNodes(point, intent, exactMatchOnly);
            if (pick2 == null || pick2.datums.length === 0) continue;
            const { datums, distance: distance2 } = pick2;
            if (pick2.datums.length === 0) continue;
            if (distance2 === 0) {
                if ((result === null || result === void 0 ? void 0 : result.distance) !== 0) {
                    result = {
                        matches: [],
                        distance: 0
                    };
                }
                for (const datum of datums){
                    const { datumIndex } = datum;
                    result.matches.push({
                        series,
                        datum,
                        datumIndex
                    });
                }
            } else if (result == null || result.distance > distance2) {
                const [datum] = datums;
                const { datumIndex } = datum;
                result = {
                    matches: [
                        {
                            series,
                            datum,
                            datumIndex
                        }
                    ],
                    distance: distance2
                };
            }
        }
        return result;
    }
    isTooltipEnabled(series) {
        var _series_tooltipEnabled;
        return (_series_tooltipEnabled = series.tooltipEnabled) !== null && _series_tooltipEnabled !== void 0 ? _series_tooltipEnabled : this.chart.tooltip.enabled;
    }
    getTooltipContent(series, datumIndex, datum, purpose) {
        let result;
        if (purpose === "aria-label" || this.isTooltipEnabled(series)) {
            const { cachedTooltipContent } = this;
            if (cachedTooltipContent != null && cachedTooltipContent.series === series && cachedTooltipContent.datumIndex === datumIndex) {
                result = cachedTooltipContent.content;
            } else {
                const content = this.chart.getTooltipContent(series, datumIndex, datum);
                this.cachedTooltipContent = {
                    series,
                    datumIndex,
                    content
                };
                result = content;
            }
            purpose;
            result;
        } else {
            this.cachedTooltipContent = void 0;
            purpose;
            result;
        }
        return result;
    }
    constructor(chart){
        super();
        this.chart = chart;
        this.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createId"])(this);
        this.series = [];
        this.announceMode = "when-changed";
        this.highlight = {
            /** Last received event that still needs to be applied. */ pendingHoverEvent: void 0,
            /** Last applied event. */ appliedHoverEvent: void 0,
            /** Last applied event, which has been temporarily stashed during the main chart update cycle. */ stashedHoverEvent: void 0
        };
        this.tooltip = {
            lastHover: void 0
        };
        /**
     * A11y Requirements for Tooltip/Highlight (see AG-13051 for details):
     *
     *   -   When the series-area is blurred, always the mouse to update the tooltip/highlight.
     *
     *   -   When the series-area receives a `focus` event, use `:focus-visible` to guess the input device.
     *       (this is decided by the browser).
     *
     *   -   For keyboard users, `focus` and `keydown` events always updates & shows the tooltip/highlight on
     *       the currently (or newly) focused datum.
     *
     *   -   For keyboard users, `mousemove` events update the tooltip/highlight iff `pickNode` finds a match
     *       for the mouse event offsets.
     */ this.hoverDevice = "pointer";
        /**
     * This is the "second last" input event. It can be useful for keydown
     * events that for which don't to set the isFocusVisible state
     * (e.g. Backspace/Delete key on FC annotations, see AG-13041).
     *
     * Use with caution! The focus indicator must ALWAYS be visible for
     * keyboard-only users.
     */ this.previousInputDevice = "keyboard";
        this.focus = {
            sortedSeries: [],
            series: void 0,
            seriesIndex: 0,
            datumIndex: 0,
            datum: void 0
        };
        this.cachedTooltipContent = void 0;
        this.hoverScheduler = debouncedAnimationFrame(()=>{
            if (!this.tooltip.lastHover && !this.highlight.pendingHoverEvent) return;
            if (this.chart.getUpdateType() <= 5 /* SERIES_UPDATE */ ) {
                this.hoverScheduler.schedule();
                return;
            }
            if (this.highlight.pendingHoverEvent) {
                this.handleHoverHighlight(false);
            }
            if (this.tooltip.lastHover) {
                this.handleHoverTooltip(this.tooltip.lastHover, false);
            }
        });
        this.tooltipCandidates = new PickedNodeState();
        const initialAltText = chart.ctx.localeManager.t("ariaInitSeriesArea");
        const label1 = chart.ctx.domManager.addChild("series-area", "series-area-aria-label1");
        const label2 = chart.ctx.domManager.addChild("series-area", "series-area-aria-label2");
        this.swapChain = new FocusSwapChain(label1, label2, "img", initialAltText);
        this.swapChain.addListener("blur", (event)=>this.onBlur(event));
        this.swapChain.addListener("focus", ()=>this.onFocus());
        if (chart.ctx.domManager.mode === "normal") {
            this.focusIndicator = new FocusIndicator(this.swapChain);
            this.focusIndicator.overrideFocusVisible(chart.mode === "integrated" ? false : void 0);
        }
        const { seriesDragInterpreter, seriesWidget, containerWidget } = chart.ctx.widgets;
        seriesWidget.setTabIndex(-1);
        this.cleanup.register(()=>chart.ctx.domManager.removeChild("series-area", "series-area-aria-label1"), ()=>chart.ctx.domManager.removeChild("series-area", "series-area-aria-label2"), seriesWidget.addListener("focus", ()=>this.swapChain.focus({
                preventScroll: true
            })), seriesWidget.addListener("mousemove", (event)=>this.onHover(event, seriesWidget)), seriesWidget.addListener("wheel", (event)=>this.onWheel(event)), seriesWidget.addListener("mouseleave", (event)=>this.onLeave(event)), seriesWidget.addListener("keydown", (event)=>this.onKeyDown(event)), seriesWidget.addListener("contextmenu", (event, current)=>this.onContextMenu(event, current)), containerWidget.addListener("contextmenu", (event, current)=>this.onContextMenu(event, current)), containerWidget.addListener("click", (event, current)=>this.onClick(event, current)), containerWidget.addListener("dblclick", (event, current)=>this.onClick(event, current)), chart.ctx.animationManager.addListener("animation-start", ()=>this.clearAll()), chart.ctx.eventsHub.on("dom:resize", ()=>this.clearAll()), chart.ctx.eventsHub.on("highlight:change", (event)=>this.changeHighlightDatum(event)), chart.ctx.eventsHub.on("layout:complete", (event)=>this.layoutComplete(event)), chart.ctx.updateService.addListener("pre-scene-render", ()=>this.preSceneRender()), chart.ctx.updateService.addListener("update-complete", ()=>this.updateComplete()), chart.ctx.eventsHub.on("zoom:change", ()=>this.clearAll()), chart.ctx.eventsHub.on("zoom:pan-start", ()=>this.clearAll()));
        if (seriesDragInterpreter) {
            this.cleanup.register(seriesDragInterpreter.events.on("drag-move", (event)=>this.onDragMove(event, seriesWidget)), seriesDragInterpreter.events.on("click", (event)=>this.onClick(event, seriesWidget)), seriesDragInterpreter.events.on("dblclick", (event)=>this.onClick(event, seriesWidget)));
        }
    }
};
function excludesType(obj, excluded) {
    return obj.type !== excluded;
}
;
var SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;
var SeriesLayerManager = class {
    setSeriesCount(count) {
        this.expectedSeriesCount = count;
    }
    getGroupIndex(seriesConfig) {
        const { internalId, seriesGrouping } = seriesConfig;
        var _seriesGrouping_groupIndex;
        return (_seriesGrouping_groupIndex = seriesGrouping === null || seriesGrouping === void 0 ? void 0 : seriesGrouping.groupIndex) !== null && _seriesGrouping_groupIndex !== void 0 ? _seriesGrouping_groupIndex : internalId;
    }
    getGroupType(seriesConfig, bringToFront) {
        return bringToFront ? "top" : seriesConfig.type;
    }
    requestGroup(seriesConfig) {
        const { internalId, contentGroup: seriesContentGroup } = seriesConfig;
        const bringToFront = seriesConfig.bringToFront();
        const type = this.getGroupType(seriesConfig, bringToFront);
        const groupIndex = this.getGroupIndex(seriesConfig);
        const seriesInfo = this.series.get(internalId);
        if (seriesInfo != null) {
            throw new Error("AG Charts - series already has an allocated layer: ".concat(JSON.stringify(seriesInfo)));
        }
        if (this.series.size === 0) {
            this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? "aggressive-grouping" : "normal";
        }
        let group = this.groups.get(type);
        if (group == null) {
            group = /* @__PURE__ */ new Map();
            this.groups.set(type, group);
        }
        const lookupIndex = this.lookupIdx(groupIndex);
        let groupInfo = group.get(lookupIndex);
        if (groupInfo == null) {
            var _seriesConfig_contentGroup_name;
            groupInfo = {
                type,
                id: lookupIndex,
                seriesIds: [],
                group: this.seriesRoot.appendChild(new Group({
                    name: "".concat((_seriesConfig_contentGroup_name = seriesConfig.contentGroup.name) !== null && _seriesConfig_contentGroup_name !== void 0 ? _seriesConfig_contentGroup_name : type, "-managed-layer"),
                    zIndex: seriesConfig.contentGroup.zIndex,
                    // Set in updateLayerCompositing
                    renderToOffscreenCanvas: false
                }))
            };
            group.set(lookupIndex, groupInfo);
        }
        this.series.set(internalId, {
            layerState: groupInfo,
            seriesConfig,
            bringToFront
        });
        groupInfo.seriesIds.push(internalId);
        groupInfo.group.appendChild(seriesContentGroup);
        return groupInfo.group;
    }
    changeGroup(seriesConfig) {
        var _this_groups_get;
        const { internalId, contentGroup } = seriesConfig;
        const bringToFront = seriesConfig.bringToFront();
        const type = this.getGroupType(seriesConfig, bringToFront);
        const oldGroup = this.series.get(internalId);
        const oldType = oldGroup ? this.getGroupType(oldGroup.seriesConfig, oldGroup.bringToFront) : void 0;
        const groupIndex = this.getGroupIndex(seriesConfig);
        const lookupIndex = this.lookupIdx(groupIndex);
        const groupInfo = (_this_groups_get = this.groups.get(type)) === null || _this_groups_get === void 0 ? void 0 : _this_groups_get.get(lookupIndex);
        if (oldType === type && (groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.seriesIds.includes(internalId)) === true) {
            return;
        }
        if (this.series.has(internalId)) {
            this._releaseGroup({
                internalId,
                contentGroup,
                type: oldType
            });
        }
        return this.requestGroup(seriesConfig);
    }
    releaseGroup(seriesConfig) {
        const { internalId, contentGroup } = seriesConfig;
        const type = this.getGroupType(seriesConfig, seriesConfig.bringToFront());
        this._releaseGroup({
            internalId,
            contentGroup,
            type
        });
    }
    _releaseGroup(seriesConfig) {
        var _this_series_get;
        const { internalId, contentGroup, type } = seriesConfig;
        if (!this.series.has(internalId)) {
            throw new Error("AG Charts - series doesn't have an allocated layer: ".concat(internalId));
        }
        const groupInfo = (_this_series_get = this.series.get(internalId)) === null || _this_series_get === void 0 ? void 0 : _this_series_get.layerState;
        if (groupInfo) {
            groupInfo.seriesIds = groupInfo.seriesIds.filter((v)=>v !== internalId);
            groupInfo.group.removeChild(contentGroup);
        }
        if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.seriesIds.length) === 0) {
            var _this_groups_get, _this_groups_get1;
            this.seriesRoot.removeChild(groupInfo.group);
            (_this_groups_get = this.groups.get(groupInfo.type)) === null || _this_groups_get === void 0 ? void 0 : _this_groups_get.delete(groupInfo.id);
            (_this_groups_get1 = this.groups.get(type)) === null || _this_groups_get1 === void 0 ? void 0 : _this_groups_get1.delete(internalId);
        } else if (groupInfo != null && groupInfo.seriesIds.length > 0) {
            groupInfo.group.zIndex = this.getLowestSeriesZIndex(groupInfo.seriesIds);
        }
        this.series.delete(internalId);
    }
    updateLayerCompositing() {
        this.groups.forEach((groups)=>{
            groups.forEach((groupInfo)=>{
                const { group, seriesIds } = groupInfo;
                let renderToOffscreenCanvas;
                if (seriesIds.length === 0) {
                    renderToOffscreenCanvas = false;
                } else if (seriesIds.length > 1) {
                    renderToOffscreenCanvas = true;
                } else {
                    const series = this.series.get(seriesIds[0]);
                    renderToOffscreenCanvas = (series === null || series === void 0 ? void 0 : series.seriesConfig.renderToOffscreenCanvas()) === true;
                }
                group.renderToOffscreenCanvas = renderToOffscreenCanvas;
                group.zIndex = this.getLowestSeriesZIndex(seriesIds);
            });
        });
    }
    lookupIdx(groupIndex) {
        if (this.mode === "normal") {
            return groupIndex;
        }
        if (typeof groupIndex === "string") {
            groupIndex = Number(groupIndex.split("-").at(-1));
            if (!Number.isFinite(groupIndex)) {
                return 0;
            }
        }
        return Math.floor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION);
    }
    destroy() {
        this.groups.forEach((groups)=>{
            groups.forEach((groupInfo)=>{
                this.seriesRoot.removeChild(groupInfo.group);
            });
        });
        this.groups.clear();
        this.series.clear();
    }
    getLowestSeriesZIndex(seriesIds) {
        let lowestSeriesZIndex = void 0;
        for (const seriesId of seriesIds){
            const series = this.series.get(seriesId);
            var _series_seriesConfig_contentGroup_zIndex;
            const zIndex = (_series_seriesConfig_contentGroup_zIndex = series === null || series === void 0 ? void 0 : series.seriesConfig.contentGroup.zIndex) !== null && _series_seriesConfig_contentGroup_zIndex !== void 0 ? _series_seriesConfig_contentGroup_zIndex : 1 /* ANY_CONTENT */ ;
            if (lowestSeriesZIndex == null || zIndex == null) {
                lowestSeriesZIndex = zIndex;
                continue;
            }
            lowestSeriesZIndex = compareZIndex(lowestSeriesZIndex, zIndex) <= 0 ? lowestSeriesZIndex : zIndex;
        }
        return lowestSeriesZIndex !== null && lowestSeriesZIndex !== void 0 ? lowestSeriesZIndex : 1 /* ANY_CONTENT */ ;
    }
    constructor(seriesRoot){
        this.seriesRoot = seriesRoot;
        this.groups = /* @__PURE__ */ new Map();
        this.series = /* @__PURE__ */ new Map();
        this.expectedSeriesCount = 1;
        this.mode = "normal";
    }
};
// packages/ag-charts-community/src/chart/touch.ts
var Touch = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.dragAction = "drag";
    }
};
__decorateClass([
    Property
], Touch.prototype, "dragAction", 2);
;
var DataWindowProcessor = class {
    destroy() {
        this.cleanup.flush();
    }
    onDataLoad() {
        this.animationManager.skip();
        this.updateService.update(1 /* UPDATE_DATA */ );
    }
    onDataError() {
        this.updateService.update(4 /* PERFORM_LAYOUT */ );
    }
    onDataSourceChange() {
        this.dirtyDataSource = true;
    }
    onUpdateComplete(event) {
        if (!event.apiUpdate && !this.dirtyZoom && !this.dirtyDataSource) return;
        this.updateWindow(event);
    }
    onZoomChange() {
        this.dirtyZoom = true;
    }
    updateWindow(event) {
        if (!this.dataService.isLazy()) return;
        const axis = this.getValidAxis();
        let window2;
        let shouldRefresh = true;
        if (axis) {
            const zoom = this.zoomManager.getAxisZoom(axis.id);
            if (zoom.min !== 0 || zoom.max !== 1) {
                window2 = this.getAxisWindow(axis, zoom);
            }
            shouldRefresh = this.shouldRefresh(event, axis, zoom);
        }
        this.dirtyZoom = false;
        this.dirtyDataSource = false;
        if (!shouldRefresh) return;
        this.dataService.load({
            windowStart: window2 === null || window2 === void 0 ? void 0 : window2.min,
            windowEnd: window2 === null || window2 === void 0 ? void 0 : window2.max
        });
    }
    getValidAxis() {
        return this.chart.axes.find((axis)=>axis.type === "time");
    }
    shouldRefresh(event, axis, zoom) {
        if (event.apiUpdate) return true;
        if (this.dirtyDataSource) return true;
        if (!this.dirtyZoom) return false;
        const lastZoom = this.lastAxisZooms.get(axis.id);
        if (lastZoom && zoom.min === lastZoom.min && zoom.max === lastZoom.max) {
            return false;
        }
        this.lastAxisZooms.set(axis.id, zoom);
        return true;
    }
    getAxisWindow(axis, zoom) {
        const { domain } = axis.scale;
        if (!zoom || domain.length === 0 || isNaN(Number(domain[0]))) return;
        const diff2 = Number(domain[1]) - Number(domain[0]);
        const min = new Date(Number(domain[0]) + diff2 * zoom.min);
        const max = new Date(Number(domain[0]) + diff2 * zoom.max);
        return {
            min,
            max
        };
    }
    constructor(chart, eventsHub, dataService, updateService, zoomManager, animationManager){
        this.chart = chart;
        this.eventsHub = eventsHub;
        this.dataService = dataService;
        this.updateService = updateService;
        this.zoomManager = zoomManager;
        this.animationManager = animationManager;
        this.dirtyZoom = false;
        this.dirtyDataSource = false;
        this.lastAxisZooms = /* @__PURE__ */ new Map();
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.cleanup.register(this.eventsHub.on("data:source-change", ()=>this.onDataSourceChange()), this.eventsHub.on("data:load", ()=>this.onDataLoad()), this.eventsHub.on("data:error", ()=>this.onDataError()), this.updateService.addListener("update-complete", (e)=>this.onUpdateComplete(e)), this.eventsHub.on("zoom:change", ()=>this.onZoomChange()));
    }
};
;
;
var isSafariRegexp = /^((?!chrome|android).)*safari/i;
var safariVersionRegexp = /Version\/(\d+(\.\d+)?)/;
var isChromeRegexp = /Chrome/;
var chromeVersionRegexp = /Chrome\/(\d+)/;
var isEdge = /Edg/;
var isOpera = /OPR/;
function isUnsupportedBrowser() {
    const { userAgent } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])("navigator");
    if (isSafariRegexp.test(userAgent)) {
        const versionExec = safariVersionRegexp.exec(userAgent);
        if (versionExec == null) return false;
        const version = parseFloat(versionExec[1]);
        const supported = Math.floor(version) > 16;
        if (!supported) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Unsupported Safari version: ".concat(version, "; ").concat(userAgent));
        }
        return !supported;
    } else if (isChromeRegexp.test(userAgent) && !isEdge.test(userAgent) && !isOpera.test(userAgent)) {
        const versionExec = chromeVersionRegexp.exec(userAgent);
        if (versionExec == null) return false;
        const version = parseInt(versionExec[1], 10);
        const supported = version > 126;
        if (!supported) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("Unsupported Chrome version: ".concat(version, "; ").concat(userAgent));
        }
        return !supported;
    }
    return false;
}
// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts
var visibleIgnoredSeries = /* @__PURE__ */ new Set([
    "map-shape-background",
    "map-line-background"
]);
var OverlaysProcessor = class {
    destroy() {
        this.cleanup.flush();
        this.domManager.removeChild("canvas-overlay", "overlay");
    }
    onLayoutComplete(param) {
        let { series: { rect } } = param;
        const isLoading = this.dataService.isLoading();
        const hasData = this.chartLike.series.some((s)=>s.hasData);
        const anySeriesVisible = this.chartLike.series.some((s)=>s.visible && !visibleIgnoredSeries.has(s.type));
        if (this.overlays.darkTheme) {
            this.overlayElem.classList.add(DEFAULT_OVERLAY_DARK_CLASS);
        } else {
            this.overlayElem.classList.remove(DEFAULT_OVERLAY_DARK_CLASS);
        }
        this.overlayElem.style.left = "".concat(rect.x, "px");
        this.overlayElem.style.top = "".concat(rect.y, "px");
        this.overlayElem.style.width = "".concat(rect.width, "px");
        this.overlayElem.style.height = "".concat(rect.height, "px");
        const loadingShown = isLoading;
        const noDataShown = !isLoading && !hasData;
        const noVisibleSeriesShown = hasData && !anySeriesVisible;
        const unsupportedBrowser = this.overlays.unsupportedBrowser.enabled && isUnsupportedBrowser();
        if (loadingShown) {
            this.showOverlay(this.overlays.loading, rect);
        } else {
            this.hideOverlay(this.overlays.loading);
        }
        if (noDataShown) {
            this.showOverlay(this.overlays.noData, rect);
        } else {
            this.hideOverlay(this.overlays.noData);
        }
        if (noVisibleSeriesShown) {
            this.showOverlay(this.overlays.noVisibleSeries, rect);
        } else {
            this.hideOverlay(this.overlays.noVisibleSeries);
        }
        if (unsupportedBrowser) {
            this.showOverlay(this.overlays.unsupportedBrowser, rect);
        } else {
            this.hideOverlay(this.overlays.unsupportedBrowser);
        }
        const shown = loadingShown || noDataShown || noVisibleSeriesShown || unsupportedBrowser;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.overlayElem, "aria-hidden", !shown);
    }
    showOverlay(overlay, seriesRect) {
        if (!overlay.enabled) return;
        const element2 = overlay.getElement(this.chartLike, this.animationManager, this.localeManager, seriesRect);
        this.overlayElem.appendChild(element2);
    }
    hideOverlay(overlay) {
        overlay.removeElement(()=>{
            this.overlayElem.innerText = "\xA0";
        }, this.animationManager);
    }
    constructor(chartLike, overlays, eventsHub, dataService, localeManager, animationManager, domManager){
        this.chartLike = chartLike;
        this.overlays = overlays;
        this.eventsHub = eventsHub;
        this.dataService = dataService;
        this.localeManager = localeManager;
        this.animationManager = animationManager;
        this.domManager = domManager;
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.overlayElem = this.domManager.addChild("canvas-overlay", "overlay");
        this.overlayElem.role = "status";
        this.overlayElem.ariaAtomic = "false";
        this.overlayElem.ariaLive = "polite";
        this.overlayElem.classList.toggle(DEFAULT_OVERLAY_CLASS);
        this.cleanup.register(this.eventsHub.on("layout:complete", (e)=>this.onLayoutComplete(e)));
    }
};
// packages/ag-charts-community/src/chart/chart.ts
var debug = Debug.create(true, "opts");
var _Chart = class _Chart extends Observable {
    static getInstance(element2) {
        return _Chart.chartsInstances.get(element2);
    }
    /** NOTE: This is exposed for use by Integrated charts only. */ get canvasElement() {
        return this.ctx.scene.canvas.element;
    }
    download(fileName, fileFormat) {
        this.ctx.scene.download(fileName, fileFormat);
    }
    getCanvasDataURL(fileFormat) {
        return this.ctx.scene.getDataURL(fileFormat);
    }
    toSVG() {
        return this.ctx.scene.toSVG();
    }
    get seriesAreaBoundingBox() {
        return this.seriesAreaManager.bbox;
    }
    getOptions() {
        var _this_queuedUserOptions_at;
        return (_this_queuedUserOptions_at = this.queuedUserOptions.at(-1)) !== null && _this_queuedUserOptions_at !== void 0 ? _this_queuedUserOptions_at : this.chartOptions.userOptions;
    }
    getChartOptions() {
        var _this_queuedChartOptions_at;
        return (_this_queuedChartOptions_at = this.queuedChartOptions.at(-1)) !== null && _this_queuedChartOptions_at !== void 0 ? _this_queuedChartOptions_at : this.chartOptions;
    }
    overrideFocusVisible(visible) {
        var _this_seriesAreaManager_focusIndicator;
        (_this_seriesAreaManager_focusIndicator = this.seriesAreaManager.focusIndicator) === null || _this_seriesAreaManager_focusIndicator === void 0 ? void 0 : _this_seriesAreaManager_focusIndicator.overrideFocusVisible(visible);
    }
    fireEvent(event) {
        callWithContext(this, this.fireEventWrapper, event);
    }
    initSeriesAreaDependencies() {
        const { ctx, tooltip, highlight: highlight5, overlays, seriesRoot, mode } = this;
        const chartType = this.getChartType();
        const fireEvent = this.fireEvent.bind(this);
        const getUpdateType = ()=>this.performUpdateType;
        const getTooltipContent = (series, datumIndex, removeThisDatum)=>this.getTooltipContent(series, datumIndex, removeThisDatum);
        return {
            fireEvent,
            getUpdateType,
            getTooltipContent,
            chartType,
            ctx,
            tooltip,
            highlight: highlight5,
            overlays,
            seriesRoot,
            mode
        };
    }
    getModuleContext() {
        return this.ctx;
    }
    getTooltipContent(series, datumIndex, removeMeDatum) {
        const baseTooltipContent = series.properties.tooltip.enabled !== false ? series.getTooltipContent(datumIndex, removeMeDatum) : void 0;
        const tooltipContent = baseTooltipContent == null ? [] : [
            baseTooltipContent
        ];
        if (this.tooltip.mode !== "shared" || this.series.length === 1) {
            return tooltipContent;
        }
        const categoryValue = series.getCategoryValue(datumIndex);
        if (categoryValue == null) return tooltipContent;
        return this.series.flatMap((s)=>{
            if (s === series) return tooltipContent;
            if (!s.isEnabled() || s.properties.tooltip.enabled === false) return [];
            const seriesDatumIndex = s.datumIndexForCategoryValue(categoryValue);
            const seriesTooltipContent = seriesDatumIndex == null ? void 0 : s.getTooltipContent(seriesDatumIndex, void 0);
            return seriesTooltipContent == null ? [] : [
                seriesTooltipContent
            ];
        });
    }
    getCaptionText() {
        return [
            this.title,
            this.subtitle,
            this.footnote
        ].filter((caption)=>caption.enabled && caption.text).map((caption)=>caption.text).join(". ");
    }
    getAriaLabel() {
        return this.ctx.localeManager.t("ariaAnnounceChart", {
            seriesCount: this.series.length
        });
    }
    resetAnimations() {
        this.chartAnimationPhase = "initial";
        for (const series of this.series){
            series.resetAnimation(this.chartAnimationPhase);
        }
        for (const axis of this.axes){
            axis.resetAnimation(this.chartAnimationPhase);
        }
        this.animationRect = void 0;
        this.ctx.animationManager.reset();
    }
    skipAnimations() {
        this.ctx.animationManager.skipCurrentBatch();
        this._performUpdateSkipAnimations = true;
    }
    detachAndClear() {
        this.container = void 0;
        this.ctx.scene.clearCanvas();
    }
    destroy(opts) {
        if (this.destroyed) {
            return;
        }
        const keepTransferableResources = opts === null || opts === void 0 ? void 0 : opts.keepTransferableResources;
        let result;
        this.performUpdateType = 8 /* NONE */ ;
        this.cleanup.flush();
        this.processors.forEach((p)=>p.destroy());
        this.overlays.destroy();
        this.modulesManager.destroy();
        if (keepTransferableResources) {
            this.ctx.scene.strip();
            result = {
                container: this.container,
                scene: this.ctx.scene
            };
        } else {
            this.ctx.scene.destroy();
            this.container = void 0;
        }
        this.destroySeries(this.series);
        this.seriesLayerManager.destroy();
        this.axes.forEach((a)=>a.destroy());
        this.axes = [];
        this.animationRect = void 0;
        this.ctx.destroy();
        this.destroyed = true;
        Object.freeze(this);
        return result;
    }
    requestFactoryUpdate(cb) {
        if (this.destroyed) return;
        this._pendingFactoryUpdatesCount++;
        this.updateMutex.acquire(async ()=>{
            if (this.destroyed) return;
            try {
                await cb(this);
            } finally{
                if (!this.destroyed) {
                    this._pendingFactoryUpdatesCount--;
                }
            }
        }).catch((e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].errorOnce(e));
    }
    clearCallbackCache() {
        this.ctx.callbackCache.invalidateCache();
        for (const series of this.series){
            series.resetDatumCallbackCache();
        }
    }
    update() {
        let type = arguments.length > 0 && arguments[0] !== void 0 /* FULL */  ? arguments[0] : 0, opts = arguments.length > 1 ? arguments[1] : void 0;
        if (this.destroyed) return;
        const { forceNodeDataRefresh = false, skipAnimations, seriesToUpdate = this.series, newAnimationBatch, apiUpdate = false } = opts !== null && opts !== void 0 ? opts : {};
        this.apiUpdate = apiUpdate;
        this.ctx.widgets.seriesWidget.setDragTouchEnabled(this.touch.dragAction !== "none");
        if (forceNodeDataRefresh) {
            this.series.forEach((series)=>series.markNodeDataDirty());
        }
        for (const series of seriesToUpdate){
            this.seriesToUpdate.add(series);
        }
        if (skipAnimations) {
            this.ctx.animationManager.skipCurrentBatch();
            this._performUpdateSkipAnimations = true;
        }
        if (newAnimationBatch && this.ctx.animationManager.isActive()) {
            this._performUpdateSkipAnimations = true;
        }
        if (this.debug.check()) {
            var _stack;
            let stack = (_stack = new Error().stack) !== null && _stack !== void 0 ? _stack : "<unknown>";
            stack = stack.replace(/\([^)]*/g, "");
            this.updateRequestors[stack] = type;
        }
        if (type < this.performUpdateType) {
            this.performUpdateType = type;
            this.ctx.domManager.setDataBoolean("updatePending", true);
            this.performUpdateTrigger.schedule(opts === null || opts === void 0 ? void 0 : opts.backOffMs);
        }
    }
    async performUpdate(count) {
        const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;
        const seriesToUpdate = [
            ...this.seriesToUpdate
        ];
        this.clearCallbackCache();
        this.performUpdateType = 8 /* NONE */ ;
        this.seriesToUpdate.clear();
        this.runningUpdateType = performUpdateType;
        if (this.updateShortcutCount === 0 && performUpdateType < 7 /* SCENE_RENDER */ ) {
            ctx.animationManager.startBatch(this._performUpdateSkipAnimations);
            ctx.animationManager.onBatchStop(()=>this.chartAnimationPhase = "ready");
        }
        this.ctx.scene.updateDebugFlags();
        this.debug("Chart.performUpdate() - start", ChartUpdateType[performUpdateType]);
        let previousSplit = performance.now();
        var _splits_start;
        (_splits_start = splits.start) !== null && _splits_start !== void 0 ? _splits_start : splits.start = previousSplit;
        const updateSplits = (splitName)=>{
            var _splits_splitName;
            (_splits_splitName = splits[splitName]) !== null && _splits_splitName !== void 0 ? _splits_splitName : splits[splitName] = 0;
            splits[splitName] += performance.now() - previousSplit;
            previousSplit = performance.now();
        };
        switch(performUpdateType){
            case 0 /* FULL */ :
                if (this.checkUpdateShortcut(0 /* FULL */ )) break;
                this.ctx.updateService.dispatchPreDomUpdate();
                this.updateDOM();
            case 1 /* UPDATE_DATA */ :
                if (this.checkUpdateShortcut(1 /* UPDATE_DATA */ )) break;
                await this.updateData();
                updateSplits("\u2B07\uFE0F");
            case 2 /* PROCESS_DATA */ :
                if (this.checkUpdateShortcut(2 /* PROCESS_DATA */ )) break;
                await this.processData();
                this.seriesAreaManager.dataChanged();
                updateSplits("\u{1F3ED}");
            case 3 /* PROCESS_DOMAIN */ :
                if (this.checkUpdateShortcut(3 /* PROCESS_DOMAIN */ )) break;
                await this.processDomains();
                updateSplits("\u26F0\uFE0F");
            case 4 /* PERFORM_LAYOUT */ :
                await this.checkFirstAutoSize();
                if (this.checkUpdateShortcut(4 /* PERFORM_LAYOUT */ )) break;
                await this.processLayout();
                updateSplits("\u2316");
            case 5 /* SERIES_UPDATE */ :
                {
                    if (this.checkUpdateShortcut(5 /* SERIES_UPDATE */ )) break;
                    await this.updateSeries(seriesToUpdate);
                    updateSplits("\u{1F914}");
                    this.updateAriaLabels();
                    this.seriesLayerManager.updateLayerCompositing();
                }
            case 6 /* PRE_SCENE_RENDER */ :
                if (this.checkUpdateShortcut(6 /* PRE_SCENE_RENDER */ )) break;
                ctx.updateService.dispatchPreSceneRender();
                updateSplits("\u2196");
            case 7 /* SCENE_RENDER */ :
                if (this.checkUpdateShortcut(7 /* SCENE_RENDER */ )) break;
                ctx.animationManager.endBatch();
                extraDebugStats["updateShortcutCount"] = this.updateShortcutCount;
                ctx.scene.render({
                    debugSplitTimes: splits,
                    extraDebugStats,
                    seriesRect: this.seriesRect
                });
                this.extraDebugStats = {};
                for (const key of Object.keys(splits)){
                    delete splits[key];
                }
                this.ctx.domManager.incrementDataCounter("sceneRenders");
                this.ctx.domManager.postRenderUpdate();
            case 8 /* NONE */ :
                this.updateShortcutCount = 0;
                this.updateRequestors = {};
                this._performUpdateSkipAnimations = false;
                ctx.animationManager.endBatch();
        }
        if (!this.destroyed) {
            ctx.updateService.dispatchUpdateComplete(this.apiUpdate);
            this.apiUpdate = false;
            this.ctx.domManager.setDataBoolean("updatePending", false);
            this.runningUpdateType = 8 /* NONE */ ;
            this.syncStatus = "ready";
        }
        this._performUpdateNotify.notify();
        const end2 = performance.now();
        this.debug("Chart.performUpdate() - end", {
            chart: this,
            durationMs: Math.round((end2 - splits["start"]) * 100) / 100,
            count,
            performUpdateType: ChartUpdateType[performUpdateType]
        });
    }
    updateThemeClassName() {
        const themeClassNamePrefix = "ag-charts-theme-";
        const validThemeClassNames = [
            "".concat(themeClassNamePrefix, "default"),
            "".concat(themeClassNamePrefix, "default-dark")
        ];
        let themeClassName = validThemeClassNames[0];
        let isDark = false;
        let { theme } = this.chartOptions.processedOptions;
        while(typeof theme !== "string" && theme != null){
            theme = theme.baseTheme;
        }
        if (typeof theme === "string") {
            themeClassName = theme.replace("ag-", themeClassNamePrefix);
            isDark = theme.includes("-dark");
        }
        if (!validThemeClassNames.includes(themeClassName)) {
            themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];
        }
        this.ctx.domManager.setThemeClass(themeClassName);
    }
    updateDOM() {
        this.updateThemeClassName();
        const { enabled, tabIndex } = this.keyboard;
        this.ctx.domManager.setTabGuardIndex(enabled ? tabIndex !== null && tabIndex !== void 0 ? tabIndex : 0 : -1);
        this.ctx.domManager.setThemeParameters(this.chartOptions.themeParameters);
    }
    updateAriaLabels() {
        this.ctx.domManager.updateCanvasLabel(this.getAriaLabel());
    }
    checkUpdateShortcut(checkUpdateType) {
        const maxShortcuts = 3;
        if (this.destroyed) return true;
        if (this.updateShortcutCount > maxShortcuts) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("exceeded the maximum number of simultaneous updates (".concat(maxShortcuts + 1, "), discarding changes and rendering"), this.updateRequestors);
            return false;
        }
        if (this.performUpdateType <= checkUpdateType) {
            this.updateShortcutCount++;
            return true;
        }
        return false;
    }
    async checkFirstAutoSize() {
        if (this.width != null && this.height != null) {} else if (!this._lastAutoSize) {
            const success = await this._autoSizeNotify.await(500);
            if (!success) {
                this.debug("Chart.checkFirstAutoSize() - timeout for first size update.");
            }
        }
    }
    onAxisChange(newValue, oldValue) {
        if (oldValue == null && newValue.length === 0) return;
        this.ctx.axisManager.updateAxes(oldValue !== null && oldValue !== void 0 ? oldValue : [], newValue);
    }
    onSeriesChange(newValue, oldValue) {
        var _this_seriesLayerManager, _this_seriesAreaManager;
        var _oldValue_filter;
        const seriesToDestroy = (_oldValue_filter = oldValue === null || oldValue === void 0 ? void 0 : oldValue.filter((series)=>!newValue.includes(series))) !== null && _oldValue_filter !== void 0 ? _oldValue_filter : [];
        this.destroySeries(seriesToDestroy);
        (_this_seriesLayerManager = this.seriesLayerManager) === null || _this_seriesLayerManager === void 0 ? void 0 : _this_seriesLayerManager.setSeriesCount(newValue.length);
        for (const series of newValue){
            if (oldValue === null || oldValue === void 0 ? void 0 : oldValue.includes(series)) continue;
            const seriesContentNode = this.seriesLayerManager.requestGroup(series);
            series.attachSeries(seriesContentNode, this.seriesRoot, this.annotationRoot);
            const chart = this;
            series.chart = {
                get mode () {
                    return chart.mode;
                },
                get isMiniChart () {
                    return false;
                },
                get seriesRect () {
                    return chart.seriesRect;
                }
            };
            series.resetAnimation(this.chartAnimationPhase);
            this.addSeriesListeners(series);
            series.addChartEventListeners();
        }
        (_this_seriesAreaManager = this.seriesAreaManager) === null || _this_seriesAreaManager === void 0 ? void 0 : _this_seriesAreaManager.seriesChanged(newValue);
    }
    destroySeries(allSeries) {
        allSeries === null || allSeries === void 0 ? void 0 : allSeries.forEach((series)=>{
            series.removeEventListener("seriesNodeClick", this.onSeriesNodeClick);
            series.removeEventListener("seriesNodeDoubleClick", this.onSeriesNodeDoubleClick);
            series.removeEventListener("groupingChanged", this.seriesGroupingChanged);
            series.destroy();
            this.seriesLayerManager.releaseGroup(series);
            series.detachSeries(void 0, this.seriesRoot, this.annotationRoot);
            series.chart = void 0;
        });
    }
    addSeriesListeners(series) {
        if (this.hasEventListener("seriesNodeClick")) {
            series.addEventListener("seriesNodeClick", this.onSeriesNodeClick);
        }
        if (this.hasEventListener("seriesNodeDoubleClick")) {
            series.addEventListener("seriesNodeDoubleClick", this.onSeriesNodeDoubleClick);
        }
        if (this.hasEventListener("seriesVisibilityChange")) {
            series.addEventListener("seriesVisibilityChange", this.onSeriesVisibilityChange);
        }
        series.addEventListener("groupingChanged", this.seriesGroupingChanged);
    }
    assignSeriesToAxes() {
        for (const axis of this.axes){
            axis.boundSeries = this.series.filter((s)=>s.axes[axis.direction] === axis);
        }
    }
    assignAxesToSeries() {
        const directionToAxesMap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["groupBy"])(this.axes, (axis)=>axis.direction);
        for (const series of this.series){
            for (const direction of series.directions){
                const directionAxes = directionToAxesMap[direction];
                if (!directionAxes) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("no available axis for direction [".concat(direction, "]; check series and axes configuration."));
                    return;
                }
                const seriesKeys = series.getKeys(direction);
                const newAxis = directionAxes.find((axis)=>!axis.keys.length || seriesKeys.some((key)=>axis.keys.includes(key)));
                if (!newAxis) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("no matching axis for direction [".concat(direction, "] and keys [").concat(seriesKeys, "]; check series and axes configuration."));
                    return;
                }
                series.axes[direction] = newAxis;
            }
        }
    }
    parentResize(size) {
        if (size == null || this.width != null && this.height != null) return;
        let { width: width2, height: height2 } = size;
        const { pixelRatio } = size;
        width2 = Math.floor(width2);
        height2 = Math.floor(height2);
        if (width2 === 0 && height2 === 0) return;
        var _this__lastAutoSize;
        const [autoWidth = 0, autoHeight = 0, autoPixelRatio = 1] = (_this__lastAutoSize = this._lastAutoSize) !== null && _this__lastAutoSize !== void 0 ? _this__lastAutoSize : [];
        if (autoWidth === width2 && autoHeight === height2 && autoPixelRatio === pixelRatio) return;
        this._lastAutoSize = [
            width2,
            height2,
            pixelRatio
        ];
        this.resize("SizeMonitor", {});
    }
    resize(source, opts) {
        var _this__lastAutoSize, _this__lastAutoSize1, _this__lastAutoSize2;
        const { scene, animationManager } = this.ctx;
        const { inWidth, inHeight, inMinWidth, inMinHeight, inOverrideDevicePixelRatio } = opts;
        this.ctx.domManager.setSizeOptions(inMinWidth !== null && inMinWidth !== void 0 ? inMinWidth : this.minWidth, inMinHeight !== null && inMinHeight !== void 0 ? inMinHeight : this.minHeight, inWidth !== null && inWidth !== void 0 ? inWidth : this.width, inHeight !== null && inHeight !== void 0 ? inHeight : this.height);
        var _ref;
        const width2 = (_ref = inWidth !== null && inWidth !== void 0 ? inWidth : this.width) !== null && _ref !== void 0 ? _ref : (_this__lastAutoSize = this._lastAutoSize) === null || _this__lastAutoSize === void 0 ? void 0 : _this__lastAutoSize[0];
        var _ref1;
        const height2 = (_ref1 = inHeight !== null && inHeight !== void 0 ? inHeight : this.height) !== null && _ref1 !== void 0 ? _ref1 : (_this__lastAutoSize1 = this._lastAutoSize) === null || _this__lastAutoSize1 === void 0 ? void 0 : _this__lastAutoSize1[1];
        var _ref2;
        const pixelRatio = (_ref2 = inOverrideDevicePixelRatio !== null && inOverrideDevicePixelRatio !== void 0 ? inOverrideDevicePixelRatio : this.overrideDevicePixelRatio) !== null && _ref2 !== void 0 ? _ref2 : (_this__lastAutoSize2 = this._lastAutoSize) === null || _this__lastAutoSize2 === void 0 ? void 0 : _this__lastAutoSize2[2];
        this.debug("Chart.resize() from ".concat(source), {
            width: width2,
            height: height2,
            pixelRatio,
            stack: new Error().stack
        });
        if (width2 == null || height2 == null || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(width2) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(height2)) return;
        if (scene.resize(width2, height2, pixelRatio)) {
            animationManager.reset();
            let skipAnimations = true;
            if ((this.width == null || this.height == null) && this._firstAutoSize) {
                skipAnimations = false;
                this._firstAutoSize = false;
            }
            this.update(4 /* PERFORM_LAYOUT */ , {
                forceNodeDataRefresh: true,
                skipAnimations
            });
            this._autoSizeNotify.notify();
        }
    }
    async updateData() {
        this.series.forEach((s)=>s.setChartData(this.data));
        const modulePromises = this.modulesManager.mapModules((m)=>{
            var _m_updateData;
            return (_m_updateData = m.updateData) === null || _m_updateData === void 0 ? void 0 : _m_updateData.call(m, this.data);
        });
        await Promise.all(modulePromises);
    }
    async processData() {
        if (this.series.some((s)=>s.canHaveAxes)) {
            this.assignAxesToSeries();
            this.assignSeriesToAxes();
        }
        const dataController = new DataController(this.mode, this.suppressFieldDotNotation);
        const seriesPromises = this.series.map((s)=>s.processData(dataController));
        const modulePromises = this.modulesManager.mapModules((m)=>{
            var _m_processData;
            return (_m_processData = m.processData) === null || _m_processData === void 0 ? void 0 : _m_processData.call(m, dataController);
        });
        this._cachedData = dataController.execute(this._cachedData);
        await Promise.all([
            ...seriesPromises,
            ...modulePromises
        ]);
        this.updateLegends();
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async processDomains() {
        for (const axis of this.axes){
            axis.processData();
        }
        for (const series of this.series){
            series.updatedDomains();
        }
    }
    updateLegends(initialStateLegend) {
        for (const { legend, legendType } of this.modulesManager.legends()){
            if (legendType === "category") {
                this.setCategoryLegendData(initialStateLegend);
            } else {
                this.setLegendData(legendType, legend);
            }
        }
    }
    setCategoryLegendData(initialState) {
        var _a;
        const { ctx: { legendManager, stateManager } } = this;
        if (initialState) {
            this.series.forEach((s)=>{
                const seriesState = initialState.find((init)=>init.seriesId === s.id);
                s.onLegendInitialState("category", seriesState);
            });
        }
        const legendData = this.series.flatMap((s)=>{
            const seriesLegendData = s.getLegendData("category");
            legendManager.updateData(s.id, seriesLegendData);
            return seriesLegendData;
        });
        if (initialState) {
            stateManager.setStateAndRestore(legendManager, initialState);
            return;
        }
        if (this.mode !== "integrated") {
            const seriesMarkerFills = {};
            const seriesTypeMap = new Map(this.series.map((s)=>[
                    s.id,
                    s.type
                ]));
            for (const { seriesId, symbol: { marker }, label } of legendData.filter((d)=>!d.hideInLegend)){
                if (marker.fill == null) continue;
                const seriesType = seriesTypeMap.get(seriesId);
                var _seriesMarkerFills_seriesType;
                const markerFill = (_seriesMarkerFills_seriesType = seriesMarkerFills[seriesType]) !== null && _seriesMarkerFills_seriesType !== void 0 ? _seriesMarkerFills_seriesType : seriesMarkerFills[seriesType] = {};
                var _markerFill_;
                (_markerFill_ = markerFill[_a = label.text]) !== null && _markerFill_ !== void 0 ? _markerFill_ : markerFill[_a] = marker.fill;
                if (markerFill[label.text] !== marker.fill) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("legend item '".concat(label.text, "' has multiple fill colors, this may cause unexpected behaviour."));
                }
            }
        }
        legendManager.update();
    }
    setLegendData(legendType, legend) {
        legend.data = this.series.filter((s)=>s.properties.showInLegend).flatMap((s)=>s.getLegendData(legendType));
    }
    async processLayout() {
        var _this_animationRect;
        const oldRect = this.animationRect;
        const { width: width2, height: height2 } = this.ctx.scene;
        const ctx = this.ctx.layoutManager.createContext(width2, height2);
        await this.performLayout(ctx);
        if (oldRect && !((_this_animationRect = this.animationRect) === null || _this_animationRect === void 0 ? void 0 : _this_animationRect.equals(oldRect))) {
            this.ctx.animationManager.skipCurrentBatch();
        }
        this.debug("Chart.performUpdate() - seriesRect", this.seriesRect);
    }
    async updateSeries(seriesToUpdate) {
        const { seriesRect } = this;
        await Promise.all(seriesToUpdate.map((series)=>series.update({
                seriesRect
            })));
        this.ctx.seriesLabelLayoutManager.updateLabels(this.series.filter((s)=>s.visible && s.usesPlacedLabels), this.padding, this.seriesRect);
    }
    async waitForUpdate(timeoutMs, failOnTimeout) {
        const agChartsDebugTimeout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])("agChartsDebugTimeout");
        if (agChartsDebugTimeout == null) {
            timeoutMs !== null && timeoutMs !== void 0 ? timeoutMs : timeoutMs = 1e5;
            failOnTimeout !== null && failOnTimeout !== void 0 ? failOnTimeout : failOnTimeout = false;
        } else {
            timeoutMs = agChartsDebugTimeout;
            failOnTimeout !== null && failOnTimeout !== void 0 ? failOnTimeout : failOnTimeout = true;
        }
        const start2 = performance.now();
        while(this._pendingFactoryUpdatesCount > 0 || this.performUpdateType !== 8 /* NONE */  || this.runningUpdateType !== 8 /* NONE */  || this.ctx.scene.waitingForUpdate()){
            if (this.destroyed) break;
            if (this._pendingFactoryUpdatesCount > 0) {
                await this.updateMutex.waitForClearAcquireQueue();
            }
            if (this.performUpdateType !== 8 /* NONE */  || this.runningUpdateType !== 8 /* NONE */ ) {
                await this._performUpdateNotify.await();
            }
            if (performance.now() - start2 > timeoutMs) {
                const message = "Chart.waitForUpdate() timeout of ".concat(timeoutMs, " reached - first chart update taking too long.");
                if (failOnTimeout) {
                    throw new Error(message);
                } else {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce(message);
                }
            }
            if (isInputPending()) {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pause"])();
            }
            if (this.ctx.scene.waitingForUpdate()) {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pause"])(50);
            }
        }
    }
    filterMiniChartSeries(series) {
        return series === null || series === void 0 ? void 0 : series.filter((s)=>s.showInMiniChart !== false);
    }
    applyOptions(newChartOptions) {
        var _deltaOptions_legend, _deltaOptions_locale, _newOpts_navigator_miniChart, _newOpts_navigator;
        const minimumUpdateType = 4 /* PERFORM_LAYOUT */ ;
        const deltaOptions = this.firstApply ? newChartOptions.processedOptions : newChartOptions.diffOptions(this.chartOptions);
        if (deltaOptions == null || Object.keys(deltaOptions).length === 0) {
            debug("Chart.applyOptions() - no delta, forcing re-layout", deltaOptions);
            this.update(minimumUpdateType, {
                apiUpdate: true,
                newAnimationBatch: true
            });
            return;
        }
        const oldOpts = this.firstApply ? {} : this.chartOptions.processedOptions;
        const newOpts = newChartOptions.processedOptions;
        debug("Chart.applyOptions() - applying delta", deltaOptions);
        const modulesChanged = this.applyModules(newOpts);
        const skip = [
            "type",
            "data",
            "series",
            "listeners",
            "preset",
            "theme",
            "legend.listeners",
            "navigator.miniChart.series",
            "navigator.miniChart.label",
            "locale.localeText",
            "axes",
            "topology",
            "nodes",
            "initialState",
            "styleContainer",
            "formatter"
        ];
        if (deltaOptions.listeners) {
            this.registerListeners(this, deltaOptions.listeners);
        }
        jsonApply(this, deltaOptions, {
            skip
        });
        let forceNodeDataRefresh = false;
        let seriesStatus = "no-op";
        if (deltaOptions.series != null) {
            seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts === null || oldOpts === void 0 ? void 0 : oldOpts.series);
            forceNodeDataRefresh = true;
        }
        if (seriesStatus === "replaced") {
            this.resetAnimations();
        }
        if (this.applyAxes(this, newOpts, oldOpts, seriesStatus, [])) {
            forceNodeDataRefresh = true;
        }
        if (deltaOptions.data) {
            this.data = deltaOptions.data;
        }
        if (((_deltaOptions_legend = deltaOptions.legend) === null || _deltaOptions_legend === void 0 ? void 0 : _deltaOptions_legend.listeners) && this.modulesManager.isEnabled("legend")) {
            Object.assign(this.legend.listeners, deltaOptions.legend.listeners);
        }
        if ((_deltaOptions_locale = deltaOptions.locale) === null || _deltaOptions_locale === void 0 ? void 0 : _deltaOptions_locale.localeText) {
            var _deltaOptions_locale1;
            this.modulesManager.getModule("locale").localeText = (_deltaOptions_locale1 = deltaOptions.locale) === null || _deltaOptions_locale1 === void 0 ? void 0 : _deltaOptions_locale1.localeText;
        }
        this.chartOptions = newChartOptions;
        const navigatorModule = this.modulesManager.getModule("navigator");
        const zoomModule = this.modulesManager.getModule("zoom");
        if (!(navigatorModule === null || navigatorModule === void 0 ? void 0 : navigatorModule.enabled) && !(zoomModule === null || zoomModule === void 0 ? void 0 : zoomModule.enabled)) {
            this.ctx.zoomManager.updateZoom("chart");
        }
        const miniChart = navigatorModule === null || navigatorModule === void 0 ? void 0 : navigatorModule.miniChart;
        var _newOpts_navigator_miniChart_series;
        const miniChartSeries = (_newOpts_navigator_miniChart_series = (_newOpts_navigator = newOpts.navigator) === null || _newOpts_navigator === void 0 ? void 0 : (_newOpts_navigator_miniChart = _newOpts_navigator.miniChart) === null || _newOpts_navigator_miniChart === void 0 ? void 0 : _newOpts_navigator_miniChart.series) !== null && _newOpts_navigator_miniChart_series !== void 0 ? _newOpts_navigator_miniChart_series : newOpts.series;
        if ((miniChart === null || miniChart === void 0 ? void 0 : miniChart.enabled) === true && miniChartSeries != null) {
            this.applyMiniChartOptions(miniChart, miniChartSeries, newOpts, oldOpts);
        } else if ((miniChart === null || miniChart === void 0 ? void 0 : miniChart.enabled) === false) {
            miniChart.series = [];
            miniChart.axes = [];
        }
        this.ctx.annotationManager.setAnnotationStyles(newChartOptions.annotationThemes);
        forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));
        const majorChange = forceNodeDataRefresh || modulesChanged;
        const updateType = majorChange ? 0 /* FULL */  : minimumUpdateType;
        this.maybeResetAnimations(seriesStatus);
        if (this.shouldClearLegendData(newOpts, oldOpts, seriesStatus)) {
            this.ctx.legendManager.clearData();
        }
        this.applyInitialState(newOpts);
        this.ctx.formatManager.setFormatter(newOpts.formatter);
        debug("Chart.applyOptions() - update type", ChartUpdateType[updateType], {
            seriesStatus,
            forceNodeDataRefresh
        });
        if (newChartOptions.optionsProcessingTime !== void 0) {
            this._performUpdateSplits["\u2699\uFE0F"] = newChartOptions.optionsProcessingTime;
            const optionsStartTime = performance.now() - newChartOptions.optionsProcessingTime;
            this._performUpdateSplits.start = optionsStartTime;
        }
        this.update(updateType, {
            apiUpdate: true,
            forceNodeDataRefresh,
            newAnimationBatch: true
        });
        this.firstApply = false;
    }
    applyInitialState(options) {
        var _options_annotations, _options_navigator, _options_zoom;
        const { annotationManager, chartTypeOriginator, historyManager, stateManager, zoomManager } = this.ctx;
        const { initialState } = options;
        if ("annotations" in options && ((_options_annotations = options.annotations) === null || _options_annotations === void 0 ? void 0 : _options_annotations.enabled) && (initialState === null || initialState === void 0 ? void 0 : initialState.annotations) != null) {
            const annotations = initialState.annotations.map((annotation)=>{
                const annotationTheme = annotationManager.getAnnotationTypeStyles(annotation.type);
                return mergeDefaults(annotation, annotationTheme);
            });
            stateManager.setState(annotationManager, annotations);
        }
        if ((initialState === null || initialState === void 0 ? void 0 : initialState.chartType) != null) {
            stateManager.setState(chartTypeOriginator, initialState.chartType);
        }
        if ((((_options_navigator = options.navigator) === null || _options_navigator === void 0 ? void 0 : _options_navigator.enabled) || ((_options_zoom = options.zoom) === null || _options_zoom === void 0 ? void 0 : _options_zoom.enabled)) && (initialState === null || initialState === void 0 ? void 0 : initialState.zoom) != null) {
            stateManager.setState(zoomManager, initialState.zoom);
        }
        if ((initialState === null || initialState === void 0 ? void 0 : initialState.legend) != null) {
            this.updateLegends(initialState.legend);
        }
        if (initialState != null) {
            historyManager.clear();
        }
    }
    maybeResetAnimations(seriesStatus) {
        if (this.mode !== "standalone") return;
        switch(seriesStatus){
            case "series-grouping-change":
            case "replaced":
                this.resetAnimations();
                break;
            default:
        }
    }
    shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {
        const seriesDataUpdate = !!deltaOptions.data || seriesStatus === "data-change" || seriesStatus === "replaced";
        const legendKeys = legendRegistry.getKeys();
        const optionsHaveLegend = Object.values(legendKeys).some((legendKey)=>deltaOptions[legendKey] != null);
        const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null || deltaOptions.formatter != null;
        return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;
    }
    shouldClearLegendData(options, oldOpts, seriesStatus) {
        var _options_series, _oldOpts_series, _options_series1;
        const seriesChanged = seriesStatus === "replaced" || seriesStatus === "series-grouping-change" || seriesStatus === "updated" && (((_options_series = options.series) === null || _options_series === void 0 ? void 0 : _options_series.length) !== ((_oldOpts_series = oldOpts.series) === null || _oldOpts_series === void 0 ? void 0 : _oldOpts_series.length) || !((_options_series1 = options.series) === null || _options_series1 === void 0 ? void 0 : _options_series1.every((s, i)=>{
            var _oldOpts_series;
            return s.type === ((_oldOpts_series = oldOpts.series) === null || _oldOpts_series === void 0 ? void 0 : _oldOpts_series[i].type);
        })));
        const legendRemoved = oldOpts.legend != null && options.legend == null;
        return seriesChanged || legendRemoved;
    }
    applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {
        var _oldOpts_navigator_miniChart, _oldOpts_navigator;
        var _oldOpts_navigator_miniChart_series;
        const oldSeries = (_oldOpts_navigator_miniChart_series = oldOpts === null || oldOpts === void 0 ? void 0 : (_oldOpts_navigator = oldOpts.navigator) === null || _oldOpts_navigator === void 0 ? void 0 : (_oldOpts_navigator_miniChart = _oldOpts_navigator.miniChart) === null || _oldOpts_navigator_miniChart === void 0 ? void 0 : _oldOpts_navigator_miniChart.series) !== null && _oldOpts_navigator_miniChart_series !== void 0 ? _oldOpts_navigator_miniChart_series : oldOpts === null || oldOpts === void 0 ? void 0 : oldOpts.series;
        const miniChartSeriesStatus = this.applySeries(miniChart, this.filterMiniChartSeries(miniChartSeries), this.filterMiniChartSeries(oldSeries));
        this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [
            "axes[].tick",
            "axes[].thickness",
            "axes[].title",
            "axes[].crosshair",
            "axes[].gridLine",
            "axes[].label"
        ]);
        const series = miniChart.series;
        for (const s of series){
            s.properties.id = void 0;
        }
        const axes = miniChart.axes;
        const horizontalAxis = axes.find((axis)=>axis.direction === "x" /* X */ );
        for (const axis of axes){
            axis.nice = false;
            axis.gridLine.enabled = false;
            axis.label.enabled = axis === horizontalAxis;
            axis.tick.enabled = false;
            axis.interactionEnabled = false;
        }
        if (horizontalAxis != null) {
            var _completeOptions_navigator, _miniChartOpts_label;
            const miniChartOpts = (_completeOptions_navigator = completeOptions.navigator) === null || _completeOptions_navigator === void 0 ? void 0 : _completeOptions_navigator.miniChart;
            const labelOptions = miniChartOpts === null || miniChartOpts === void 0 ? void 0 : miniChartOpts.label;
            const intervalOptions = miniChartOpts === null || miniChartOpts === void 0 ? void 0 : (_miniChartOpts_label = miniChartOpts.label) === null || _miniChartOpts_label === void 0 ? void 0 : _miniChartOpts_label.interval;
            horizontalAxis.line.enabled = false;
            horizontalAxis.label.set(without(labelOptions, [
                "interval",
                "autoRotate",
                "autoRotateAngle",
                "itemStyler",
                "minSpacing",
                "rotation"
            ]));
            if (horizontalAxis.type === "grouped-category") {
                horizontalAxis.label.enabled = false;
                horizontalAxis.label.rotation = 0;
                const { depthOptions } = horizontalAxis;
                if (depthOptions.length === 0) {
                    depthOptions.set([
                        {
                            label: {
                                enabled: true
                            }
                        }
                    ]);
                } else {
                    for(let i = 1; i < depthOptions.length; i++){
                        depthOptions[i].label.enabled = false;
                    }
                }
            } else if (horizontalAxis.type === "time" || horizontalAxis.type === "unit-time" || horizontalAxis.type === "ordinal-time") {
                horizontalAxis.parentLevel.enabled = false;
            }
            horizontalAxis.interval.step = intervalOptions === null || intervalOptions === void 0 ? void 0 : intervalOptions.step;
            horizontalAxis.interval.values = intervalOptions === null || intervalOptions === void 0 ? void 0 : intervalOptions.values;
            horizontalAxis.interval.minSpacing = intervalOptions === null || intervalOptions === void 0 ? void 0 : intervalOptions.minSpacing;
            horizontalAxis.interval.maxSpacing = intervalOptions === null || intervalOptions === void 0 ? void 0 : intervalOptions.maxSpacing;
        }
    }
    applyModules(options) {
        const { type: chartType } = this.constructor;
        let modulesChanged = false;
        for (const module of moduleRegistry.byType("root", "legend")){
            const isConfigured = options[module.optionsKey] != null;
            const shouldBeEnabled = isConfigured && module.chartTypes.includes(chartType);
            if (shouldBeEnabled === this.modulesManager.isEnabled(module)) continue;
            if (shouldBeEnabled) {
                this.modulesManager.addModule(module, (m)=>m.moduleFactory(this.getModuleContext()));
                if (module.type === "legend") {
                    var _this_modulesManager_getModule;
                    (_this_modulesManager_getModule = this.modulesManager.getModule(module)) === null || _this_modulesManager_getModule === void 0 ? void 0 : _this_modulesManager_getModule.attachLegend(this.ctx.scene);
                }
                this[module.optionsKey] = this.modulesManager.getModule(module);
            } else {
                this.modulesManager.removeModule(module);
                delete this[module.optionsKey];
            }
            modulesChanged = true;
        }
        return modulesChanged;
    }
    initSeriesDeclarationOrder(series) {
        for(let idx = 0; idx < series.length; idx++){
            series[idx].setSeriesIndex(idx);
        }
    }
    applySeries(chart, optSeries, oldOptSeries) {
        if (!optSeries) {
            return "no-change";
        }
        const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);
        if (matchResult.status === "no-overlap") {
            debug("Chart.applySeries() - creating new series instances, status: ".concat(matchResult.status), matchResult);
            const chartSeries = optSeries.map((opts)=>this.createSeries(opts));
            this.initSeriesDeclarationOrder(chartSeries);
            chart.series = chartSeries;
            return "replaced";
        }
        debug("Chart.applySeries() - matchResult", matchResult);
        const seriesInstances = [];
        let dataChanged = false;
        let groupingChanged = false;
        let isUpdated = false;
        const changes = matchResult.changes.toSorted((a, b)=>a.targetIdx - b.targetIdx);
        for (const change of changes){
            var _change_diff;
            groupingChanged || (groupingChanged = change.status === "series-grouping");
            dataChanged || (dataChanged = ((_change_diff = change.diff) === null || _change_diff === void 0 ? void 0 : _change_diff.data) != null);
            isUpdated || (isUpdated = change.status !== "no-op");
            switch(change.status){
                case "add":
                    {
                        const newSeries = this.createSeries(change.opts);
                        seriesInstances.push(newSeries);
                        debug("Chart.applySeries() - created new series", newSeries);
                        break;
                    }
                case "remove":
                    debug("Chart.applySeries() - removing series at previous idx ".concat(change.idx), change.series);
                    break;
                case "no-op":
                    seriesInstances.push(change.series);
                    debug("Chart.applySeries() - no change to series at previous idx ".concat(change.idx), change.series);
                    break;
                case "series-grouping":
                case "update":
                default:
                    {
                        const { series, diff: diff2, idx } = change;
                        debug("Chart.applySeries() - applying series diff previous idx ".concat(idx), diff2, series);
                        this.applySeriesValues(series, diff2);
                        series.markNodeDataDirty();
                        seriesInstances.push(series);
                    }
            }
        }
        this.initSeriesDeclarationOrder(seriesInstances);
        debug("Chart.applySeries() - final series instances", seriesInstances);
        chart.series = seriesInstances;
        if (groupingChanged) {
            return "series-grouping-change";
        }
        if (dataChanged) {
            return "data-change";
        }
        return isUpdated ? "updated" : "no-op";
    }
    applyAxes(chart, options, oldOpts, seriesStatus) {
        let skip = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
        if (!("axes" in options) || !options.axes) {
            return false;
        }
        skip = [
            "axes[].type",
            ...skip
        ];
        const axes = options.axes;
        const forceRecreate = seriesStatus === "replaced";
        const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i)=>a.type === axes[i].type);
        if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {
            chart.axes.forEach((axis, index)=>{
                var _oldOpts_axes;
                var _oldOpts_axes_index;
                const previousOpts = (_oldOpts_axes_index = (_oldOpts_axes = oldOpts.axes) === null || _oldOpts_axes === void 0 ? void 0 : _oldOpts_axes[index]) !== null && _oldOpts_axes_index !== void 0 ? _oldOpts_axes_index : {};
                const axisDiff = jsonDiff(previousOpts, axes[index]);
                debug("Chart.applyAxes() - applying axis diff idx ".concat(index), axisDiff);
                const path = "axes[".concat(index, "]");
                jsonApply(axis, axisDiff, {
                    path,
                    skip
                });
            });
            return true;
        }
        debug("Chart.applyAxes() - creating new axes instances; seriesStatus: ".concat(seriesStatus));
        chart.axes = this.createAxis(axes, skip);
        return true;
    }
    createSeries(seriesOptions) {
        const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());
        this.applySeriesOptionModules(seriesInstance, seriesOptions);
        this.applySeriesValues(seriesInstance, seriesOptions);
        return seriesInstance;
    }
    applySeriesOptionModules(series, options) {
        const moduleContext = series.createModuleContext();
        const moduleMap = series.getModuleMap();
        for (const module of moduleRegistry.byType("series-option")){
            if (module.optionsKey in options && module.seriesTypes.includes(series.type)) {
                moduleMap.addModule(module, (m)=>m.moduleFactory(moduleContext));
            }
        }
    }
    applySeriesValues(target, options) {
        const moduleMap = target.getModuleMap();
        const { type: _, data, listeners, seriesGrouping, showInMiniChart: __, ...seriesOptions } = options;
        for (const moduleDef of EXPECTED_ENTERPRISE_MODULES){
            if (moduleDef.type !== "series-option") continue;
            if (moduleDef.optionsKey in seriesOptions) {
                const module = moduleMap.getModule(moduleDef.optionsKey);
                if (module) {
                    const moduleOptions = seriesOptions[moduleDef.optionsKey];
                    delete seriesOptions[moduleDef.optionsKey];
                    module.properties.set(moduleOptions);
                }
            }
        }
        if (seriesOptions.visible != null) {
            target.visible = seriesOptions.visible;
        }
        target.properties.set(seriesOptions);
        if ("data" in options) {
            target.setOptionsData(data);
        }
        if (listeners) {
            this.registerListeners(target, listeners);
        }
        if ("seriesGrouping" in options) {
            if (seriesGrouping == null) {
                target.seriesGrouping = void 0;
            } else {
                target.seriesGrouping = {
                    ...target.seriesGrouping,
                    ...seriesGrouping
                };
            }
        }
    }
    createAxis(options, skip) {
        const newAxes = [];
        const moduleContext = this.getModuleContext();
        for(let index = 0; index < options.length; index++){
            const axisOptions = options[index];
            const axis = axisRegistry.create(axisOptions.type, moduleContext);
            this.applyAxisModules(axis, axisOptions);
            jsonApply(axis, axisOptions, {
                path: "axes[".concat(index, "]"),
                skip
            });
            newAxes.push(axis);
        }
        guessInvalidPositions(newAxes);
        return newAxes;
    }
    applyAxisModules(axis, options) {
        const moduleContext = axis.createModuleContext();
        const moduleMap = axis.getModuleMap();
        for (const module of moduleRegistry.byType("axis-option")){
            const shouldBeEnabled = options[module.optionsKey] != null;
            if (shouldBeEnabled === moduleMap.isEnabled(module)) continue;
            if (shouldBeEnabled) {
                moduleMap.addModule(module, (m)=>m.moduleFactory(moduleContext));
                axis[module.optionsKey] = moduleMap.getModule(module);
            } else {
                moduleMap.removeModule(module);
                delete axis[module.optionsKey];
            }
        }
    }
    registerListeners(source, listeners) {
        source.clearEventListeners();
        for (const [property, listener] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entries"])(listeners)){
            source.addEventListener(property, listener);
        }
    }
    constructor(options, resources){
        var _a;
        super();
        this.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createId"])(this);
        this.seriesRoot = new TranslatableGroup({
            name: "".concat(this.id, "-series-root"),
            zIndex: 7 /* SERIES_LAYER */ 
        });
        this.annotationRoot = new TranslatableGroup({
            name: "".concat(this.id, "-annotation-root"),
            zIndex: 11 /* SERIES_ANNOTATION */ 
        });
        this.titleGroup = new Group({
            name: "titles",
            zIndex: 15 /* SERIES_LABEL */ 
        });
        this.debug = Debug.create();
        this.extraDebugStats = {};
        this.data = [];
        this._firstAutoSize = true;
        this._autoSizeNotify = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncAwaitQueue"]();
        this.chartCaptions = new ChartCaptions();
        this.padding = new Padding(20);
        this.keyboard = new Keyboard();
        this.touch = new Touch();
        this.mode = "standalone";
        this.styleNonce = void 0;
        this.formatter = void 0;
        this.suppressFieldDotNotation = false;
        this.loadGoogleFonts = false;
        this.destroyed = false;
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.chartAnimationPhase = "initial";
        this.modulesManager = new ModulesManager();
        this.processors = [];
        this.queuedUserOptions = [];
        this.queuedChartOptions = [];
        this.firstApply = true;
        this.syncStatus = "init";
        // Use a wrapper to comply with the @typescript-eslint/unbound-method rule.
        this.fireEventWrapper = (event)=>super.fireEvent(event);
        this.apiUpdate = false;
        this._pendingFactoryUpdatesCount = 0;
        this._performUpdateSkipAnimations = false;
        this._performUpdateNotify = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncAwaitQueue"]();
        this.performUpdateType = 8 /* NONE */ ;
        this.runningUpdateType = 8 /* NONE */ ;
        this.updateShortcutCount = 0;
        this.seriesToUpdate = /* @__PURE__ */ new Set();
        this.updateMutex = new Mutex();
        this.updateRequestors = {};
        this.performUpdateTrigger = debouncedCallback((param)=>{
            let { count } = param;
            if (this.destroyed) return;
            this.updateMutex.acquire(async ()=>{
                try {
                    await this.performUpdate(count);
                } catch (error) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].error("update error", error, error.stack);
                }
            }).catch((e)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].errorOnce(e));
        });
        this._performUpdateSplits = {};
        this.axes = [];
        this.series = [];
        this._cachedData = void 0;
        this.onSeriesNodeClick = (event)=>{
            this.fireEvent(event);
        };
        this.onSeriesNodeDoubleClick = (event)=>{
            this.fireEvent(event);
        };
        this.onSeriesVisibilityChange = (event)=>{
            this.fireEvent(event);
        };
        this.seriesGroupingChanged = (event)=>{
            if (!(event instanceof SeriesGroupingChangedEvent)) return;
            const { series, seriesGrouping } = event;
            if (series.contentGroup.isRoot()) return;
            const seriesContentNode = this.seriesLayerManager.changeGroup({
                internalId: series.internalId,
                type: series.type,
                contentGroup: series.contentGroup,
                bringToFront: ()=>series.bringToFront(),
                renderToOffscreenCanvas: ()=>series.renderToOffscreenCanvas(),
                seriesGrouping
            });
            if (seriesContentNode != null) {
                series.attachSeries(seriesContentNode, this.seriesRoot, this.annotationRoot);
            }
        };
        this.chartOptions = options;
        const scene = resources === null || resources === void 0 ? void 0 : resources.scene;
        var _resources_container, _ref;
        const container = (_ref = (_resources_container = resources === null || resources === void 0 ? void 0 : resources.container) !== null && _resources_container !== void 0 ? _resources_container : options.processedOptions.container) !== null && _ref !== void 0 ? _ref : void 0;
        var _resources_styleContainer;
        const styleContainer = (_resources_styleContainer = resources === null || resources === void 0 ? void 0 : resources.styleContainer) !== null && _resources_styleContainer !== void 0 ? _resources_styleContainer : options.specialOverrides.styleContainer;
        if (scene) {
            this._firstAutoSize = false;
            this._lastAutoSize = [
                scene.width,
                scene.height,
                scene.pixelRatio
            ];
        }
        const root = new Group({
            name: "root"
        });
        root.visible = false;
        root.append(this.seriesRoot);
        root.append(this.annotationRoot);
        root.append(this.titleGroup);
        this.titleGroup.append(this.title.node);
        this.titleGroup.append(this.subtitle.node);
        this.titleGroup.append(this.footnote.node);
        this.tooltip = new Tooltip();
        this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot);
        var _options_userOptions_mode;
        this.mode = (_options_userOptions_mode = options.userOptions.mode) !== null && _options_userOptions_mode !== void 0 ? _options_userOptions_mode : this.mode;
        this.styleNonce = options.processedOptions.styleNonce;
        var _options_optionMetadata_withDragInterpretation;
        const ctx = this.ctx = new ChartContext(this, {
            chartType: this.getChartType(),
            scene,
            root,
            container,
            styleContainer,
            domMode: options.optionMetadata.domMode,
            withDragInterpretation: (_options_optionMetadata_withDragInterpretation = options.optionMetadata.withDragInterpretation) !== null && _options_optionMetadata_withDragInterpretation !== void 0 ? _options_optionMetadata_withDragInterpretation : true,
            syncManager: new SyncManager(this),
            fireEvent: (event)=>this.fireEvent(event),
            updateCallback: (type, opts)=>this.update(type, opts),
            updateMutex: this.updateMutex
        });
        this.cleanup.register(ctx.eventsHub.on("dom:resize", ()=>this.parentResize(ctx.domManager.containerSize)));
        this.overlays = new ChartOverlays();
        var _renderer;
        (_renderer = (_a = this.overlays.loading).renderer) !== null && _renderer !== void 0 ? _renderer : _a.renderer = ()=>getLoadingSpinner(this.overlays.loading.getText(ctx.localeManager), ctx.animationManager.defaultDuration);
        this.processors = [
            new DataWindowProcessor(this, ctx.eventsHub, ctx.dataService, ctx.updateService, ctx.zoomManager, ctx.animationManager),
            new OverlaysProcessor(this, this.overlays, ctx.eventsHub, ctx.dataService, ctx.localeManager, ctx.animationManager, ctx.domManager)
        ];
        this.highlight = new ChartHighlight();
        this.container = container;
        const moduleContext = this.getModuleContext();
        ctx.domManager.setDataBoolean("animating", false);
        this.seriesAreaManager = new SeriesAreaManager(this.initSeriesAreaDependencies());
        this.cleanup.register(ctx.layoutManager.registerElement(0 /* Caption */ , (e)=>{
            e.layoutBox.shrink(this.padding.toJson());
            this.chartCaptions.positionCaptions(e);
        }), ctx.eventsHub.on("layout:complete", (e)=>this.chartCaptions.positionAbsoluteCaptions(e)), ctx.eventsHub.on("data:load", (event)=>{
            this.data = event.data;
        }), this.title.registerInteraction(moduleContext, "beforebegin"), this.subtitle.registerInteraction(moduleContext, "beforebegin"), this.footnote.registerInteraction(moduleContext, "afterend"), Widget.addWindowEvent("page-left", ()=>this.destroy()), ctx.animationManager.addListener("animation-frame", ()=>{
            this.update(7 /* SCENE_RENDER */ );
        }), ctx.animationManager.addListener("animation-start", ()=>ctx.domManager.setDataBoolean("animating", true)), ctx.animationManager.addListener("animation-stop", ()=>ctx.domManager.setDataBoolean("animating", false)), ctx.eventsHub.on("zoom:change", ()=>{
            this.series.forEach((s)=>{
                var _s_animationState;
                return (_s_animationState = s.animationState) === null || _s_animationState === void 0 ? void 0 : _s_animationState.transition("updateData");
            });
            const skipAnimations = this.chartAnimationPhase !== "initial";
            this.update(4 /* PERFORM_LAYOUT */ , {
                forceNodeDataRefresh: true,
                skipAnimations
            });
        }));
        this.parentResize(ctx.domManager.containerSize);
    }
};
_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();
__decorateClass([
    ActionOnSet({
        newValue (value) {
            if (this.destroyed) return;
            this.ctx.domManager.setContainer(value);
            _Chart.chartsInstances.set(value, this);
        },
        oldValue (value) {
            _Chart.chartsInstances.delete(value);
        }
    })
], _Chart.prototype, "container", 2);
__decorateClass([
    ActionOnSet({
        newValue (value) {
            this.resize("width option", {
                inWidth: value
            });
        }
    })
], _Chart.prototype, "width", 2);
__decorateClass([
    ActionOnSet({
        newValue (value) {
            this.resize("height option", {
                inHeight: value
            });
        }
    })
], _Chart.prototype, "height", 2);
__decorateClass([
    ActionOnSet({
        newValue (value) {
            this.resize("minWidth option", {
                inMinWidth: value
            });
        }
    })
], _Chart.prototype, "minWidth", 2);
__decorateClass([
    ActionOnSet({
        newValue (value) {
            this.resize("minHeight option", {
                inMinHeight: value
            });
        }
    })
], _Chart.prototype, "minHeight", 2);
__decorateClass([
    ActionOnSet({
        newValue (value) {
            this.resize("overrideDevicePixelRatio option", {
                inOverrideDevicePixelRatio: value
            });
        }
    })
], _Chart.prototype, "overrideDevicePixelRatio", 2);
__decorateClass([
    Property
], _Chart.prototype, "padding", 2);
__decorateClass([
    Property
], _Chart.prototype, "keyboard", 2);
__decorateClass([
    Property
], _Chart.prototype, "touch", 2);
__decorateClass([
    Property
], _Chart.prototype, "mode", 2);
__decorateClass([
    Property
], _Chart.prototype, "styleNonce", 2);
__decorateClass([
    ProxyProperty("chartCaptions.title")
], _Chart.prototype, "title", 2);
__decorateClass([
    ProxyProperty("chartCaptions.subtitle")
], _Chart.prototype, "subtitle", 2);
__decorateClass([
    ProxyProperty("chartCaptions.footnote")
], _Chart.prototype, "footnote", 2);
__decorateClass([
    Property
], _Chart.prototype, "formatter", 2);
__decorateClass([
    Property
], _Chart.prototype, "suppressFieldDotNotation", 2);
__decorateClass([
    Property
], _Chart.prototype, "loadGoogleFonts", 2);
__decorateClass([
    ActionOnSet({
        changeValue (newValue, oldValue) {
            this.onAxisChange(newValue, oldValue);
        }
    })
], _Chart.prototype, "axes", 2);
__decorateClass([
    ActionOnSet({
        changeValue (newValue, oldValue) {
            this.onSeriesChange(newValue, oldValue);
        }
    })
], _Chart.prototype, "series", 2);
var Chart = _Chart;
;
;
function removeUsedEnterpriseOptions(options, silent) {
    var _options_series_, _options_series;
    let usedOptions = [];
    const optsType = options === null || options === void 0 ? void 0 : (_options_series = options.series) === null || _options_series === void 0 ? void 0 : (_options_series_ = _options_series[0]) === null || _options_series_ === void 0 ? void 0 : _options_series_.type;
    const isGaugeChart = optsType === "linear-gauge" || optsType === "radial-gauge";
    const optionsChartType = optsType ? chartTypes2.get(optsType) : "unknown";
    for (const module of EXPECTED_ENTERPRISE_MODULES){
        if (optionsChartType !== "unknown" && !module.chartTypes.includes(optionsChartType)) continue;
        if (module.type === "root" || module.type === "legend") {
            const optionValue = options[module.optionsKey];
            if (optionValue == null) continue;
            if (!module.optionsInnerKey) {
                usedOptions.push(module.optionsKey);
                delete options[module.optionsKey];
            } else if (optionValue[module.optionsInnerKey]) {
                usedOptions.push("".concat(module.optionsKey, ".").concat(module.optionsInnerKey));
                delete optionValue[module.optionsInnerKey];
            }
        } else if (module.type === "axis") {
            var _options_axes;
            if (!("axes" in options) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(options.axes) || !((_options_axes = options.axes) === null || _options_axes === void 0 ? void 0 : _options_axes.some((axis)=>axis.type === module.identifier))) {
                continue;
            }
            usedOptions.push("axis[type=".concat(module.identifier, "]"));
            options.axes = options.axes.filter((axis)=>axis.type !== module.identifier);
        } else if (module.type === "axis-option") {
            var _options_axes1;
            if (!("axes" in options) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(options.axes) || !((_options_axes1 = options.axes) === null || _options_axes1 === void 0 ? void 0 : _options_axes1.some((axis)=>axis[module.optionsKey]))) {
                continue;
            }
            usedOptions.push("axis.".concat(module.optionsKey));
            options.axes.forEach((axis)=>{
                if (axis[module.optionsKey]) {
                    delete axis[module.optionsKey];
                }
            });
        } else if (module.type === "series") {
            var _options_series1;
            if (module.community) continue;
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(options.series) || !((_options_series1 = options.series) === null || _options_series1 === void 0 ? void 0 : _options_series1.some((series)=>series.type === module.identifier))) {
                continue;
            }
            usedOptions.push("series[type=".concat(module.identifier, "]"));
            options.series = options.series.filter((series)=>series.type !== module.identifier);
        } else if (module.type === "series-option") {
            var _options_series2;
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(options.series) || !((_options_series2 = options.series) === null || _options_series2 === void 0 ? void 0 : _options_series2.some((series)=>series[module.optionsKey]))) {
                continue;
            }
            usedOptions.push("series.".concat(module.optionsKey));
            options.series.forEach((series)=>{
                if (series[module.optionsKey]) {
                    delete series[module.optionsKey];
                }
            });
        }
    }
    if (usedOptions.length && !silent) {
        if (isGaugeChart) {
            usedOptions = [
                "AgCharts.createGauge"
            ];
        }
        let enterprisePackageName = "ag-charts-enterprise";
        let enterpriseReferenceUrl = "https://www.ag-grid.com/charts/javascript/installation/";
        if (options.mode === "integrated") {
            enterprisePackageName = "ag-grid-charts-enterprise' or 'ag-grid-enterprise/charts-enterprise";
            enterpriseReferenceUrl = "https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/";
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce([
            "unable to use these enterprise features as '".concat(enterprisePackageName, "' has not been loaded:"),
            "",
            ...usedOptions,
            "",
            "See: ".concat(enterpriseReferenceUrl)
        ].join("\n"));
    }
}
function removeUnusedEnterpriseOptions(options) {
    const integratedMode = "mode" in options && options.mode === "integrated";
    for (const module of moduleRegistry.byType("root", "legend")){
        const moduleOptions = options[module.optionsKey];
        const isPresentAndDisabled = moduleOptions != null && moduleOptions.enabled === false;
        const removable = !("removable" in module) || module.removable === true || module.removable === "standalone-only" && !integratedMode;
        if (isPresentAndDisabled && removable) {
            delete options[module.optionsKey];
        }
    }
}
;
;
// packages/ag-charts-community/src/module/coreModulesTypes.ts
function paletteType(partial) {
    if ((partial === null || partial === void 0 ? void 0 : partial.up) || (partial === null || partial === void 0 ? void 0 : partial.down) || (partial === null || partial === void 0 ? void 0 : partial.neutral)) {
        return "user-full";
    } else if ((partial === null || partial === void 0 ? void 0 : partial.fills) || (partial === null || partial === void 0 ? void 0 : partial.strokes)) {
        return "user-indexed";
    }
    return "inbuilt";
}
// packages/ag-charts-community/src/chart/themes/defaultColors.ts
var DEFAULT_FILLS = {
    BLUE: "#5090dc",
    ORANGE: "#ffa03a",
    GREEN: "#459d55",
    CYAN: "#34bfe1",
    YELLOW: "#e1cc00",
    VIOLET: "#9669cb",
    GRAY: "#b5b5b5",
    MAGENTA: "#bd5aa7",
    BROWN: "#8a6224",
    RED: "#ef5452"
};
var DEFAULT_STROKES = {
    BLUE: "#2b5c95",
    ORANGE: "#cc6f10",
    GREEN: "#1e652e",
    CYAN: "#18859e",
    YELLOW: "#a69400",
    VIOLET: "#603c88",
    GRAY: "#575757",
    MAGENTA: "#7d2f6d",
    BROWN: "#4f3508",
    RED: "#a82529"
};
// packages/ag-charts-community/src/chart/themes/symbols.ts
var symbols_exports = {};
__export(symbols_exports, {
    DEFAULT_ANNOTATION_HANDLE_FILL: ()=>DEFAULT_ANNOTATION_HANDLE_FILL,
    DEFAULT_ANNOTATION_STATISTICS_COLOR: ()=>DEFAULT_ANNOTATION_STATISTICS_COLOR,
    DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE: ()=>DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,
    DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL: ()=>DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
    DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE: ()=>DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,
    DEFAULT_ANNOTATION_STATISTICS_FILL: ()=>DEFAULT_ANNOTATION_STATISTICS_FILL,
    DEFAULT_ANNOTATION_STATISTICS_STROKE: ()=>DEFAULT_ANNOTATION_STATISTICS_STROKE,
    DEFAULT_CAPTION_ALIGNMENT: ()=>DEFAULT_CAPTION_ALIGNMENT,
    DEFAULT_CAPTION_LAYOUT_STYLE: ()=>DEFAULT_CAPTION_LAYOUT_STYLE,
    DEFAULT_FIBONACCI_STROKES: ()=>DEFAULT_FIBONACCI_STROKES,
    DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL: ()=>DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
    DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR: ()=>DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
    DEFAULT_GRIDLINE_ENABLED: ()=>DEFAULT_GRIDLINE_ENABLED,
    DEFAULT_POLAR_SERIES_STROKE: ()=>DEFAULT_POLAR_SERIES_STROKE,
    DEFAULT_SEPARATION_LINES_COLOUR: ()=>DEFAULT_SEPARATION_LINES_COLOUR,
    DEFAULT_SHADOW_COLOUR: ()=>DEFAULT_SHADOW_COLOUR,
    DEFAULT_SPARKLINE_CROSSHAIR_STROKE: ()=>DEFAULT_SPARKLINE_CROSSHAIR_STROKE,
    DEFAULT_TEXTBOX_COLOR: ()=>DEFAULT_TEXTBOX_COLOR,
    DEFAULT_TEXTBOX_FILL: ()=>DEFAULT_TEXTBOX_FILL,
    DEFAULT_TEXTBOX_STROKE: ()=>DEFAULT_TEXTBOX_STROKE,
    DEFAULT_TEXT_ANNOTATION_COLOR: ()=>DEFAULT_TEXT_ANNOTATION_COLOR,
    DEFAULT_TOOLBAR_POSITION: ()=>DEFAULT_TOOLBAR_POSITION,
    IS_DARK_THEME: ()=>IS_DARK_THEME,
    PALETTE_ALT_DOWN_FILL: ()=>PALETTE_ALT_DOWN_FILL,
    PALETTE_ALT_DOWN_STROKE: ()=>PALETTE_ALT_DOWN_STROKE,
    PALETTE_ALT_NEUTRAL_FILL: ()=>PALETTE_ALT_NEUTRAL_FILL,
    PALETTE_ALT_NEUTRAL_STROKE: ()=>PALETTE_ALT_NEUTRAL_STROKE,
    PALETTE_ALT_UP_FILL: ()=>PALETTE_ALT_UP_FILL,
    PALETTE_ALT_UP_STROKE: ()=>PALETTE_ALT_UP_STROKE,
    PALETTE_DOWN_FILL: ()=>PALETTE_DOWN_FILL,
    PALETTE_DOWN_STROKE: ()=>PALETTE_DOWN_STROKE,
    PALETTE_NEUTRAL_FILL: ()=>PALETTE_NEUTRAL_FILL,
    PALETTE_NEUTRAL_STROKE: ()=>PALETTE_NEUTRAL_STROKE,
    PALETTE_UP_FILL: ()=>PALETTE_UP_FILL,
    PALETTE_UP_STROKE: ()=>PALETTE_UP_STROKE
});
var IS_DARK_THEME = Symbol("is-dark-theme");
var DEFAULT_SEPARATION_LINES_COLOUR = Symbol("default-separation-lines-colour");
var DEFAULT_SHADOW_COLOUR = Symbol("default-shadow-colour");
var DEFAULT_CAPTION_LAYOUT_STYLE = Symbol("default-caption-layout-style");
var DEFAULT_CAPTION_ALIGNMENT = Symbol("default-caption-alignment");
var PALETTE_UP_STROKE = Symbol("palette-up-stroke");
var PALETTE_DOWN_STROKE = Symbol("palette-down-stroke");
var PALETTE_UP_FILL = Symbol("palette-up-fill");
var PALETTE_DOWN_FILL = Symbol("palette-down-fill");
var PALETTE_NEUTRAL_STROKE = Symbol("palette-neutral-stroke");
var PALETTE_NEUTRAL_FILL = Symbol("palette-neutral-fill");
var PALETTE_ALT_UP_STROKE = Symbol("palette-alt-up-stroke");
var PALETTE_ALT_DOWN_STROKE = Symbol("palette-alt-down-stroke");
var PALETTE_ALT_UP_FILL = Symbol("palette-alt-up-fill");
var PALETTE_ALT_DOWN_FILL = Symbol("palette-alt-down-fill");
var PALETTE_ALT_NEUTRAL_FILL = Symbol("palette-gray-fill");
var PALETTE_ALT_NEUTRAL_STROKE = Symbol("palette-gray-stroke");
var DEFAULT_POLAR_SERIES_STROKE = Symbol("default-polar-series-stroke");
var DEFAULT_SPARKLINE_CROSSHAIR_STROKE = Symbol("default-sparkline-crosshair-stroke");
var DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR = Symbol("default-financial-charts-annotation-stroke");
var DEFAULT_FIBONACCI_STROKES = Symbol("default-hierarchy-strokes");
var DEFAULT_TEXT_ANNOTATION_COLOR = Symbol("default-text-annotation-color");
var DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL = Symbol("default-financial-charts-annotation-background-fill");
var DEFAULT_ANNOTATION_HANDLE_FILL = Symbol("default-annotation-handle-fill");
var DEFAULT_ANNOTATION_STATISTICS_FILL = Symbol("default-annotation-statistics-fill");
var DEFAULT_ANNOTATION_STATISTICS_STROKE = Symbol("default-annotation-statistics-stroke");
var DEFAULT_ANNOTATION_STATISTICS_COLOR = Symbol("default-annotation-statistics-color");
var DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE = Symbol("default-annotation-statistics-divider-stroke");
var DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL = Symbol("default-annotation-statistics-fill");
var DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE = Symbol("default-annotation-statistics-stroke");
var DEFAULT_TEXTBOX_FILL = Symbol("default-textbox-fill");
var DEFAULT_TEXTBOX_STROKE = Symbol("default-textbox-stroke");
var DEFAULT_TEXTBOX_COLOR = Symbol("default-textbox-color");
var DEFAULT_TOOLBAR_POSITION = Symbol("default-toolbar-position");
var DEFAULT_GRIDLINE_ENABLED = Symbol("default-gridline-enabled");
// packages/ag-charts-community/src/chart/themes/util.ts
var DIRECTION_SWAP_AXES = [
    {
        type: "number" /* NUMBER */ ,
        position: {
            $if: [
                {
                    $eq: [
                        {
                            $path: [
                                "/series/0/direction",
                                void 0
                            ]
                        },
                        "horizontal"
                    ]
                },
                "bottom" /* BOTTOM */ ,
                "left" /* LEFT */ 
            ]
        }
    },
    {
        type: "category" /* CATEGORY */ ,
        position: {
            $if: [
                {
                    $eq: [
                        {
                            $path: [
                                "/series/0/direction",
                                void 0
                            ]
                        },
                        "horizontal"
                    ]
                },
                "left" /* LEFT */ ,
                "bottom" /* BOTTOM */ 
            ]
        }
    }
];
var SAFE_FILL_OPERATION = {
    $if: [
        {
            $or: [
                {
                    $isGradient: {
                        $palette: "fill"
                    }
                },
                {
                    $isPattern: {
                        $palette: "fill"
                    }
                },
                {
                    $isImage: {
                        $value: "$1"
                    }
                }
            ]
        },
        {
            $palette: "fillFallback"
        },
        {
            $palette: "fill"
        }
    ]
};
var SAFE_FILLS_OPERATION = {
    $if: [
        {
            $or: [
                {
                    $isGradient: {
                        $palette: "fill"
                    }
                },
                {
                    $isPattern: {
                        $palette: "fill"
                    }
                },
                {
                    $isImage: {
                        $value: "$1"
                    }
                }
            ]
        },
        {
            $palette: "fillsFallback"
        },
        {
            $palette: "fills"
        }
    ]
};
var SAFE_STROKE_FILL_OPERATION = {
    $if: [
        {
            $isGradient: {
                $palette: "fill"
            }
        },
        {
            $palette: "fillFallback"
        },
        {
            $if: [
                {
                    $isPattern: {
                        $palette: "fill"
                    }
                },
                {
                    $path: [
                        "/stroke",
                        {
                            $palette: "fillFallback"
                        },
                        {
                            $palette: "fill"
                        }
                    ]
                },
                {
                    $palette: "fill"
                }
            ]
        }
    ]
};
var SAFE_RANGE2_OPERATION = {
    $if: [
        {
            $or: [
                {
                    $isGradient: {
                        $palette: "fill"
                    }
                },
                {
                    $isPattern: {
                        $palette: "fill"
                    }
                },
                {
                    $isImage: {
                        $value: "$1"
                    }
                }
            ]
        },
        [
            {
                $palette: "fillFallback"
            },
            {
                $palette: "fillFallback"
            }
        ],
        {
            $palette: "range2"
        }
    ]
};
var FILL_GRADIENT_LINEAR_DEFAULTS = {
    type: "gradient",
    gradient: "linear",
    bounds: "item",
    colorStops: {
        $palette: "gradient"
    },
    rotation: 0,
    reverse: false
};
var FILL_GRADIENT_LINEAR_HIERARCHY_DEFAULTS = {
    ...FILL_GRADIENT_LINEAR_DEFAULTS,
    colorStops: [
        {
            $mix: [
                {
                    $path: [
                        "/1",
                        {
                            $palette: "fill"
                        },
                        {
                            $palette: "hierarchyColors"
                        }
                    ]
                },
                "black",
                0.15
            ]
        },
        {
            $mix: [
                {
                    $path: [
                        "/1",
                        {
                            $palette: "fill"
                        },
                        {
                            $palette: "hierarchyColors"
                        }
                    ]
                },
                "white",
                0.15
            ]
        }
    ]
};
var FILL_GRADIENT_LINEAR_SHADED_DEFAULTS = (key)=>({
        ...FILL_GRADIENT_LINEAR_DEFAULTS,
        colorStops: {
            $if: [
                {
                    $or: [
                        {
                            $isGradient: {
                                $palette: "".concat(key, ".fill")
                            }
                        },
                        {
                            $isPattern: {
                                $palette: "".concat(key, ".fill")
                            }
                        },
                        {
                            $isImage: {
                                $palette: "".concat(key, ".fill")
                            }
                        }
                    ]
                },
                {
                    $map: [
                        {
                            $path: [
                                "/color",
                                void 0,
                                {
                                    $value: "$1"
                                }
                            ]
                        },
                        {
                            $path: [
                                "/colorStops",
                                void 0,
                                {
                                    $palette: "".concat(key, ".fill")
                                }
                            ]
                        }
                    ]
                },
                [
                    {
                        $mix: [
                            {
                                $palette: "".concat(key, ".fill")
                            },
                            "black",
                            0.15
                        ]
                    },
                    {
                        $mix: [
                            {
                                $palette: "".concat(key, ".fill")
                            },
                            "white",
                            0.15
                        ]
                    }
                ]
            ]
        }
    });
var FILL_GRADIENT_RADIAL_DEFAULTS = {
    type: "gradient",
    gradient: "radial",
    bounds: "item",
    colorStops: {
        $palette: "gradient"
    },
    rotation: 0,
    reverse: false
};
var FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS = {
    ...FILL_GRADIENT_RADIAL_DEFAULTS,
    reverse: true
};
var FILL_GRADIENT_RADIAL_SERIES_DEFAULTS = {
    ...FILL_GRADIENT_RADIAL_DEFAULTS,
    bounds: "series"
};
var FILL_GRADIENT_RADIAL_REVERSED_SERIES_DEFAULTS = {
    ...FILL_GRADIENT_RADIAL_DEFAULTS,
    bounds: "series",
    reverse: true
};
var FILL_GRADIENT_CONIC_DEFAULTS = {
    type: "gradient",
    gradient: "conic",
    bounds: "series",
    colorStops: {
        $palette: "gradient"
    },
    rotation: 0,
    reverse: false
};
var FILL_PATTERN_DEFAULTS = {
    type: "pattern",
    pattern: "forward-slanted-lines",
    width: 10,
    height: 10,
    padding: 2,
    fill: {
        $if: [
            {
                $or: [
                    {
                        $isGradient: {
                            $palette: "fill"
                        }
                    },
                    {
                        $isImage: {
                            $palette: "fill"
                        }
                    }
                ]
            },
            {
                $palette: "fillFallback"
            },
            {
                $if: [
                    {
                        $isPattern: {
                            $palette: "fill"
                        }
                    },
                    {
                        $path: [
                            "/fill",
                            {
                                $palette: "fillFallback"
                            },
                            {
                                $palette: "fill"
                            }
                        ]
                    },
                    {
                        $palette: "fill"
                    }
                ]
            }
        ]
    },
    fillOpacity: 1,
    stroke: SAFE_STROKE_FILL_OPERATION,
    strokeOpacity: 1,
    strokeWidth: 4,
    backgroundFill: "none",
    backgroundFillOpacity: 1,
    rotation: 0,
    scale: 1
};
var FILL_PATTERN_HIERARCHY_DEFAULTS = {
    ...FILL_PATTERN_DEFAULTS,
    fill: {
        $path: [
            "/1",
            {
                $palette: "fill"
            },
            {
                $palette: "hierarchyColors"
            }
        ]
    },
    stroke: {
        $path: [
            "/1",
            {
                $palette: "fill"
            },
            {
                $palette: "hierarchyColors"
            }
        ]
    }
};
var FILL_IMAGE_DEFAULTS = {
    type: "image",
    backgroundFill: {
        $palette: "fillFallback"
    },
    backgroundFillOpacity: 1,
    repeat: "no-repeat",
    fit: "contain",
    rotation: 0
};
function getSequentialColors(colors) {
    return mapValues(colors, (value)=>{
        const color11 = Color.fromString(value);
        return [
            Color.darken(color11, 0.15).toString(),
            value,
            Color.lighten(color11, 0.15).toString()
        ];
    });
}
var ITEM_HIGHLIGHT_BASE_STYLE = {
    stroke: {
        $path: [
            "../../highlightStyle/item/stroke",
            "rgba(0, 0, 0, 0.4)"
        ]
    },
    strokeWidth: {
        $path: [
            "../../highlightStyle/item/strokeWidth",
            2
        ]
    },
    strokeOpacity: {
        $path: [
            "../../highlightStyle/item/strokeOpacity",
            void 0
        ]
    },
    opacity: {
        $path: [
            "../../highlightStyle/item/opacity",
            1
        ]
    }
};
var ITEM_HIGHLIGHT_STYLE = {
    ...ITEM_HIGHLIGHT_BASE_STYLE,
    fill: {
        $path: [
            "../../highlightStyle/item/fill",
            "rgba(255,255,255, 0.33)"
        ]
    },
    fillOpacity: {
        $path: [
            "../../highlightStyle/item/fillOpacity",
            void 0
        ]
    }
};
var LABEL_BOXING_DEFAULTS = {
    padding: 8,
    cornerRadius: 4,
    fill: {
        $if: [
            {
                $and: [
                    {
                        $eq: [
                            {
                                $path: "./fill/type"
                            },
                            "image"
                        ]
                    },
                    {
                        $isUserOption: [
                            "./fill/backgroundFill",
                            false,
                            true
                        ]
                    }
                ]
            },
            {
                backgroundFill: "transparent"
            },
            void 0
        ]
    },
    border: {
        enabled: {
            $isUserOption: [
                "../border",
                true,
                false
            ]
        },
        strokeWidth: 1,
        stroke: {
            $foregroundOpacity: 0.08
        }
    }
};
function multiSeriesHighlightStyle() {
    let hasFill = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return {
        enabled: true,
        highlightedItem: hasFill ? ITEM_HIGHLIGHT_STYLE : ITEM_HIGHLIGHT_BASE_STYLE,
        unhighlightedItem: {
            strokeWidth: {
                $path: [
                    "../../highlightStyle/series/strokeWidth",
                    void 0
                ]
            }
        },
        highlightedSeries: {
            strokeWidth: {
                $path: [
                    "../../highlightStyle/series/strokeWidth",
                    void 0
                ]
            }
        },
        unhighlightedSeries: {
            opacity: {
                $path: [
                    "../../highlightStyle/series/dimOpacity",
                    void 0
                ]
            }
        }
    };
}
function singleSeriesHighlightStyle() {
    let hasFill = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return {
        enabled: true,
        highlightedItem: hasFill ? ITEM_HIGHLIGHT_STYLE : ITEM_HIGHLIGHT_BASE_STYLE,
        unhighlightedItem: {
            strokeWidth: {
                $path: [
                    "../../highlightStyle/series/strokeWidth",
                    void 0
                ]
            },
            opacity: {
                $path: [
                    "../../highlightStyle/series/dimOpacity",
                    void 0
                ]
            }
        }
    };
}
var LEGEND_CONTAINER_THEME = {
    border: {
        enabled: false,
        stroke: {
            $foregroundBackgroundMix: 0.25
        },
        strokeOpacity: 1,
        strokeWidth: 1
    },
    cornerRadius: 4,
    fillOpacity: 1,
    padding: {
        $if: [
            {
                $eq: [
                    {
                        $path: "./border/enabled"
                    },
                    true
                ]
            },
            5,
            {
                $isUserOption: [
                    "./fill",
                    5,
                    0
                ]
            }
        ]
    }
};
// packages/ag-charts-community/src/chart/themes/chartTheme.ts
var DEFAULT_BACKGROUND_FILL = "white";
var CHART_TYPE_CONFIG = {
    get cartesian () {
        return {
            seriesTypes: chartTypes2.cartesianTypes,
            commonOptions: [
                "zoom",
                "navigator"
            ]
        };
    },
    get polar () {
        return {
            seriesTypes: chartTypes2.polarTypes,
            commonOptions: []
        };
    },
    get topology () {
        return {
            seriesTypes: chartTypes2.topologyTypes,
            commonOptions: []
        };
    },
    get standalone () {
        return {
            seriesTypes: chartTypes2.standaloneTypes,
            commonOptions: []
        };
    }
};
var PRESET_OVERRIDES_TYPES = {
    "radial-gauge": true,
    "linear-gauge": true
};
function isPresetOverridesType(type) {
    return PRESET_OVERRIDES_TYPES[type] === true;
}
var _ChartTheme = class _ChartTheme {
    static getDefaultColors() {
        return {
            fills: DEFAULT_FILLS,
            fillsFallback: Object.values(DEFAULT_FILLS),
            strokes: DEFAULT_STROKES,
            sequentialColors: getSequentialColors(DEFAULT_FILLS),
            divergingColors: [
                DEFAULT_FILLS.ORANGE,
                DEFAULT_FILLS.YELLOW,
                DEFAULT_FILLS.GREEN
            ],
            hierarchyColors: [
                "#fff",
                "#e0e5ea",
                "#c1ccd5",
                "#a3b4c1",
                "#859cad"
            ],
            secondSequentialColors: Color.interpolate([
                Color.fromHexString(DEFAULT_FILLS.BLUE),
                Color.fromHexString("#cbdef5")
            ], 8).map((color11)=>color11.toString()),
            secondDivergingColors: [
                DEFAULT_FILLS.GREEN,
                DEFAULT_FILLS.YELLOW,
                DEFAULT_FILLS.RED
            ],
            secondHierarchyColors: [
                "#fff",
                "#c5cbd1",
                "#a4b1bd",
                "#8498a9",
                "#648096"
            ],
            up: {
                fill: DEFAULT_FILLS.GREEN,
                stroke: DEFAULT_STROKES.GREEN
            },
            down: {
                fill: DEFAULT_FILLS.RED,
                stroke: DEFAULT_STROKES.RED
            },
            neutral: {
                fill: DEFAULT_FILLS.GRAY,
                stroke: DEFAULT_STROKES.GRAY
            },
            altUp: {
                fill: DEFAULT_FILLS.BLUE,
                stroke: DEFAULT_STROKES.BLUE
            },
            altDown: {
                fill: DEFAULT_FILLS.ORANGE,
                stroke: DEFAULT_STROKES.ORANGE
            },
            altNeutral: {
                fill: DEFAULT_FILLS.GRAY,
                stroke: DEFAULT_STROKES.GRAY
            }
        };
    }
    static getDefaultPublicParameters() {
        return {
            accentColor: "#2196f3",
            axisColor: {
                $foregroundBackgroundMix: 0.325
            },
            backgroundColor: DEFAULT_BACKGROUND_FILL,
            borderColor: {
                $foregroundOpacity: 0.15
            },
            borderRadius: 4,
            chartBackgroundColor: {
                $ref: "backgroundColor"
            },
            chartPadding: 20,
            focusShadow: "0 0 0 3px var(--ag-charts-accent-color)",
            foregroundColor: "#181d1f",
            fontFamily: "Verdana, sans-serif",
            fontSize: BASE_FONT_SIZE,
            fontWeight: 400,
            gridLineColor: {
                $foregroundBackgroundMix: 0.1
            },
            popupShadow: "0 0 16px rgba(0, 0, 0, 0.15)",
            subtleTextColor: {
                $mix: [
                    {
                        $ref: "textColor"
                    },
                    {
                        $ref: "chartBackgroundColor"
                    },
                    0.38
                ]
            },
            textColor: {
                $ref: "foregroundColor"
            },
            chromeBackgroundColor: {
                $foregroundBackgroundMix: 0.02
            },
            chromeFontFamily: {
                $ref: "fontFamily"
            },
            chromeFontSize: {
                $ref: "fontSize"
            },
            chromeFontWeight: {
                $ref: "fontWeight"
            },
            chromeTextColor: {
                $ref: "foregroundColor"
            },
            chromeSubtleTextColor: {
                $mix: [
                    {
                        $ref: "chromeTextColor"
                    },
                    {
                        $ref: "backgroundColor"
                    },
                    0.38
                ]
            },
            buttonBackgroundColor: {
                $ref: "backgroundColor"
            },
            buttonBorder: true,
            buttonFontWeight: 400,
            buttonTextColor: {
                $ref: "textColor"
            },
            inputBackgroundColor: {
                $ref: "backgroundColor"
            },
            inputBorder: true,
            inputTextColor: {
                $ref: "textColor"
            },
            menuBackgroundColor: {
                $ref: "chromeBackgroundColor"
            },
            menuBorder: true,
            menuTextColor: {
                $ref: "chromeTextColor"
            },
            panelBackgroundColor: {
                $ref: "chromeBackgroundColor"
            },
            panelSubtleTextColor: {
                $ref: "chromeSubtleTextColor"
            },
            tooltipBackgroundColor: {
                $ref: "chromeBackgroundColor"
            },
            tooltipBorder: true,
            tooltipTextColor: {
                $ref: "chromeTextColor"
            },
            tooltipSubtleTextColor: {
                $ref: "chromeSubtleTextColor"
            },
            crosshairLabelBackgroundColor: {
                $ref: "foregroundColor"
            },
            crosshairLabelTextColor: {
                $ref: "chartBackgroundColor"
            }
        };
    }
    static getAxisDefaults(overrideDefaults, param) {
        let { title, time: time3 } = param;
        return mergeDefaults(overrideDefaults, title && {
            title: {
                enabled: false,
                text: "Axis Title",
                spacing: 25,
                fontWeight: {
                    $ref: "fontWeight"
                },
                fontSize: {
                    $rem: FONT_SIZE_RATIO.MEDIUM
                },
                fontFamily: {
                    $ref: "fontFamily"
                },
                color: {
                    $ref: "textColor"
                }
            }
        }, time3 && {
            parentLevel: {
                enabled: false,
                label: {
                    // TODO: { $merge: [{ $path: '../../label' }, { fontWeight: 'bold' }]}
                    enabled: {
                        $path: "../../label/enabled"
                    },
                    border: {
                        enabled: {
                            $or: [
                                {
                                    $isUserOption: [
                                        "../border",
                                        true,
                                        false
                                    ]
                                },
                                {
                                    $path: "../../../label/border/enabled"
                                }
                            ]
                        },
                        strokeWidth: {
                            $path: "../../../label/border/strokeWidth"
                        },
                        stroke: {
                            $path: "../../../label/border/stroke"
                        }
                    },
                    fill: {
                        $path: "../../label/fill"
                    },
                    fontSize: {
                        $path: "../../label/fontSize"
                    },
                    fontFamily: {
                        $path: "../../label/fontFamily"
                    },
                    fontWeight: "bold",
                    spacing: {
                        $path: "../../label/spacing"
                    },
                    color: {
                        $path: "../../label/color"
                    },
                    cornerRadius: {
                        $path: "../../label/cornerRadius"
                    },
                    padding: {
                        $path: "../../label/padding"
                    },
                    avoidCollisions: {
                        $path: "../../label/avoidCollisions"
                    }
                },
                tick: {
                    enabled: {
                        $path: "../../tick/enabled"
                    },
                    width: {
                        $path: "../../tick/width"
                    },
                    size: {
                        $path: "../../tick/size"
                    },
                    stroke: {
                        $path: "../../tick/stroke"
                    }
                }
            }
        }, {
            label: {
                enabled: true,
                fontSize: {
                    $ref: "fontSize"
                },
                fontFamily: {
                    $ref: "fontFamily"
                },
                fontWeight: {
                    $ref: "fontWeight"
                },
                spacing: 11,
                color: {
                    $ref: "textColor"
                },
                avoidCollisions: true,
                cornerRadius: 4,
                border: {
                    enabled: {
                        $isUserOption: [
                            "../border",
                            true,
                            false
                        ]
                    },
                    strokeWidth: 1,
                    stroke: {
                        $foregroundOpacity: 0.08
                    }
                },
                padding: {
                    $if: [
                        {
                            $eq: [
                                {
                                    $path: "./border/enabled"
                                },
                                true
                            ]
                        },
                        {
                            left: 12,
                            right: 12,
                            top: 8,
                            bottom: 8
                        },
                        void 0
                    ]
                }
            },
            line: {
                enabled: true,
                width: 1,
                stroke: {
                    $ref: "axisColor"
                }
            },
            tick: {
                enabled: false,
                size: 6,
                width: 1,
                stroke: {
                    $ref: "axisColor"
                }
            },
            gridLine: {
                enabled: true,
                width: 1,
                style: {
                    $apply: [
                        {
                            fillOpacity: 1,
                            stroke: {
                                $ref: "gridLineColor"
                            },
                            strokeWidth: {
                                $path: "../../width"
                            },
                            lineDash: []
                        },
                        [
                            {
                                fillOpacity: 1,
                                stroke: {
                                    $ref: "gridLineColor"
                                },
                                strokeWidth: {
                                    $path: "../../width"
                                },
                                lineDash: []
                            }
                        ]
                    ]
                }
            },
            crossLines: {
                $apply: [
                    {
                        enabled: true,
                        fill: {
                            $ref: "foregroundColor"
                        },
                        stroke: {
                            $ref: "foregroundColor"
                        },
                        fillOpacity: 0.08,
                        strokeWidth: 1,
                        label: {
                            fontSize: {
                                $ref: "fontSize"
                            },
                            fontFamily: {
                                $ref: "fontFamily"
                            },
                            fontWeight: {
                                $ref: "fontWeight"
                            },
                            padding: 5,
                            color: {
                                $ref: "textColor"
                            }
                        }
                    },
                    void 0,
                    // TODO: can we just infer this common path?
                    {
                        $pathString: [
                            "/common/axes/$axisType/crossLines",
                            {
                                axisType: {
                                    $path: [
                                        "/axes/$index/type"
                                    ]
                                }
                            }
                        ]
                    },
                    {
                        $pathString: [
                            "/$seriesType/axes/$axisType/crossLines",
                            {
                                seriesType: {
                                    $path: [
                                        "/series/0/type",
                                        "line"
                                    ]
                                },
                                axisType: {
                                    $path: [
                                        "/axes/$index/type"
                                    ]
                                }
                            }
                        ]
                    }
                ]
            }
        });
    }
    getChartDefaults() {
        return {
            minHeight: 300,
            minWidth: 300,
            background: {
                visible: true,
                fill: {
                    $ref: "chartBackgroundColor"
                }
            },
            padding: {
                top: {
                    $ref: "chartPadding"
                },
                right: {
                    $ref: "chartPadding"
                },
                bottom: {
                    $ref: "chartPadding"
                },
                left: {
                    $ref: "chartPadding"
                }
            },
            seriesArea: {
                border: {
                    enabled: false,
                    stroke: {
                        $ref: "foregroundColor"
                    },
                    strokeOpacity: 1,
                    strokeWidth: 1
                },
                cornerRadius: 4,
                padding: {
                    $if: [
                        {
                            $eq: [
                                {
                                    $path: "./border/enabled"
                                },
                                true
                            ]
                        },
                        5,
                        0
                    ]
                }
            },
            keyboard: {
                enabled: true
            },
            title: {
                enabled: false,
                text: "Title",
                spacing: {
                    $if: [
                        {
                            $path: "../subtitle/enabled"
                        },
                        10,
                        20
                    ]
                },
                fontWeight: {
                    $ref: "fontWeight"
                },
                fontSize: {
                    $rem: FONT_SIZE_RATIO.LARGEST
                },
                fontFamily: {
                    $ref: "fontFamily"
                },
                color: {
                    $ref: "textColor"
                },
                wrapping: "hyphenate",
                layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,
                textAlign: DEFAULT_CAPTION_ALIGNMENT
            },
            subtitle: {
                enabled: false,
                text: "Subtitle",
                spacing: 20,
                fontWeight: {
                    $ref: "fontWeight"
                },
                fontSize: {
                    $rem: FONT_SIZE_RATIO.MEDIUM
                },
                fontFamily: {
                    $ref: "fontFamily"
                },
                color: {
                    $ref: "subtleTextColor"
                },
                wrapping: "hyphenate",
                layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,
                textAlign: DEFAULT_CAPTION_ALIGNMENT
            },
            footnote: {
                enabled: false,
                text: "Footnote",
                spacing: 20,
                fontSize: {
                    $rem: FONT_SIZE_RATIO.MEDIUM
                },
                fontFamily: {
                    $ref: "fontFamily"
                },
                fontWeight: {
                    $ref: "fontWeight"
                },
                color: {
                    $ref: "subtleTextColor"
                },
                wrapping: "hyphenate",
                layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,
                textAlign: DEFAULT_CAPTION_ALIGNMENT
            },
            legend: {
                ...LEGEND_CONTAINER_THEME,
                enabled: {
                    $and: [
                        {
                            $greaterThan: [
                                {
                                    $size: [
                                        {
                                            $path: "/series"
                                        }
                                    ]
                                },
                                1
                            ]
                        },
                        {
                            $or: [
                                {
                                    $isChartType: "cartesian"
                                },
                                {
                                    $isChartType: "standalone"
                                },
                                {
                                    $and: [
                                        {
                                            $isChartType: "polar"
                                        },
                                        {
                                            $not: {
                                                $isSeriesType: "pie"
                                            }
                                        },
                                        {
                                            $not: {
                                                $isSeriesType: "donut"
                                            }
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                },
                position: "bottom" /* BOTTOM */ ,
                orientation: {
                    $if: [
                        {
                            $or: [
                                {
                                    $eq: [
                                        {
                                            $path: "./position"
                                        },
                                        "left" /* LEFT */ 
                                    ]
                                },
                                {
                                    $eq: [
                                        {
                                            $path: "./position"
                                        },
                                        "left-top" /* LEFT_TOP */ 
                                    ]
                                },
                                {
                                    $eq: [
                                        {
                                            $path: "./position"
                                        },
                                        "left-bottom" /* LEFT_BOTTOM */ 
                                    ]
                                },
                                {
                                    $eq: [
                                        {
                                            $path: "./position"
                                        },
                                        "right" /* RIGHT */ 
                                    ]
                                },
                                {
                                    $eq: [
                                        {
                                            $path: "./position"
                                        },
                                        "right-top" /* RIGHT_TOP */ 
                                    ]
                                },
                                {
                                    $eq: [
                                        {
                                            $path: "./position"
                                        },
                                        "right-bottom" /* RIGHT_BOTTOM */ 
                                    ]
                                },
                                {
                                    $eq: [
                                        {
                                            $path: "./position/placement"
                                        },
                                        "left" /* LEFT */ 
                                    ]
                                },
                                {
                                    $eq: [
                                        {
                                            $path: "./position/placement"
                                        },
                                        "left-top" /* LEFT_TOP */ 
                                    ]
                                },
                                {
                                    $eq: [
                                        {
                                            $path: "./position/placement"
                                        },
                                        "left-bottom" /* LEFT_BOTTOM */ 
                                    ]
                                },
                                {
                                    $eq: [
                                        {
                                            $path: "./position/placement"
                                        },
                                        "right" /* RIGHT */ 
                                    ]
                                },
                                {
                                    $eq: [
                                        {
                                            $path: "./position/placement"
                                        },
                                        "right-top" /* RIGHT_TOP */ 
                                    ]
                                },
                                {
                                    $eq: [
                                        {
                                            $path: "./position/placement"
                                        },
                                        "right-bottom" /* RIGHT_BOTTOM */ 
                                    ]
                                }
                            ]
                        },
                        "vertical",
                        "horizontal"
                    ]
                },
                spacing: 30,
                listeners: {},
                toggleSeries: true,
                item: {
                    paddingX: 16,
                    paddingY: 8,
                    marker: {
                        size: 15,
                        padding: 8
                    },
                    showSeriesStroke: true,
                    label: {
                        color: {
                            $ref: "textColor"
                        },
                        fontSize: {
                            $rem: FONT_SIZE_RATIO.SMALL
                        },
                        fontFamily: {
                            $ref: "fontFamily"
                        },
                        fontWeight: {
                            $ref: "fontWeight"
                        }
                    }
                },
                reverseOrder: false,
                pagination: {
                    marker: {
                        size: 12
                    },
                    activeStyle: {
                        fill: {
                            $ref: "foregroundColor"
                        }
                    },
                    inactiveStyle: {
                        fill: {
                            $ref: "subtleTextColor"
                        }
                    },
                    highlightStyle: {
                        fill: {
                            $ref: "foregroundColor"
                        }
                    },
                    label: {
                        color: {
                            $ref: "textColor"
                        }
                    }
                },
                fill: {
                    $if: [
                        {
                            $path: [
                                "./position/floating",
                                false
                            ]
                        },
                        {
                            $ref: "chartBackgroundColor"
                        },
                        "transparent"
                    ]
                }
            },
            tooltip: {
                enabled: true,
                darkTheme: IS_DARK_THEME,
                delay: 0,
                pagination: false,
                mode: {
                    $if: [
                        {
                            $and: [
                                {
                                    $isChartType: "cartesian"
                                },
                                {
                                    $not: {
                                        $hasSeriesType: "bubble"
                                    }
                                },
                                {
                                    $not: {
                                        $hasSeriesType: "scatter"
                                    }
                                },
                                {
                                    $greaterThan: [
                                        {
                                            $size: [
                                                {
                                                    $path: "/series"
                                                }
                                            ]
                                        },
                                        1
                                    ]
                                },
                                {
                                    $lessThan: [
                                        {
                                            $size: [
                                                {
                                                    $path: "/series"
                                                }
                                            ]
                                        },
                                        4
                                    ]
                                }
                            ]
                        },
                        "shared",
                        "single"
                    ]
                }
            },
            overlays: {
                darkTheme: IS_DARK_THEME
            },
            listeners: {},
            series: {
                tooltip: {
                    range: {
                        $path: [
                            "/tooltip/range",
                            "exact"
                        ]
                    },
                    position: {
                        anchorTo: {
                            $path: [
                                "/tooltip/position/anchorTo",
                                "pointer"
                            ]
                        },
                        placement: {
                            $path: [
                                "/tooltip/position/placement",
                                void 0
                            ]
                        },
                        xOffset: {
                            $path: [
                                "/tooltip/position/xOffset",
                                0
                            ]
                        },
                        yOffset: {
                            $path: [
                                "/tooltip/position/yOffset",
                                0
                            ]
                        }
                    }
                }
            }
        };
    }
    processOverrides(presets, overrides) {
        chartTypes2.seriesTypes.forEach((s)=>{
            const seriesType = s;
            const seriesOverrides = overrides[seriesType];
            if (isPresetOverridesType(seriesType)) {
                presets[seriesType] = seriesOverrides;
                delete overrides[seriesType];
            }
        });
    }
    createChartConfigPerChartType(config) {
        for (const [nextType, { seriesTypes }] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entries"])(CHART_TYPE_CONFIG)){
            const typeDefaults = chartDefaults.get(nextType);
            for (const seriesType of seriesTypes){
                var _config_seriesType;
                (_config_seriesType = config[seriesType]) !== null && _config_seriesType !== void 0 ? _config_seriesType : config[seriesType] = deepClone(typeDefaults);
            }
        }
        return config;
    }
    getDefaults() {
        const getOverridesByType = (chartType, seriesTypes)=>{
            const result = {};
            const chartTypeDefaults = {
                axes: {},
                ...legendRegistry.getThemeTemplates(),
                ...this.getChartDefaults(),
                ...chartDefaults.get(chartType)
            };
            for (const seriesType of seriesTypes){
                var _result_seriesType;
                result[seriesType] = mergeDefaults(seriesRegistry.getThemeTemplate(seriesType), (_result_seriesType = result[seriesType]) !== null && _result_seriesType !== void 0 ? _result_seriesType : deepClone(chartTypeDefaults));
                const { axes } = result[seriesType];
                for (const axisType of axisRegistry.keys()){
                    axes[axisType] = mergeDefaults(axes[axisType], axisRegistry.getThemeTemplate(axisType), _ChartTheme.axisDefault[axisType]);
                }
                if (seriesType === "map-shape-background" || seriesType === "map-line-background") {
                    delete result[seriesType].series.tooltip;
                }
            }
            return result;
        };
        return mergeDefaults(getOverridesByType("cartesian", chartTypes2.cartesianTypes), getOverridesByType("polar", chartTypes2.polarTypes), getOverridesByType("topology", chartTypes2.topologyTypes), getOverridesByType("standalone", chartTypes2.standaloneTypes));
    }
    static applyTemplateTheme(node, _other, params) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(node)) {
            for(let i = 0; i < node.length; i++){
                const symbol = node[i];
                if (typeof symbol === "symbol" && (params === null || params === void 0 ? void 0 : params.has(symbol))) {
                    node[i] = params.get(symbol);
                }
            }
        } else {
            for (const name of Object.keys(node)){
                const value = node[name];
                if (typeof value === "symbol" && (params === null || params === void 0 ? void 0 : params.has(value))) {
                    node[name] = params.get(value);
                }
            }
        }
    }
    templateTheme(themeTemplate) {
        let clone2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        const themeInstance = clone2 ? deepClone(themeTemplate) : themeTemplate;
        const params = this.getTemplateParameters();
        jsonWalk(themeInstance, _ChartTheme.applyTemplateTheme, void 0, void 0, params);
        return themeInstance;
    }
    getDefaultColors() {
        return _ChartTheme.getDefaultColors();
    }
    getPublicParameters() {
        return _ChartTheme.getDefaultPublicParameters();
    }
    // Private parameters that are not exposed in the themes API.
    getTemplateParameters() {
        var _this_palette_up, _this_palette_up1, _this_palette_down, _this_palette_down1, _this_palette_neutral, _this_palette_neutral1, _this_palette_altUp, _this_palette_altUp1, _this_palette_altDown, _this_palette_altDown1, _this_palette_altNeutral, _this_palette_altNeutral1;
        const params = /* @__PURE__ */ new Map();
        params.set(IS_DARK_THEME, false);
        params.set(DEFAULT_SEPARATION_LINES_COLOUR, "#d9d9d9");
        params.set(DEFAULT_SHADOW_COLOUR, "#00000080");
        params.set(DEFAULT_SPARKLINE_CROSSHAIR_STROKE, "#aaa");
        params.set(DEFAULT_CAPTION_LAYOUT_STYLE, "block");
        params.set(DEFAULT_CAPTION_ALIGNMENT, "center");
        params.set(DEFAULT_FIBONACCI_STROKES, [
            "#797b86",
            "#e24c4a",
            "#f49d2d",
            "#65ab58",
            "#409682",
            "#4db9d2",
            "#5090dc",
            "#3068f9",
            "#e24c4a",
            "#913aac",
            "#d93e64"
        ]);
        params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, DEFAULT_FILLS.BLUE);
        params.set(DEFAULT_TEXT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);
        params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_BACKGROUND_FILL);
        params.set(DEFAULT_ANNOTATION_STATISTICS_FILL, "#fafafa");
        params.set(DEFAULT_ANNOTATION_STATISTICS_STROKE, "#ddd");
        params.set(DEFAULT_ANNOTATION_STATISTICS_COLOR, "#000");
        params.set(DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE, "#181d1f");
        params.set(DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL, "#e35c5c");
        params.set(DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE, "#e35c5c");
        params.set(DEFAULT_TEXTBOX_FILL, "#fafafa");
        params.set(DEFAULT_TEXTBOX_STROKE, "#ddd");
        params.set(DEFAULT_TEXTBOX_COLOR, "#000");
        params.set(DEFAULT_TOOLBAR_POSITION, "top");
        params.set(DEFAULT_GRIDLINE_ENABLED, false);
        const defaultColors = this.getDefaultColors();
        var _this_palette_up_stroke;
        params.set(PALETTE_UP_STROKE, (_this_palette_up_stroke = (_this_palette_up = this.palette.up) === null || _this_palette_up === void 0 ? void 0 : _this_palette_up.stroke) !== null && _this_palette_up_stroke !== void 0 ? _this_palette_up_stroke : defaultColors.up.stroke);
        var _this_palette_up_fill;
        params.set(PALETTE_UP_FILL, (_this_palette_up_fill = (_this_palette_up1 = this.palette.up) === null || _this_palette_up1 === void 0 ? void 0 : _this_palette_up1.fill) !== null && _this_palette_up_fill !== void 0 ? _this_palette_up_fill : defaultColors.up.fill);
        var _this_palette_down_stroke;
        params.set(PALETTE_DOWN_STROKE, (_this_palette_down_stroke = (_this_palette_down = this.palette.down) === null || _this_palette_down === void 0 ? void 0 : _this_palette_down.stroke) !== null && _this_palette_down_stroke !== void 0 ? _this_palette_down_stroke : defaultColors.down.stroke);
        var _this_palette_down_fill;
        params.set(PALETTE_DOWN_FILL, (_this_palette_down_fill = (_this_palette_down1 = this.palette.down) === null || _this_palette_down1 === void 0 ? void 0 : _this_palette_down1.fill) !== null && _this_palette_down_fill !== void 0 ? _this_palette_down_fill : defaultColors.down.fill);
        var _this_palette_neutral_stroke;
        params.set(PALETTE_NEUTRAL_STROKE, (_this_palette_neutral_stroke = (_this_palette_neutral = this.palette.neutral) === null || _this_palette_neutral === void 0 ? void 0 : _this_palette_neutral.stroke) !== null && _this_palette_neutral_stroke !== void 0 ? _this_palette_neutral_stroke : defaultColors.neutral.stroke);
        var _this_palette_neutral_fill;
        params.set(PALETTE_NEUTRAL_FILL, (_this_palette_neutral_fill = (_this_palette_neutral1 = this.palette.neutral) === null || _this_palette_neutral1 === void 0 ? void 0 : _this_palette_neutral1.fill) !== null && _this_palette_neutral_fill !== void 0 ? _this_palette_neutral_fill : defaultColors.neutral.fill);
        var _this_palette_altUp_stroke;
        params.set(PALETTE_ALT_UP_STROKE, (_this_palette_altUp_stroke = (_this_palette_altUp = this.palette.altUp) === null || _this_palette_altUp === void 0 ? void 0 : _this_palette_altUp.stroke) !== null && _this_palette_altUp_stroke !== void 0 ? _this_palette_altUp_stroke : defaultColors.up.stroke);
        var _this_palette_altUp_fill;
        params.set(PALETTE_ALT_UP_FILL, (_this_palette_altUp_fill = (_this_palette_altUp1 = this.palette.altUp) === null || _this_palette_altUp1 === void 0 ? void 0 : _this_palette_altUp1.fill) !== null && _this_palette_altUp_fill !== void 0 ? _this_palette_altUp_fill : defaultColors.up.fill);
        var _this_palette_altDown_stroke;
        params.set(PALETTE_ALT_DOWN_STROKE, (_this_palette_altDown_stroke = (_this_palette_altDown = this.palette.altDown) === null || _this_palette_altDown === void 0 ? void 0 : _this_palette_altDown.stroke) !== null && _this_palette_altDown_stroke !== void 0 ? _this_palette_altDown_stroke : defaultColors.down.stroke);
        var _this_palette_altDown_fill;
        params.set(PALETTE_ALT_DOWN_FILL, (_this_palette_altDown_fill = (_this_palette_altDown1 = this.palette.altDown) === null || _this_palette_altDown1 === void 0 ? void 0 : _this_palette_altDown1.fill) !== null && _this_palette_altDown_fill !== void 0 ? _this_palette_altDown_fill : defaultColors.down.fill);
        var _this_palette_altNeutral_fill;
        params.set(PALETTE_ALT_NEUTRAL_FILL, (_this_palette_altNeutral_fill = (_this_palette_altNeutral = this.palette.altNeutral) === null || _this_palette_altNeutral === void 0 ? void 0 : _this_palette_altNeutral.fill) !== null && _this_palette_altNeutral_fill !== void 0 ? _this_palette_altNeutral_fill : defaultColors.altNeutral.fill);
        var _this_palette_altNeutral_stroke;
        params.set(PALETTE_ALT_NEUTRAL_STROKE, (_this_palette_altNeutral_stroke = (_this_palette_altNeutral1 = this.palette.altNeutral) === null || _this_palette_altNeutral1 === void 0 ? void 0 : _this_palette_altNeutral1.stroke) !== null && _this_palette_altNeutral_stroke !== void 0 ? _this_palette_altNeutral_stroke : defaultColors.altNeutral.stroke);
        return params;
    }
    constructor(options = {}){
        const { overrides, palette, params } = deepClone(options);
        const defaults = this.createChartConfigPerChartType(this.getDefaults());
        const presets = {};
        if (overrides) {
            this.processOverrides(presets, overrides);
        }
        const { fills, strokes, sequentialColors, ...otherColors } = this.getDefaultColors();
        this.palette = deepFreeze(mergeDefaults(palette, {
            fills: Object.values(fills),
            strokes: Object.values(strokes),
            sequentialColors: Object.values(sequentialColors),
            ...otherColors
        }));
        this.paletteType = paletteType(palette);
        this.params = mergeDefaults(params, this.getPublicParameters());
        this.config = deepFreeze(deepClone(defaults));
        this.overrides = deepFreeze(overrides);
        this.presets = deepFreeze(presets);
    }
};
_ChartTheme.axisDefault = {
    ["number" /* NUMBER */ ]: _ChartTheme.getAxisDefaults({
        keys: [],
        line: {
            enabled: false
        },
        crosshair: {
            enabled: true
        }
    }, {
        title: true,
        time: false
    }),
    ["log" /* LOG */ ]: _ChartTheme.getAxisDefaults({
        keys: [],
        base: 10,
        line: {
            enabled: false
        },
        crosshair: {
            enabled: true
        }
    }, {
        title: true,
        time: false
    }),
    ["category" /* CATEGORY */ ]: _ChartTheme.getAxisDefaults({
        keys: [],
        groupPaddingInner: 0.1,
        label: {
            autoRotate: true,
            wrapping: "on-space"
        },
        gridLine: {
            enabled: DEFAULT_GRIDLINE_ENABLED
        },
        crosshair: {
            enabled: false
        }
    }, {
        title: true,
        time: false
    }),
    ["grouped-category" /* GROUPED_CATEGORY */ ]: _ChartTheme.getAxisDefaults({
        keys: [],
        tick: {
            enabled: true,
            stroke: DEFAULT_SEPARATION_LINES_COLOUR
        },
        label: {
            spacing: 10,
            rotation: 270,
            wrapping: "on-space"
        },
        maxThicknessRatio: 0.5,
        paddingInner: 0.4,
        groupPaddingInner: 0.2,
        crosshair: {
            enabled: false
        }
    }, {
        title: true,
        time: false
    }),
    ["time" /* TIME */ ]: _ChartTheme.getAxisDefaults({
        keys: [],
        gridLine: {
            enabled: DEFAULT_GRIDLINE_ENABLED
        },
        crosshair: {
            enabled: true
        }
    }, {
        title: true,
        time: true
    }),
    ["unit-time" /* UNIT_TIME */ ]: _ChartTheme.getAxisDefaults({
        keys: [],
        groupPaddingInner: 0.1,
        label: {
            autoRotate: false
        },
        gridLine: {
            enabled: DEFAULT_GRIDLINE_ENABLED
        },
        crosshair: {
            enabled: true
        },
        parentLevel: {
            enabled: true
        }
    }, {
        title: true,
        time: true
    }),
    ["ordinal-time" /* ORDINAL_TIME */ ]: _ChartTheme.getAxisDefaults({
        keys: [],
        groupPaddingInner: 0,
        label: {
            autoRotate: false
        },
        gridLine: {
            enabled: DEFAULT_GRIDLINE_ENABLED
        },
        crosshair: {
            enabled: true
        }
    }, {
        title: true,
        time: true
    }),
    ["angle-category" /* ANGLE_CATEGORY */ ]: _ChartTheme.getAxisDefaults({
        label: {
            spacing: 5
        },
        gridLine: {
            enabled: DEFAULT_GRIDLINE_ENABLED
        },
        shape: {
            $findFirstSiblingNotOperation: void 0
        }
    }, {
        title: false,
        time: false
    }),
    ["angle-number" /* ANGLE_NUMBER */ ]: _ChartTheme.getAxisDefaults({
        label: {
            spacing: 5
        },
        gridLine: {
            enabled: DEFAULT_GRIDLINE_ENABLED
        }
    }, {
        title: false,
        time: false
    }),
    ["radius-category" /* RADIUS_CATEGORY */ ]: _ChartTheme.getAxisDefaults({
        positionAngle: 0,
        line: {
            enabled: false
        }
    }, {
        title: true,
        time: false
    }),
    ["radius-number" /* RADIUS_NUMBER */ ]: _ChartTheme.getAxisDefaults({
        positionAngle: 0,
        line: {
            enabled: false
        },
        shape: {
            $findFirstSiblingNotOperation: void 0
        }
    }, {
        title: true,
        time: false
    })
};
var ChartTheme = _ChartTheme;
// packages/ag-charts-community/src/chart/themes/darkTheme.ts
var DEFAULT_DARK_BACKGROUND_FILL = "#192232";
var DEFAULT_DARK_FILLS = {
    BLUE: "#5090dc",
    ORANGE: "#ffa03a",
    GREEN: "#459d55",
    CYAN: "#34bfe1",
    YELLOW: "#e1cc00",
    VIOLET: "#9669cb",
    GRAY: "#b5b5b5",
    MAGENTA: "#bd5aa7",
    BROWN: "#8a6224",
    RED: "#ef5452"
};
var DEFAULT_DARK_STROKES = {
    BLUE: "#74a8e6",
    ORANGE: "#ffbe70",
    GREEN: "#6cb176",
    CYAN: "#75d4ef",
    YELLOW: "#f6e559",
    VIOLET: "#aa86d8",
    GRAY: "#a1a1a1",
    MAGENTA: "#ce7ab9",
    BROWN: "#997b52",
    RED: "#ff7872"
};
var DarkTheme = class extends ChartTheme {
    getDefaultColors() {
        return {
            fills: DEFAULT_DARK_FILLS,
            fillsFallback: Object.values(DEFAULT_DARK_FILLS),
            strokes: DEFAULT_DARK_STROKES,
            sequentialColors: getSequentialColors(DEFAULT_DARK_FILLS),
            divergingColors: [
                DEFAULT_DARK_FILLS.ORANGE,
                DEFAULT_DARK_FILLS.YELLOW,
                DEFAULT_DARK_FILLS.GREEN
            ],
            hierarchyColors: [
                "#192834",
                "#253746",
                "#324859",
                "#3f596c",
                "#4d6a80"
            ],
            secondSequentialColors: [
                "#5090dc",
                "#4882c6",
                "#4073b0",
                "#38659a",
                "#305684",
                "#28486e",
                "#203a58",
                "#182b42"
            ],
            secondDivergingColors: [
                DEFAULT_DARK_FILLS.GREEN,
                DEFAULT_DARK_FILLS.YELLOW,
                DEFAULT_DARK_FILLS.RED
            ],
            secondHierarchyColors: [
                "#192834",
                "#3b5164",
                "#496275",
                "#577287",
                "#668399"
            ],
            up: {
                fill: DEFAULT_DARK_FILLS.GREEN,
                stroke: DEFAULT_DARK_STROKES.GREEN
            },
            down: {
                fill: DEFAULT_DARK_FILLS.RED,
                stroke: DEFAULT_DARK_STROKES.RED
            },
            neutral: {
                fill: DEFAULT_DARK_FILLS.GRAY,
                stroke: DEFAULT_DARK_STROKES.GRAY
            },
            altUp: {
                fill: DEFAULT_DARK_FILLS.BLUE,
                stroke: DEFAULT_DARK_STROKES.BLUE
            },
            altDown: {
                fill: DEFAULT_DARK_FILLS.ORANGE,
                stroke: DEFAULT_DARK_STROKES.ORANGE
            },
            altNeutral: {
                fill: DEFAULT_DARK_FILLS.GRAY,
                stroke: DEFAULT_DARK_STROKES.GRAY
            }
        };
    }
    getPublicParameters() {
        return {
            ...super.getPublicParameters(),
            axisColor: {
                $foregroundBackgroundMix: 0.737
            },
            backgroundColor: DEFAULT_DARK_BACKGROUND_FILL,
            borderColor: {
                $foregroundBackgroundMix: 0.216
            },
            chromeBackgroundColor: {
                $foregroundBackgroundMix: 0.07
            },
            foregroundColor: "#fff",
            gridLineColor: {
                $foregroundBackgroundMix: 0.257
            },
            popupShadow: "0 0 16px rgba(0, 0, 0, 0.33)",
            subtleTextColor: {
                $mix: [
                    {
                        $ref: "textColor"
                    },
                    {
                        $ref: "chartBackgroundColor"
                    },
                    0.57
                ]
            },
            crosshairLabelBackgroundColor: {
                $foregroundBackgroundMix: 0.65
            }
        };
    }
    getTemplateParameters() {
        const params = super.getTemplateParameters();
        params.set(IS_DARK_THEME, true);
        params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);
        params.set(DEFAULT_SEPARATION_LINES_COLOUR, "#7f8389");
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, DEFAULT_DARK_FILLS.BLUE);
        params.set(DEFAULT_TEXT_ANNOTATION_COLOR, "#fff");
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, DEFAULT_DARK_FILLS.BLUE);
        params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_DARK_BACKGROUND_FILL);
        params.set(DEFAULT_ANNOTATION_STATISTICS_FILL, "#28313e");
        params.set(DEFAULT_ANNOTATION_STATISTICS_STROKE, "#4b525d");
        params.set(DEFAULT_ANNOTATION_STATISTICS_COLOR, "#fff");
        params.set(DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE, "#fff");
        params.set(DEFAULT_TEXTBOX_FILL, "#28313e");
        params.set(DEFAULT_TEXTBOX_STROKE, "#4b525d");
        params.set(DEFAULT_TEXTBOX_COLOR, "#fff");
        return params;
    }
    constructor(options){
        super(options);
    }
};
// packages/ag-charts-community/src/chart/themes/financialDark.ts
var FINANCIAL_DARK_FILLS = {
    GREEN: "#089981",
    RED: "#F23645",
    BLUE: "#5090dc",
    GRAY: "#A9A9A9"
};
var FINANCIAL_DARK_STROKES = {
    GREEN: "#089981",
    RED: "#F23645",
    BLUE: "#5090dc",
    GRAY: "#909090"
};
var FinancialDark = class extends DarkTheme {
    getDefaultColors() {
        return {
            ...super.getDefaultColors(),
            fills: {
                ...FINANCIAL_DARK_FILLS
            },
            fillsFallback: Object.values({
                ...FINANCIAL_DARK_FILLS
            }),
            strokes: {
                ...FINANCIAL_DARK_STROKES
            },
            sequentialColors: getSequentialColors(FINANCIAL_DARK_FILLS),
            divergingColors: [
                FINANCIAL_DARK_FILLS.GREEN,
                FINANCIAL_DARK_FILLS.BLUE,
                FINANCIAL_DARK_FILLS.RED
            ],
            // hierarchyColors: [],
            secondSequentialColors: [
                "#5090dc",
                "#4882c6",
                "#4073b0",
                "#38659a",
                "#305684",
                "#28486e",
                "#203a58",
                "#182b42"
            ],
            // secondDivergingColors: [],
            // secondHierarchyColors: [],
            up: {
                fill: FINANCIAL_DARK_FILLS.GREEN,
                stroke: FINANCIAL_DARK_STROKES.GREEN
            },
            down: {
                fill: FINANCIAL_DARK_FILLS.RED,
                stroke: FINANCIAL_DARK_STROKES.RED
            },
            neutral: {
                fill: FINANCIAL_DARK_FILLS.BLUE,
                stroke: FINANCIAL_DARK_STROKES.BLUE
            },
            altUp: {
                fill: FINANCIAL_DARK_FILLS.GREEN,
                stroke: FINANCIAL_DARK_STROKES.GREEN
            },
            altDown: {
                fill: FINANCIAL_DARK_FILLS.RED,
                stroke: FINANCIAL_DARK_STROKES.RED
            },
            altNeutral: {
                fill: FINANCIAL_DARK_FILLS.GRAY,
                stroke: FINANCIAL_DARK_STROKES.GRAY
            }
        };
    }
    getPublicParameters() {
        return {
            ...super.getPublicParameters(),
            chartPadding: 0,
            gridLineColor: {
                $foregroundBackgroundMix: 0.12
            }
        };
    }
    getTemplateParameters() {
        const params = super.getTemplateParameters();
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, FINANCIAL_DARK_FILLS.BLUE);
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, FINANCIAL_DARK_FILLS.BLUE);
        params.set(DEFAULT_CAPTION_LAYOUT_STYLE, "overlay");
        params.set(DEFAULT_CAPTION_ALIGNMENT, "left");
        params.set(DEFAULT_TOOLBAR_POSITION, "bottom");
        params.set(DEFAULT_GRIDLINE_ENABLED, true);
        return params;
    }
};
// packages/ag-charts-community/src/chart/themes/financialLight.ts
var FINANCIAL_LIGHT_FILLS = {
    GREEN: "#089981",
    RED: "#F23645",
    BLUE: "#5090dc",
    GRAY: "#A9A9A9"
};
var FINANCIAL_LIGHT_STROKES = {
    GREEN: "#089981",
    RED: "#F23645",
    BLUE: "#5090dc",
    GRAY: "#909090"
};
var FinancialLight = class extends ChartTheme {
    getDefaultColors() {
        return {
            ...super.getDefaultColors(),
            fills: {
                ...FINANCIAL_LIGHT_FILLS
            },
            fillsFallback: Object.values({
                ...FINANCIAL_LIGHT_FILLS
            }),
            strokes: {
                ...FINANCIAL_LIGHT_STROKES
            },
            sequentialColors: getSequentialColors(FINANCIAL_LIGHT_FILLS),
            divergingColors: [
                FINANCIAL_LIGHT_FILLS.GREEN,
                FINANCIAL_LIGHT_FILLS.BLUE,
                FINANCIAL_LIGHT_FILLS.RED
            ],
            // hierarchyColors: [],
            // secondSequentialColors: [],
            // secondDivergingColors: [],
            // secondHierarchyColors: [],
            up: {
                fill: FINANCIAL_LIGHT_FILLS.GREEN,
                stroke: FINANCIAL_LIGHT_STROKES.GREEN
            },
            down: {
                fill: FINANCIAL_LIGHT_FILLS.RED,
                stroke: FINANCIAL_LIGHT_STROKES.RED
            },
            neutral: {
                fill: FINANCIAL_LIGHT_FILLS.BLUE,
                stroke: FINANCIAL_LIGHT_STROKES.BLUE
            },
            altUp: {
                fill: FINANCIAL_LIGHT_FILLS.GREEN,
                stroke: FINANCIAL_LIGHT_STROKES.GREEN
            },
            altDown: {
                fill: FINANCIAL_LIGHT_FILLS.RED,
                stroke: FINANCIAL_LIGHT_STROKES.RED
            },
            altNeutral: {
                fill: FINANCIAL_LIGHT_FILLS.GRAY,
                stroke: FINANCIAL_LIGHT_STROKES.GRAY
            }
        };
    }
    getPublicParameters() {
        return {
            ...super.getPublicParameters(),
            chartPadding: 0,
            gridLineColor: {
                $foregroundBackgroundMix: 0.06
            }
        };
    }
    getTemplateParameters() {
        const params = super.getTemplateParameters();
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, FINANCIAL_LIGHT_FILLS.BLUE);
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, FINANCIAL_LIGHT_FILLS.BLUE);
        params.set(DEFAULT_CAPTION_LAYOUT_STYLE, "overlay");
        params.set(DEFAULT_CAPTION_ALIGNMENT, "left");
        params.set(DEFAULT_TOOLBAR_POSITION, "bottom");
        params.set(DEFAULT_GRIDLINE_ENABLED, true);
        return params;
    }
};
// packages/ag-charts-community/src/chart/themes/materialDark.ts
var MATERIAL_DARK_FILLS = {
    BLUE: "#2196F3",
    ORANGE: "#FF9800",
    GREEN: "#4CAF50",
    CYAN: "#00BCD4",
    YELLOW: "#FFEB3B",
    VIOLET: "#7E57C2",
    GRAY: "#9E9E9E",
    MAGENTA: "#F06292",
    BROWN: "#795548",
    RED: "#F44336"
};
var MATERIAL_DARK_STROKES = {
    BLUE: "#90CAF9",
    ORANGE: "#FFCC80",
    GREEN: "#A5D6A7",
    CYAN: "#80DEEA",
    YELLOW: "#FFF9C4",
    VIOLET: "#B39DDB",
    GRAY: "#E0E0E0",
    MAGENTA: "#F48FB1",
    BROWN: "#A1887F",
    RED: "#EF9A9A"
};
var MaterialDark = class extends DarkTheme {
    getDefaultColors() {
        return {
            ...super.getDefaultColors(),
            fills: MATERIAL_DARK_FILLS,
            fillsFallback: Object.values(MATERIAL_DARK_FILLS),
            strokes: MATERIAL_DARK_STROKES,
            sequentialColors: getSequentialColors(MATERIAL_DARK_FILLS),
            divergingColors: [
                MATERIAL_DARK_FILLS.ORANGE,
                MATERIAL_DARK_FILLS.YELLOW,
                MATERIAL_DARK_FILLS.GREEN
            ],
            // hierarchyColors: [],
            secondSequentialColors: [
                "#2196f3",
                // 500
                "#208FEC",
                // (interpolated)
                "#1E88E5",
                // 600
                "#1C7FDC",
                // (interpolated)
                "#1976d2",
                // 700
                "#176EC9",
                // (interpolated)
                "#1565c0"
            ],
            secondDivergingColors: [
                MATERIAL_DARK_FILLS.GREEN,
                MATERIAL_DARK_FILLS.YELLOW,
                MATERIAL_DARK_FILLS.RED
            ],
            // secondHierarchyColors: [],
            up: {
                fill: MATERIAL_DARK_FILLS.GREEN,
                stroke: MATERIAL_DARK_STROKES.GREEN
            },
            down: {
                fill: MATERIAL_DARK_FILLS.RED,
                stroke: MATERIAL_DARK_STROKES.RED
            },
            neutral: {
                fill: MATERIAL_DARK_FILLS.GRAY,
                stroke: MATERIAL_DARK_STROKES.GRAY
            },
            altUp: {
                fill: MATERIAL_DARK_FILLS.BLUE,
                stroke: MATERIAL_DARK_STROKES.BLUE
            },
            altDown: {
                fill: MATERIAL_DARK_FILLS.RED,
                stroke: MATERIAL_DARK_STROKES.RED
            },
            altNeutral: {
                fill: MATERIAL_DARK_FILLS.GRAY,
                stroke: MATERIAL_DARK_STROKES.GRAY
            }
        };
    }
    getTemplateParameters() {
        const params = super.getTemplateParameters();
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, MATERIAL_DARK_FILLS.BLUE);
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, MATERIAL_DARK_FILLS.BLUE);
        return params;
    }
};
// packages/ag-charts-community/src/chart/themes/materialLight.ts
var MATERIAL_LIGHT_FILLS = {
    BLUE: "#2196F3",
    ORANGE: "#FF9800",
    GREEN: "#4CAF50",
    CYAN: "#00BCD4",
    YELLOW: "#FFEB3B",
    VIOLET: "#7E57C2",
    GRAY: "#9E9E9E",
    MAGENTA: "#F06292",
    BROWN: "#795548",
    RED: "#F44336"
};
var MATERIAL_LIGHT_STROKES = {
    BLUE: "#1565C0",
    ORANGE: "#E65100",
    GREEN: "#2E7D32",
    CYAN: "#00838F",
    YELLOW: "#F9A825",
    VIOLET: "#4527A0",
    GRAY: "#616161",
    MAGENTA: "#C2185B",
    BROWN: "#4E342E",
    RED: "#B71C1C"
};
var MaterialLight = class extends ChartTheme {
    getDefaultColors() {
        return {
            ...super.getDefaultColors(),
            fills: MATERIAL_LIGHT_FILLS,
            fillsFallback: Object.values(MATERIAL_LIGHT_FILLS),
            strokes: MATERIAL_LIGHT_STROKES,
            sequentialColors: getSequentialColors(MATERIAL_LIGHT_FILLS),
            divergingColors: [
                MATERIAL_LIGHT_FILLS.ORANGE,
                MATERIAL_LIGHT_FILLS.YELLOW,
                MATERIAL_LIGHT_FILLS.GREEN
            ],
            // hierarchyColors: [],
            secondSequentialColors: [
                "#2196f3",
                // 500
                "#329EF4",
                // (interpolated)
                "#42a5f5",
                // 400
                "#53ADF6",
                // (interpolated)
                "#64b5f6",
                // 300
                "#7AC0F8",
                // (interpolated)
                "#90caf9"
            ],
            secondDivergingColors: [
                MATERIAL_LIGHT_FILLS.GREEN,
                MATERIAL_LIGHT_FILLS.YELLOW,
                MATERIAL_LIGHT_FILLS.RED
            ],
            // secondHierarchyColors: [],
            up: {
                fill: MATERIAL_LIGHT_FILLS.GREEN,
                stroke: MATERIAL_LIGHT_STROKES.GREEN
            },
            down: {
                fill: MATERIAL_LIGHT_FILLS.RED,
                stroke: MATERIAL_LIGHT_STROKES.RED
            },
            neutral: {
                fill: MATERIAL_LIGHT_FILLS.GRAY,
                stroke: MATERIAL_LIGHT_STROKES.GRAY
            },
            altUp: {
                fill: MATERIAL_LIGHT_FILLS.BLUE,
                stroke: MATERIAL_LIGHT_STROKES.BLUE
            },
            altDown: {
                fill: MATERIAL_LIGHT_FILLS.RED,
                stroke: MATERIAL_LIGHT_STROKES.RED
            },
            altNeutral: {
                fill: MATERIAL_LIGHT_FILLS.GRAY,
                stroke: MATERIAL_LIGHT_STROKES.GRAY
            }
        };
    }
    getTemplateParameters() {
        const params = super.getTemplateParameters();
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, MATERIAL_LIGHT_FILLS.BLUE);
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, MATERIAL_LIGHT_FILLS.BLUE);
        return params;
    }
};
// packages/ag-charts-community/src/chart/themes/polychromaDark.ts
var POLYCHROMA_DARK_FILLS = {
    BLUE: "#436ff4",
    PURPLE: "#9a7bff",
    MAGENTA: "#d165d2",
    PINK: "#f0598b",
    RED: "#f47348",
    ORANGE: "#f2a602",
    YELLOW: "#e9e201",
    GREEN: "#21b448",
    CYAN: "#00b9a2",
    MODERATE_BLUE: "#00aee4",
    GRAY: "#bbbbbb"
};
var POLYCHROMA_DARK_STROKES = {
    BLUE: "#6698ff",
    PURPLE: "#c0a3ff",
    MAGENTA: "#fc8dfc",
    PINK: "#ff82b1",
    RED: "#ff9b70",
    ORANGE: "#ffcf4e",
    YELLOW: "#ffff58",
    GREEN: "#58dd70",
    CYAN: "#51e2c9",
    MODERATE_BLUE: "#4fd7ff",
    GRAY: "#eeeeee"
};
var PolychromaDark = class extends DarkTheme {
    getDefaultColors() {
        return {
            fills: POLYCHROMA_DARK_FILLS,
            fillsFallback: Object.values(POLYCHROMA_DARK_FILLS),
            strokes: POLYCHROMA_DARK_STROKES,
            sequentialColors: getSequentialColors(POLYCHROMA_DARK_FILLS),
            divergingColors: [
                POLYCHROMA_DARK_FILLS.BLUE,
                POLYCHROMA_DARK_FILLS.RED
            ],
            hierarchyColors: [],
            secondSequentialColors: [
                POLYCHROMA_DARK_FILLS.BLUE,
                POLYCHROMA_DARK_FILLS.PURPLE,
                POLYCHROMA_DARK_FILLS.MAGENTA,
                POLYCHROMA_DARK_FILLS.PINK,
                POLYCHROMA_DARK_FILLS.RED,
                POLYCHROMA_DARK_FILLS.ORANGE,
                POLYCHROMA_DARK_FILLS.YELLOW,
                POLYCHROMA_DARK_FILLS.GREEN
            ],
            secondDivergingColors: [
                POLYCHROMA_DARK_FILLS.BLUE,
                POLYCHROMA_DARK_FILLS.RED
            ],
            secondHierarchyColors: [],
            up: {
                fill: POLYCHROMA_DARK_FILLS.GREEN,
                stroke: POLYCHROMA_DARK_STROKES.GREEN
            },
            down: {
                fill: POLYCHROMA_DARK_FILLS.RED,
                stroke: POLYCHROMA_DARK_STROKES.RED
            },
            neutral: {
                fill: POLYCHROMA_DARK_FILLS.GRAY,
                stroke: POLYCHROMA_DARK_STROKES.GRAY
            },
            altUp: {
                fill: POLYCHROMA_DARK_FILLS.BLUE,
                stroke: POLYCHROMA_DARK_STROKES.BLUE
            },
            altDown: {
                fill: POLYCHROMA_DARK_FILLS.RED,
                stroke: POLYCHROMA_DARK_STROKES.RED
            },
            altNeutral: {
                fill: POLYCHROMA_DARK_FILLS.GRAY,
                stroke: POLYCHROMA_DARK_STROKES.GRAY
            }
        };
    }
    getTemplateParameters() {
        const params = super.getTemplateParameters();
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, POLYCHROMA_DARK_FILLS.BLUE);
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_DARK_FILLS.BLUE);
        return params;
    }
};
// packages/ag-charts-community/src/chart/themes/polychromaLight.ts
var POLYCHROMA_LIGHT_FILLS = {
    BLUE: "#436ff4",
    PURPLE: "#9a7bff",
    MAGENTA: "#d165d2",
    PINK: "#f0598b",
    RED: "#f47348",
    ORANGE: "#f2a602",
    YELLOW: "#e9e201",
    GREEN: "#21b448",
    CYAN: "#00b9a2",
    MODERATE_BLUE: "#00aee4",
    GRAY: "#bbbbbb"
};
var POLYCHROMA_LIGHT_STROKES = {
    BLUE: "#2346c9",
    PURPLE: "#7653d4",
    MAGENTA: "#a73da9",
    PINK: "#c32d66",
    RED: "#c84b1c",
    ORANGE: "#c87f00",
    YELLOW: "#c1b900",
    GREEN: "#008c1c",
    CYAN: "#00927c",
    MODERATE_BLUE: "#0087bb",
    GRAY: "#888888"
};
var PolychromaLight = class extends ChartTheme {
    getDefaultColors() {
        return {
            ...super.getDefaultColors(),
            fills: POLYCHROMA_LIGHT_FILLS,
            fillsFallback: Object.values(POLYCHROMA_LIGHT_FILLS),
            strokes: POLYCHROMA_LIGHT_STROKES,
            sequentialColors: getSequentialColors(POLYCHROMA_LIGHT_FILLS),
            divergingColors: [
                POLYCHROMA_LIGHT_FILLS.BLUE,
                POLYCHROMA_LIGHT_FILLS.RED
            ],
            hierarchyColors: [],
            secondSequentialColors: [
                POLYCHROMA_LIGHT_FILLS.BLUE,
                POLYCHROMA_LIGHT_FILLS.PURPLE,
                POLYCHROMA_LIGHT_FILLS.MAGENTA,
                POLYCHROMA_LIGHT_FILLS.PINK,
                POLYCHROMA_LIGHT_FILLS.RED,
                POLYCHROMA_LIGHT_FILLS.ORANGE,
                POLYCHROMA_LIGHT_FILLS.YELLOW,
                POLYCHROMA_LIGHT_FILLS.GREEN
            ],
            secondDivergingColors: [
                POLYCHROMA_LIGHT_FILLS.BLUE,
                POLYCHROMA_LIGHT_FILLS.RED
            ],
            secondHierarchyColors: [],
            up: {
                fill: POLYCHROMA_LIGHT_FILLS.GREEN,
                stroke: POLYCHROMA_LIGHT_STROKES.GREEN
            },
            down: {
                fill: POLYCHROMA_LIGHT_FILLS.RED,
                stroke: POLYCHROMA_LIGHT_STROKES.RED
            },
            neutral: {
                fill: POLYCHROMA_LIGHT_FILLS.GRAY,
                stroke: POLYCHROMA_LIGHT_STROKES.GRAY
            },
            altUp: {
                fill: POLYCHROMA_LIGHT_FILLS.BLUE,
                stroke: POLYCHROMA_LIGHT_STROKES.BLUE
            },
            altDown: {
                fill: POLYCHROMA_LIGHT_FILLS.RED,
                stroke: POLYCHROMA_LIGHT_STROKES.RED
            },
            altNeutral: {
                fill: POLYCHROMA_LIGHT_FILLS.GRAY,
                stroke: POLYCHROMA_LIGHT_STROKES.GRAY
            }
        };
    }
    getTemplateParameters() {
        const params = super.getTemplateParameters();
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, POLYCHROMA_LIGHT_FILLS.BLUE);
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_LIGHT_FILLS.BLUE);
        return params;
    }
};
// packages/ag-charts-community/src/chart/themes/sheetsDark.ts
var SHEETS_DARK_FILLS = {
    BLUE: "#4472C4",
    ORANGE: "#ED7D31",
    GRAY: "#A5A5A5",
    YELLOW: "#FFC000",
    MODERATE_BLUE: "#5B9BD5",
    GREEN: "#70AD47",
    DARK_GRAY: "#7B7B7B",
    DARK_BLUE: "#264478",
    VERY_DARK_GRAY: "#636363",
    DARK_YELLOW: "#997300"
};
var SHEETS_DARK_STROKES = {
    BLUE: "#6899ee",
    ORANGE: "#ffa55d",
    GRAY: "#cdcdcd",
    YELLOW: "#ffea53",
    MODERATE_BLUE: "#82c3ff",
    GREEN: "#96d56f",
    DARK_GRAY: "#a1a1a1",
    DARK_BLUE: "#47689f",
    VERY_DARK_GRAY: "#878787",
    DARK_YELLOW: "#c0993d"
};
var SheetsDark = class extends DarkTheme {
    getDefaultColors() {
        return {
            ...super.getDefaultColors(),
            fills: {
                ...SHEETS_DARK_FILLS,
                RED: SHEETS_DARK_FILLS.ORANGE
            },
            fillsFallback: Object.values({
                ...SHEETS_DARK_FILLS,
                RED: SHEETS_DARK_FILLS.ORANGE
            }),
            strokes: {
                ...SHEETS_DARK_STROKES,
                RED: SHEETS_DARK_STROKES.ORANGE
            },
            sequentialColors: getSequentialColors({
                ...SHEETS_DARK_FILLS,
                RED: SHEETS_DARK_FILLS.ORANGE
            }),
            divergingColors: [
                SHEETS_DARK_FILLS.ORANGE,
                SHEETS_DARK_FILLS.YELLOW,
                SHEETS_DARK_FILLS.GREEN
            ],
            // hierarchyColors: [],
            secondSequentialColors: [
                "#5090dc",
                "#4882c6",
                "#4073b0",
                "#38659a",
                "#305684",
                "#28486e",
                "#203a58",
                "#182b42"
            ],
            secondDivergingColors: [
                SHEETS_DARK_FILLS.GREEN,
                SHEETS_DARK_FILLS.YELLOW,
                SHEETS_DARK_FILLS.ORANGE
            ],
            // secondHierarchyColors: [],
            up: {
                fill: SHEETS_DARK_FILLS.GREEN,
                stroke: SHEETS_DARK_STROKES.GREEN
            },
            down: {
                fill: SHEETS_DARK_FILLS.ORANGE,
                stroke: SHEETS_DARK_STROKES.ORANGE
            },
            neutral: {
                fill: SHEETS_DARK_FILLS.GRAY,
                stroke: SHEETS_DARK_STROKES.GRAY
            },
            altUp: {
                fill: SHEETS_DARK_FILLS.BLUE,
                stroke: SHEETS_DARK_STROKES.BLUE
            },
            altDown: {
                fill: SHEETS_DARK_FILLS.ORANGE,
                stroke: SHEETS_DARK_STROKES.ORANGE
            },
            altNeutral: {
                fill: SHEETS_DARK_FILLS.GRAY,
                stroke: SHEETS_DARK_STROKES.GRAY
            }
        };
    }
    getTemplateParameters() {
        const params = super.getTemplateParameters();
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, SHEETS_DARK_FILLS.BLUE);
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, SHEETS_DARK_FILLS.BLUE);
        return params;
    }
};
// packages/ag-charts-community/src/chart/themes/sheetsLight.ts
var SHEETS_LIGHT_FILLS = {
    BLUE: "#5281d5",
    ORANGE: "#ff8d44",
    GRAY: "#b5b5b5",
    YELLOW: "#ffd02f",
    MODERATE_BLUE: "#6aabe6",
    GREEN: "#7fbd57",
    DARK_GRAY: "#8a8a8a",
    DARK_BLUE: "#335287",
    VERY_DARK_GRAY: "#717171",
    DARK_YELLOW: "#a98220"
};
var SHEETS_LIGHT_STROKES = {
    BLUE: "#214d9b",
    ORANGE: "#c25600",
    GRAY: "#7f7f7f",
    YELLOW: "#d59800",
    MODERATE_BLUE: "#3575ac",
    GREEN: "#4b861a",
    DARK_GRAY: "#575757",
    DARK_BLUE: "#062253",
    VERY_DARK_GRAY: "#414141",
    DARK_YELLOW: "#734f00"
};
var SheetsLight = class extends ChartTheme {
    getDefaultColors() {
        return {
            ...super.getDefaultColors(),
            fills: {
                ...SHEETS_LIGHT_FILLS,
                RED: SHEETS_LIGHT_FILLS.ORANGE
            },
            fillsFallback: Object.values({
                ...SHEETS_LIGHT_FILLS,
                RED: SHEETS_LIGHT_FILLS.ORANGE
            }),
            strokes: {
                ...SHEETS_LIGHT_STROKES,
                RED: SHEETS_LIGHT_STROKES.ORANGE
            },
            sequentialColors: getSequentialColors({
                ...SHEETS_LIGHT_FILLS,
                RED: SHEETS_LIGHT_FILLS.ORANGE
            }),
            divergingColors: [
                SHEETS_LIGHT_FILLS.ORANGE,
                SHEETS_LIGHT_FILLS.YELLOW,
                SHEETS_LIGHT_FILLS.GREEN
            ],
            // hierarchyColors: [],
            secondSequentialColors: [
                "#5090dc",
                "#629be0",
                "#73a6e3",
                "#85b1e7",
                "#96bcea",
                "#a8c8ee",
                "#b9d3f1",
                "#cbdef5"
            ],
            secondDivergingColors: [
                SHEETS_LIGHT_FILLS.GREEN,
                SHEETS_LIGHT_FILLS.YELLOW,
                SHEETS_LIGHT_FILLS.ORANGE
            ],
            secondHierarchyColors: [],
            up: {
                fill: SHEETS_LIGHT_FILLS.GREEN,
                stroke: SHEETS_LIGHT_STROKES.GREEN
            },
            down: {
                fill: SHEETS_LIGHT_FILLS.ORANGE,
                stroke: SHEETS_LIGHT_STROKES.ORANGE
            },
            neutral: {
                fill: SHEETS_LIGHT_STROKES.GRAY,
                stroke: SHEETS_LIGHT_STROKES.GRAY
            },
            altUp: {
                fill: SHEETS_LIGHT_FILLS.BLUE,
                stroke: SHEETS_LIGHT_STROKES.BLUE
            },
            altDown: {
                fill: SHEETS_LIGHT_FILLS.ORANGE,
                stroke: SHEETS_LIGHT_STROKES.ORANGE
            },
            altNeutral: {
                fill: SHEETS_LIGHT_FILLS.GRAY,
                stroke: SHEETS_LIGHT_STROKES.GRAY
            }
        };
    }
    getTemplateParameters() {
        const params = super.getTemplateParameters();
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, SHEETS_LIGHT_FILLS.BLUE);
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, SHEETS_LIGHT_FILLS.BLUE);
        return params;
    }
};
;
;
;
var legendPlacementLiterals = [
    "top",
    "top-right",
    "top-left",
    "bottom",
    "bottom-right",
    "bottom-left",
    "right",
    "right-top",
    "right-bottom",
    "left",
    "left-top",
    "left-bottom"
];
var legendPositionOptionsDef = {
    floating: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])(...legendPlacementLiterals),
    xOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    yOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
};
var legendPositionValidator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachDescription"])((value, context)=>{
    let result;
    if (typeof value === "string") {
        const allowedValues = legendPlacementLiterals;
        if (allowedValues.includes(value)) {
            result = true;
        } else {
            result = {
                valid: false,
                invalid: [],
                cleared: null
            };
            result.invalid.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ValidationError"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorType"].Invalid, 'a legend placement string: ["'.concat(legendPlacementLiterals.join('", "'), '"]'), value, context.path));
        }
    } else {
        const { cleared, invalid } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"])(value, legendPositionOptionsDef);
        result = {
            valid: invalid.length === 0,
            cleared,
            invalid
        };
    }
    return result;
}, "a legend position object or placement string");
var shapeValidator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("circle", "cross", "diamond", "heart", "plus", "pin", "square", "star", "triangle"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"]);
var textWrapValidator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("never", "always", "hyphenate", "on-space");
var tooltipPlacementValidator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("top", "right", "bottom", "left", "top-right", "bottom-right", "bottom-left", "top-left", "center");
var rangeValidator2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("exact", "nearest"));
var textOrSegments = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])({
    text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
}, "text segments array"));
var zoomAnchorPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("pointer", "start", "middle", "end");
var chartCaptionOptionsDefs = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    text: textOrSegments,
    textAlign: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("left", "center", "right"),
    wrapping: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("never", "always", "hyphenate", "on-space"),
    spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    maxWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    maxHeight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
};
chartCaptionOptionsDefs.padding = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]);
var chartOverlayOptionsDefs = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    text: textOrSegments,
    renderer: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlElement"]))
};
var contextMenuItemLiterals = [
    "defaults",
    "download",
    "zoom-to-cursor",
    "pan-to-cursor",
    "reset-zoom",
    "toggle-series-visibility",
    "toggle-other-series",
    "separator"
];
var contextMenuItemObjectDef = {
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("action", "separator"),
    showOn: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("always", "series-area", "series-node", "legend-item"),
    label: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    action: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
    items: (value, context)=>contextMenuItemsArray(value, context)
};
contextMenuItemObjectDef.iconUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]);
var contextMenuItemObjectValidator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsDefs"])(contextMenuItemObjectDef);
var contextMenuItemValidator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachDescription"])((value, context)=>{
    let result;
    if (typeof value === "string") {
        const allowedValues = contextMenuItemLiterals;
        if (allowedValues.includes(value)) {
            result = true;
        } else {
            result = {
                valid: false,
                invalid: [],
                cleared: null
            };
            result.invalid.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ValidationError"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ErrorType"].Invalid, 'a context menu item string alias: ["'.concat(contextMenuItemLiterals.join('", "'), '"]'), value, context.path));
        }
    } else {
        result = contextMenuItemObjectValidator(value, context);
    }
    return result;
}, "a context menu item object or string alias: [".concat(contextMenuItemLiterals.join(", "), "]"));
var contextMenuItemsArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(contextMenuItemValidator, "a menu items array", false);
var toolbarButtonOptionsDefs = {
    label: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    ariaLabel: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    tooltip: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    icon: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("align-center", "align-left", "align-right", "arrow-drawing", "arrow-down-drawing", "arrow-up-drawing", "callout-annotation", "candlestick-series", "close", "comment-annotation", "date-range-drawing", "date-price-range-drawing", "delete", "disjoint-channel-drawing", "drag-handle", "fill-color", "line-style-solid", "line-style-dashed", "line-style-dotted", "high-low-series", "hlc-series", "hollow-candlestick-series", "horizontal-line-drawing", "line-color", "line-series", "line-with-markers-series", "locked", "measurer-drawing", "note-annotation", "ohlc-series", "pan-end", "pan-left", "pan-right", "pan-start", "parallel-channel-drawing", "position-bottom", "position-center", "position-top", "price-label-annotation", "price-range-drawing", "reset", "settings", "step-line-series", "text-annotation", "trend-line-drawing", "fibonacci-retracement-drawing", "fibonacci-retracement-trend-based-drawing", "unlocked", "vertical-line-drawing", "zoom-in", "zoom-out")
};
var formatter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]));
var formatObjectValidator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsDefs"])({
    x: formatter,
    y: formatter,
    angle: formatter,
    radius: formatter,
    size: formatter,
    color: formatter,
    label: formatter,
    secondaryLabel: formatter,
    sectorLabel: formatter,
    calloutLabel: formatter,
    legendItem: formatter
});
var numberFormatValidator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachDescription"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidNumberFormat"], "a valid number format string");
var commonChartOptionsDefs = {
    width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    height: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    minWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    minHeight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    suppressFieldDotNotation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    title: chartCaptionOptionsDefs,
    subtitle: chartCaptionOptionsDefs,
    footnote: chartCaptionOptionsDefs,
    padding: {
        top: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        right: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        bottom: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        left: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    },
    seriesArea: {
        border: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["borderOptionsDef"],
        clip: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["padding"]
    },
    legend: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        position: legendPositionValidator,
        orientation: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("horizontal", "vertical"),
        maxWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        maxHeight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        border: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["borderOptionsDef"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["padding"],
        fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorUnion"],
        fillOpacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
        preventHidingAll: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        reverseOrder: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        toggleSeries: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        item: {
            marker: {
                size: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
                shape: shapeValidator,
                padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
                strokeWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
            },
            line: {
                length: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
                strokeWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
            },
            label: {
                maxLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
                formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
            },
            maxWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            paddingX: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            paddingY: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            showSeriesStroke: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]
        },
        pagination: {
            marker: {
                size: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
                shape: shapeValidator,
                padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
            },
            activeStyle: {
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
            },
            inactiveStyle: {
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
            },
            highlightStyle: {
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
            },
            label: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
        },
        listeners: {
            legendItemClick: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
            legendItemDoubleClick: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"]
        }
    },
    gradientLegend: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        position: legendPositionValidator,
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        reverseOrder: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        border: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["borderOptionsDef"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["padding"],
        fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorUnion"],
        fillOpacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
        gradient: {
            preferredLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            thickness: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
        },
        scale: {
            label: {
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"],
                minSpacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
                format: numberFormatValidator,
                formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"]
            },
            padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            interval: {
                step: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
                values: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["array"],
                minSpacing: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lessThan"])("maxSpacing")),
                maxSpacing: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["greaterThan"])("minSpacing"))
            }
        }
    },
    listeners: {
        seriesNodeClick: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
        seriesNodeDoubleClick: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
        seriesVisibilityChange: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
        click: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
        doubleClick: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
        annotations: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
        zoom: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"]
    },
    loadGoogleFonts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    highlight: {
        range: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("tooltip", "node")
    },
    overlays: {
        loading: chartOverlayOptionsDefs,
        noData: chartOverlayOptionsDefs,
        noVisibleSeries: chartOverlayOptionsDefs,
        unsupportedBrowser: chartOverlayOptionsDefs
    },
    tooltip: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        showArrow: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        pagination: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        delay: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        range: rangeValidator2,
        wrapping: textWrapValidator,
        mode: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("single", "shared", "compact"),
        position: {
            anchorTo: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("pointer", "node", "chart"),
            placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(tooltipPlacementValidator, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(tooltipPlacementValidator)),
            xOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
            yOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
        }
    },
    animation: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        duration: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    },
    contextMenu: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        items: contextMenuItemsArray
    },
    context: ()=>true,
    dataSource: {
        getData: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"]
    },
    keyboard: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        tabIndex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
    },
    touch: {
        dragAction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("none", "drag", "hover")
    },
    ranges: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        buttons: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])({
            ...toolbarButtonOptionsDefs,
            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["date"])), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayLength"])(2, 2)), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"])
        }, "range button options array")
    },
    // modules
    locale: {
        localeText: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["object"],
        getLocaleText: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"])
    },
    background: {
        visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        // enterprise
        image: {
            url: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
            top: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
            right: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
            bottom: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
            left: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
            width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            height: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            opacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
        }
    },
    styleNonce: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    sync: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        groupId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        axes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("x", "y", "xy"),
        nodeInteraction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        zoom: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]
    },
    zoom: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        enableAxisDragging: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        enableAxisScrolling: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        enableDoubleClickToReset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        enablePanning: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        enableScrolling: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        enableSelecting: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        enableTwoFingerZoom: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        keepAspectRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        anchorPointX: zoomAnchorPoint,
        anchorPointY: zoomAnchorPoint,
        axisDraggingMode: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("pan", "zoom"),
        axes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("x", "y", "xy"),
        deceleration: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("off", "short", "long"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]),
        minVisibleItems: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        panKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("alt", "ctrl", "meta", "shift"),
        scrollingStep: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
        autoScaling: {
            enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
        },
        buttons: {
            enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            buttons: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])({
                ...toolbarButtonOptionsDefs,
                value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("reset", "zoom-in", "zoom-out", "pan-left", "pan-right", "pan-start", "pan-end"),
                section: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]
            }, "zoom button options array"),
            visible: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("always", "zoomed", "hover")
        }
    },
    formatter: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]), formatObjectValidator)
};
commonChartOptionsDefs.dataSource.requestThrottle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]);
commonChartOptionsDefs.dataSource.updateThrottle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]);
commonChartOptionsDefs.dataSource.updateDuringInteraction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]);
commonChartOptionsDefs.zoom.enableIndependentAxes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]);
commonChartOptionsDefs.statusBar = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
commonChartOptionsDefs.foreground = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])({
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    image: {
        url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        top: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        right: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        bottom: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        left: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        height: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        opacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
    },
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"]
});
commonChartOptionsDefs.overrideDevicePixelRatio = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]);
commonChartOptionsDefs.sync.domainMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("direction", "position", "key"));
var commonSeriesThemeableOptionsDefs = {
    cursor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    context: ()=>true,
    showInLegend: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    nodeClickRange: rangeValidator2,
    listeners: {
        seriesNodeClick: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
        seriesNodeDoubleClick: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"]
    },
    // TODO Remove in next major version
    highlightStyle: {
        item: {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
        },
        series: {
            enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            dimOpacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
            strokeWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
        }
    },
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["highlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"])
};
var commonSeriesOptionsDefs = {
    ...commonSeriesThemeableOptionsDefs,
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    context: ()=>true,
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["array"]
};
commonSeriesOptionsDefs.seriesGrouping = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]);
var markerOptionsDefs = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    shape: shapeValidator,
    size: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
        shape: shapeValidator,
        size: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    }),
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var seriesLabelOptionsDefs = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
    format: numberFormatValidator,
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelBoxOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
    })),
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelBoxOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
};
var autoSizedLabelOptionsDefs = {
    ...seriesLabelOptionsDefs,
    lineHeight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    minimumFontSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    wrapping: textWrapValidator,
    overflowStrategy: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("ellipsis", "hide")
};
var errorBarThemeableOptionsDefs = {
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    cap: {
        visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        length: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        lengthRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var errorBarOptionsDefs = {
    ...errorBarThemeableOptionsDefs,
    xLowerKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    xUpperKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    yLowerKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    yUpperKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    xLowerName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    xUpperName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    yLowerName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    yUpperName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
        cap: {
            visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            length: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            lengthRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
        }
    })
};
var tooltipOptionsDefs = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    showArrow: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    range: rangeValidator2,
    renderer: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsDefs"])({
        heading: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        title: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])({
            label: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"])
        })
    }, "tooltip renderer result object"))),
    position: {
        anchorTo: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("node", "pointer", "chart"),
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(tooltipPlacementValidator, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(tooltipPlacementValidator)),
        xOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        yOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
    },
    interaction: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]
    }
};
var shadowOptionsDefs = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    xOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    yOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    blur: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    color: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]
};
var interpolationOptionsDefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeUnion"])({
    linear: {},
    smooth: {
        tension: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
    },
    step: {
        position: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("start", "middle", "end")
    }
}, "interpolation line options");
// packages/ag-charts-community/src/api/preset/gaugeOptionsDefs.ts
var fillsOptionsDef = {
    fills: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayLength"])(2), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsDefs"])({
        color: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        stop: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
    }, "")), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorStopsOrderValidator"]),
    fillMode: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("continuous", "discrete")
};
var linearGaugeTargetOptionsDef = {
    value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    shape: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("circle", "cross", "diamond", "heart", "plus", "pin", "square", "star", "triangle", "line"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"]),
    placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("before", "after", "middle"),
    spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    size: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    rotation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var radialGaugeTargetOptionsDef = {
    value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    shape: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("circle", "cross", "diamond", "heart", "plus", "pin", "square", "star", "triangle", "line"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"]),
    placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("inside", "outside", "middle"),
    spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    size: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    rotation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    label: {
        ...seriesLabelOptionsDefs,
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    },
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var linearGaugeSeriesThemeableOptionsDef = {
    direction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("horizontal", "vertical"),
    cornerMode: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("container", "item"),
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    thickness: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    segmentation: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        interval: {
            values: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
            step: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
            count: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
        }
    },
    bar: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        thickness: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        thicknessRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
        ...fillsOptionsDef,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    label: {
        ...autoSizedLabelOptionsDefs,
        text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        avoidCollisions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("inside-start", "outside-start", "inside-end", "outside-end", "inside-center", "bar-inside", "bar-inside-end", "bar-outside-end", "bar-end")
    },
    tooltip: tooltipOptionsDefs,
    ...without(commonSeriesThemeableOptionsDefs, [
        "listeners"
    ])
};
var linearGaugeSeriesOptionsDef = {
    ...linearGaugeSeriesThemeableOptionsDef,
    ...without(commonSeriesOptionsDefs, [
        "listeners"
    ]),
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("linear-gauge")),
    value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
    scale: {
        min: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lessThan"])("max")),
        max: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["greaterThan"])("min")),
        label: {
            enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
            rotation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
            spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            minSpacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("before", "after"),
            avoidCollisions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            format: numberFormatValidator,
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
        },
        interval: {
            values: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
            step: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
        },
        ...fillsOptionsDef,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    targets: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])(linearGaugeTargetOptionsDef, "target options array")
};
linearGaugeSeriesOptionsDef.margin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]);
linearGaugeSeriesOptionsDef.defaultColorRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]));
linearGaugeSeriesOptionsDef.defaultTarget = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])({
    ...linearGaugeTargetOptionsDef,
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    label: {
        ...seriesLabelOptionsDefs,
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
    }
});
linearGaugeSeriesOptionsDef.defaultScale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(linearGaugeSeriesOptionsDef.scale);
linearGaugeSeriesOptionsDef.scale.defaultFill = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]);
var radialGaugeSeriesThemeableOptionsDef = {
    outerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    innerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    outerRadiusRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    innerRadiusRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    startAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    endAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    cornerMode: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("container", "item"),
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    scale: {
        min: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lessThan"])("max")),
        max: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["greaterThan"])("min")),
        label: {
            enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
            rotation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
            spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            minSpacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            avoidCollisions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            format: numberFormatValidator,
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
        },
        interval: {
            values: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
            step: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
        },
        ...fillsOptionsDef,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    segmentation: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        interval: {
            values: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
            step: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
            count: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
        }
    },
    bar: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        ...fillsOptionsDef,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    needle: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        radiusRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    label: {
        text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        ...autoSizedLabelOptionsDefs
    },
    secondaryLabel: {
        text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        ...autoSizedLabelOptionsDefs
    },
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs
};
var radialGaugeSeriesOptionsDef = {
    ...radialGaugeSeriesThemeableOptionsDef,
    ...commonSeriesOptionsDefs,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("radial-gauge")),
    value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
    targets: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])(radialGaugeTargetOptionsDef, "target options array")
};
radialGaugeSeriesOptionsDef.defaultColorRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]));
radialGaugeSeriesOptionsDef.defaultTarget = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])({
    ...radialGaugeTargetOptionsDef,
    value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    label: {
        ...seriesLabelOptionsDefs,
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
    }
});
radialGaugeSeriesOptionsDef.scale.defaultFill = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]);
;
;
var timeIntervalUnit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("millisecond", "second", "minute", "hour", "day", "month", "year");
var timeIntervalDefs = {
    unit: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(timeIntervalUnit),
    step: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumberNonZero"],
    epoch: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["date"],
    utc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]
};
timeIntervalDefs.every = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"];
var timeInterval2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsDefs"])(timeIntervalDefs, "a time interval object");
var commonCrossLineLabelOptionsDefs = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
};
var commonCrossLineOptionsDefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachDescription"])({
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("line", "range")),
    range: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachDescription"])((_, param)=>{
        let { options } = param;
        return options.type === "range";
    }, "crossLine type to be 'range'"), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayLength"])(2, 2)),
    value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachDescription"])((_, param)=>{
        let { options } = param;
        return options.type === "line";
    }, "crossLine type to be 'line'"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]),
    label: commonCrossLineLabelOptionsDefs,
    fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
    fillOpacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
}, "cross-line options");
var cartesianCrossLineOptionsDefs = {
    ...commonCrossLineOptionsDefs,
    label: {
        ...commonCrossLineLabelOptionsDefs,
        position: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("top", "left", "right", "bottom", "top-left", "top-right", "bottom-left", "bottom-right", "inside", "inside-left", "inside-right", "inside-top", "inside-bottom", "inside-top-left", "inside-bottom-left", "inside-top-right", "inside-bottom-right"),
        rotation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
    }
};
var commonAxisLabelOptionsDefs = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    rotation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    avoidCollisions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    minSpacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelBoxOptionsDef"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
    })),
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelBoxOptionsDef"]
};
var cartesianAxisLabelOptionsDefs = {
    autoRotate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    autoRotateAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    wrapping: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("never", "always", "hyphenate", "on-space"),
    truncate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    ...commonAxisLabelOptionsDefs
};
var cartesianNumericAxisLabel = {
    format: numberFormatValidator,
    ...cartesianAxisLabelOptionsDefs
};
var cartesianTimeAxisLabel = {
    format: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["object"]),
    ...cartesianAxisLabelOptionsDefs
};
var cartesianAxisTick = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    size: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    stroke: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]
};
var cartesianTimeAxisParentLevel = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    label: cartesianTimeAxisLabel,
    tick: cartesianAxisTick
};
var commonAxisIntervalOptionsDefs = {
    values: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]),
    minSpacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
};
var commonAxisOptionsDefs = {
    reverse: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    gridLine: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        style: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])({
            fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
            fillOpacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            stroke: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["themeOperator"]),
            strokeWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            lineDash: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"])
        }, "a grid-line style object array")
    },
    interval: commonAxisIntervalOptionsDefs,
    label: commonAxisLabelOptionsDefs,
    line: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        stroke: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]
    },
    tick: cartesianAxisTick,
    context: ()=>true
};
commonAxisOptionsDefs.layoutConstraints = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])({
    stacked: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]),
    align: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("start", "end")),
    unit: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("percent", "px")),
    width: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"])
});
var cartesianAxisOptionsDefs = {
    ...commonAxisOptionsDefs,
    keys: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    crossLines: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])(cartesianCrossLineOptionsDefs, "a cross-line options array"),
    position: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("top", "right", "bottom", "left"),
    thickness: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    maxThicknessRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    title: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
    }
};
cartesianAxisOptionsDefs.title._enabledFromTheme = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]);
var cartesianAxisBandHighlightOptions = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
function cartesianAxisCrosshairOptions(canFormat, timeFormat) {
    const baseCrosshairLabel = {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        xOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        yOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        formatter: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
        renderer: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsDefs"])({
            text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
            color: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
            backgroundColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
            opacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
        }, "crosshair label renderer result object")))
    };
    let crosshairLabel;
    if (canFormat) {
        crosshairLabel = {
            ...baseCrosshairLabel,
            format: timeFormat ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsDefs"])({
                millisecond: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
                second: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
                hour: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
                day: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
                month: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
                year: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]
            })) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]
        };
    }
    return {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        snap: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        label: crosshairLabel !== null && crosshairLabel !== void 0 ? crosshairLabel : baseCrosshairLabel,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    };
}
function continuousAxisOptions(validDatum, supportTimeInterval) {
    return {
        min: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(validDatum, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lessThan"])("max")),
        max: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(validDatum, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["greaterThan"])("min")),
        nice: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        interval: {
            step: supportTimeInterval ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumberNonZero"], timeIntervalUnit, timeInterval2) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumberNonZero"],
            values: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(validDatum),
            minSpacing: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lessThan"])("maxSpacing")),
            maxSpacing: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["greaterThan"])("minSpacing"))
        }
    };
}
var discreteTimeAxisIntervalOptionsDefs = {
    step: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumberNonZero"], timeIntervalUnit, timeInterval2),
    values: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["date"])),
    minSpacing: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lessThan"])("maxSpacing")),
    maxSpacing: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["greaterThan"])("minSpacing")),
    placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("on", "between")
};
;
var _CategoryAxis = class _CategoryAxis extends CartesianAxis {
    static is(value) {
        return value instanceof _CategoryAxis;
    }
    isCategoryLike() {
        return true;
    }
    hasDefinedDomain() {
        return false;
    }
    normaliseDataDomain(domain) {
        return {
            domain,
            clipped: false
        };
    }
    updateScale() {
        super.updateScale();
        let { paddingInner, paddingOuter } = this;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(paddingInner) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(paddingOuter)) {
            const padding2 = this.reduceBandScalePadding();
            paddingInner !== null && paddingInner !== void 0 ? paddingInner : paddingInner = padding2.inner;
            paddingOuter !== null && paddingOuter !== void 0 ? paddingOuter : paddingOuter = padding2.outer;
        }
        this.scale.paddingInner = paddingInner !== null && paddingInner !== void 0 ? paddingInner : 0;
        this.scale.paddingOuter = paddingOuter !== null && paddingOuter !== void 0 ? paddingOuter : 0;
    }
    calculateGridLines(ticks, p1, p2) {
        const gridLines = super.calculateGridLines(ticks, p1, p2);
        if (this.interval.placement === "between" && ticks.length > 0) {
            gridLines.push(super.calculateGridLine({
                index: ticks.at(-1).index + 1,
                tickId: "after:".concat(ticks.at(-1).tickId),
                translation: this.range[1]
            }, ticks.length, p1, p2, ticks));
        }
        return gridLines;
    }
    calculateGridLine(param, index, p1, p2, ticks) {
        let { index: tickIndex, tickId, translation } = param;
        const { gridLine, horizontal, interval, scale: scale2 } = this;
        if (interval.placement !== "between") {
            return super.calculateGridLine({
                index: tickIndex,
                tickId,
                translation
            }, index, p1, p2, ticks);
        }
        const halfStep = translation < scale2.step ? Math.floor(scale2.step / 2) : scale2.step / 2;
        const offset = translation - halfStep;
        const [x1, y1, x2, y2] = horizontal ? [
            offset,
            Math.max(p1, p2),
            offset,
            Math.min(p1, p2)
        ] : [
            Math.min(p1, p2),
            offset,
            Math.max(p1, p2),
            offset
        ];
        const { style } = gridLine;
        var _style_;
        const { stroke: stroke2, strokeWidth = 0, lineDash } = (_style_ = style[tickIndex % style.length]) !== null && _style_ !== void 0 ? _style_ : {};
        return {
            tickId,
            offset,
            x1,
            y1,
            x2,
            y2,
            stroke: stroke2,
            strokeWidth,
            lineDash
        };
    }
    calculateGridFills(ticks, p1, p2) {
        const { horizontal, range: range3, scale: scale2 } = this;
        if (this.interval.placement !== "between") {
            return super.calculateGridFills(ticks, p1, p2);
        }
        const gridFills = [];
        if (ticks.length == 0) return gridFills;
        const firstTick = ticks[0];
        const firstFillOffCanvas = firstTick.translation > range3[0] + scale2.step / 2;
        const lastTick = ticks[ticks.length - 1];
        const lastFillOffCanvas = horizontal && lastTick.translation < range3[1] - scale2.step / 2;
        if (firstFillOffCanvas) {
            const tick = {
                tickId: "before:".concat(firstTick.tickId),
                translation: firstTick.translation - scale2.step
            };
            gridFills.push(this.calculateGridFill(tick, -1, firstTick.index - 1, p1, p2, ticks));
        }
        gridFills.push(...ticks.map((tick, index)=>this.calculateGridFill(tick, index, tick.index, p1, p2, ticks)));
        if (lastFillOffCanvas) {
            const tick = {
                tickId: "after:".concat(lastTick.tickId),
                translation: lastTick.translation + scale2.step
            };
            gridFills.push(this.calculateGridFill(tick, ticks.length, lastTick.index + 1, p1, p2, ticks));
        }
        return gridFills;
    }
    calculateGridFill(param, index, gridFillIndex, p1, p2, ticks) {
        let { tickId, translation } = param;
        const { gridLine, horizontal, interval, scale: scale2 } = this;
        if (interval.placement !== "between") {
            return super.calculateGridFill({
                tickId,
                translation
            }, index, gridFillIndex, p1, p2, ticks);
        }
        const startOffset = translation - scale2.step / 2;
        const endOffset = translation + scale2.step / 2;
        const [x1, y1, x2, y2] = horizontal ? [
            startOffset,
            Math.max(p1, p2),
            endOffset,
            Math.min(p1, p2)
        ] : [
            Math.min(p1, p2),
            startOffset,
            Math.max(p1, p2),
            endOffset
        ];
        var _gridLine_style_;
        const { fill, fillOpacity } = (_gridLine_style_ = gridLine.style[gridFillIndex % gridLine.style.length]) !== null && _gridLine_style_ !== void 0 ? _gridLine_style_ : {};
        return {
            tickId,
            x1,
            y1,
            x2,
            y2,
            fill,
            fillOpacity
        };
    }
    calculateTickLines(ticks, direction) {
        const tickLines = super.calculateTickLines(ticks, direction);
        if (this.interval.placement === "between" && ticks.length > 0) {
            var _ticks_at;
            tickLines.push(super.calculateTickLine({
                primary: false,
                tickId: "after:".concat((_ticks_at = ticks.at(-1)) === null || _ticks_at === void 0 ? void 0 : _ticks_at.tickId),
                translation: this.range[1]
            }, ticks.length, direction, ticks));
        }
        return tickLines;
    }
    calculateTickLine(param, index, direction, ticks) {
        let { primary, tickId, translation } = param;
        const { horizontal, interval, primaryTick, scale: scale2, tick } = this;
        if (interval.placement !== "between") {
            return super.calculateTickLine({
                primary,
                tickId,
                translation
            }, index, direction, ticks);
        }
        const datumTick = primary && (primaryTick === null || primaryTick === void 0 ? void 0 : primaryTick.enabled) ? primaryTick : tick;
        const h = -direction * this.getTickSize(datumTick);
        const halfStep = translation < scale2.step ? Math.floor(scale2.step / 2) : scale2.step / 2;
        const offset = translation - halfStep;
        const [x1, y1, x2, y2] = horizontal ? [
            offset,
            0,
            offset,
            h
        ] : [
            0,
            offset,
            h,
            offset
        ];
        const { stroke: stroke2, width: strokeWidth } = datumTick;
        const lineDash = void 0;
        return {
            tickId,
            offset,
            x1,
            y1,
            x2,
            y2,
            stroke: stroke2,
            strokeWidth,
            lineDash
        };
    }
    reduceBandScalePadding() {
        return this.boundSeries.reduce((result, series)=>{
            var _series_getBandScalePadding;
            const padding2 = (_series_getBandScalePadding = series.getBandScalePadding) === null || _series_getBandScalePadding === void 0 ? void 0 : _series_getBandScalePadding.call(series);
            if (padding2) {
                if (result.inner > padding2.inner) {
                    result.inner = padding2.inner;
                }
                if (result.outer < padding2.outer) {
                    result.outer = padding2.outer;
                }
            }
            return result;
        }, {
            inner: Infinity,
            outer: -Infinity
        });
    }
    tickFormatParams(_domain, _ticks, _fractionDigits, _timeInterval) {
        return {
            type: "category"
        };
    }
    datumFormatParams(value, params, _fractionDigits, _timeInterval, _style) {
        const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
        if (Array.isArray(value) && value.some((v)=>typeof v !== "string")) {
            value = value.map(String);
        } else if (!Array.isArray(value) && typeof value !== "string" && typeof value !== "number" && !(value instanceof Date)) {
            value = String(value);
        }
        return {
            type: "category",
            value,
            datum,
            seriesId,
            legendItemName,
            key,
            source,
            property,
            domain,
            boundSeries
        };
    }
    constructor(moduleCtx, scale2 = new CategoryScale(), includeInvisibleDomains = true){
        super(moduleCtx, scale2);
        this.groupPaddingInner = 0.1;
        this.includeInvisibleDomains = includeInvisibleDomains;
        this.nice = false;
    }
};
_CategoryAxis.className = "CategoryAxis";
_CategoryAxis.type = "category";
__decorateClass([
    Property
], _CategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass([
    Property
], _CategoryAxis.prototype, "paddingInner", 2);
__decorateClass([
    Property
], _CategoryAxis.prototype, "paddingOuter", 2);
var CategoryAxis = _CategoryAxis;
;
// packages/ag-charts-community/src/scale/groupedCategoryScale.ts
var GroupedCategoryScale = class _GroupedCategoryScale extends CategoryScale {
    static is(value) {
        return value instanceof _GroupedCategoryScale;
    }
    normalizeDomains() {
        for(var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++){
            domains[_key] = arguments[_key];
        }
        const { domain } = super.normalizeDomains(...domains);
        return {
            domain,
            animatable: false
        };
    }
    findIndex(value) {
        var _super_findIndex;
        return (_super_findIndex = super.findIndex(value)) !== null && _super_findIndex !== void 0 ? _super_findIndex : this.getMatchIndex(value);
    }
    getMatchIndex(value) {
        const key = JSON.stringify(value);
        const match = this._domain.find((d)=>JSON.stringify(d) === key);
        if (match != null) {
            return super.findIndex(match);
        }
    }
};
// packages/ag-charts-community/src/util/extent.ts
function extent(values) {
    if (values.length === 0) {
        return null;
    }
    let min = Infinity;
    let max = -Infinity;
    for (const n of values){
        const v = n instanceof Date ? n.getTime() : n;
        if (typeof v !== "number") continue;
        if (v < min) {
            min = v;
        }
        if (v > max) {
            max = v;
        }
    }
    const result = [
        min,
        max
    ];
    return result.every(isFinite) ? result : null;
}
function normalisedExtentWithMetadata(d, min, max) {
    let clipped = false;
    const de = extent(d);
    if (de == null) {
        return {
            extent: min != null && max != null && min <= max ? [
                min,
                max
            ] : [],
            clipped: false
        };
    }
    let [d0, d1] = de;
    if (min != null) {
        clipped || (clipped = min > d0);
        d0 = min;
    }
    if (max != null) {
        clipped || (clipped = max < d1);
        d1 = max;
    }
    if (d0 > d1) {
        return {
            extent: [],
            clipped: false
        };
    }
    return {
        extent: [
            d0,
            d1
        ],
        clipped
    };
}
;
;
function sumValues(values) {
    let accumulator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [
        0,
        0
    ];
    for (const value of values){
        if (typeof value !== "number") {
            continue;
        }
        if (value < 0) {
            accumulator[0] += value;
        }
        if (value > 0) {
            accumulator[1] += value;
        }
    }
    return accumulator;
}
function sum(id, matchGroupId) {
    const result = {
        id,
        matchGroupIds: [
            matchGroupId
        ],
        type: "aggregate",
        aggregateFunction: (values)=>sumValues(values)
    };
    return result;
}
function groupSum(id, matchGroupId) {
    return {
        id,
        type: "aggregate",
        matchGroupIds: matchGroupId ? [
            matchGroupId
        ] : void 0,
        aggregateFunction: (values)=>sumValues(values),
        groupAggregateFunction: function(next) {
            let acc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [
                0,
                0
            ];
            var _next_;
            acc[0] += (_next_ = next === null || next === void 0 ? void 0 : next[0]) !== null && _next_ !== void 0 ? _next_ : 0;
            var _next_1;
            acc[1] += (_next_1 = next === null || next === void 0 ? void 0 : next[1]) !== null && _next_1 !== void 0 ? _next_1 : 0;
            return acc;
        }
    };
}
function range2(id, matchGroupId) {
    const result = {
        id,
        matchGroupIds: [
            matchGroupId
        ],
        type: "aggregate",
        aggregateFunction: (values)=>ContinuousDomain.extendDomain(values)
    };
    return result;
}
function groupCount(id) {
    return {
        id,
        type: "aggregate",
        aggregateFunction: ()=>[
                0,
                1
            ],
        groupAggregateFunction: function(next) {
            let acc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [
                0,
                0
            ];
            var _next_;
            acc[0] += (_next_ = next === null || next === void 0 ? void 0 : next[0]) !== null && _next_ !== void 0 ? _next_ : 0;
            var _next_1;
            acc[1] += (_next_1 = next === null || next === void 0 ? void 0 : next[1]) !== null && _next_1 !== void 0 ? _next_1 : 0;
            return acc;
        }
    };
}
function groupAverage(id, matchGroupId) {
    const def = {
        id,
        matchGroupIds: matchGroupId ? [
            matchGroupId
        ] : void 0,
        type: "aggregate",
        aggregateFunction: (values)=>sumValues(values),
        groupAggregateFunction: function(next) {
            let acc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [
                0,
                0,
                -1
            ];
            var _next_;
            acc[0] += (_next_ = next === null || next === void 0 ? void 0 : next[0]) !== null && _next_ !== void 0 ? _next_ : 0;
            var _next_1;
            acc[1] += (_next_1 = next === null || next === void 0 ? void 0 : next[1]) !== null && _next_1 !== void 0 ? _next_1 : 0;
            acc[2]++;
            return acc;
        },
        finalFunction: function() {
            let acc = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [
                0,
                0,
                0
            ];
            const result = acc[0] + acc[1];
            if (result >= 0) {
                return [
                    0,
                    result / acc[2]
                ];
            }
            return [
                result / acc[2],
                0
            ];
        }
    };
    return def;
}
function area(id, aggFn, matchGroupId) {
    const result = {
        id,
        matchGroupIds: matchGroupId ? [
            matchGroupId
        ] : void 0,
        type: "aggregate",
        aggregateFunction: function(values) {
            let keyRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            const keyWidth = keyRange[1] - keyRange[0];
            return aggFn.aggregateFunction(values).map((v)=>v / keyWidth);
        }
    };
    if (aggFn.groupAggregateFunction) {
        result.groupAggregateFunction = aggFn.groupAggregateFunction;
    }
    return result;
}
function accumulatedValue(onlyPositive) {
    return ()=>{
        let value = 0;
        return (datum)=>{
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(datum)) {
                return datum;
            }
            value += onlyPositive ? Math.max(0, datum) : datum;
            return value;
        };
    };
}
function trailingAccumulatedValue() {
    return ()=>{
        let value = 0;
        return (datum)=>{
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(datum)) {
                return datum;
            }
            const trailingValue = value;
            value += datum;
            return trailingValue;
        };
    };
}
// packages/ag-charts-community/src/chart/data/processors.ts
var MAX_ANIMATABLE_NODES = 1e3;
function processedDataIsAnimatable(processedData) {
    return processedData.input.count <= MAX_ANIMATABLE_NODES;
}
function basicContinuousCheckDatumValidation(value) {
    return value != null && isContinuous(value);
}
function basicDiscreteCheckDatumValidation(value) {
    return value != null;
}
function getValidationFn(scaleType) {
    switch(scaleType){
        case "number":
        case "log":
        case "time":
        case "unit-time":
        case "ordinal-time":
        case "color":
            return basicContinuousCheckDatumValidation;
        default:
            return basicDiscreteCheckDatumValidation;
    }
}
function getValueType(scaleType) {
    switch(scaleType){
        case "number":
        case "log":
        case "time":
        case "color":
            return "range";
        default:
            return "category";
    }
}
function keyProperty(propName, scaleType) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const result = {
        property: propName,
        type: "key",
        valueType: getValueType(scaleType),
        validation: getValidationFn(scaleType),
        ...opts
    };
    return result;
}
function valueProperty(propName, scaleType) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const result = {
        property: propName,
        type: "value",
        valueType: getValueType(scaleType),
        validation: getValidationFn(scaleType),
        ...opts
    };
    return result;
}
function rowCountProperty(propName) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const result = {
        property: propName,
        type: "value",
        valueType: "range",
        missingValue: 1,
        processor: ()=>()=>1,
        ...opts
    };
    return result;
}
var noopProcessor = function(v) {
    return v;
};
function processorChain() {
    for(var _len = arguments.length, chain = new Array(_len), _key = 0; _key < _len; _key++){
        chain[_key] = arguments[_key];
    }
    const filteredChain = chain.filter((fn)=>fn != null);
    if (filteredChain.length === 0) {
        return ()=>noopProcessor;
    }
    if (filteredChain.length === 1) {
        return filteredChain[0];
    }
    return ()=>{
        const processorInstances = filteredChain.map((fn)=>fn());
        return (value, index)=>{
            return processorInstances.reduce((r, p)=>p(r, index), value);
        };
    };
}
function rangedValueProperty(propName) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { min = -Infinity, max = Infinity, processor, ...defOpts } = opts;
    return {
        type: "value",
        property: propName,
        valueType: "range",
        validation: basicContinuousCheckDatumValidation,
        processor: processorChain(processor, ()=>(datum)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(datum) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(min, datum, max) : datum),
        ...defOpts
    };
}
function accumulativeValueProperty(propName, scaleType) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const { onlyPositive, processor, ...defOpts } = opts;
    const result = {
        ...valueProperty(propName, scaleType, defOpts),
        processor: processorChain(processor, accumulatedValue(onlyPositive))
    };
    return result;
}
function trailingAccumulatedValueProperty(propName, scaleType) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const result = {
        ...valueProperty(propName, scaleType, opts),
        processor: trailingAccumulatedValue()
    };
    return result;
}
function groupAccumulativeValueProperty(propName, mode, sum2, opts, scaleType) {
    return [
        valueProperty(propName, scaleType, opts),
        accumulateGroup(opts.groupId, mode, sum2, opts.separateNegative),
        ...opts.rangeId != null ? [
            range2(opts.rangeId, opts.groupId)
        ] : []
    ];
}
function groupStackValueProperty(propName, scaleType, opts) {
    return [
        valueProperty(propName, scaleType, opts),
        accumulateStack(opts.groupId)
    ];
}
var SMALLEST_KEY_INTERVAL = {
    type: "reducer",
    property: "smallestKeyInterval",
    initialValue: Infinity,
    reducer: ()=>{
        let prevX = NaN;
        return function() {
            let smallestSoFar = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Infinity, keys = arguments.length > 1 ? arguments[1] : void 0;
            const nextX = typeof keys[0] === "number" ? keys[0] : Number(keys[0]);
            const interval = Math.abs(nextX - prevX);
            prevX = nextX;
            if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {
                return interval;
            }
            return smallestSoFar;
        };
    }
};
var LARGEST_KEY_INTERVAL = {
    type: "reducer",
    property: "largestKeyInterval",
    initialValue: -Infinity,
    reducer: ()=>{
        let prevX = NaN;
        return function() {
            let largestSoFar = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -Infinity, keys = arguments.length > 1 ? arguments[1] : void 0;
            const nextX = typeof keys[0] === "number" ? keys[0] : Number(keys[0]);
            const interval = Math.abs(nextX - prevX);
            prevX = nextX;
            if (!isNaN(interval) && interval > 0 && interval > largestSoFar) {
                return interval;
            }
            return largestSoFar;
        };
    }
};
var SORT_DOMAIN_GROUPS = {
    type: "processor",
    property: "sortedGroupDomain",
    calculate: (param)=>{
        let { domain: { groups } } = param;
        return groups === null || groups === void 0 ? void 0 : groups.slice().sort((a, b)=>{
            for(let i = 0; i < a.length; i++){
                const result = a[i] - b[i];
                if (result !== 0) {
                    return result;
                }
            }
            return 0;
        });
    }
};
function normaliseFnBuilder(param) {
    let { normaliseTo } = param;
    const normalise2 = (val, extent2)=>{
        if (extent2 === 0) return null;
        const result = (val !== null && val !== void 0 ? val : 0) * normaliseTo / extent2;
        if (result >= 0) {
            return Math.min(normaliseTo, result);
        }
        return Math.max(-normaliseTo, result);
    };
    return ()=>()=>(columns, valueIndexes, dataGroup)=>{
                const extent2 = normaliseFindExtent(columns, valueIndexes, dataGroup);
                for (const valueIdx of valueIndexes){
                    const datumIndices = dataGroup.datumIndices[valueIdx];
                    if (datumIndices == null) continue;
                    for (const datumIndex of datumIndices){
                        const column = columns[valueIdx];
                        const value = column[datumIndex];
                        if (value == null) {
                            column[datumIndex] = void 0;
                            continue;
                        }
                        column[datumIndex] = typeof value === "number" ? normalise2(value, extent2) : value.map((v)=>normalise2(v, extent2));
                    }
                }
            };
}
function normaliseFindExtent(columns, valueIndexes, dataGroup) {
    const valuesExtent = [
        0,
        0
    ];
    for (const valueIdx of valueIndexes){
        const column = columns[valueIdx];
        const datumIndices = dataGroup.datumIndices[valueIdx];
        if (datumIndices == null) continue;
        for (const datumIndex of datumIndices){
            const value = column[datumIndex];
            if (value == null) continue;
            const valueExtent = typeof value === "number" ? value : Math.max(...value.map((v)=>v !== null && v !== void 0 ? v : 0));
            const valIdx = valueExtent < 0 ? 0 : 1;
            if (valIdx === 0) {
                valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], valueExtent);
            } else {
                valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], valueExtent);
            }
        }
    }
    return Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);
}
function normaliseGroupTo(matchGroupIds, normaliseTo) {
    return {
        type: "group-value-processor",
        matchGroupIds,
        adjust: memo({
            normaliseTo
        }, normaliseFnBuilder)
    };
}
function normalisePropertyFnBuilder(param) {
    let { normaliseTo, zeroDomain, rangeMin, rangeMax } = param;
    const normaliseSpan = normaliseTo[1] - normaliseTo[0];
    const normalise2 = (val, start2, span)=>{
        const result = normaliseTo[0] + (val - start2) / span * normaliseSpan;
        if (span === 0) {
            return zeroDomain;
        } else if (result >= normaliseTo[1]) {
            return normaliseTo[1];
        } else if (result < normaliseTo[0]) {
            return normaliseTo[0];
        }
        return result;
    };
    return ()=>(pData, pIdx)=>{
            let [start2, end2] = pData.domain.values[pIdx];
            if (rangeMin != null) start2 = rangeMin;
            if (rangeMax != null) end2 = rangeMax;
            const span = end2 - start2;
            pData.domain.values[pIdx] = [
                normaliseTo[0],
                normaliseTo[1]
            ];
            const column = pData.columns[pIdx];
            for(let datumIndex = 0; datumIndex < column.length; datumIndex += 1){
                column[datumIndex] = normalise2(column[datumIndex], start2, span);
            }
        };
}
function normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {
    return {
        type: "property-value-processor",
        property,
        adjust: memo({
            normaliseTo,
            rangeMin,
            rangeMax,
            zeroDomain
        }, normalisePropertyFnBuilder)
    };
}
var ANIMATION_VALIDATION_UNIQUE_KEYS = 1;
var ANIMATION_VALIDATION_ORDERED_KEYS = 2;
function animationValidationProcessKey(count, def, keyValues, column) {
    var _column_;
    let validation = ANIMATION_VALIDATION_UNIQUE_KEYS | ANIMATION_VALIDATION_ORDERED_KEYS;
    if (def.valueType === "category") {
        if (keyValues.length < count) validation &= ~ANIMATION_VALIDATION_UNIQUE_KEYS;
        return validation;
    }
    let lastValue = (_column_ = column[0]) === null || _column_ === void 0 ? void 0 : _column_.valueOf();
    for(let d = 1; validation !== 0 && d < column.length; d++){
        var _column_d;
        const keyValue = (_column_d = column[d]) === null || _column_d === void 0 ? void 0 : _column_d.valueOf();
        if (!Number.isFinite(keyValue) || lastValue > keyValue) validation &= ~ANIMATION_VALIDATION_ORDERED_KEYS;
        if (Number.isFinite(keyValue) && lastValue === keyValue) validation &= ~ANIMATION_VALIDATION_UNIQUE_KEYS;
        lastValue = keyValue;
    }
    return validation;
}
function animationValidation(valueKeyIds) {
    return {
        type: "processor",
        property: "animationValidation",
        calculate (result) {
            if (!processedDataIsAnimatable(result)) return;
            const { keys: keysDefs, values: valuesDef } = result.defs;
            const { input, domain: { keys: domainKeys, values: domainValues }, keys, columns, invalidKeyCount } = result;
            let validation = ANIMATION_VALIDATION_UNIQUE_KEYS | ANIMATION_VALIDATION_ORDERED_KEYS;
            if (input.count !== 0) {
                for(let i = 0; validation !== 0 && i < keysDefs.length; i++){
                    for (const scope of keysDefs[i].scopes){
                        const column = keys[i].get(scope);
                        var _invalidKeyCount_get;
                        const missingKeys = (_invalidKeyCount_get = invalidKeyCount === null || invalidKeyCount === void 0 ? void 0 : invalidKeyCount.get(scope)) !== null && _invalidKeyCount_get !== void 0 ? _invalidKeyCount_get : 0;
                        const count = column.length - missingKeys;
                        validation &= animationValidationProcessKey(count, keysDefs[i], domainKeys[i], column);
                    }
                }
                for(let i = 0; validation !== 0 && i < valuesDef.length; i++){
                    const value = valuesDef[i];
                    if (!(valueKeyIds === null || valueKeyIds === void 0 ? void 0 : valueKeyIds.includes(value.id))) continue;
                    validation &= animationValidationProcessKey(0, value, domainValues[i], columns[i]);
                }
            }
            return {
                uniqueKeys: (validation & ANIMATION_VALIDATION_UNIQUE_KEYS) !== 0,
                orderedKeys: (validation & ANIMATION_VALIDATION_ORDERED_KEYS) !== 0
            };
        }
    };
}
function buildGroupAccFn(param) {
    let { mode, separateNegative } = param;
    return ()=>()=>(columns, valueIndexes, dataGroup)=>{
                const acc = [
                    0,
                    0
                ];
                for (const valueIdx of valueIndexes){
                    const datumIndices = dataGroup.datumIndices[valueIdx];
                    if (datumIndices == null) continue;
                    for (const datumIndex of datumIndices){
                        const column = columns[valueIdx];
                        const currentVal = column[datumIndex];
                        const accIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNegative"])(currentVal) && separateNegative ? 0 : 1;
                        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(currentVal)) continue;
                        if (mode === "normal") acc[accIndex] += currentVal;
                        column[datumIndex] = acc[accIndex];
                        if (mode === "trailing") acc[accIndex] += currentVal;
                    }
                }
            };
}
function buildGroupWindowAccFn(param) {
    let { mode, sum: sum2 } = param;
    return ()=>{
        const lastValues = [];
        let firstRow = true;
        return ()=>{
            return (columns, valueIndexes, dataGroup)=>{
                let acc = 0;
                for (const valueIdx of valueIndexes){
                    const column = columns[valueIdx];
                    const datumIndices = dataGroup.datumIndices[valueIdx];
                    if (datumIndices == null) continue;
                    for (const datumIndex of datumIndices){
                        const currentVal = column[datumIndex];
                        const lastValue = firstRow && sum2 === "current" ? 0 : lastValues[valueIdx];
                        lastValues[valueIdx] = currentVal;
                        const sumValue = sum2 === "current" ? currentVal : lastValue;
                        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(currentVal) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(lastValue)) {
                            column[datumIndex] = acc;
                            continue;
                        }
                        if (mode === "normal") {
                            acc += sumValue;
                        }
                        column[datumIndex] = acc;
                        if (mode === "trailing") {
                            acc += sumValue;
                        }
                    }
                }
                firstRow = false;
            };
        };
    };
}
function accumulateGroup(matchGroupId, mode, sum2) {
    let separateNegative = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    let adjust;
    if (mode.startsWith("window")) {
        const modeParam = mode.endsWith("-trailing") ? "trailing" : "normal";
        adjust = memo({
            mode: modeParam,
            sum: sum2
        }, buildGroupWindowAccFn);
    } else {
        adjust = memo({
            mode,
            separateNegative
        }, buildGroupAccFn);
    }
    return {
        type: "group-value-processor",
        matchGroupIds: [
            matchGroupId
        ],
        adjust
    };
}
function groupStackAccFn() {
    return ()=>(columns, valueIndexes, dataGroup)=>{
            const acc = new Float64Array(valueIndexes.length);
            let stackCount = 0;
            for (const valueIdx of valueIndexes){
                const column = columns[valueIdx];
                const datumIndices = dataGroup.datumIndices[valueIdx];
                if (datumIndices == null) continue;
                for (const datumIndex of datumIndices){
                    const currentValue = column[datumIndex];
                    acc[stackCount] = Number.isFinite(currentValue) ? currentValue : NaN;
                    stackCount += 1;
                    column[datumIndex] = acc.subarray(0, stackCount);
                }
            }
        };
}
function accumulateStack(matchGroupId) {
    return {
        type: "group-value-processor",
        matchGroupIds: [
            matchGroupId
        ],
        adjust: groupStackAccFn
    };
}
function valueIdentifier(value) {
    var _value_id;
    return (_value_id = value.id) !== null && _value_id !== void 0 ? _value_id : value.property;
}
function valueIndices(id, previousData, processedData) {
    const properties = /* @__PURE__ */ new Map();
    const previousValues = previousData.defs.values;
    for(let previousIndex = 0; previousIndex < previousValues.length; previousIndex += 1){
        var _previousValue_scopes;
        const previousValue = previousValues[previousIndex];
        if (((_previousValue_scopes = previousValue.scopes) === null || _previousValue_scopes === void 0 ? void 0 : _previousValue_scopes.includes(id)) === false) continue;
        const valueId = valueIdentifier(previousValue);
        if (properties.has(valueId)) return;
        properties.set(valueId, previousIndex);
    }
    const indices = [];
    const nextValues = processedData.defs.values;
    for(let nextIndex = 0; nextIndex < nextValues.length; nextIndex += 1){
        var _nextValue_scopes;
        const nextValue = nextValues[nextIndex];
        if (((_nextValue_scopes = nextValue.scopes) === null || _nextValue_scopes === void 0 ? void 0 : _nextValue_scopes.includes(id)) === false) continue;
        const valueId = valueIdentifier(nextValue);
        const previousIndex = properties.get(valueId);
        if (previousIndex == null) return;
        properties.delete(valueId);
        indices.push({
            previousIndex,
            nextIndex
        });
    }
    if (properties.size !== 0) return;
    return indices;
}
function columnsEqual(previousColumns, nextColumns, indices, previousDatumIndex, nextDatumIndex) {
    for (const { previousIndex, nextIndex } of indices){
        const previousColumn = previousColumns[previousIndex];
        const nextColumn = nextColumns[nextIndex];
        const previousValue = previousColumn[previousDatumIndex];
        const nextValue = nextColumn[nextDatumIndex];
        if (previousValue !== nextValue) {
            return false;
        }
    }
    return true;
}
function diff(id, previousData) {
    let updateMovedData = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    return {
        type: "processor",
        property: "diff",
        calculate (processedData, previousValue) {
            if (!processedDataIsAnimatable(processedData)) return;
            const moved = /* @__PURE__ */ new Map();
            const added = /* @__PURE__ */ new Map();
            const updated = /* @__PURE__ */ new Map();
            const removed = /* @__PURE__ */ new Map();
            const previousKeys = previousData.keys;
            const keys = processedData.keys;
            const previousColumns = previousData.columns;
            const columns = processedData.columns;
            const indices = valueIndices(id, previousData, processedData);
            if (indices == null) return previousValue;
            const length2 = Math.max(previousData.input.count, processedData.input.count);
            for(let i = 0; i < length2; i++){
                const hasPreviousDatum = i < previousData.input.count;
                const hasDatum = i < processedData.input.count;
                const prevKeys = hasPreviousDatum ? datumKeys(previousKeys, id, i) : void 0;
                const prevId = prevKeys != null ? createDatumId(prevKeys) : "";
                const dKeys = hasDatum ? datumKeys(keys, id, i) : void 0;
                const datumId = dKeys != null ? createDatumId(dKeys) : "";
                if (hasDatum && hasPreviousDatum && prevId === datumId) {
                    if (!columnsEqual(previousColumns, columns, indices, i, i)) {
                        updated.set(datumId, i);
                    }
                    continue;
                }
                const removedIndex = removed.get(datumId);
                if (removedIndex != null) {
                    if (updateMovedData || !columnsEqual(previousColumns, columns, indices, removedIndex, i)) {
                        updated.set(datumId, i);
                        moved.set(datumId, i);
                    }
                    removed.delete(datumId);
                } else if (hasDatum) {
                    added.set(datumId, i);
                }
                const addedIndex = added.get(prevId);
                if (addedIndex != null) {
                    if (updateMovedData || !columnsEqual(previousColumns, columns, indices, addedIndex, i)) {
                        updated.set(prevId, i);
                        moved.set(prevId, i);
                    }
                    added.delete(prevId);
                } else if (hasPreviousDatum) {
                    updated.delete(prevId);
                    removed.set(prevId, i);
                }
            }
            const changed = added.size > 0 || updated.size > 0 || removed.size > 0;
            const value = {
                changed,
                added: new Set(added.keys()),
                updated: new Set(updated.keys()),
                removed: new Set(removed.keys()),
                moved: new Set(moved.keys())
            };
            return {
                ...previousValue,
                [id]: value
            };
        }
    };
}
function createDatumId(keys) {
    for(var _len = arguments.length, extraKeys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        extraKeys[_key - 1] = arguments[_key];
    }
    let result;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(keys)) {
        result = keys.map((key)=>transformIntegratedCategoryValue(key)).join("___");
    } else {
        result = transformIntegratedCategoryValue(keys);
    }
    const primitiveType = typeof result === "string" || typeof result === "number" || typeof result === "boolean" || result instanceof Date;
    if (primitiveType && extraKeys.length > 0) {
        result += "___".concat(extraKeys.join("___"));
    }
    return result;
}
// packages/ag-charts-community/src/chart/axis/tree.ts
var Dimensions = class {
    update(x, y) {
        if (x > this.right) {
            this.right = x;
        }
        if (x < this.left) {
            this.left = x;
        }
        if (y > this.bottom) {
            this.bottom = y;
        }
        if (y < this.top) {
            this.top = y;
        }
    }
    constructor(){
        this.top = Infinity;
        this.right = -Infinity;
        this.bottom = -Infinity;
        this.left = Infinity;
    }
};
var TreeNode = class _TreeNode {
    insertTick(tick, index) {
        let root = this;
        for(let i = 0; i < tick.length; i++){
            const pathPart = tick[i];
            const isNotLeaf = i !== tick.length - 1;
            const { children } = root;
            const existingNode = children.find((child)=>child.label === pathPart);
            if (existingNode && isNotLeaf) {
                root = existingNode;
            } else {
                const node = new _TreeNode(pathPart, root, index);
                node.index = children.length;
                children.push(node);
                if (isNotLeaf) {
                    root = node;
                }
            }
        }
    }
    getLeftSibling() {
        var _this_parent;
        return this.index > 0 ? (_this_parent = this.parent) === null || _this_parent === void 0 ? void 0 : _this_parent.children[this.index - 1] : void 0;
    }
    getLeftmostSibling() {
        var _this_parent;
        return this.index > 0 ? (_this_parent = this.parent) === null || _this_parent === void 0 ? void 0 : _this_parent.children[0] : void 0;
    }
    // traverse the left contour of a subtree, return the successor of v on this contour
    nextLeft() {
        return this.children[0];
    }
    // traverse the right contour of a subtree, return the successor of v on this contour
    nextRight() {
        return this.children.at(-1);
    }
    getSiblings() {
        var _this_parent;
        var _this_parent_children_filter;
        return (_this_parent_children_filter = (_this_parent = this.parent) === null || _this_parent === void 0 ? void 0 : _this_parent.children.filter((_, i)=>i !== this.index)) !== null && _this_parent_children_filter !== void 0 ? _this_parent_children_filter : [];
    }
    constructor(label = "", parent, refId){
        this.label = label;
        this.parent = parent;
        this.refId = refId;
        this.position = 0;
        this.subtreeLeft = NaN;
        this.subtreeRight = NaN;
        this.children = [];
        this.leafCount = 0;
        this.prelim = 0;
        this.mod = 0;
        this.ancestor = this;
        this.change = 0;
        this.shift = 0;
        this.index = 0;
        // screen is meant to be recomputed from (layout) when the tree is resized (without performing another layout)
        this.screen = 0;
        this.depth = parent ? parent.depth + 1 : 0;
    }
};
function ticksToTree(ticks) {
    const maxDepth = ticks.reduce((depth, tick)=>depth < tick.length ? tick.length : depth, 0);
    const root = new TreeNode();
    for(let i = 0; i < ticks.length; i++){
        const tick = ticks[i];
        while(tick.length < maxDepth){
            tick.push("");
        }
        root.insertTick(tick, i);
    }
    return root;
}
function moveSubtree(wm, wp, shift) {
    const subtrees = wp.index - wm.index;
    const ratio11 = shift / subtrees;
    wp.change -= ratio11;
    wp.shift += shift;
    wm.change += ratio11;
    wp.prelim += shift;
    wp.mod += shift;
}
function ancestor(vim, v, defaultAncestor) {
    return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;
}
function executeShifts(param) {
    let { children } = param;
    let shift = 0;
    let change = 0;
    for(let i = children.length - 1; i >= 0; i--){
        const w = children[i];
        w.prelim += shift;
        w.mod += shift;
        change += w.change;
        shift += w.shift + change;
    }
}
function apportion(v, defaultAncestor) {
    const w = v.getLeftSibling();
    if (w) {
        let vop = v;
        let vip = v;
        let vim = w;
        let vom = vip.getLeftmostSibling();
        let sip = vip.mod;
        let sop = vop.mod;
        let sim = vim.mod;
        let som = vom.mod;
        while(vim.nextRight() && vip.nextLeft()){
            vim = vim.nextRight();
            vip = vip.nextLeft();
            vom = vom.nextLeft();
            vop = vop.nextRight();
            vop.ancestor = v;
            const shift = vim.prelim + sim - (vip.prelim + sip) + 1;
            if (shift > 0) {
                moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);
                sip += shift;
                sop += shift;
            }
            sim += vim.mod;
            sip += vip.mod;
            som += vom.mod;
            sop += vop.mod;
        }
        if (vim.nextRight() && !vop.nextRight()) {
            vop.mod += sim - sop;
        } else {
            if (vip.nextLeft() && !vom.nextLeft()) {
                vom.mod += sip - som;
            }
            defaultAncestor = v;
        }
    }
    return defaultAncestor;
}
function firstWalk(node) {
    const { children } = node;
    if (children.length) {
        let [defaultAncestor] = children;
        for (const child of children){
            firstWalk(child);
            defaultAncestor = apportion(child, defaultAncestor);
        }
        executeShifts(node);
        const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;
        const leftSibling = node.getLeftSibling();
        if (leftSibling) {
            node.prelim = leftSibling.prelim + 1;
            node.mod = node.prelim - midpoint;
        } else {
            node.prelim = midpoint;
        }
    } else {
        const leftSibling = node.getLeftSibling();
        node.prelim = leftSibling ? leftSibling.prelim + 1 : 0;
    }
}
function secondWalk(v, m, layout) {
    v.position = v.prelim + m;
    layout.insertNode(v);
    for (const w of v.children){
        secondWalk(w, m + v.mod, layout);
    }
}
function thirdWalk(v) {
    const { children } = v;
    let leafCount = 0;
    for (const w of children){
        thirdWalk(w);
        if (w.children.length) {
            leafCount += w.leafCount;
        } else {
            leafCount++;
        }
    }
    v.leafCount = leafCount;
    if (children.length) {
        v.subtreeLeft = children[0].subtreeLeft;
        v.subtreeRight = children[children.length - 1].subtreeRight;
        v.position = (v.subtreeLeft + v.subtreeRight) / 2;
    } else {
        v.subtreeLeft = v.position;
        v.subtreeRight = v.position;
    }
}
function treeLayout(ticks) {
    const layout = new TreeLayout();
    const root = ticksToTree(ticks);
    firstWalk(root);
    secondWalk(root, -root.prelim, layout);
    thirdWalk(root);
    return layout;
}
var TreeLayout = class {
    insertNode(node) {
        if (this.depth < node.depth) {
            this.depth = node.depth;
        }
        this.dimensions.update(node.position, node.depth);
        this.nodes.push(node);
    }
    scaling(extent2, flip) {
        let scaling = 1;
        if (extent2 > 0) {
            const { left, right } = this.dimensions;
            if (right !== left) {
                scaling = extent2 / (right - left);
            }
        }
        if (flip) {
            scaling *= -1;
        }
        return scaling;
    }
    constructor(){
        this.dimensions = new Dimensions();
        this.nodes = [];
        this.depth = 0;
    }
};
// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts
var DepthLabelProperties = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.enabled = true;
        this.border = new LabelBorder();
    }
};
__decorateClass([
    Property
], DepthLabelProperties.prototype, "enabled", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "avoidCollisions", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "border", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "color", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "cornerRadius", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "spacing", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "rotation", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "wrapping", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "truncate", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "fill", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "fontStyle", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "fontWeight", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "fontSize", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "fontFamily", 2);
__decorateClass([
    Property
], DepthLabelProperties.prototype, "padding", 2);
var DepthTickProperties = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.enabled = true;
    }
};
__decorateClass([
    Property
], DepthTickProperties.prototype, "enabled", 2);
__decorateClass([
    Property
], DepthTickProperties.prototype, "width", 2);
__decorateClass([
    Property
], DepthTickProperties.prototype, "stroke", 2);
var DepthProperties = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.label = new DepthLabelProperties();
        this.tick = new DepthTickProperties();
    }
};
__decorateClass([
    Property
], DepthProperties.prototype, "label", 2);
__decorateClass([
    Property
], DepthProperties.prototype, "tick", 2);
var GroupedCategoryAxis = class extends CategoryAxis {
    resizeTickTree() {
        if (!this.tickTreeLayout) return;
        const { nodes } = this.tickTreeLayout;
        const { range: range3, step, inset, bandwidth } = this.scale;
        const width2 = Math.abs(range3[1] - range3[0]) - step;
        const scaling = this.tickTreeLayout.scaling(width2, range3[0] > range3[1]);
        const shift = inset + bandwidth / 2;
        let offset = 0;
        for (const node of nodes){
            const screen = node.position * scaling;
            if (offset > screen) {
                offset = screen;
            }
            node.screen = screen + shift;
        }
        for (const node of nodes){
            node.screen -= offset;
        }
    }
    getDepthOptionsMap(maxDepth) {
        const optionsMap = [];
        const { depthOptions, label } = this;
        const defaultNonLeafRotation = this.horizontal ? 0 : -90;
        for(let i = 0; i < maxDepth; i++){
            var _depthOptions_i, _depthOptions_i1, _depthOptions_i2, _depthOptions_i3, _depthOptions_i4, _depthOptions_i5;
            var _depthOptions_i_label_enabled, _depthOptions_i_label_spacing, _depthOptions_i_label_wrapping, _depthOptions_i_label_truncate, _depthOptions_i_label_rotation, _depthOptions_i_label_avoidCollisions;
            optionsMap.push(((_depthOptions_i_label_enabled = (_depthOptions_i = depthOptions[i]) === null || _depthOptions_i === void 0 ? void 0 : _depthOptions_i.label.enabled) !== null && _depthOptions_i_label_enabled !== void 0 ? _depthOptions_i_label_enabled : label.enabled) ? {
                enabled: true,
                spacing: (_depthOptions_i_label_spacing = (_depthOptions_i1 = depthOptions[i]) === null || _depthOptions_i1 === void 0 ? void 0 : _depthOptions_i1.label.spacing) !== null && _depthOptions_i_label_spacing !== void 0 ? _depthOptions_i_label_spacing : label.spacing,
                wrapping: (_depthOptions_i_label_wrapping = (_depthOptions_i2 = depthOptions[i]) === null || _depthOptions_i2 === void 0 ? void 0 : _depthOptions_i2.label.wrapping) !== null && _depthOptions_i_label_wrapping !== void 0 ? _depthOptions_i_label_wrapping : label.wrapping,
                truncate: (_depthOptions_i_label_truncate = (_depthOptions_i3 = depthOptions[i]) === null || _depthOptions_i3 === void 0 ? void 0 : _depthOptions_i3.label.truncate) !== null && _depthOptions_i_label_truncate !== void 0 ? _depthOptions_i_label_truncate : label.truncate,
                rotation: (_depthOptions_i_label_rotation = (_depthOptions_i4 = depthOptions[i]) === null || _depthOptions_i4 === void 0 ? void 0 : _depthOptions_i4.label.rotation) !== null && _depthOptions_i_label_rotation !== void 0 ? _depthOptions_i_label_rotation : i ? defaultNonLeafRotation : label.rotation,
                // Default top-level label roration only applies to label leaves
                avoidCollisions: (_depthOptions_i_label_avoidCollisions = (_depthOptions_i5 = depthOptions[i]) === null || _depthOptions_i5 === void 0 ? void 0 : _depthOptions_i5.label.avoidCollisions) !== null && _depthOptions_i_label_avoidCollisions !== void 0 ? _depthOptions_i_label_avoidCollisions : label.avoidCollisions
            } : {
                enabled: false,
                spacing: 0,
                rotation: 0,
                avoidCollisions: false
            });
        }
        return optionsMap;
    }
    updateCategoryLabels() {
        if (!this.computedLayout) return;
        this.tickLabelGroupSelection.update(this.computedLayout.tickLabelLayout).each((node, datum)=>{
            node.fill = datum.color;
            node.text = datum.text;
            node.textBaseline = datum.textBaseline;
            var _datum_textAlign;
            node.textAlign = (_datum_textAlign = datum.textAlign) !== null && _datum_textAlign !== void 0 ? _datum_textAlign : "center";
            node.setFont(datum);
            node.setBoxing(datum);
        });
    }
    updateAxisLine() {
        if (!this.computedLayout) return;
        this.lineNode.visible = this.line.enabled;
        this.lineNode.stroke = this.line.stroke;
        this.lineNode.strokeWidth = this.line.width;
    }
    computeLayout() {
        var _this_tickTreeLayout;
        this.updateDirection();
        this.updateScale();
        const { step } = this.scale;
        const { title, label, range: range3, depthOptions, horizontal, line } = this;
        this.lineNode.datum = horizontal ? {
            x1: range3[0],
            x2: range3[1],
            y1: 0,
            y2: 0
        } : {
            x1: 0,
            x2: 0,
            y1: range3[0],
            y2: range3[1]
        };
        this.lineNode.setProperties({
            stroke: line.stroke,
            strokeWidth: line.enabled ? line.width : 0
        });
        this.resizeTickTree();
        if (!((_this_tickTreeLayout = this.tickTreeLayout) === null || _this_tickTreeLayout === void 0 ? void 0 : _this_tickTreeLayout.depth)) {
            return {
                bbox: BBox.zero,
                spacing: 0,
                separatorLayout: [],
                tickLabelLayout: []
            };
        }
        const { depth: maxDepth, nodes: treeLabels } = this.tickTreeLayout;
        const sideFlag = horizontal ? -label.getSideFlag() : label.getSideFlag();
        const tickLabelLayout = [];
        const labelBBoxes = /* @__PURE__ */ new Map();
        const tempText = new TransformableText();
        const optionsMap = this.getDepthOptionsMap(maxDepth);
        const labelSpacing = sideFlag * optionsMap[0].spacing;
        const tickFormatter = this.tickFormatter(this.scale.domain, this.scale.domain, false);
        const setLabelProps = (datum, index)=>{
            var _optionsMap_depth, _depthOptions_depth;
            const depth = maxDepth - datum.depth;
            if (!((_optionsMap_depth = optionsMap[depth]) === null || _optionsMap_depth === void 0 ? void 0 : _optionsMap_depth.enabled) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inRange"])(datum.screen, range3)) {
                return false;
            }
            let text = tickFormatter(datum.label, index - 1);
            const labelStyles = this.getLabelStyles({
                value: text,
                depth
            }, (_depthOptions_depth = depthOptions[depth]) === null || _depthOptions_depth === void 0 ? void 0 : _depthOptions_depth.label);
            if (label.avoidCollisions) {
                const rotation = optionsMap[depth].rotation;
                let maxWidth = (datum.leafCount || 1) * step;
                let maxHeight = this.thickness;
                if (rotation != null) {
                    const innerRect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getMaxInnerRectSize"])(rotation, maxWidth, maxHeight);
                    maxWidth = innerRect.width;
                    maxHeight = innerRect.height;
                }
                text = TextWrapper.wrapText(text, {
                    font: labelStyles,
                    textWrap: optionsMap[depth].wrapping,
                    overflow: optionsMap[depth].truncate ? "ellipsis" : "hide",
                    maxWidth,
                    maxHeight
                }) || text;
            }
            tempText.x = horizontal ? datum.screen : labelSpacing;
            tempText.y = horizontal ? labelSpacing : datum.screen;
            tempText.rotation = 0;
            tempText.lineHeight = TextUtils.getLineHeight(labelStyles.fontSize);
            tempText.fill = labelStyles.color;
            tempText.text = text;
            tempText.textAlign = "center";
            tempText.textBaseline = label.parallel ? "top" : "bottom";
            tempText.setFont(labelStyles);
            tempText.setBoxing(labelStyles);
            return true;
        };
        const depthLabelMaxSize = {};
        treeLabels.forEach((datum, index)=>{
            var _optionsMap_depth;
            const depth = maxDepth - datum.depth;
            var _depthLabelMaxSize_depth;
            (_depthLabelMaxSize_depth = depthLabelMaxSize[depth]) !== null && _depthLabelMaxSize_depth !== void 0 ? _depthLabelMaxSize_depth : depthLabelMaxSize[depth] = 0;
            const isVisible = setLabelProps(datum, index);
            if (!isVisible || !tempText.getBBox()) return;
            labelBBoxes.set(index, tempText.getBBox());
            tempText.rotation = normalizeAngle360FromDegrees((_optionsMap_depth = optionsMap[depth]) === null || _optionsMap_depth === void 0 ? void 0 : _optionsMap_depth.rotation);
            const { width: width2, height: height2 } = tempText.getBBox();
            const labelSize = horizontal ? height2 : width2;
            if (depthLabelMaxSize[depth] < labelSize) {
                depthLabelMaxSize[depth] = labelSize;
            }
        });
        const idGenerator = createIdsGenerator();
        const separatorData = /* @__PURE__ */ new Map();
        const nestedPadding = (d)=>{
            if (d === 0) return 0;
            let v = depthLabelMaxSize[0];
            for(let i = 1; i <= d; i++){
                v += optionsMap[i].spacing;
                if (i !== d) {
                    v += depthLabelMaxSize[i];
                }
            }
            return v;
        };
        treeLabels.forEach((datum, index)=>{
            if (index === 0) return;
            const visible = setLabelProps(datum, index);
            const isLeaf = !datum.children.length;
            const depth = maxDepth - datum.depth;
            if (datum.parent) {
                const separatorX = isLeaf ? datum.position : datum.position - (datum.leafCount - 1) / 2;
                if (!separatorData.has(separatorX)) {
                    var _this_depthOptions_depth;
                    const tickOptions = (_this_depthOptions_depth = this.depthOptions[depth]) === null || _this_depthOptions_depth === void 0 ? void 0 : _this_depthOptions_depth.tick;
                    let v = depthLabelMaxSize[0];
                    for(let i = 0; i <= depth; i++){
                        v += optionsMap[i].spacing;
                        if (i !== 0) {
                            v += depthLabelMaxSize[i];
                        }
                    }
                    separatorData.set(separatorX, {
                        tickSize: v,
                        tickStroke: tickOptions === null || tickOptions === void 0 ? void 0 : tickOptions.stroke,
                        tickWidth: (tickOptions === null || tickOptions === void 0 ? void 0 : tickOptions.enabled) !== false ? tickOptions === null || tickOptions === void 0 ? void 0 : tickOptions.width : 0
                    });
                }
            }
            if (!visible) return;
            const labelRotation = normalizeAngle360FromDegrees(optionsMap[depth].rotation);
            const { width: w, height: h } = labelBBoxes.get(index);
            const depthPadding = nestedPadding(depth);
            tempText.textAlign = "center";
            tempText.textBaseline = "middle";
            tempText.rotation = labelRotation;
            if (horizontal) {
                tempText.y += (depthPadding + angularPadding(w / 2, h / 2, labelRotation)) * sideFlag;
                tempText.rotationCenterX = datum.screen;
                tempText.rotationCenterY = tempText.y;
            } else {
                tempText.x += depthPadding * sideFlag + angularPadding((optionsMap[depth].spacing * sideFlag + w) / 2, label.mirrored ? w : 0, labelRotation) - w / 2;
                tempText.rotationCenterX = tempText.x;
                tempText.rotationCenterY = datum.screen;
            }
            if (optionsMap[depth].avoidCollisions) {
                const { width: width2, height: height2 } = tempText.getBBox();
                const labelSize = horizontal ? width2 : height2;
                const availableRange = isLeaf ? step : datum.leafCount * step;
                if (labelSize > availableRange) {
                    labelBBoxes.delete(index);
                    return;
                }
            }
            const text = tempText.getPlainText();
            const boxing = tempText.getBoxingProperties();
            tickLabelLayout.push({
                text,
                visible: true,
                tickId: idGenerator(text),
                range: this.scale.range,
                border: boxing.border,
                color: tempText.fill,
                cornerRadius: boxing.cornerRadius,
                fill: boxing.fill,
                fontFamily: tempText.fontFamily,
                fontSize: tempText.fontSize,
                fontStyle: tempText.fontStyle,
                fontWeight: tempText.fontWeight,
                padding: boxing.padding,
                rotation: tempText.rotation,
                rotationCenterX: tempText.rotationCenterX,
                rotationCenterY: tempText.rotationCenterY,
                textAlign: tempText.textAlign,
                textBaseline: tempText.textBaseline,
                x: tempText.x,
                y: tempText.y
            });
            labelBBoxes.set(index, Transformable.toCanvas(tempText));
        });
        const separatorLayout = [
            ...separatorData.values()
        ];
        separatorLayout.push(separatorLayout[0]);
        const bboxes = [
            this.lineNodeBBox(),
            BBox.merge(labelBBoxes.values()),
            new BBox(0, 0, separatorLayout[0].tickSize * sideFlag, 0)
        ];
        let spacing = 0;
        if (title.enabled) {
            const withoutTitle = BBox.merge(bboxes);
            spacing = horizontal ? withoutTitle.height : withoutTitle.width;
            bboxes.push(this.titleBBox(this.scale.domain, spacing));
        }
        const mergedBBox = BBox.merge(bboxes);
        this.layoutCrossLines();
        return {
            bbox: mergedBBox,
            spacing,
            separatorLayout,
            tickLabelLayout
        };
    }
    /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   * Supposed to be called _manually_ after changing _any_ of the axis properties.
   * This allows to bulk set axis properties before updating the nodes.
   * The node changes made by this method are rendered on the next animation frame.
   * We could schedule this method call automatically on the next animation frame
   * when any of the axis properties change (the way we do when properties of scene graph's
   * nodes change), but this will mean that we first wait for the next animation
   * frame to make changes to the nodes of the axis, then wait for another animation
   * frame to render those changes. It's nice to have everything update automatically,
   * but this extra level of async indirection will not just introduce an unwanted delay,
   * it will also make it harder to reason about the program.
   */ update() {
        if (!this.computedLayout) return;
        this.moduleCtx.animationManager.skipCurrentBatch();
        const { tickScale, tick, gridLine, gridLength } = this;
        const { separatorLayout, spacing } = this.computedLayout;
        const { position, horizontal, gridPadding } = this;
        const direction = position === "bottom" || position === "right" ? -1 : 1;
        const p1 = gridPadding;
        const p2 = direction * gridLength - gridPadding;
        const ticks = tickScale.ticks({
            nice: false,
            interval: void 0,
            tickCount: void 0,
            minTickCount: 0,
            maxTickCount: Infinity
        }).ticks.map((t, index)=>({
                index,
                tickId: createDatumId(t, index),
                translation: Math.round(tickScale.convert(t))
            }));
        this.gridLineGroupSelection.update(gridLine.enabled && gridLength ? this.calculateGridLines(ticks, p1, p2) : []);
        this.gridFillGroupSelection.update(gridLine.enabled && gridLength ? this.calculateGridFills(ticks, p1, p2) : []);
        this.tickLineGroupSelection.update(tick.enabled ? ticks.map((param, index)=>{
            let { tickId, translation: offset } = param;
            var _separatorLayout_index;
            const { tickSize = this.getTickSize(), tickStroke: stroke2 = tick.stroke, tickWidth: strokeWidth = tick.width } = (_separatorLayout_index = separatorLayout[index]) !== null && _separatorLayout_index !== void 0 ? _separatorLayout_index : {};
            const h = -direction * tickSize;
            const [x1, x2, y1, y2] = horizontal ? [
                offset,
                offset,
                0,
                h
            ] : [
                0,
                h,
                offset,
                offset
            ];
            const lineDash = void 0;
            return {
                tickId,
                offset,
                x1,
                y1,
                x2,
                y2,
                stroke: stroke2,
                strokeWidth,
                lineDash
            };
        }) : []);
        this.updatePosition();
        this.updateCategoryLabels();
        this.updateAxisLine();
        this.updateGridLines();
        this.updateGridFills();
        this.updateTickLines();
        this.updateTitle(this.scale.domain, spacing);
        this.updateCrossLines();
        this.resetSelectionNodes();
    }
    calculateLayout() {
        const { separatorLayout, tickLabelLayout, spacing, bbox } = this.computeLayout();
        this.computedLayout = {
            separatorLayout,
            tickLabelLayout,
            spacing
        };
        return {
            bbox,
            niceDomain: this.scale.domain
        };
    }
    /**
   * The length of the grid. The grid is only visible in case of a non-zero value.
   */ onGridVisibilityChange() {
        super.onGridVisibilityChange();
        this.tickLabelGroupSelection.clear();
    }
    updateScale() {
        super.updateScale();
        this.tickScale.range = this.scale.range;
        this.scale.paddingOuter = this.scale.paddingInner / 2;
    }
    processData() {
        const { direction } = this;
        const flatDomains = this.boundSeries.filter((s)=>s.visible).flatMap((series)=>series.getDomain(direction));
        var _extent;
        this.dataDomain = {
            domain: (_extent = extent(flatDomains)) !== null && _extent !== void 0 ? _extent : this.filterDuplicateArrays(flatDomains),
            clipped: false
        };
        if (this.isReversed()) {
            this.dataDomain.domain.reverse();
        }
        const domain = this.dataDomain.domain.map((datum)=>// Handle integrated charts data when provided as an object
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(datum) && "value" in datum ? datum.value : datum));
        this.tickTreeLayout = treeLayout(domain);
        const orderedDomain = [];
        for (const node of this.tickTreeLayout.nodes){
            if (node.leafCount || node.refId == null) continue;
            orderedDomain.push(this.dataDomain.domain[node.refId]);
        }
        this.scale.domain = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sortBasedOnArray"])(this.dataDomain.domain, orderedDomain);
        this.tickScale.domain = domain.concat([
            [
                ""
            ]
        ]);
    }
    filterDuplicateArrays(array6) {
        const seen = /* @__PURE__ */ new Set();
        return array6.filter((item)=>{
            const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(item) ? JSON.stringify(item) : item;
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
        });
    }
    constructor(moduleCtx){
        super(moduleCtx, new GroupedCategoryScale());
        // Label scale (labels are positioned between ticks, tick count = label count + 1).
        // We don't call is `labelScale` for consistency with other axes.
        this.tickScale = new GroupedCategoryScale();
        this.depthOptions = new PropertiesArray(DepthProperties);
        this.includeInvisibleDomains = true;
        this.tickScale.paddingInner = 1;
        this.tickScale.paddingOuter = 0;
    }
};
GroupedCategoryAxis.className = "GroupedCategoryAxis";
GroupedCategoryAxis.type = "grouped-category";
__decorateClass([
    Property
], GroupedCategoryAxis.prototype, "depthOptions", 2);
;
;
var logFunctions = {
    2: (_base, x)=>Math.log2(x),
    [Math.E]: (_base, x)=>Math.log(x),
    10: (_base, x)=>Math.log10(x)
};
var DEFAULT_LOG = (base, x)=>Math.log(x) / Math.log(base);
function log(base, domain, x) {
    const start2 = Math.min(...domain);
    var _logFunctions_base;
    const fn = (_logFunctions_base = logFunctions[base]) !== null && _logFunctions_base !== void 0 ? _logFunctions_base : DEFAULT_LOG;
    return start2 >= 0 ? fn(base, x) : -fn(base, -x);
}
var powFunctions = {
    [Math.E]: (_base, x)=>Math.exp(x),
    10: (_base, x)=>x >= 0 ? 10 ** x : 1 / 10 ** -x
};
var DEFAULT_POW = (base, x)=>base ** x;
function pow(base, domain, x) {
    const start2 = Math.min(...domain);
    var _powFunctions_base;
    const fn = (_powFunctions_base = powFunctions[base]) !== null && _powFunctions_base !== void 0 ? _powFunctions_base : DEFAULT_POW;
    return start2 >= 0 ? fn(base, x) : -fn(base, -x);
}
var LogScale = class _LogScale extends ContinuousScale {
    static is(value) {
        return value instanceof _LogScale;
    }
    transform(x) {
        const [min, max] = findMinMax(this.domain);
        if (min >= 0 !== max >= 0) return NaN;
        return min >= 0 ? Math.log(x) : -Math.log(-x);
    }
    transformInvert(x) {
        const [min, max] = findMinMax(this.domain);
        if (min >= 0 !== max >= 0) return NaN;
        return min >= 0 ? Math.exp(x) : -Math.exp(-x);
    }
    toDomain(d) {
        return d;
    }
    niceDomain(_ticks) {
        let domain = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.domain;
        if (domain.length < 2) return [];
        const { base } = this;
        const [d0, d1] = domain;
        const roundStart = d0 > d1 ? Math.ceil : Math.floor;
        const roundStop = d0 > d1 ? Math.floor : Math.ceil;
        const n0 = pow(base, domain, roundStart(log(base, domain, d0)));
        const n1 = pow(base, domain, roundStop(log(base, domain, d1)));
        return [
            n0,
            n1
        ];
    }
    ticks(param) {
        let { interval, tickCount = ContinuousScale.defaultTickCount } = param, domain = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.domain, visibleRange = arguments.length > 2 ? arguments[2] : void 0;
        if (!domain || domain.length < 2 || tickCount < 1) {
            return;
        }
        const base = this.base;
        const [d0, d1] = domain;
        const start2 = Math.min(d0, d1);
        const stop = Math.max(d0, d1);
        let p0 = this.log(start2);
        let p1 = this.log(stop);
        if (interval) {
            const inBounds = (tick)=>tick >= start2 && tick <= stop;
            const step = Math.min(Math.abs(interval), Math.abs(p1 - p0));
            const { ticks: rangeTicks, count, firstTickIndex } = range(p0, p1, step, visibleRange);
            const ticks2 = rangeTicks.map(this.pow).filter(inBounds);
            if (!isDenseInterval(ticks2.length, this.getPixelRange())) {
                return {
                    ticks: ticks2,
                    count,
                    firstTickIndex
                };
            }
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInteger"])(base) || p1 - p0 >= tickCount) {
            const step = Math.min(p1 - p0, tickCount);
            const { ticks: ticks2, count, firstTickIndex } = createTicks(p0, p1, step, void 0, void 0, visibleRange);
            return {
                ticks: ticks2.map(this.pow),
                count,
                firstTickIndex
            };
        }
        const ticks = [];
        const isPositive = start2 > 0;
        p0 = Math.floor(p0) - 1;
        p1 = Math.round(p1) + 1;
        const availableSpacing = findRangeExtent(this.range) / tickCount;
        let lastTickPosition = Infinity;
        for(let p = p0; p <= p1; p++){
            const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));
            for(let k = 1; k < base; k++){
                const q = isPositive ? k : base - k + 1;
                const t = this.pow(p) * q;
                const tickPosition = this.convert(t);
                const prevSpacing = Math.abs(lastTickPosition - tickPosition);
                const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);
                const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;
                if (t >= start2 && t <= stop && (k === 1 || fits || ticks.length === 0)) {
                    ticks.push(t);
                    lastTickPosition = tickPosition;
                }
            }
        }
        return filterVisibleTicks(ticks, isPositive, visibleRange);
    }
    constructor(d = [
        1,
        10
    ], r = [
        0,
        1
    ]){
        super(d, r);
        this.type = "log";
        // Handling <1 and crossing 0 cases is tricky, easiest solution is to default to clamping.
        this.defaultClamp = true;
        this.base = 10;
        this.log = (x)=>log(this.base, this.domain, x);
        this.pow = (x)=>pow(this.base, this.domain, x);
    }
};
// packages/ag-charts-community/src/scale/linearScale.ts
var LinearScale = class _LinearScale extends ContinuousScale {
    static is(value) {
        return value instanceof _LinearScale;
    }
    static getTickStep(start2, stop, ticks) {
        const { interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount } = ticks;
        return interval !== null && interval !== void 0 ? interval : tickStep(start2, stop, tickCount, minTickCount, maxTickCount);
    }
    toDomain(d) {
        return d;
    }
    ticks(param) {
        let { interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount } = param, domain = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.domain, visibleRange = arguments.length > 2 ? arguments[2] : void 0;
        if (!domain || domain.length < 2 || tickCount < 1 || !domain.every(isFinite)) {
            return {
                ticks: [],
                count: 0,
                firstTickIndex: 0
            };
        }
        const [d0, d1] = domain;
        if (interval) {
            const step = Math.abs(interval);
            if (!isDenseInterval((d1 - d0) / step, this.getPixelRange())) {
                return range(d0, d1, step, visibleRange);
            }
        }
        return createTicks(d0, d1, tickCount, minTickCount, maxTickCount, visibleRange);
    }
    niceDomain(ticks) {
        let domain = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.domain;
        if (domain.length < 2) return [];
        const { tickCount = ContinuousScale.defaultTickCount } = ticks;
        let [start2, stop] = domain;
        if (tickCount === 1) {
            [start2, stop] = niceTicksDomain(start2, stop);
        } else if (tickCount > 1) {
            const roundStart = start2 > stop ? Math.ceil : Math.floor;
            const roundStop = start2 > stop ? Math.floor : Math.ceil;
            const maxAttempts = 4;
            for(let i = 0; i < maxAttempts; i++){
                const prev0 = start2;
                const prev1 = stop;
                const step = _LinearScale.getTickStep(start2, stop, ticks);
                const [d0, d1] = domain;
                start2 = roundStart(d0 / step) * step;
                stop = roundStop(d1 / step) * step;
                if (start2 === prev0 && stop === prev1) break;
            }
        }
        return [
            start2,
            stop
        ];
    }
    constructor(){
        super([
            0,
            1
        ], [
            0,
            1
        ]);
        this.type = "number";
    }
};
// packages/ag-charts-community/src/chart/axis/numberAxis.ts
var NumberAxis = class extends CartesianAxis {
    hasDefinedDomain() {
        const { min, max } = this;
        return min != null && max != null && min < max;
    }
    normaliseDataDomain(d) {
        const { min, max } = this;
        const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);
        return {
            domain: extent2,
            clipped
        };
    }
    createDatumFormatter(_domain, ticks) {
        const { format } = this.label;
        return typeof format === "number" ? tickFormat(ticks, format) : void 0;
    }
    tickFormatParams(_domain, _ticks, fractionDigits) {
        return {
            type: "number",
            fractionDigits
        };
    }
    datumFormatParams(value, params, fractionDigits) {
        const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
        return {
            type: "number",
            value,
            datum,
            seriesId,
            legendItemName,
            key,
            source,
            property,
            domain,
            boundSeries,
            fractionDigits
        };
    }
    constructor(moduleCtx, scale2 = new LinearScale()){
        super(moduleCtx, scale2);
    }
};
NumberAxis.className = "NumberAxis";
NumberAxis.type = "number";
__decorateClass([
    Property
], NumberAxis.prototype, "min", 2);
__decorateClass([
    Property
], NumberAxis.prototype, "max", 2);
// packages/ag-charts-community/src/chart/axis/logAxis.ts
var LogAxis = class extends NumberAxis {
    normaliseDataDomain(d) {
        const { min, max } = this;
        const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);
        if (extent2[0] < 0 && extent2[1] > 0 || d[0] < 0 && d[1] > 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("The log axis domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.");
            return {
                domain: [],
                clipped
            };
        } else if (extent2[0] === 0 || extent2[1] === 0 || d[0] === 0 || d[1] === 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("The log axis domain contains a value of 0, the chart data cannot be rendered. See log axis documentation for more information.");
            return {
                domain: [],
                clipped
            };
        }
        return {
            domain: extent2,
            clipped
        };
    }
    set base(value) {
        this.scale.base = value;
    }
    get base() {
        return this.scale.base;
    }
    constructor(moduleCtx){
        super(moduleCtx, new LogScale());
    }
};
LogAxis.className = "LogAxis";
LogAxis.type = "log";
;
var TimeAxisParentLevel = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.enabled = false;
        this.label = new AxisLabel();
        this.tick = new AxisTick();
    }
};
__decorateClass([
    Property
], TimeAxisParentLevel.prototype, "enabled", 2);
__decorateClass([
    Property
], TimeAxisParentLevel.prototype, "label", 2);
__decorateClass([
    Property
], TimeAxisParentLevel.prototype, "tick", 2);
var TimeAxis = class extends CartesianAxis {
    // eslint-disable-next-line sonarjs/use-type-alias
    get _unit() {
        return void 0;
    }
    set _unit(_unit) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("To use 'unit', use an axis with type 'unit-time' instead of 'time'.");
    }
    hasDefinedDomain() {
        const { min, max } = this;
        return min != null && max != null && min < max;
    }
    isCategoryLike() {
        return false;
    }
    get primaryLabel() {
        return this.parentLevel.enabled ? this.parentLevel.label : void 0;
    }
    get primaryTick() {
        return this.parentLevel.enabled ? this.parentLevel.tick : void 0;
    }
    normaliseDataDomain(d) {
        return normaliseTimeDataDomain(d, this.min, this.max);
    }
    processData() {
        super.processData();
        const { boundSeries, direction, min, max } = this;
        this.minimumTimeGranularity = minimumTimeAxisDatumGranularity(boundSeries, direction, min, max);
    }
    tickFormatParams(domain, ticks, _fractionDigits, timeInterval3) {
        timeInterval3 !== null && timeInterval3 !== void 0 ? timeInterval3 : timeInterval3 = lowestGranularityUnitForTicks(ticks);
        const truncateDate = dateTruncationForDomain(domain);
        const unit = intervalUnit(timeInterval3);
        const step = intervalStep(timeInterval3);
        const epoch = intervalEpoch(timeInterval3);
        return {
            type: "date",
            unit,
            step,
            epoch,
            truncateDate
        };
    }
    datumFormatParams(value, params, _fractionDigits, timeInterval3, style) {
        if (typeof value === "number") value = new Date(value);
        if (timeInterval3 == null) {
            const { minimumTimeGranularity } = this;
            const datumGranularity = lowestGranularityUnitForValue(value);
            if (minimumTimeGranularity != null && intervalMilliseconds(minimumTimeGranularity) < intervalMilliseconds(datumGranularity)) {
                timeInterval3 = minimumTimeGranularity;
            } else {
                timeInterval3 = datumGranularity;
            }
        }
        const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
        const unit = intervalUnit(timeInterval3);
        const step = intervalStep(timeInterval3);
        const epoch = intervalEpoch(timeInterval3);
        return {
            type: "date",
            value,
            datum,
            seriesId,
            legendItemName,
            key,
            source,
            property,
            domain,
            boundSeries,
            unit,
            step,
            epoch,
            style
        };
    }
    constructor(moduleCtx){
        super(moduleCtx, new TimeScale());
        this.parentLevel = new TimeAxisParentLevel();
        this.min = void 0;
        this.max = void 0;
        this.minimumTimeGranularity = void 0;
    }
};
TimeAxis.className = "TimeAxis";
TimeAxis.type = "time";
__decorateClass([
    Property
], TimeAxis.prototype, "parentLevel", 2);
__decorateClass([
    Property
], TimeAxis.prototype, "min", 2);
__decorateClass([
    Property
], TimeAxis.prototype, "max", 2);
__decorateClass([
    Property,
    ProxyPropertyOnWrite("_unit")
], TimeAxis.prototype, "unit", 2);
function minimumTimeAxisDatumGranularity(boundSeries, direction, min, max) {
    const minTimeInterval = boundSeries.reduce((t, series)=>{
        var _series_minTimeInterval;
        return Math.min((_series_minTimeInterval = series.minTimeInterval()) !== null && _series_minTimeInterval !== void 0 ? _series_minTimeInterval : Infinity, t);
    }, Infinity);
    if (Number.isFinite(minTimeInterval)) {
        return lowestGranularityForInterval(minTimeInterval);
    } else {
        var _calculateDefaultUnit;
        return (_calculateDefaultUnit = calculateDefaultUnit(boundSeries, direction, min, max)) === null || _calculateDefaultUnit === void 0 ? void 0 : _calculateDefaultUnit.unit;
    }
}
function calculateDefaultUnit(boundSeries, direction, min, max) {
    let start2 = Infinity;
    let end2 = -Infinity;
    let interval;
    let maxDataCount = 0;
    const domainValues = [];
    for (const series of boundSeries){
        if (!series.visible) continue;
        const { domain } = normaliseTimeDataDomain(series.getDomain(direction), void 0, void 0);
        if (domain.length === 0) continue;
        const d0 = domain[0].valueOf();
        const d1 = domain[domain.length - 1].valueOf();
        domainValues.push(d0, d1);
        start2 = Math.min(start2 !== null && start2 !== void 0 ? start2 : Infinity, d0, d1);
        end2 = Math.max(end2 !== null && end2 !== void 0 ? end2 : -Infinity, d0, d1);
        const domainExtent = Math.abs(d1 - d0);
        if (domainExtent === 0) continue;
        const dataCount = series.dataCount();
        maxDataCount = Math.max(maxDataCount, dataCount);
        if (dataCount <= 1) continue;
        const i = domainExtent / (dataCount - 1);
        interval = Math.min(interval !== null && interval !== void 0 ? interval : Infinity, i);
    }
    var _min_valueOf, _max_valueOf;
    start2 = Math.min(start2, (_min_valueOf = min === null || min === void 0 ? void 0 : min.valueOf()) !== null && _min_valueOf !== void 0 ? _min_valueOf : Infinity, (_max_valueOf = max === null || max === void 0 ? void 0 : max.valueOf()) !== null && _max_valueOf !== void 0 ? _max_valueOf : Infinity);
    var _min_valueOf1, _max_valueOf1;
    end2 = Math.max(end2, (_min_valueOf1 = min === null || min === void 0 ? void 0 : min.valueOf()) !== null && _min_valueOf1 !== void 0 ? _min_valueOf1 : -Infinity, (_max_valueOf1 = max === null || max === void 0 ? void 0 : max.valueOf()) !== null && _max_valueOf1 !== void 0 ? _max_valueOf1 : -Infinity);
    if (!Number.isFinite(start2) || !Number.isFinite(end2)) return;
    interval !== null && interval !== void 0 ? interval : interval = Math.abs(end2 - start2);
    interval = Math.min(interval, minNonZeroDifference(domainValues));
    const unit = lowestGranularityForInterval(interval);
    let step = interval / intervalMilliseconds(unit);
    if (maxDataCount <= 2) {
        step = Math.floor(step);
    } else {
        step = Math.round(step);
    }
    step = Math.max(step, 1);
    const epoch = step === 1 ? void 0 : intervalFloor(unit, start2);
    return {
        unit,
        step,
        epoch
    };
}
function minNonZeroDifference(values) {
    values.sort((a, b)=>a - b);
    let minDiff = Infinity;
    for(let i = 1; i < values.length; i++){
        const d0 = values[i - 1];
        const d1 = values[i];
        const delta3 = d1 - d0;
        if (delta3 > 0) {
            minDiff = Math.min(minDiff, Math.abs(d1 - d0));
        }
    }
    return minDiff;
}
function normaliseTimeDataDomain(d, min, max) {
    var _extent;
    let clipped = false;
    if (typeof min === "number") {
        min = new Date(min);
    }
    if (typeof max === "number") {
        max = new Date(max);
    }
    const de = (_extent = extent(d)) === null || _extent === void 0 ? void 0 : _extent.map((x)=>new Date(x));
    if (de == null) {
        return {
            domain: min != null && max != null && min.valueOf() <= max.valueOf() ? [
                min,
                max
            ] : [],
            clipped: false
        };
    }
    let [d0, d1] = de;
    if (min instanceof Date) {
        clipped || (clipped = min > d0);
        d0 = min;
    }
    if (max instanceof Date) {
        clipped || (clipped = max < d1);
        d1 = max;
    }
    if (d0 > d1) {
        return {
            domain: [],
            clipped: false
        };
    }
    return {
        domain: [
            d0,
            d1
        ],
        clipped
    };
}
// packages/ag-charts-community/src/chart/axis/discreteTimeAxis.ts
var DiscreteTimeAxis = class extends CategoryAxis {
    calculateGridLine(param, index, p1, p2, ticks) {
        let { index: tickIndex, tickId, translation } = param;
        const { gridLine, horizontal, interval, range: range3 } = this;
        if (interval.placement !== "between") {
            return super.calculateGridLine({
                index: tickIndex,
                tickId,
                translation
            }, index, p1, p2, ticks);
        }
        const prevTick = ticks[index - 1];
        const offset = prevTick ? translation - (translation - prevTick.translation) / 2 : range3[0];
        const [x1, y1, x2, y2] = horizontal ? [
            offset,
            Math.max(p1, p2),
            offset,
            Math.min(p1, p2)
        ] : [
            Math.min(p1, p2),
            offset,
            Math.max(p1, p2),
            offset
        ];
        const { style } = gridLine;
        var _style_;
        const { stroke: stroke2, strokeWidth = 0, lineDash } = (_style_ = style[tickIndex % style.length]) !== null && _style_ !== void 0 ? _style_ : {};
        return {
            tickId,
            offset,
            x1,
            y1,
            x2,
            y2,
            stroke: stroke2,
            strokeWidth,
            lineDash
        };
    }
    calculateGridFills(ticks, p1, p2) {
        if (this.interval.placement !== "between") {
            return super.calculateGridFills(ticks, p1, p2);
        }
        return ticks.map((tick, index)=>this.calculateGridFill(tick, index, tick.index, p1, p2, ticks));
    }
    calculateGridFill(param, index, gridFillIndex, p1, p2, ticks) {
        let { tickId, translation } = param;
        const { gridLine, horizontal, interval, range: range3 } = this;
        if (interval.placement !== "between") {
            return super.calculateGridFill({
                tickId,
                translation
            }, index, gridFillIndex, p1, p2, ticks);
        }
        const prevTick = ticks[index - 1];
        const nextTick = ticks[index + 1];
        const startOffset = prevTick ? translation - (translation - prevTick.translation) / 2 : range3[0];
        const endOffset = nextTick ? translation + (nextTick.translation - translation) / 2 : range3[1];
        const [x1, y1, x2, y2] = horizontal ? [
            startOffset,
            Math.max(p1, p2),
            endOffset,
            Math.min(p1, p2)
        ] : [
            Math.min(p1, p2),
            startOffset,
            Math.max(p1, p2),
            endOffset
        ];
        var _gridLine_style_;
        const { fill, fillOpacity } = (_gridLine_style_ = gridLine.style[gridFillIndex % gridLine.style.length]) !== null && _gridLine_style_ !== void 0 ? _gridLine_style_ : {};
        return {
            tickId,
            x1,
            y1,
            x2,
            y2,
            fill,
            fillOpacity
        };
    }
    calculateTickLine(param, index, direction, ticks) {
        let { primary, tickId, translation } = param;
        const { horizontal, interval, primaryTick, range: range3, tick } = this;
        if (interval.placement !== "between") {
            return super.calculateTickLine({
                primary,
                tickId,
                translation
            }, index, direction, ticks);
        }
        const datumTick = primary && (primaryTick === null || primaryTick === void 0 ? void 0 : primaryTick.enabled) ? primaryTick : tick;
        const h = -direction * this.getTickSize(datumTick);
        const prevTick = ticks[index - 1];
        const offset = prevTick ? translation - (translation - prevTick.translation) / 2 : range3[0];
        const [x1, y1, x2, y2] = horizontal ? [
            offset,
            0,
            offset,
            h
        ] : [
            0,
            offset,
            h,
            offset
        ];
        const { stroke: stroke2, width: strokeWidth } = datumTick;
        const lineDash = void 0;
        return {
            tickId,
            offset,
            x1,
            y1,
            x2,
            y2,
            stroke: stroke2,
            strokeWidth,
            lineDash
        };
    }
};
// packages/ag-charts-community/src/chart/axis/unitTimeAxis.ts
var UnitTimeAxis = class extends DiscreteTimeAxis {
    get primaryLabel() {
        return this.parentLevel.enabled ? this.parentLevel.label : void 0;
    }
    get primaryTick() {
        return this.parentLevel.enabled ? this.parentLevel.tick : void 0;
    }
    hasDefinedDomain() {
        const { min, max } = this;
        return min != null && max != null && min < max;
    }
    isCategoryLike() {
        return true;
    }
    processData() {
        super.processData();
        let defaultUnit;
        const { domain } = this.dataDomain;
        if (domain.length === 2 && domain[0].valueOf() === domain[1].valueOf()) {
            defaultUnit = lowestGranularityUnitForValue(domain[0]);
        } else {
            const { boundSeries, direction, min, max } = this;
            defaultUnit = calculateDefaultUnit(boundSeries, direction, min, max);
        }
        if (!objectsEqual(this.defaultUnit, defaultUnit)) {
            this.defaultUnit = defaultUnit;
        }
    }
    updateScale() {
        super.updateScale();
        var _this_unit;
        this.scale.interval = (_this_unit = this.unit) !== null && _this_unit !== void 0 ? _this_unit : this.defaultUnit;
    }
    normaliseDataDomain(domain) {
        return normaliseTimeDataDomain(domain, this.min, this.max);
    }
    createDatumFormatter(_domain, _ticks) {
        const timeInterval3 = this.scale.interval;
        const { format } = this.label;
        if (format == null) return;
        const specifier = labelSpecifier(timeInterval3 != null ? deriveTimeSpecifier(format, intervalUnit(timeInterval3)) : format, timeInterval3);
        if (specifier == null) return;
        return buildDateFormatter(specifier);
    }
    tickFormatParams(domain, ticks, _fractionDigits, timeInterval3) {
        timeInterval3 !== null && timeInterval3 !== void 0 ? timeInterval3 : timeInterval3 = lowestGranularityUnitForTicks(ticks);
        const truncateDate = dateTruncationForDomain(domain);
        const unit = intervalUnit(timeInterval3);
        const step = intervalStep(timeInterval3);
        const epoch = intervalEpoch(timeInterval3);
        return {
            type: "date",
            unit,
            step,
            epoch,
            truncateDate
        };
    }
    datumFormatParams(value, params, _fractionDigits, timeInterval3, style) {
        var _this_unit, _ref;
        const interval = (_ref = (_this_unit = this.unit) !== null && _this_unit !== void 0 ? _this_unit : this.defaultUnit) !== null && _ref !== void 0 ? _ref : "millisecond";
        value = intervalFloor(interval, value);
        if (typeof value === "number") value = new Date(value);
        timeInterval3 !== null && timeInterval3 !== void 0 ? timeInterval3 : timeInterval3 = interval;
        const { datum, seriesId, legendItemName, key, source, property, domain, boundSeries } = params;
        const unit = intervalUnit(timeInterval3);
        const step = intervalStep(timeInterval3);
        const epoch = intervalEpoch(timeInterval3);
        return {
            type: "date",
            value,
            datum,
            seriesId,
            legendItemName,
            key,
            source,
            property,
            domain,
            boundSeries,
            unit,
            step,
            epoch,
            style
        };
    }
    constructor(moduleCtx){
        super(moduleCtx, new UnitTimeScale(), false);
        this.parentLevel = new TimeAxisParentLevel();
        this.min = void 0;
        this.max = void 0;
        // eslint-disable-next-line sonarjs/use-type-alias
        this.unit = void 0;
        this.defaultUnit = void 0;
    }
};
UnitTimeAxis.className = "UnitTimeAxis";
UnitTimeAxis.type = "unit-time";
__decorateClass([
    Property
], UnitTimeAxis.prototype, "parentLevel", 2);
__decorateClass([
    Property
], UnitTimeAxis.prototype, "min", 2);
__decorateClass([
    Property
], UnitTimeAxis.prototype, "max", 2);
__decorateClass([
    Property
], UnitTimeAxis.prototype, "unit", 2);
// packages/ag-charts-community/src/module/axisModules.ts
var numberAxisOptionsDefs = {
    ...cartesianAxisOptionsDefs,
    ...continuousAxisOptions(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("number")),
    label: cartesianNumericAxisLabel,
    crosshair: cartesianAxisCrosshairOptions(true)
};
var logAxisOptionsDefs = {
    ...cartesianAxisOptionsDefs,
    ...continuousAxisOptions(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("log")),
    base: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumberNonZero"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attachDescription"])((value)=>value !== 1, "not equal to 1")),
    label: cartesianNumericAxisLabel,
    crosshair: cartesianAxisCrosshairOptions(true)
};
var timeAxisOptionsDefs = {
    ...cartesianAxisOptionsDefs,
    ...continuousAxisOptions((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["date"]), true),
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("time")),
    label: cartesianTimeAxisLabel,
    parentLevel: cartesianTimeAxisParentLevel,
    crosshair: cartesianAxisCrosshairOptions(true, true)
};
var categoryAxisOptionsDefs = {
    ...cartesianAxisOptionsDefs,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("category")),
    label: cartesianAxisLabelOptionsDefs,
    paddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    paddingOuter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    groupPaddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    crosshair: cartesianAxisCrosshairOptions(),
    bandHighlight: cartesianAxisBandHighlightOptions,
    interval: {
        ...commonAxisIntervalOptionsDefs,
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("on", "between")
    }
};
var groupedCategoryAxisOptionsDefs = {
    ...cartesianAxisOptionsDefs,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("grouped-category")),
    label: cartesianAxisLabelOptionsDefs,
    crosshair: cartesianAxisCrosshairOptions(),
    bandHighlight: cartesianAxisBandHighlightOptions,
    paddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    groupPaddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    depthOptions: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])({
        label: {
            enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            avoidCollisions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            wrapping: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("never", "always", "hyphenate", "on-space"),
            truncate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            rotation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
            spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelBoxOptionsDef"]
        },
        tick: {
            enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            stroke: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
            width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
        }
    }, "depth options objects array")
};
var unitTimeAxisOptionsDefs = {
    ...cartesianAxisOptionsDefs,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("unit-time")),
    unit: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(timeInterval2, timeIntervalUnit),
    label: cartesianTimeAxisLabel,
    parentLevel: cartesianTimeAxisParentLevel,
    paddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    paddingOuter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    groupPaddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    crosshair: cartesianAxisCrosshairOptions(true, true),
    bandHighlight: cartesianAxisBandHighlightOptions,
    min: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["date"]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lessThan"])("max")),
    max: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["date"]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["greaterThan"])("min")),
    interval: discreteTimeAxisIntervalOptionsDefs
};
var NumberAxisModule = {
    type: "axis",
    name: "number",
    chartType: "cartesian",
    options: numberAxisOptionsDefs,
    create: (ctx)=>new NumberAxis(ctx)
};
var LogAxisModule = {
    type: "axis",
    name: "log",
    chartType: "cartesian",
    options: logAxisOptionsDefs,
    create: (ctx)=>new LogAxis(ctx)
};
var TimeAxisModule = {
    type: "axis",
    name: "time",
    chartType: "cartesian",
    options: timeAxisOptionsDefs,
    create: (ctx)=>new TimeAxis(ctx)
};
var CategoryAxisModule = {
    type: "axis",
    name: "category",
    chartType: "cartesian",
    options: categoryAxisOptionsDefs,
    create: (ctx)=>new CategoryAxis(ctx)
};
var GroupedCategoryAxisModule = {
    type: "axis",
    name: "grouped-category",
    chartType: "cartesian",
    options: groupedCategoryAxisOptionsDefs,
    create: (ctx)=>new GroupedCategoryAxis(ctx)
};
var UnitTimeAxisModule = {
    type: "axis",
    name: "unit-time",
    chartType: "cartesian",
    options: unitTimeAxisOptionsDefs,
    create: (ctx)=>new UnitTimeAxis(ctx)
};
;
var ordinalTimeAxisOptionsDefs = {
    ...cartesianAxisOptionsDefs,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("ordinal-time")),
    paddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    paddingOuter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    groupPaddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    label: cartesianTimeAxisLabel,
    parentLevel: cartesianTimeAxisParentLevel,
    interval: discreteTimeAxisIntervalOptionsDefs,
    crosshair: cartesianAxisCrosshairOptions(true, true),
    bandHighlight: cartesianAxisBandHighlightOptions
};
var angleNumberAxisOptionsDefs = {
    ...commonAxisOptionsDefs,
    ...continuousAxisOptions(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("angle-number")),
    crossLines: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])(commonCrossLineOptionsDefs),
    startAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    endAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    label: {
        ...commonAxisLabelOptionsDefs,
        orientation: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("fixed", "parallel", "perpendicular"),
        format: numberFormatValidator
    }
};
var invalidOptionsFromIntegratedCharts = {
    // @ts-expect-error integrated sets this from the formatting panel, but it isn't relevant.
    innerRadiusRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
};
var angleCategoryAxisOptionsDefs = {
    ...commonAxisOptionsDefs,
    ...invalidOptionsFromIntegratedCharts,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("angle-category")),
    shape: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("polygon", "circle"),
    crossLines: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])(commonCrossLineOptionsDefs),
    startAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    endAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    paddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    groupPaddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    label: {
        ...commonAxisLabelOptionsDefs,
        orientation: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("fixed", "parallel", "perpendicular")
    }
};
var radiusNumberAxisOptionsDefs = {
    ...commonAxisOptionsDefs,
    ...continuousAxisOptions(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("radius-number")),
    shape: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("polygon", "circle"),
    positionAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    innerRadiusRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    crossLines: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])({
        ...commonCrossLineOptionsDefs,
        label: {
            ...commonCrossLineLabelOptionsDefs,
            positionAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
        }
    }, "cross-line options"),
    title: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
    },
    label: {
        ...commonAxisLabelOptionsDefs,
        format: numberFormatValidator
    }
};
var radiusCategoryAxisOptionsDefs = {
    ...commonAxisOptionsDefs,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("radius-category")),
    positionAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    innerRadiusRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    paddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    paddingOuter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    groupPaddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    label: commonAxisLabelOptionsDefs,
    crossLines: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])({
        ...commonCrossLineOptionsDefs,
        label: {
            ...commonCrossLineLabelOptionsDefs,
            positionAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
        }
    }, "cross-line options"),
    title: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
    }
};
;
var highlight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"]);
var areaSeriesThemeableOptionsDef = {
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    connectMissingData: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    interpolation: interpolationOptionsDefs,
    label: seriesLabelOptionsDefs,
    marker: markerOptionsDefs,
    tooltip: tooltipOptionsDefs,
    shadow: shadowOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    highlight
};
var areaSeriesOptionsDef = {
    ...areaSeriesThemeableOptionsDef,
    ...commonSeriesOptionsDefs,
    highlight,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("area")),
    xKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    yKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    xName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    yName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    stacked: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    stackGroup: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    normalizedTo: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
};
;
var highlight2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["barHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["barHighlightOptionsDef"]);
var barSeriesThemeableOptionsDef = {
    direction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("horizontal", "vertical"),
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    }),
    crisp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    label: {
        ...seriesLabelOptionsDefs,
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("inside-center", "inside-start", "inside-end", "outside-start", "outside-end"),
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    },
    errorBar: errorBarThemeableOptionsDefs,
    shadow: shadowOptionsDefs,
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    highlight: highlight2,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
barSeriesThemeableOptionsDef.sparklineMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]);
var barSeriesOptionsDef = {
    ...barSeriesThemeableOptionsDef,
    ...commonSeriesOptionsDefs,
    highlight: highlight2,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("bar")),
    xKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    yKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    xName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    yName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    direction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("horizontal", "vertical"),
    grouped: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    stacked: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    stackGroup: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    normalizedTo: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    legendItemName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    errorBar: errorBarOptionsDefs
};
barSeriesOptionsDef.pickOutsideVisibleMinorAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]);
barSeriesOptionsDef.focusPriority = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]);
;
var bubbleSeriesThemeableOptionsDef = {
    title: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    domain: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
    maxSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    label: {
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("top", "right", "bottom", "left"),
        ...seriesLabelOptionsDefs
    },
    tooltip: tooltipOptionsDefs,
    maxRenderedItems: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    ...commonSeriesThemeableOptionsDefs,
    ...without(markerOptionsDefs, [
        "enabled"
    ]),
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"])
};
var bubbleSeriesOptionsDef = {
    ...bubbleSeriesThemeableOptionsDef,
    ...commonSeriesOptionsDefs,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("bubble")),
    xKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    yKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    sizeKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    labelKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    xName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    yName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    sizeName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    labelName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"])
};
;
var histogramSeriesThemeableOptionsDef = {
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    label: seriesLabelOptionsDefs,
    tooltip: tooltipOptionsDefs,
    shadow: shadowOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"])
};
var histogramSeriesOptionsDef = {
    ...commonSeriesOptionsDefs,
    ...histogramSeriesThemeableOptionsDef,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("histogram")),
    xKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    yKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    xName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    yName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    areaPlot: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    aggregation: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("count", "sum", "mean"),
    bins: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"])),
    binCount: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
};
;
var highlight3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineHighlightOptionsDef"]);
var lineSeriesThemeableOptionsDef = {
    title: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    connectMissingData: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    interpolation: interpolationOptionsDefs,
    label: seriesLabelOptionsDefs,
    marker: markerOptionsDefs,
    tooltip: tooltipOptionsDefs,
    errorBar: errorBarThemeableOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    highlight: highlight3
};
lineSeriesThemeableOptionsDef.sparklineMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]);
var lineSeriesOptionsDef = {
    ...lineSeriesThemeableOptionsDef,
    ...commonSeriesOptionsDefs,
    highlight: highlight3,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("line")),
    xKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    yKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    xName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    yName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    stacked: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    stackGroup: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    normalizedTo: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    legendItemName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    errorBar: errorBarOptionsDefs
};
lineSeriesOptionsDef.pickOutsideVisibleMinorAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]);
lineSeriesOptionsDef.focusPriority = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]);
;
var scatterSeriesThemeableOptionsDef = {
    title: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    label: {
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("top", "right", "bottom", "left"),
        ...seriesLabelOptionsDefs
    },
    tooltip: tooltipOptionsDefs,
    errorBar: errorBarThemeableOptionsDefs,
    maxRenderedItems: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    ...commonSeriesThemeableOptionsDefs,
    ...without(markerOptionsDefs, [
        "enabled"
    ]),
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"])
};
var scatterSeriesOptionsDef = {
    ...scatterSeriesThemeableOptionsDef,
    ...commonSeriesOptionsDefs,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("scatter")),
    xKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    yKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    labelKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    xName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    yName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    labelName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    errorBar: errorBarOptionsDefs,
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"])
};
;
;
var highlight4 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"]);
var pieSeriesThemeableOptionsDef = {
    ...commonSeriesThemeableOptionsDefs,
    radiusMin: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    radiusMax: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    rotation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    outerRadiusOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    outerRadiusRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    hideZeroValueSectorsInLegend: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    sectorSpacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    }),
    title: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        showInLegend: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
    },
    calloutLabel: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        offset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        minAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        avoidCollisions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
        format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
            enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelBoxOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
        }),
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelBoxOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
    },
    sectorLabel: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        positionOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        positionRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
        formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
        format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
            enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelBoxOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
        }),
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelBoxOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
    },
    calloutLine: {
        colors: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
        length: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        strokeWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    },
    fills: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorUnion"]),
    strokes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    tooltip: tooltipOptionsDefs,
    shadow: shadowOptionsDefs,
    highlight: highlight4,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    ...without(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"], [
        "fill"
    ]),
    ...without(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"], [
        "stroke"
    ])
};
var pieSeriesOptionsDef = {
    ...pieSeriesThemeableOptionsDef,
    ...commonSeriesOptionsDefs,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("pie")),
    angleKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
    radiusKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    calloutLabelKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    sectorLabelKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    legendItemKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    angleName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    radiusName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    calloutLabelName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    sectorLabelName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    highlight: highlight4
};
pieSeriesOptionsDef.defaultColorRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"])));
pieSeriesOptionsDef.defaultPatternFills = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]));
pieSeriesOptionsDef.title._enabledFromTheme = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]);
pieSeriesOptionsDef.calloutLabel._enabledFromTheme = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]);
pieSeriesOptionsDef.sectorLabel._enabledFromTheme = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]);
// packages/ag-charts-community/src/chart/series/polar/donutSeriesOptionsDef.ts
var donutSeriesThemeableOptionsDef = {
    ...pieSeriesThemeableOptionsDef,
    innerRadiusOffset: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    innerRadiusRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    innerCircle: {
        fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        fillOpacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
    },
    innerLabels: {
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelBoxOptionsDef"]
    }
};
var donutSeriesOptionsDef = {
    ...donutSeriesThemeableOptionsDef,
    ...pieSeriesOptionsDef,
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("donut")),
    innerLabels: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])({
        text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]),
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["labelBoxOptionsDef"]
    }, "inner label options array")
};
;
var annotationLineOptionsDef = {
    lineStyle: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("solid", "dashed", "dotted"),
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var annotationHandleStylesDefs = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var annotationTextStylesDef = {
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    locked: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    handle: annotationHandleStylesDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
};
var annotationLineTextDefs = {
    position: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("top", "center", "bottom"),
    alignment: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("left", "center", "right"),
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
};
var annotationChannelTextDefs = {
    position: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("top", "inside", "bottom"),
    alignment: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("left", "center", "right"),
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
};
var annotationAxisLabelOptionsDef = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var annotationChannelMiddleDefs = {
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    ...annotationLineOptionsDef,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
};
var annotationMeasurerStatisticsOptionsDefs = {
    divider: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
};
var annotationQuickMeasurerDirectionStylesDefs = {
    handle: annotationHandleStylesDefs,
    statistics: annotationMeasurerStatisticsOptionsDefs,
    ...annotationLineOptionsDef,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
};
var annotationLineStyleDefs = {
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    locked: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    extendStart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    extendEnd: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    handle: annotationHandleStylesDefs,
    text: annotationLineTextDefs,
    ...annotationLineOptionsDef,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
};
var annotationCrossLineStyleDefs = {
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    locked: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    axisLabel: annotationAxisLabelOptionsDef,
    handle: annotationHandleStylesDefs,
    text: annotationLineTextDefs,
    ...annotationLineOptionsDef,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
};
var annotationChannelStyleDefs = {
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    locked: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    extendStart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    extendEnd: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    handle: annotationHandleStylesDefs,
    text: annotationChannelTextDefs,
    background: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...annotationLineOptionsDef,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
};
var annotationDisjointChannelStyleDefs = {
    ...annotationChannelStyleDefs
};
var annotationParallelChannelStyleDefs = {
    ...annotationChannelStyleDefs,
    middle: annotationChannelMiddleDefs
};
var annotationFibonacciStylesDefs = {
    label: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"],
    showFill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    isMultiColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    strokes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    rangeStroke: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
    bands: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])(4, 6, 10),
    ...annotationLineStyleDefs
};
var annotationCalloutStylesDefs = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...annotationTextStylesDef
};
var annotationCommentStylesDefs = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...annotationTextStylesDef
};
var annotationNoteStylesDefs = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...annotationTextStylesDef,
    background: {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
    }
};
var annotationShapeStylesDefs = {
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    locked: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    handle: annotationHandleStylesDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"]
};
var annotationMeasurerStylesDefs = {
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    locked: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    extendStart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    extendEnd: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    handle: annotationHandleStylesDefs,
    text: annotationLineTextDefs,
    background: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    statistics: annotationMeasurerStatisticsOptionsDefs,
    ...annotationLineOptionsDef,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
};
var annotationQuickMeasurerStylesDefs = {
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    up: annotationQuickMeasurerDirectionStylesDefs,
    down: annotationQuickMeasurerDirectionStylesDefs
};
var annotationOptionsDef = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    axesButtons: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        axes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("x", "y", "xy")
    },
    toolbar: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        buttons: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])({
            ...toolbarButtonOptionsDefs,
            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("line-menu", "fibonacci-menu", "text-menu", "shape-menu", "measurer-menu", "line", "horizontal-line", "vertical-line", "parallel-channel", "disjoint-channel", "fibonacci-retracement", "fibonacci-retracement-trend-based", "text", "comment", "callout", "note", "clear")
        }, "annotation toolbar buttons array")
    },
    optionsToolbar: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        buttons: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsDefs"])({
            ...toolbarButtonOptionsDefs,
            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("line-stroke-width", "line-style-type", "line-color", "fill-color", "text-color", "text-size", "delete", "settings"))
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsDefs"])({
            ...toolbarButtonOptionsDefs,
            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("lock")),
            checkedOverrides: toolbarButtonOptionsDefs
        })))
    }
};
annotationOptionsDef.data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["array"]);
annotationOptionsDef.xKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]);
annotationOptionsDef.volumeKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]);
annotationOptionsDef.snap = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]);
;
var boxPlotStyleOptionsDef = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    whisker: {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    cap: {
        lengthRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
    }
};
var boxPlotHighlightStyleOptionsDef = {
    ...boxPlotStyleOptionsDef,
    opacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
};
var boxPlotSeriesThemeableOptionsDef = {
    direction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("horizontal", "vertical"),
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        whisker: {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
        },
        cap: {
            lengthRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
        }
    }),
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...boxPlotStyleOptionsDef,
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(boxPlotHighlightStyleOptionsDef, boxPlotHighlightStyleOptionsDef)
};
var candlestickSeriesItemOptionsDef = {
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    wick: {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var candlestickHighlightStyleOptionsDef = {
    ...candlestickSeriesItemOptionsDef,
    opacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
};
var candlestickSeriesThemeableOptionsDef = {
    item: {
        up: candlestickSeriesItemOptionsDef,
        down: candlestickSeriesItemOptionsDef
    },
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        wick: {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
        }
    }),
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(candlestickHighlightStyleOptionsDef, candlestickHighlightStyleOptionsDef)
};
var chordSeriesThemeableOptionsDef = {
    fills: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorUnion"]),
    strokes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    label: {
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        maxWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        ...seriesLabelOptionsDefs
    },
    link: {
        tension: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
        itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
            tension: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
        }),
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    node: {
        width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
        }),
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs
};
var coneFunnelSeriesThemeableOptionsDef = {
    direction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("horizontal", "vertical"),
    fills: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorUnion"]),
    strokes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    label: {
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("before", "middle", "after"),
        ...seriesLabelOptionsDefs
    },
    stageLabel: {
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("before", "after"),
        format: numberFormatValidator,
        ...commonAxisLabelOptionsDefs
    },
    tooltip: tooltipOptionsDefs,
    ...without(commonSeriesThemeableOptionsDefs, [
        "showInLegend"
    ]),
    ...without(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"], [
        "fill"
    ]),
    ...without(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"], [
        "stroke"
    ]),
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["highlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineHighlightOptionsDef"])
};
var funnelSeriesThemeableOptionsDef = {
    direction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("horizontal", "vertical"),
    fills: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorUnion"]),
    strokes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    }),
    spacingRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    crisp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    dropOff: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    stageLabel: {
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("before", "after"),
        format: numberFormatValidator,
        ...commonAxisLabelOptionsDefs
    },
    label: seriesLabelOptionsDefs,
    tooltip: tooltipOptionsDefs,
    shadow: shadowOptionsDefs,
    ...without(commonSeriesThemeableOptionsDefs, [
        "showInLegend"
    ]),
    ...without(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"], [
        "fill"
    ]),
    ...without(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"], [
        "stroke"
    ]),
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var heatmapSeriesThemeableOptionsDef = {
    title: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    textAlign: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("left", "center", "right"),
    verticalAlign: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("top", "middle", "bottom"),
    itemPadding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
    }),
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    label: autoSizedLabelOptionsDefs,
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
};
var ohlcSeriesThemeableOptionsDef = {
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    }),
    item: {
        up: {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
        },
        down: {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
        }
    },
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineHighlightOptionsDef"])
};
var mapLineSeriesThemeableOptionsDef = {
    maxStrokeWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    }),
    sizeDomain: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]),
    label: seriesLabelOptionsDefs,
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    highlightStyle: {
        // eslint-disable-next-line sonarjs/deprecation
        ...commonSeriesThemeableOptionsDefs.highlightStyle,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
    },
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineHighlightOptionsDef"])
};
var mapLineBackgroundSeriesThemeableOptionsDef = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var mapMarkerSeriesThemeableOptionsDef = {
    colorRange: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    maxSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    sizeDomain: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]),
    label: {
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("top", "bottom", "left", "right"),
        ...seriesLabelOptionsDefs
    },
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...without(markerOptionsDefs, [
        "enabled"
    ]),
    // TODO Remove in next major version
    highlightStyle: {
        // eslint-disable-next-line sonarjs/deprecation
        ...commonSeriesThemeableOptionsDefs.highlightStyle,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
    },
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"])
};
var mapShapeSeriesThemeableOptionsDef = {
    colorRange: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    }),
    label: autoSizedLabelOptionsDefs,
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    // TODO Remove in next major version
    highlightStyle: {
        // eslint-disable-next-line sonarjs/deprecation
        ...commonSeriesThemeableOptionsDefs.highlightStyle,
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
    },
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"])
};
var mapShapeBackgroundSeriesThemeableOptionsDef = {
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var nightingaleSeriesThemeableOptionsDef = {
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    }),
    label: seriesLabelOptionsDefs,
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["barHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["barHighlightOptionsDef"])
};
var pyramidSeriesThemeableOptionsDef = {
    direction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("horizontal", "vertical"),
    aspectRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    reverse: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    }),
    fills: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorUnion"]),
    strokes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    label: seriesLabelOptionsDefs,
    stageLabel: {
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("before", "after"),
        ...seriesLabelOptionsDefs
    },
    tooltip: tooltipOptionsDefs,
    shadow: shadowOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...without(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"], [
        "fill"
    ]),
    ...without(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"], [
        "stroke"
    ]),
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var radarAreaSeriesThemeableOptionsDef = {
    connectMissingData: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    marker: markerOptionsDefs,
    label: seriesLabelOptionsDefs,
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"])
};
var radarLineSeriesThemeableOptionsDef = {
    connectMissingData: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    marker: markerOptionsDefs,
    label: seriesLabelOptionsDefs,
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineHighlightOptionsDef"])
};
var radialBarSeriesThemeableOptionsDef = {
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    }),
    label: seriesLabelOptionsDefs,
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["barHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["barHighlightOptionsDef"])
};
var radialColumnSeriesThemeableOptionsDef = {
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    columnWidthRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    maxColumnWidthRatio: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    }),
    label: seriesLabelOptionsDefs,
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["barHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["barHighlightOptionsDef"])
};
var rangeAreaSeriesThemeableOptionsDef = {
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    connectMissingData: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    interpolation: interpolationOptionsDefs,
    label: {
        ...seriesLabelOptionsDefs,
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("inside", "outside"),
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    },
    marker: markerOptionsDefs,
    tooltip: tooltipOptionsDefs,
    shadow: shadowOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shapeHighlightOptionsDef"])
};
var rangeBarSeriesThemeableOptionsDef = {
    direction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("horizontal", "vertical"),
    grouped: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    }),
    label: {
        ...seriesLabelOptionsDefs,
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("inside", "outside"),
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    },
    tooltip: tooltipOptionsDefs,
    shadow: shadowOptionsDefs,
    ...commonSeriesThemeableOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
    highlight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["multiSeriesHighlightOptionsDef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["barHighlightOptionsDef"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["barHighlightOptionsDef"])
};
var sankeySeriesThemeableOptionsDef = {
    fills: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorUnion"]),
    strokes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    label: {
        ...seriesLabelOptionsDefs,
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    },
    link: {
        itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
        }),
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    node: {
        width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        alignment: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("left", "center", "right", "justify"),
        itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
        }),
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs
};
var sunburstSeriesThemeableOptionsDef = {
    fills: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorUnion"]),
    strokes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    colorRange: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    sectorSpacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
    }),
    label: {
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        ...autoSizedLabelOptionsDefs
    },
    secondaryLabel: autoSizedLabelOptionsDefs,
    tooltip: tooltipOptionsDefs,
    ...without(commonSeriesThemeableOptionsDefs, [
        "highlight",
        "showInLegend"
    ]),
    ...without(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"], [
        "fill"
    ]),
    ...without(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"], [
        "stroke"
    ]),
    // TODO Remove in next major version
    highlightStyle: {
        label: {
            color: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]
        },
        secondaryLabel: {
            color: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]
        },
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
    }
};
var treemapSeriesThemeableOptionsDef = {
    fills: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorUnion"]),
    strokes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    colorRange: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
    }),
    group: {
        gap: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        textAlign: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("left", "center", "right"),
        interactive: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        label: {
            ...seriesLabelOptionsDefs,
            spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
        },
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
    },
    tile: {
        gap: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
        textAlign: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("left", "center", "right"),
        verticalAlign: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("top", "middle", "bottom"),
        label: {
            ...seriesLabelOptionsDefs,
            spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            lineHeight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            minimumFontSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            wrapping: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("never", "always", "hyphenate", "on-space"),
            overflowStrategy: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("ellipsis", "hide")
        },
        secondaryLabel: {
            ...seriesLabelOptionsDefs,
            lineHeight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            minimumFontSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            wrapping: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("never", "always", "hyphenate", "on-space"),
            overflowStrategy: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("ellipsis", "hide")
        },
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
    },
    tooltip: tooltipOptionsDefs,
    ...without(commonSeriesThemeableOptionsDefs, [
        "highlight",
        "showInLegend"
    ]),
    // TODO Remove in next major version
    highlightStyle: {
        group: {
            label: {
                color: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]
            },
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
        },
        tile: {
            label: {
                color: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]
            },
            secondaryLabel: {
                color: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]
            },
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"]
        }
    }
};
var waterfallSeriesItemOptionsDef = {
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    itemStyler: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callbackDefs"])({
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"],
        cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    }),
    label: {
        ...seriesLabelOptionsDefs,
        placement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("inside-start", "inside-center", "inside-end", "outside-start", "outside-end"),
        spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    },
    tooltip: tooltipOptionsDefs,
    shadow: shadowOptionsDefs,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fillOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
};
var waterfallSeriesThemeableOptionsDef = {
    direction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("horizontal", "vertical"),
    showInMiniChart: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    item: {
        positive: waterfallSeriesItemOptionsDef,
        negative: waterfallSeriesItemOptionsDef,
        total: waterfallSeriesItemOptionsDef
    },
    line: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    tooltip: tooltipOptionsDefs,
    ...commonSeriesThemeableOptionsDefs
};
// packages/ag-charts-community/src/chart/themes/themeOptionsDef.ts
var serializableDate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsDefs"])({
    __type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("date")),
    value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"])
}, "a serializable date object");
var navigatorHandleOptionsDef = {
    width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    height: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    grip: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
    stroke: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
    strokeWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
};
var navigatorOptionsDef = {
    enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    height: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
    cornerRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
    mask: {
        fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        fillOpacity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
        stroke: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        strokeWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
    },
    minHandle: navigatorHandleOptionsDef,
    maxHandle: navigatorHandleOptionsDef,
    miniChart: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        padding: {
            top: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            bottom: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
        },
        label: {
            enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            avoidCollisions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            spacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
            format: numberFormatValidator,
            formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callback"],
            interval: {
                minSpacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
                maxSpacing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"],
                values: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["array"],
                step: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
            },
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontOptionsDef"]
        },
        series: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]
    }
};
var cartesianAxesThemeDef = {
    number: {
        ...without(numberAxisOptionsDefs, [
            "type",
            "crossLines"
        ]),
        top: without(numberAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        right: without(numberAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        bottom: without(numberAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        left: without(numberAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        crossLines: without(cartesianCrossLineOptionsDefs, [
            "type"
        ])
    },
    log: {
        ...without(logAxisOptionsDefs, [
            "type",
            "crossLines"
        ]),
        top: without(logAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        right: without(logAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        bottom: without(logAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        left: without(logAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        crossLines: without(cartesianCrossLineOptionsDefs, [
            "type"
        ])
    },
    category: {
        ...without(categoryAxisOptionsDefs, [
            "type",
            "crossLines"
        ]),
        top: without(categoryAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        right: without(categoryAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        bottom: without(categoryAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        left: without(categoryAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        crossLines: without(cartesianCrossLineOptionsDefs, [
            "type"
        ])
    },
    time: {
        ...without(timeAxisOptionsDefs, [
            "type",
            "crossLines"
        ]),
        top: without(timeAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        right: without(timeAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        bottom: without(timeAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        left: without(timeAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        crossLines: without(cartesianCrossLineOptionsDefs, [
            "type"
        ])
    },
    "unit-time": {
        ...without(unitTimeAxisOptionsDefs, [
            "type",
            "crossLines"
        ]),
        top: without(unitTimeAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        right: without(unitTimeAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        bottom: without(unitTimeAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        left: without(unitTimeAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        crossLines: without(cartesianCrossLineOptionsDefs, [
            "type"
        ])
    },
    "grouped-category": {
        ...without(groupedCategoryAxisOptionsDefs, [
            "type"
        ]),
        top: without(groupedCategoryAxisOptionsDefs, [
            "type",
            "position"
        ]),
        right: without(groupedCategoryAxisOptionsDefs, [
            "type",
            "position"
        ]),
        bottom: without(groupedCategoryAxisOptionsDefs, [
            "type",
            "position"
        ]),
        left: without(groupedCategoryAxisOptionsDefs, [
            "type",
            "position"
        ]),
        crossLines: without(cartesianCrossLineOptionsDefs, [
            "type"
        ])
    },
    "ordinal-time": {
        ...without(ordinalTimeAxisOptionsDefs, [
            "type",
            "crossLines"
        ]),
        top: without(ordinalTimeAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        right: without(ordinalTimeAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        bottom: without(ordinalTimeAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        left: without(ordinalTimeAxisOptionsDefs, [
            "type",
            "crossLines",
            "position"
        ]),
        crossLines: without(cartesianCrossLineOptionsDefs, [
            "type"
        ])
    }
};
var polarAxesThemeDef = {
    "angle-category": {
        ...without(angleCategoryAxisOptionsDefs, [
            "type",
            "crossLines"
        ]),
        crossLines: without(commonCrossLineOptionsDefs, [
            "type"
        ])
    },
    "angle-number": {
        ...without(angleNumberAxisOptionsDefs, [
            "type",
            "crossLines"
        ]),
        crossLines: without(commonCrossLineOptionsDefs, [
            "type"
        ])
    },
    "radius-category": {
        ...without(radiusCategoryAxisOptionsDefs, [
            "type",
            "crossLines"
        ]),
        crossLines: {
            ...without(commonCrossLineOptionsDefs, [
                "type"
            ]),
            label: {
                ...commonCrossLineLabelOptionsDefs,
                positionAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
            }
        }
    },
    "radius-number": {
        ...without(radiusNumberAxisOptionsDefs, [
            "type",
            "crossLines"
        ]),
        crossLines: {
            ...without(commonCrossLineOptionsDefs, [
                "type"
            ]),
            label: {
                ...commonCrossLineLabelOptionsDefs,
                positionAngle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]
            }
        }
    }
};
var undocumentedSeriesOptionsDef = {
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]
};
var themeOverridesOptionsDef = {
    common: {
        ...commonChartOptionsDefs,
        navigator: navigatorOptionsDef,
        axes: {
            ...cartesianAxesThemeDef,
            ...polarAxesThemeDef
        },
        annotations: {
            ...annotationOptionsDef,
            line: annotationLineStyleDefs,
            "horizontal-line": annotationCrossLineStyleDefs,
            "vertical-line": annotationCrossLineStyleDefs,
            "disjoint-channel": annotationDisjointChannelStyleDefs,
            "parallel-channel": annotationParallelChannelStyleDefs,
            "fibonacci-retracement": annotationFibonacciStylesDefs,
            "fibonacci-retracement-trend-based": annotationFibonacciStylesDefs,
            callout: annotationCalloutStylesDefs,
            comment: annotationCommentStylesDefs,
            note: annotationNoteStylesDefs,
            text: annotationTextStylesDef,
            arrow: annotationLineStyleDefs,
            "arrow-up": annotationShapeStylesDefs,
            "arrow-down": annotationShapeStylesDefs,
            "date-range": annotationMeasurerStylesDefs,
            "price-range": annotationMeasurerStylesDefs,
            "date-price-range": annotationMeasurerStylesDefs,
            "quick-date-price-range": annotationQuickMeasurerStylesDefs
        },
        chartToolbar: {
            enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"]
        },
        initialState: {
            legend: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])({
                visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
                seriesId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
                itemId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
                legendItemName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]
            }, "legend state array"),
            zoom: {
                rangeX: {
                    start: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], serializableDate),
                    end: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], serializableDate)
                },
                rangeY: {
                    start: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], serializableDate),
                    end: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], serializableDate)
                },
                ratioX: {
                    start: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
                    end: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
                },
                ratioY: {
                    start: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
                    end: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
                },
                autoScaledAxes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["constant"])("y"))
            }
        }
    },
    line: {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: lineSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    scatter: {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: scatterSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    bubble: {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: bubbleSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    area: {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: areaSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    bar: {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: barSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "box-plot": {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: boxPlotSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    candlestick: {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: candlestickSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "cone-funnel": {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: coneFunnelSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    funnel: {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: funnelSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    ohlc: {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: ohlcSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    histogram: {
        ...commonChartOptionsDefs,
        axes: without(cartesianAxesThemeDef, [
            "category",
            "grouped-category",
            "unit-time",
            "ordinal-time"
        ]),
        series: histogramSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    heatmap: {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: heatmapSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    waterfall: {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: waterfallSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "range-bar": {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: rangeBarSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "range-area": {
        ...commonChartOptionsDefs,
        axes: cartesianAxesThemeDef,
        series: rangeAreaSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    donut: {
        ...commonChartOptionsDefs,
        series: donutSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    pie: {
        ...commonChartOptionsDefs,
        series: pieSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "radar-line": {
        ...commonChartOptionsDefs,
        axes: polarAxesThemeDef,
        series: radarLineSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "radar-area": {
        ...commonChartOptionsDefs,
        axes: polarAxesThemeDef,
        series: radarAreaSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "radial-bar": {
        ...commonChartOptionsDefs,
        axes: polarAxesThemeDef,
        series: radialBarSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "radial-column": {
        ...commonChartOptionsDefs,
        axes: polarAxesThemeDef,
        series: radialColumnSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    nightingale: {
        ...commonChartOptionsDefs,
        axes: polarAxesThemeDef,
        series: nightingaleSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    sunburst: {
        ...commonChartOptionsDefs,
        series: sunburstSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    treemap: {
        ...commonChartOptionsDefs,
        series: treemapSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "map-shape": {
        ...commonChartOptionsDefs,
        series: mapShapeSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "map-line": {
        ...commonChartOptionsDefs,
        series: mapLineSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "map-marker": {
        ...commonChartOptionsDefs,
        series: mapMarkerSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "map-shape-background": {
        ...commonChartOptionsDefs,
        series: mapShapeBackgroundSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "map-line-background": {
        ...commonChartOptionsDefs,
        series: mapLineBackgroundSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    sankey: {
        ...commonChartOptionsDefs,
        series: sankeySeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    chord: {
        ...commonChartOptionsDefs,
        series: chordSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    pyramid: {
        ...commonChartOptionsDefs,
        series: pyramidSeriesThemeableOptionsDef,
        navigator: navigatorOptionsDef,
        ...undocumentedSeriesOptionsDef
    },
    "radial-gauge": {
        ...commonChartOptionsDefs,
        ...radialGaugeSeriesThemeableOptionsDef,
        targets: without(radialGaugeTargetOptionsDef, [
            "value"
        ]),
        tooltip: {
            ...radialGaugeSeriesThemeableOptionsDef.tooltip,
            ...commonChartOptionsDefs.tooltip
        }
    },
    "linear-gauge": {
        ...commonChartOptionsDefs,
        ...linearGaugeSeriesThemeableOptionsDef,
        targets: without(linearGaugeTargetOptionsDef, [
            "value"
        ]),
        tooltip: {
            ...linearGaugeSeriesThemeableOptionsDef.tooltip,
            ...commonChartOptionsDefs.tooltip
        }
    }
};
function mapValues2(object4, mapper) {
    const result = {};
    for (const key of Reflect.ownKeys(object4)){
        result[key] = mapper(object4[key], key, object4);
    }
    return result;
}
var themeOverridesOptionsWithOperatorsDef = mapValues2(themeOverridesOptionsDef, function themeOperatorMapper(value, key) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSymbol"])(key)) return value;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(value)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(value, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["themeOperator"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSymbol"]);
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(value)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optionsDefs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unionSymbol"] in value ? mapValues2(value, (val)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(val) ? mapValues2(val, themeOperatorMapper) : val) : mapValues2(value, themeOperatorMapper)), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["themeOperator"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSymbol"]);
    }
    throw new Error("Invalid theme override value: ".concat(String(value)));
});
// packages/ag-charts-community/src/chart/themes/vividDark.ts
var VIVID_DARK_FILLS = {
    BLUE: "#0083ff",
    ORANGE: "#ff6600",
    GREEN: "#00af00",
    CYAN: "#00ccff",
    YELLOW: "#f7c700",
    VIOLET: "#ac26ff",
    GRAY: "#a7a7b7",
    MAGENTA: "#e800c5",
    BROWN: "#b54300",
    RED: "#ff0000"
};
var VIVID_DARK_STROKES = {
    BLUE: "#67b7ff",
    ORANGE: "#ffc24d",
    GREEN: "#5cc86f",
    CYAN: "#54ebff",
    VIOLET: "#fff653",
    YELLOW: "#c18aff",
    GRAY: "#aeaeae",
    MAGENTA: "#f078d4",
    BROWN: "#ba8438",
    RED: "#ff726e"
};
var VividDark = class extends DarkTheme {
    getDefaultColors() {
        return {
            fills: VIVID_DARK_FILLS,
            fillsFallback: Object.values(VIVID_DARK_FILLS),
            strokes: VIVID_DARK_STROKES,
            sequentialColors: getSequentialColors(VIVID_DARK_FILLS),
            divergingColors: [
                VIVID_DARK_FILLS.ORANGE,
                VIVID_DARK_FILLS.YELLOW,
                VIVID_DARK_FILLS.GREEN
            ],
            hierarchyColors: [],
            secondSequentialColors: [
                "#0083ff",
                "#0076e6",
                "#0069cc",
                "#005cb3",
                "#004f99",
                "#004280",
                "#003466",
                "#00274c"
            ],
            secondDivergingColors: [
                VIVID_DARK_FILLS.GREEN,
                VIVID_DARK_FILLS.YELLOW,
                VIVID_DARK_FILLS.RED
            ],
            secondHierarchyColors: [],
            up: {
                fill: VIVID_DARK_FILLS.GREEN,
                stroke: VIVID_DARK_STROKES.GREEN
            },
            down: {
                fill: VIVID_DARK_FILLS.RED,
                stroke: VIVID_DARK_STROKES.RED
            },
            neutral: {
                fill: VIVID_DARK_FILLS.GRAY,
                stroke: VIVID_DARK_STROKES.GRAY
            },
            altUp: {
                fill: VIVID_DARK_FILLS.BLUE,
                stroke: VIVID_DARK_STROKES.BLUE
            },
            altDown: {
                fill: VIVID_DARK_FILLS.ORANGE,
                stroke: VIVID_DARK_STROKES.ORANGE
            },
            altNeutral: {
                fill: VIVID_DARK_FILLS.GRAY,
                stroke: VIVID_DARK_STROKES.GRAY
            }
        };
    }
    getTemplateParameters() {
        const params = super.getTemplateParameters();
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, VIVID_DARK_FILLS.BLUE);
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, VIVID_DARK_FILLS.BLUE);
        return params;
    }
};
// packages/ag-charts-community/src/chart/themes/vividLight.ts
var VIVID_FILLS = {
    BLUE: "#0083ff",
    ORANGE: "#ff6600",
    GREEN: "#00af00",
    CYAN: "#00ccff",
    YELLOW: "#f7c700",
    VIOLET: "#ac26ff",
    GRAY: "#a7a7b7",
    MAGENTA: "#e800c5",
    BROWN: "#b54300",
    RED: "#ff0000"
};
var VIVID_STROKES = {
    BLUE: "#0f68c0",
    ORANGE: "#d47100",
    GREEN: "#007922",
    CYAN: "#009ac2",
    VIOLET: "#bca400",
    YELLOW: "#753cac",
    GRAY: "#646464",
    MAGENTA: "#9b2685",
    BROWN: "#6c3b00",
    RED: "#cb0021"
};
var VividLight = class extends ChartTheme {
    getDefaultColors() {
        return {
            ...super.getDefaultColors(),
            fills: VIVID_FILLS,
            fillsFallback: Object.values(VIVID_FILLS),
            strokes: VIVID_STROKES,
            sequentialColors: getSequentialColors(VIVID_FILLS),
            divergingColors: [
                VIVID_FILLS.ORANGE,
                VIVID_FILLS.YELLOW,
                VIVID_FILLS.GREEN
            ],
            hierarchyColors: [],
            secondSequentialColors: [
                "#0083ff",
                "#1a8fff",
                "#339cff",
                "#4da8ff",
                "#66b5ff",
                "#80c1ff",
                "#99cdff",
                "#b3daff"
            ],
            secondDivergingColors: [
                VIVID_FILLS.GREEN,
                VIVID_FILLS.YELLOW,
                VIVID_FILLS.RED
            ],
            secondHierarchyColors: [],
            up: {
                fill: VIVID_FILLS.GREEN,
                stroke: VIVID_STROKES.GREEN
            },
            down: {
                fill: VIVID_FILLS.RED,
                stroke: VIVID_STROKES.RED
            },
            neutral: {
                fill: VIVID_FILLS.GRAY,
                stroke: VIVID_STROKES.GRAY
            },
            altUp: {
                fill: VIVID_FILLS.BLUE,
                stroke: VIVID_STROKES.BLUE
            },
            altDown: {
                fill: VIVID_FILLS.ORANGE,
                stroke: VIVID_STROKES.ORANGE
            },
            altNeutral: {
                fill: VIVID_FILLS.GRAY,
                stroke: VIVID_STROKES.GRAY
            }
        };
    }
    getTemplateParameters() {
        const params = super.getTemplateParameters();
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR, VIVID_FILLS.BLUE);
        params.set(DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL, VIVID_FILLS.BLUE);
        return params;
    }
};
// packages/ag-charts-community/src/chart/mapping/themes.ts
var lightTheme = simpleMemorize(()=>new ChartTheme());
var themeCacheDebug = Debug.create(true, "perf");
var cacheCallback = (status, fn, keys)=>{
    themeCacheDebug("[CACHE] ChartTheme", status, fn.name, keys);
};
var themes = {
    // darkThemes,
    "ag-default-dark": simpleMemorize(()=>new DarkTheme()),
    "ag-sheets-dark": simpleMemorize(()=>new SheetsDark(), cacheCallback),
    "ag-polychroma-dark": simpleMemorize(()=>new PolychromaDark(), cacheCallback),
    "ag-vivid-dark": simpleMemorize(()=>new VividDark(), cacheCallback),
    "ag-material-dark": simpleMemorize(()=>new MaterialDark(), cacheCallback),
    "ag-financial-dark": simpleMemorize(()=>new FinancialDark(), cacheCallback),
    // lightThemes,
    "ag-default": lightTheme,
    "ag-sheets": simpleMemorize(()=>new SheetsLight(), cacheCallback),
    "ag-polychroma": simpleMemorize(()=>new PolychromaLight(), cacheCallback),
    "ag-vivid": simpleMemorize(()=>new VividLight(), cacheCallback),
    "ag-material": simpleMemorize(()=>new MaterialLight(), cacheCallback),
    "ag-financial": simpleMemorize(()=>new FinancialLight(), cacheCallback)
};
var getChartTheme = simpleMemorize(createChartTheme, cacheCallback);
function createChartTheme(value) {
    if (value instanceof ChartTheme) {
        return value;
    } else if (!validateStructure(value)) {
        return lightTheme();
    }
    if (value == null || typeof value === "string") {
        const stockTheme = themes[value !== null && value !== void 0 ? value : "ag-default"];
        if (stockTheme) {
            return stockTheme();
        }
        throw new Error("Cannot find theme `".concat(value, "`."));
    }
    const { cleared, invalid } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"])(reduceThemeOptions(value), themeOptionsDef, "theme");
    for (const error of invalid){
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce(String(error));
    }
    const baseTheme = (cleared === null || cleared === void 0 ? void 0 : cleared.baseTheme) ? getChartTheme(cleared.baseTheme) : lightTheme();
    return cleared ? new baseTheme.constructor(cleared) : baseTheme;
}
function reduceThemeOptions(options) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(options.baseTheme)) return options;
    let maybeNested = options;
    let palette;
    let params;
    const overrides = [];
    while(typeof maybeNested === "object"){
        palette !== null && palette !== void 0 ? palette : palette = maybeNested.palette;
        params !== null && params !== void 0 ? params : params = maybeNested.params;
        if (maybeNested.overrides) {
            overrides.push(maybeNested.overrides);
        }
        maybeNested = maybeNested.baseTheme;
    }
    return {
        baseTheme: maybeNested,
        overrides: mergeDefaults(...overrides),
        params,
        palette
    };
}
var themeOptionsDef = {
    baseTheme: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["object"]),
    overrides: themeOverridesOptionsWithOperatorsDef,
    params: {
        accentColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        axisColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        backgroundColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        borderColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        borderRadius: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        chartBackgroundColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        chartPadding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        focusShadow: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        foregroundColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        fontFamily: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontFamilyFull"],
        fontSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        fontWeight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
        gridLineColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        popupShadow: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        subtleTextColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        textColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        chromeBackgroundColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        chromeFontFamily: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fontFamilyFull"],
        chromeFontSize: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        chromeFontWeight: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"]),
        chromeSubtleTextColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        chromeTextColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        buttonBackgroundColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        buttonBorder: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        buttonFontWeight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"],
        buttonTextColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        inputBackgroundColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        inputBorder: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        inputTextColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        menuBackgroundColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        menuBorder: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        menuTextColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        panelBackgroundColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        panelSubtleTextColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        tooltipBackgroundColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        tooltipBorder: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        tooltipTextColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        tooltipSubtleTextColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        crosshairLabelBackgroundColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
        crosshairLabelTextColor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]
    },
    palette: {
        fills: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorUnion"]),
        strokes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]),
        up: {
            fill: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gradientStrict"]),
            stroke: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]
        },
        down: {
            fill: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gradientStrict"]),
            stroke: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]
        },
        neutral: {
            fill: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gradientStrict"]),
            stroke: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"]
        }
    }
};
var themeNameValidator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("ag-default", "ag-default-dark", "ag-sheets", "ag-sheets-dark", "ag-polychroma", "ag-polychroma-dark", "ag-vivid", "ag-vivid-dark", "ag-material", "ag-material-dark", "ag-financial", "ag-financial-dark");
function validateStructure(value) {
    const { invalid } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"])({
        theme: value
    }, {
        theme: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(themeNameValidator, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["object"])
    });
    for (const error of invalid){
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce(String(error));
    }
    return invalid.length === 0;
}
// packages/ag-charts-community/src/module/enterpriseModule.ts
var enterpriseModule = {
    isEnterprise: false
};
;
;
;
var PATH_EDGE = "path";
var PATH_ARRAY_EDGE = "pathArray";
var DEFAULTS_EDGE = "default";
var OVERRIDES_EDGE = "override";
var USER_OPTIONS_EDGE = "user";
var OPERATION_EDGE = "operation";
var OPERATION_VALUE_EDGE = "operationValue";
var DEPENDENCY_EDGE = "dependency";
var AUTO_ENABLE_EDGE = "autoEnable";
var AUTO_ENABLE_VALUE_EDGE = "autoEnableValue";
function isRatio(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(value) && value >= 0 && value <= 1;
}
function hasPathSafe(object4, path) {
    let result = object4;
    for (const part of path){
        const isPartKey = typeof part === "string" && result != null && (typeof result === "object" || Array.isArray(result)) && part in result;
        if (!isPartKey) return false;
        result = result[part];
    }
    return true;
}
function getPathSafe(object4, path) {
    let result = object4;
    for (const part of path){
        const isPartKey = typeof part === "string" && result != null && (typeof result === "object" || Array.isArray(result)) && part in result;
        if (!isPartKey) return;
        result = result[part];
    }
    return result;
}
function setPathSafe(object4, path, value) {
    const pathLength = path.length;
    if (pathLength === 0) return;
    let result = object4;
    const lastIndex = pathLength - 1;
    const lastPart = path[lastIndex];
    for(let i = 0; i < lastIndex; i++){
        const part = path[i];
        const nextPart = path[i + 1];
        let currentValue = result[part];
        if (currentValue == null || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObjectLike"])(currentValue)) {
            currentValue = isNaN(Number(nextPart)) ? {} : [];
            result[part] = currentValue;
        }
        result = currentValue;
    }
    result[lastPart] = value;
}
var DIGITS_ONLY_REGEX = /^\d+$/;
function getPathLastIndexIndex(pathArray) {
    for(let i = pathArray.length - 1; i >= 0; i--){
        const part = pathArray[i];
        if (DIGITS_ONLY_REGEX.test(part)) {
            return i;
        }
    }
    return -1;
}
function getPathLastIndex(pathArray) {
    const indexIndex = getPathLastIndexIndex(pathArray);
    return Number(pathArray[indexIndex]);
}
function resolvePath(currentPath, path, variables) {
    const relativePathParts = path.split("/");
    let resolvedPath = [
        ...currentPath
    ];
    if (path.startsWith("/")) {
        resolvedPath = [];
        relativePathParts.shift();
    }
    let prevPartWasTwoDots = false;
    for (const part of relativePathParts){
        if (part === "..") {
            resolvedPath.pop();
            if (!prevPartWasTwoDots) resolvedPath.pop();
        } else if (part === ".") {
            resolvedPath.pop();
        } else if (part === "$index") {
            const index = getPathLastIndex(currentPath);
            if (isNaN(index)) return UNRESOLVABLE_PATH;
            resolvedPath.push("".concat(index));
        } else if (part === "$prevIndex") {
            const index = getPathLastIndex(currentPath);
            if (isNaN(index) || Number(index) <= 0) return UNRESOLVABLE_PATH;
            resolvedPath.push("".concat(Number(index) - 1));
        } else if (part.startsWith("$")) {
            const variable = variables === null || variables === void 0 ? void 0 : variables[part.slice(1)];
            if (variable == null) return UNRESOLVABLE_PATH;
            resolvedPath.push(variable);
        } else if (part.length !== 0) {
            resolvedPath.push(part);
        }
        prevPartWasTwoDots = part === "..";
    }
    return resolvedPath;
}
var UNRESOLVABLE_PATH = Symbol("unresolvable-path");
var RESOLVED_TO_BRANCH = Symbol("resolved-to-branch");
// packages/ag-charts-community/src/module/optionsGraphOperations.ts
function getOperation(value, keys) {
    if (value == null || typeof value !== "object" || Array.isArray(value)) return;
    keys !== null && keys !== void 0 ? keys : keys = Object.keys(value);
    if (keys.length === 0) return;
    const operation = keys[0];
    if (!operationTypes.has(operation)) return;
    return {
        operation,
        values: Array.isArray(value[operation]) ? value[operation] : [
            value[operation]
        ]
    };
}
function getOperationTargetVertex(graph, vertex, valueVertex) {
    const operation = getOperation(graph.getVertexValue(valueVertex));
    switch(operation === null || operation === void 0 ? void 0 : operation.operation){
        case "$path" /* Path */ :
            {
                const [relativePath] = operation.values;
                const pathArray = graph.getPathArray(vertex);
                const path = resolvePath(pathArray, relativePath);
                if (path === UNRESOLVABLE_PATH) return;
                return graph.findVertexAtPath(path);
            }
        case "$value" /* Value */ :
            return vertex;
    }
}
var chartOperations = {
    $hasSeriesType: {
        dependencies: seriesTypeDependencyFactory,
        resolve: hasSeriesTypeOperation
    },
    $isChartType: {
        dependencies: seriesTypeDependencyFactory,
        resolve: isChartTypeOperation
    },
    $isSeriesType: {
        dependencies: seriesTypeDependencyFactory,
        resolve: isSeriesTypeOperation
    }
};
function seriesTypeDependencyFactory(graph, vertex, _values) {
    const dependencyVertex = graph.findVertexAtPath([
        "series",
        "0",
        "type"
    ]);
    if (dependencyVertex) {
        graph.addEdge(vertex, dependencyVertex, DEPENDENCY_EDGE);
    }
}
function hasSeriesTypeOperation(graph, vertex, values) {
    const [valueVertex] = values;
    const value = graph.resolveVertexValue(vertex, valueVertex);
    const series = graph.getResolvedPath([
        "series"
    ]);
    if (!Array.isArray(series)) return false;
    for (const s of series){
        if (s.type === value) return true;
    }
    return false;
}
function isSeriesTypeOperation(graph, vertex, values) {
    const [valueVertex] = values;
    const value = graph.resolveVertexValue(vertex, valueVertex);
    const seriesType = graph.getResolvedPath([
        "series",
        "0",
        "type"
    ]);
    return seriesType === value;
}
function isChartTypeOperation(graph, vertex, values) {
    const [valueVertex] = values;
    const value = graph.resolveVertexValue(vertex, valueVertex);
    const seriesType = graph.getResolvedPath([
        "series",
        "0",
        "type"
    ]);
    if (typeof seriesType !== "string") return false;
    switch(value){
        case "cartesian":
            return chartTypes2.isCartesian(seriesType);
        case "polar":
            return chartTypes2.isPolar(seriesType);
        case "standalone":
            return chartTypes2.isStandalone(seriesType);
    }
    return false;
}
var colorOperations = {
    $foregroundBackgroundMix: foregroundBackgroundMixOperation,
    $foregroundOpacity: foregroundOpacityOperation,
    $interpolate: interpolateOperation,
    $isGradient: isGradientOperation,
    $isImage: isImageOperation,
    $isPattern: isPatternOperation,
    $mix: mixOperation
};
function foregroundBackgroundMixOperation(graph, vertex, values) {
    const [foregroundRatioVertex] = values;
    const foregroundRatio = graph.resolveVertexValue(vertex, foregroundRatioVertex);
    const foregroundColor = graph.getParamValue("foregroundColor");
    const backgroundColor = graph.getParamValue("backgroundColor");
    if (typeof foregroundColor === "string" && typeof backgroundColor === "string" && isRatio(foregroundRatio)) {
        return Color.mix(Color.fromString(foregroundColor), Color.fromString(backgroundColor), 1 - foregroundRatio).toString();
    }
    Debug.inDevelopmentMode(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("`$foregroundBackgroundMix` json operation failed on [".concat(String(foregroundRatio), "}}] at [").concat(graph.getPathArray(vertex).join("."), "], expecting a number between 0 and 1.")));
}
function foregroundOpacityOperation(graph, vertex, values) {
    const [opacityVertex] = values;
    const opacity = graph.resolveVertexValue(vertex, opacityVertex);
    const foregroundColor = graph.getParamValue("foregroundColor");
    if (typeof foregroundColor === "string" && isRatio(opacity)) {
        const color11 = Color.fromString(foregroundColor);
        return new Color(color11.r, color11.g, color11.b, opacity).toString();
    }
    Debug.inDevelopmentMode(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("`$foregroundOpacity` json operation failed on [".concat(String(opacity), "}}] at [").concat(graph.getPathArray(vertex).join("."), "], expecting a number between 0 and 1.")));
}
function interpolateOperation(graph, vertex, values) {
    const [colorsVertex, countVertex] = values;
    const colors = graph.resolveVertexValue(vertex, colorsVertex);
    const count = graph.resolveVertexValue(vertex, countVertex);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(colors) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(count)) return;
    return Color.interpolate(colors.map((color11)=>Color.fromString(color11)), count).map((color11)=>color11.toString());
}
function isGradientOperation(graph, vertex, values) {
    const [valueVertex] = values;
    const value = graph.resolveVertexValue(vertex, valueVertex);
    return isGradientFill(value);
}
function isImageOperation(graph, vertex, values) {
    const [valueVertex] = values;
    const value = graph.resolveVertexValue(vertex, valueVertex);
    return isImageFill(value);
}
function isPatternOperation(graph, vertex, values) {
    const [valueVertex] = values;
    const value = graph.resolveVertexValue(vertex, valueVertex);
    return isPatternFill(value);
}
function mixOperation(graph, vertex, values) {
    const [colorAVertex, colorBVertex, ratioVertex] = values;
    const colorA = graph.resolveVertexValue(vertex, colorAVertex);
    const colorB = graph.resolveVertexValue(vertex, colorBVertex);
    const ratio11 = graph.resolveVertexValue(vertex, ratioVertex);
    const pathArray = graph.getPathArray(vertex);
    const warningPrefix = "`$mix` json operation failed on [".concat(String(colorA), ", ").concat(String(colorB), ", ").concat(String(ratio11), "] at [").concat(pathArray.join("."), "], expecting");
    const warningMessage = "".concat(warningPrefix, " two colors and a number between 0 and 1.");
    if (typeof colorB !== "string" || !isRatio(ratio11)) {
        Debug.inDevelopmentMode(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce(warningMessage));
        return;
    }
    if (typeof colorA === "string") {
        try {
            return Color.mix(Color.fromString(colorA), Color.fromString(colorB), ratio11).toString();
        } catch (e) {
            Debug.inDevelopmentMode(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce(warningMessage));
            return;
        }
    }
    if (!isGradientFill(colorA)) {
        Debug.inDevelopmentMode(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce(warningMessage));
        return;
    }
    let colorStops = colorA.colorStops;
    try {
        colorStops = colorStops === null || colorStops === void 0 ? void 0 : colorStops.map((value)=>{
            let color11;
            if (typeof value.color === "string") {
                color11 = Color.mix(Color.fromString(value.color), Color.fromString(colorB), ratio11).toString();
            }
            return {
                ...value,
                color: color11
            };
        });
    } catch (e) {
        Debug.inDevelopmentMode(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("".concat(warningPrefix, " a gradient, a color and a number between 0 and 1.")));
        return;
    }
    return {
        ...colorA,
        colorStops
    };
}
var fontOperations = {
    $rem: remOperation
};
function remOperation(graph, vertex, values) {
    const [valueVertex] = values;
    const value = graph.getVertexValue(valueVertex);
    const fontSize = graph.getParamValue("fontSize");
    if (typeof fontSize === "number" && typeof value === "number") {
        return Math.round(value * fontSize);
    }
    Debug.inDevelopmentMode(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("`$rem` json operation failed on [".concat(String(value), "] at [").concat(graph.getPathArray(vertex).join("."), "], expecting a number.")));
}
var logicOperations = {
    $and: andOperation,
    $eq: eqOperation,
    $greaterThan: greaterThanOperation,
    $if: ifOperation,
    $lessThan: lessThanOperation,
    $not: notOperation,
    $or: orOperation,
    $switch: switchOperation
};
function andOperation(graph, vertex, values) {
    for (const valueVertex of values){
        const value = graph.resolveVertexValue(vertex, valueVertex);
        if (!value) return false;
    }
    return true;
}
function eqOperation(graph, vertex, values) {
    let compare;
    let first2 = true;
    for (const valueVertex of values){
        const value = graph.resolveVertexValue(vertex, valueVertex);
        if (first2) {
            compare = value;
            first2 = false;
        } else if (value !== compare) {
            return false;
        }
    }
    return true;
}
function greaterThanOperation(graph, vertex, values) {
    const [value, compare] = values;
    return graph.resolveVertexValue(vertex, value) > graph.resolveVertexValue(vertex, compare);
}
function ifOperation(graph, vertex, values) {
    const [conditionVertex, thenVertex, elseVertex] = values;
    const condition = graph.resolveVertexValue(vertex, conditionVertex);
    const valueVertex = condition ? thenVertex : elseVertex;
    const neighbours = graph.neighboursWithEdgeValue(valueVertex, PATH_EDGE);
    if (neighbours) {
        for (const neighbour of neighbours){
            graph.addEdge(vertex, neighbour, PATH_EDGE);
        }
    }
    return graph.resolveVertexValue(vertex, valueVertex);
}
function lessThanOperation(graph, vertex, values) {
    const [value, compare] = values;
    return graph.resolveVertexValue(vertex, value) < graph.resolveVertexValue(vertex, compare);
}
function notOperation(graph, vertex, values) {
    for (const valueVertex of values){
        return !graph.resolveVertexValue(vertex, valueVertex);
    }
}
function orOperation(graph, vertex, values) {
    for (const valueVertex of values){
        const value = graph.resolveVertexValue(vertex, valueVertex);
        if (value) return true;
    }
    return false;
}
function switchOperation(graph, vertex, values) {
    const [conditionValueVertex, defaultValueVertex, ...caseVertices] = values;
    const conditionValue = graph.resolveVertexValue(vertex, conditionValueVertex);
    for (const caseVertex of caseVertices){
        const caseValue = graph.getVertexValue(caseVertex);
        if (!Array.isArray(caseValue)) continue;
        const [caseConditionValue, caseResultValue] = caseValue;
        if (conditionValue === caseConditionValue || Array.isArray(caseConditionValue) && caseConditionValue.includes(conditionValue)) {
            return caseResultValue;
        }
    }
    return graph.getVertexValue(defaultValueVertex);
}
var locationOperations = {
    $isUserOption: isUserOptionOperation,
    $isThemeOverride: isThemeOverrideOperation,
    $palette: paletteOperation,
    $mapPalette: mapPaletteOperation,
    $path: {
        dependencies: pathOperationDependenciesFactory,
        resolve: pathOperation
    },
    $pathString: {
        dependencies: pathOperationDependenciesFactory,
        resolve: pathStringOperation
    },
    $ref: refOperation
};
function isUserOptionOperation(graph, vertex, values) {
    const [relativePathVertices, thenVertex, elseVertex] = values;
    const children = graph.neighboursWithEdgeValue(relativePathVertices, PATH_EDGE);
    if (children) {
        for (const child of children){
            const relativePathVertex = graph.findNeighbour(child, DEFAULTS_EDGE);
            if (relativePathVertex && isUserOptionCheck(graph, vertex, relativePathVertex)) {
                return graph.resolveVertexValue(vertex, thenVertex);
            }
        }
    } else if (isUserOptionCheck(graph, vertex, relativePathVertices)) {
        return graph.resolveVertexValue(vertex, thenVertex);
    }
    return graph.resolveVertexValue(vertex, elseVertex);
}
function isUserOptionCheck(graph, vertex, relativePathVertex) {
    const relativePath = graph.resolveVertexValue(vertex, relativePathVertex);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(relativePath)) {
        throw new Error("`$isUserOption` json operation failed on [".concat(String(relativePath), "], expecting a string."));
    }
    const pathArray = graph.getPathArray(vertex);
    const path = resolvePath(pathArray, relativePath);
    if (path === UNRESOLVABLE_PATH) return false;
    return graph.hasUserOption(path);
}
function isThemeOverrideOperation(graph, vertex, values) {
    const [relativePathVertex, thenVertex, elseVertex] = values;
    const relativePath = graph.resolveVertexValue(vertex, relativePathVertex);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(relativePath)) {
        throw new Error("`$isThemeOverride` json operation failed on [".concat(String(relativePath), "], expecting a string."));
    }
    const pathArray = graph.getPathArray(vertex);
    const path = resolvePath(pathArray, relativePath);
    if (path === UNRESOLVABLE_PATH) return;
    if (graph.hasThemeOverride(path)) {
        return graph.resolveVertexValue(vertex, thenVertex);
    }
    return graph.resolveVertexValue(vertex, elseVertex);
}
var PALETTE_INDEX_KEYS = /* @__PURE__ */ new Set([
    "fill",
    "fillFallback",
    "stroke",
    "gradient",
    "range2"
]);
function paletteOperation(graph, vertex, values) {
    const [keyVertex] = values;
    const key = graph.resolveVertexValue(vertex, keyVertex);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(key)) return;
    if (PALETTE_INDEX_KEYS.has(key)) {
        const pathArray = graph.getPathArray(vertex);
        const index = getPathLastIndex(pathArray);
        if (isNaN(index)) return;
        switch(key){
            case "fill":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circularSliceArray"])(graph.palette.fills, 1, index)[0];
            case "fillFallback":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circularSliceArray"])(graph.palette.fillsFallback, 1, index)[0];
            case "stroke":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circularSliceArray"])(graph.palette.strokes, 1, index)[0];
            case "gradient":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circularSliceArray"])(graph.palette.sequentialColors, 1, index)[0];
            case "range2":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circularSliceArray"])(graph.palette.fills, 2, index);
        }
        return;
    }
    if (key === "gradients") {
        return graph.palette.sequentialColors;
    }
    const value = getPathSafe(graph.palette, key.split("."));
    if (Array.isArray(value)) return [
        ...value
    ];
    if (typeof value === "object") return {
        ...value
    };
    return value;
}
function mapPaletteOperation(graph, vertex, values) {
    const [keyVertex] = values;
    const key = graph.resolveVertexValue(vertex, keyVertex);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(key)) return;
    if (PALETTE_INDEX_KEYS.has(key)) {
        const pathArray = graph.getPathArray(vertex);
        let index = getPathLastIndex(pathArray);
        let ignoreIndexOffset = 0;
        const path = [
            "series",
            "0",
            "type"
        ];
        for(let i = 0; i < index; i++){
            path[1] = "".concat(i);
            const siblingSeriesType = graph.getResolvedPath(path);
            if ("map-shape-background" === siblingSeriesType || "map-line-background" === siblingSeriesType) {
                ignoreIndexOffset++;
            }
        }
        index -= ignoreIndexOffset;
        if (isNaN(index)) return;
        switch(key){
            case "fill":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circularSliceArray"])(graph.palette.fills, 1, index)[0];
            case "fillFallback":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circularSliceArray"])(graph.palette.fillsFallback, 1, index)[0];
            case "stroke":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circularSliceArray"])(graph.palette.strokes, 1, index)[0];
            case "gradient":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circularSliceArray"])(graph.palette.sequentialColors, 1, index)[0];
            case "range2":
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["circularSliceArray"])(graph.palette.fills, 2, index);
        }
        return;
    }
    if (key === "gradients") {
        return graph.palette.sequentialColors;
    }
    const value = getPathSafe(graph.palette, key.split("."));
    if (Array.isArray(value)) return [
        ...value
    ];
    if (typeof value === "object") return {
        ...value
    };
    return value;
}
function pathOperationDependenciesFactory(graph, vertex, values) {
    const [relativePathVertex] = values;
    const relativePath = graph.getVertexValue(relativePathVertex);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(relativePath)) {
        const pathArray = graph.getPathArray(vertex);
        const path = resolvePath(pathArray, relativePath);
        if (path === UNRESOLVABLE_PATH) {
            return;
        }
        const dependencyVertex = graph.findVertexAtPath(path);
        if (dependencyVertex) {
            graph.addEdge(vertex, dependencyVertex, DEPENDENCY_EDGE);
        }
    }
}
function pathOperation(graph, vertex, values) {
    const hasDefaultValue = values.length > 1;
    const hasCustomBranch = values.length > 2;
    const [relativePathVertex, defaultValueVertex, customBranchVertex] = values;
    const relativePath = graph.resolveVertexValue(vertex, relativePathVertex);
    const customBranch = hasCustomBranch ? graph.resolveVertexValue(vertex, customBranchVertex) : null;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(relativePath)) {
        throw new Error("`$path` json operation failed on [".concat(String(relativePath), "], expecting a string."));
    }
    const pathArray = graph.getPathArray(vertex);
    const path = resolvePath(pathArray, relativePath);
    if (path === UNRESOLVABLE_PATH) {
        return;
    }
    const resolved = customBranch ? getPathSafe(customBranch, path) : graph.getResolvedPath(path);
    if (resolved != null) {
        return resolved;
    }
    if (hasDefaultValue) {
        return graph.resolveVertexValue(vertex, defaultValueVertex);
    }
}
function pathStringOperation(graph, vertex, values) {
    const [relativePathVertex, variablesVertex] = values;
    const relativePath = graph.resolveVertexValue(vertex, relativePathVertex);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(relativePath)) {
        throw new Error("`$path` json operation failed on [".concat(String(relativePath), "], expecting a string."));
    }
    let variables;
    if (variablesVertex) {
        variables = graph.graftAndResolveOrphan(vertex, variablesVertex);
    }
    const pathArray = graph.getPathArray(vertex);
    const path = resolvePath(pathArray, relativePath, variables);
    if (path === UNRESOLVABLE_PATH) {
        throw new Error("Unresolvable path [".concat(relativePath, "] at [").concat(pathArray.join("."), "]"));
    }
    return path;
}
function refOperation(graph, _vertex, values) {
    const [value] = values;
    const paramKey = graph.getVertexValue(value);
    return graph.getParamValue(paramKey);
}
var transformOperations = {
    $apply: applyOperation,
    $applyTheme: applyThemeOperation,
    $findFirstSiblingNotOperation: findFirstSiblingNotOperationOperation,
    $map: mapOperation,
    $merge: mergeOperation,
    $omit: omitOperation,
    $size: sizeOperation,
    $shallow: shallowOperation,
    $value: valueOperation
};
function applyOperation(graph, vertex, values) {
    const [objectVertex, defaultValueVertex, overridesPathVertex1, overridesPathVertex2] = values;
    const object4 = graph.getVertexValue(objectVertex);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(object4)) return;
    const defaultValue = defaultValueVertex ? graph.getVertexValue(defaultValueVertex) : void 0;
    const children = graph.neighboursWithEdgeValue(vertex, PATH_EDGE);
    const overridesPath1 = overridesPathVertex1 ? graph.resolveVertexValue(vertex, overridesPathVertex1) : void 0;
    const overridesPath2 = overridesPathVertex2 ? graph.resolveVertexValue(vertex, overridesPathVertex2) : void 0;
    if ((!children || children.length === 0) && defaultValue != null) {
        if (getOperation(defaultValue)) {
            const resolvedDefaultValue = graph.resolveVertexValue(vertex, defaultValueVertex);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(resolvedDefaultValue)) {
                graph.graftObject(vertex, resolvedDefaultValue, [
                    overridesPath1,
                    overridesPath2
                ]);
            }
        } else {
            graph.graftObject(vertex, defaultValue, [
                overridesPath1,
                overridesPath2
            ]);
        }
    }
    if (!children) return RESOLVED_TO_BRANCH;
    for (const child of children){
        const childNeighbours = graph.neighboursWithEdgeValue(child, PATH_EDGE);
        if (!childNeighbours || childNeighbours.length === 0) {
            const stubVertex = graph.addVertex({});
            graph.addEdge(child, stubVertex, DEFAULTS_EDGE);
        } else {
            graph.graftObject(child, object4, [
                overridesPath1,
                overridesPath2
            ]);
        }
    }
    return RESOLVED_TO_BRANCH;
}
function applyThemeOperation(graph, vertex, values) {
    const [fromPathVertex, variablesVertex, ignorePathsVertex] = values;
    let fromPaths = graph.getVertexValue(fromPathVertex);
    if (typeof fromPaths === "string") {
        fromPaths = [
            fromPaths
        ];
    }
    if (!Array.isArray(fromPaths)) return;
    const children = graph.neighboursWithEdgeValue(vertex, PATH_EDGE);
    const ignorePathsValue = ignorePathsVertex ? graph.getVertexValue(ignorePathsVertex) : [];
    const ignorePaths = Array.isArray(ignorePathsValue) ? new Set(ignorePathsValue) : /* @__PURE__ */ new Set();
    if (!children) return RESOLVED_TO_BRANCH;
    for (const child of children){
        const variables = graph.graftAndResolveOrphan(child, variablesVertex);
        for (const fromPath of fromPaths){
            const fromPathResolved = resolvePath([], fromPath, variables);
            if (fromPathResolved === UNRESOLVABLE_PATH) {
                continue;
            }
            graph.graftConfig(child, fromPathResolved, ignorePaths);
        }
    }
    return RESOLVED_TO_BRANCH;
}
function findFirstSiblingNotOperationOperation(graph, vertex, values) {
    const [defaultValueVertex] = values;
    const pathArray = graph.getPathArray(vertex);
    const indexIndex = getPathLastIndexIndex(pathArray);
    if (indexIndex < 0) {
        return graph.resolveVertexValue(vertex, defaultValueVertex);
    }
    const parentPathArray = pathArray.slice(0, indexIndex);
    const parentVertex = graph.findVertexAtPath(parentPathArray);
    if (!parentVertex) {
        return graph.resolveVertexValue(vertex, defaultValueVertex);
    }
    const siblings = graph.neighboursWithEdgeValue(parentVertex, PATH_EDGE);
    if (siblings) {
        for(let index = 0; index < siblings.length; index++){
            if ("".concat(index) === pathArray[indexIndex]) continue;
            const siblingChildPathArray = parentPathArray.concat([
                "".concat(index),
                ...pathArray.slice(indexIndex + 1)
            ]);
            const siblingChildVertex = graph.findVertexAtPath(siblingChildPathArray);
            if (!siblingChildVertex) continue;
            const siblingChildUserOptionsValue = graph.findNeighbourValue(siblingChildVertex, USER_OPTIONS_EDGE);
            if (siblingChildUserOptionsValue != null) {
                return siblingChildUserOptionsValue;
            }
            const siblingChildOverridesValue = graph.findNeighbourValue(siblingChildVertex, OVERRIDES_EDGE);
            if (siblingChildOverridesValue != null) {
                return siblingChildOverridesValue;
            }
        }
    }
    return graph.resolveVertexValue(vertex, defaultValueVertex);
}
function mapOperation(graph, vertex, values) {
    const [mapOperationVertex, mapValuesVertex] = values;
    const mapOperationFn = graph.getVertexValue(mapOperationVertex);
    const mapValues3 = graph.resolveVertexValue(vertex, mapValuesVertex);
    if (!Array.isArray(mapValues3)) return;
    if (!getOperation(mapOperationFn)) return mapValues3.map(()=>mapOperationFn);
    let index = 0;
    for (const value of mapValues3){
        graph.graftValue(vertex, "".concat(index), mapOperationFn, value);
        index++;
    }
    return RESOLVED_TO_BRANCH;
}
function mergeOperation(graph, vertex, values) {
    for (const valueVertex of values){
        const value = graph.resolveVertexValue(vertex, valueVertex);
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(value)) continue;
        graph.graftObject(vertex, value);
    }
    return RESOLVED_TO_BRANCH;
}
function omitOperation(graph, vertex, values) {
    const [keysVertex, objectVertex] = values;
    let keys = graph.getVertexValue(keysVertex);
    if (!Array.isArray(keys)) {
        const targetVertex = getOperationTargetVertex(graph, vertex, objectVertex);
        if (!targetVertex) return;
        keys = graph.resolveVertexValue(targetVertex, keysVertex);
    }
    const object4 = graph.resolveVertexValue(vertex, objectVertex);
    if (!Array.isArray(keys) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(object4)) return;
    return without(object4, keys);
}
function sizeOperation(graph, vertex, values) {
    const [valueVertex] = values;
    const value = graph.resolveVertexValue(vertex, valueVertex);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObjectLike"])(value)) return 0;
    return Object.keys(value).length;
}
function shallowOperation(graph, _vertex, values) {
    const shallowValues = [];
    for (const valueVertex of values){
        shallowValues.push(graph.getVertexValue(valueVertex));
    }
    return shallowValues;
}
function valueOperation(graph, vertex, values) {
    const [valueVertex] = values;
    const value = graph.getVertexValue(valueVertex);
    const pathArray = graph.getPathArray(vertex);
    if (value === "$index") {
        return getPathLastIndex(pathArray);
    }
    if (value === "$1") {
        return graph.resolveValue$1(pathArray);
    }
}
var numericOperations = {
    $isEven: isEvenOperation,
    $mul: mulOperation,
    $round: roundOperation
};
function isEvenOperation(graph, vertex, values) {
    const [valueVertex] = values;
    const value = graph.resolveVertexValue(vertex, valueVertex);
    if (isNaN(Number(value))) return false;
    return Number(value) % 2 === 0;
}
function mulOperation(graph, vertex, values) {
    let result;
    for (const valueVertex of values){
        const value = graph.resolveVertexValue(vertex, valueVertex);
        if (result == null) {
            result = Number(value);
        } else {
            result *= Number(value);
        }
    }
    return result;
}
function roundOperation(graph, vertex, values) {
    for (const valueVertex of values){
        return Math.round(Number(graph.resolveVertexValue(vertex, valueVertex)));
    }
}
var operations = {
    ...chartOperations,
    ...colorOperations,
    ...fontOperations,
    ...locationOperations,
    ...logicOperations,
    ...numericOperations,
    ...transformOperations
};
var operationTypes = new Set(Object.keys(operations));
function isOperation(value) {
    return operationTypes.has(value);
}
// packages/ag-charts-community/src/module/optionsGraph.ts
var createOptionsGraph = simpleMemorize(createOptionsGraphFn);
function createOptionsGraphFn(theme, options) {
    return new OptionsGraph(theme.config, options, theme.params, theme.palette, theme.overrides, theme.getTemplateParameters());
}
var _OptionsGraph = class _OptionsGraph extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AdjacencyListGraph"] {
    clear() {
        super.clear();
        this.cachedPathVertices.clear();
    }
    resolve() {
        this.resolved = {};
        this.resolvedParams = {};
        this.resolvedAnnotations = {};
        this.resolveVertex(this.params, this.resolvedParams);
        this.resolveVertex(this.annotations, this.resolvedAnnotations);
        this.resolveVertex(this.root);
        return this.resolved;
    }
    resolveParams() {
        return this.resolvedParams;
    }
    resolveAnnotationThemes() {
        return this.resolvedAnnotations;
    }
    findVertexAtPath(path) {
        const key = path.join(".");
        if (this.cachedPathVertices.has(key)) {
            return this.cachedPathVertices.get(key);
        }
        const vertex = this.findVertexAlongEdge(this.root, path, PATH_EDGE);
        if (!vertex) return;
        this.cachedPathVertices.set(key, vertex);
        return vertex;
    }
    hasUserOption(path) {
        return hasPathSafe(this.userOptions, path);
    }
    hasThemeOverride(path) {
        if (path[0] === "axes" && path.length > 1) {
            const axisType = this.getResolvedPath([
                "axes",
                path[1],
                "type"
            ]);
            if (hasPathSafe(this.overrides, [
                "common",
                "axes",
                axisType,
                ...path.slice(2)
            ])) {
                return true;
            }
            const seriesType = this.getResolvedPath([
                "series",
                "0",
                "type"
            ]);
            return hasPathSafe(this.overrides, [
                seriesType,
                "axes",
                axisType,
                ...path.slice(2)
            ]);
        }
        if (path[0] === "series" && path.length > 1) {
            const seriesType = this.getResolvedPath([
                "series",
                path[1],
                "type"
            ]);
            return hasPathSafe(this.overrides, [
                seriesType,
                "series",
                ...path.slice(2)
            ]);
        }
        return hasPathSafe(this.overrides, path);
    }
    getParamValue(path) {
        if (this.resolvedParams[path] != null) {
            return this.resolvedParams[path];
        }
        const paramVertex = this.findVertexAlongEdge(this.params, [
            path
        ], PATH_EDGE);
        if (!paramVertex) return;
        const defaultValueVertex = this.findNeighbour(paramVertex, DEFAULTS_EDGE);
        if (!defaultValueVertex) return;
        const resolved = this.resolveVertexValue(paramVertex, defaultValueVertex);
        this.resolvedParams[path] = resolved;
        return resolved;
    }
    getPathArray(vertex) {
        var _this_findNeighbourValue;
        return (_this_findNeighbourValue = this.findNeighbourValue(vertex, PATH_ARRAY_EDGE)) !== null && _this_findNeighbourValue !== void 0 ? _this_findNeighbourValue : [];
    }
    getResolvedPath(path) {
        return getPathSafe(this.resolved, path);
    }
    resolveVertexValue(vertex, valueVertex) {
        this.resolveVertexDependencies(valueVertex);
        const operation = this.findNeighbourValue(valueVertex, OPERATION_EDGE);
        if (operation && isOperation(operation)) {
            const operationValues = this.neighboursWithEdgeValue(valueVertex, OPERATION_VALUE_EDGE);
            const operator = operations[operation];
            const operatorFn = typeof operator === "function" ? operator : operator.resolve;
            const resolved = operatorFn === null || operatorFn === void 0 ? void 0 : operatorFn(this, vertex, operationValues !== null && operationValues !== void 0 ? operationValues : []);
            return resolved === RESOLVED_TO_BRANCH ? void 0 : resolved;
        }
        let value = this.getVertexValue(valueVertex);
        if (Array.isArray(value)) {
            const object4 = {};
            this.resolveVertexChildren(valueVertex, object4);
            value = getPathSafe(object4, this.getPathArray(vertex));
        }
        return this.resolveValueOrSymbol(value);
    }
    // Resolve the value currently referenced by `$1`
    resolveValue$1(pathArray) {
        return getPathSafe(this.value$1, pathArray);
    }
    // Graft a branch of the theme config onto the target vertex.
    graftConfig(target, configPathArray, ignorePaths) {
        const targetConfigObject = getPathSafe(this.config, configPathArray);
        const targetPathArrayVertex = this.findNeighbour(target, PATH_ARRAY_EDGE);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(targetConfigObject)) {
            this.buildGraphFromObject(target, DEFAULTS_EDGE, targetConfigObject, targetPathArrayVertex, void 0, ignorePaths);
        }
        if (this.overrides) {
            const targetOverridesObject = getPathSafe(this.overrides, configPathArray);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(targetOverridesObject)) {
                this.buildGraphFromObject(target, OVERRIDES_EDGE, targetOverridesObject, targetPathArrayVertex, void 0, ignorePaths);
            }
            const commonOverridesObject = getPathSafe(this.overrides, [
                "common",
                ...configPathArray.slice(1)
            ]);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(commonOverridesObject)) {
                this.buildGraphFromObject(target, OVERRIDES_EDGE, commonOverridesObject, targetPathArrayVertex, void 0, ignorePaths);
            }
        }
        this.buildDependencyGraph();
    }
    // Graft a given object onto the target vertex.
    graftObject(target, object4, overridesPathArrays) {
        const pathArrayVertex = this.findNeighbour(target, PATH_ARRAY_EDGE);
        this.buildGraphFromObject(target, DEFAULTS_EDGE, object4, pathArrayVertex);
        if (this.overrides && overridesPathArrays) {
            for (const overridePathArray of overridesPathArrays){
                if (overridePathArray == null) continue;
                const overrides = getPathSafe(this.overrides, overridePathArray);
                if (overrides) {
                    this.buildGraphFromObject(target, OVERRIDES_EDGE, overrides, pathArrayVertex);
                }
            }
        }
        this.buildDependencyGraph();
    }
    // Graft a given operation and value onto `path` child of the target vertex.
    graftValue(target, path, operation, value) {
        const pathArray = [
            ...this.getPathArray(target),
            path
        ];
        setPathSafe(this.value$1, pathArray, value);
        var _this_findVertexAtPath;
        const pathVertex = (_this_findVertexAtPath = this.findVertexAtPath(pathArray)) !== null && _this_findVertexAtPath !== void 0 ? _this_findVertexAtPath : this.addVertex(path);
        this.buildGraphFromValue(target, pathVertex, DEFAULTS_EDGE, pathArray, operation);
        this.buildDependencyGraph();
    }
    // Resolve a branch as if it were a child of the context vertex, but without attaching it to the resolved root.
    graftAndResolveOrphan(context, branch) {
        const orphan = {};
        const orphanVertex = this.addVertex(orphan);
        const contextPathArray = this.getPathArray(context);
        this.graftAndResolveChildren(branch, orphanVertex, contextPathArray, []);
        this.resolveVertex(orphanVertex, orphan);
        return getPathSafe(orphan, contextPathArray);
    }
    buildGraphFromObject(parentVertex, edgeValue, object4, pathArrayVertex) {
        let shallowPaths = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : _OptionsGraph.SHALLOW_KEYS, ignorePaths = arguments.length > 5 ? arguments[5] : void 0;
        const keys = Object.keys(object4);
        const operation = getOperation(object4, keys);
        if (operation) {
            const valueVertex = this.addVertex(object4);
            this.addEdge(parentVertex, valueVertex, edgeValue);
            this.buildGraphFromOperation(valueVertex, edgeValue, operation, pathArrayVertex);
            return;
        }
        if (keys.length === 0) {
            this.addEdge(parentVertex, this.addVertex(Array.isArray(object4) ? [] : {}), edgeValue);
            this.buildGraphAutoEnable(parentVertex, edgeValue, object4, void 0);
            return;
        }
        const pathVertices = this.getVertexChildrenByKey(parentVertex);
        const pathArray = pathArrayVertex ? this.getVertexValue(pathArrayVertex) : [];
        let enabledVertex;
        const childPathArray = [
            ...pathArray
        ];
        const pathArrayLength = pathArray.length;
        for (const key of keys){
            if (ignorePaths === null || ignorePaths === void 0 ? void 0 : ignorePaths.has(key)) continue;
            var _pathVertices_get;
            const childPathVertex = (_pathVertices_get = pathVertices === null || pathVertices === void 0 ? void 0 : pathVertices.get(key)) !== null && _pathVertices_get !== void 0 ? _pathVertices_get : this.addVertex(key);
            childPathArray[pathArrayLength] = key;
            if (shallowPaths === null || shallowPaths === void 0 ? void 0 : shallowPaths.has(key)) {
                this.buildShallowGraphFromValue(parentVertex, childPathVertex, edgeValue, childPathArray, object4[key]);
            } else {
                this.buildGraphFromValue(parentVertex, childPathVertex, edgeValue, childPathArray, object4[key], shallowPaths);
            }
            if (key === "enabled") {
                enabledVertex = childPathVertex;
            }
        }
        this.buildGraphAutoEnable(parentVertex, edgeValue, object4, enabledVertex);
    }
    buildGraphAutoEnable(parentVertex, edgeValue, object4, enabledVertex) {
        if (edgeValue === DEFAULTS_EDGE && !enabledVertex) return;
        if (edgeValue === USER_OPTIONS_EDGE && enabledVertex) return;
        if (edgeValue !== DEFAULTS_EDGE && edgeValue !== USER_OPTIONS_EDGE && edgeValue !== OVERRIDES_EDGE) return;
        let autoEnableVertex = this.findNeighbour(parentVertex, AUTO_ENABLE_EDGE);
        if (!autoEnableVertex) {
            autoEnableVertex = this.addVertex(AUTO_ENABLE_EDGE);
            this.addEdge(parentVertex, autoEnableVertex, AUTO_ENABLE_EDGE);
        }
        if (enabledVertex) {
            this.addEdge(enabledVertex, autoEnableVertex, AUTO_ENABLE_VALUE_EDGE);
        }
        const { enabled, _enabledFromTheme } = object4;
        this.addEdge(autoEnableVertex, this.addVertex({
            enabled,
            _enabledFromTheme,
            keys: Object.keys(object4).length
        }), edgeValue);
    }
    getVertexChildrenByKey(vertex) {
        const pathNeighbours = this.neighboursWithEdgeValue(vertex, PATH_EDGE);
        if (!pathNeighbours) return;
        const pathVertices = /* @__PURE__ */ new Map();
        for (const neighbour of pathNeighbours){
            pathVertices.set(this.getVertexValue(neighbour), neighbour);
        }
        return pathVertices;
    }
    buildGraphFromValue(parentVertex, pathVertex, edgeValue, pathArray, value, shallowPaths) {
        this.addEdge(parentVertex, pathVertex, PATH_EDGE);
        let pathArrayVertex = this.findNeighbour(pathVertex, PATH_ARRAY_EDGE);
        if (!pathArrayVertex) {
            pathArrayVertex = this.addVertex([
                ...pathArray
            ]);
            this.addEdge(pathVertex, pathArrayVertex, PATH_ARRAY_EDGE);
        }
        const operation = getOperation(value);
        if (operation) {
            const valueVertex = this.addVertex(value);
            this.addEdge(pathVertex, valueVertex, edgeValue);
            this.addEdge(valueVertex, pathArrayVertex, PATH_ARRAY_EDGE);
            this.buildGraphFromOperation(valueVertex, edgeValue, operation, pathArrayVertex);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObjectLike"])(value)) {
            this.buildGraphFromObject(pathVertex, edgeValue, value, pathArrayVertex, shallowPaths);
        } else {
            const valueVertex = this.addVertex(value);
            this.addEdge(pathVertex, valueVertex, edgeValue);
        }
    }
    buildShallowGraphFromValue(parentVertex, pathVertex, edgeValue, pathArray, value) {
        this.addEdge(parentVertex, pathVertex, PATH_EDGE);
        let pathArrayVertex = this.findNeighbour(pathVertex, PATH_ARRAY_EDGE);
        if (!pathArrayVertex) {
            pathArrayVertex = this.addVertex([
                ...pathArray
            ]);
            this.addEdge(pathVertex, pathArrayVertex, PATH_ARRAY_EDGE);
        }
        const valueVertex = this.addVertex(value);
        this.addEdge(pathVertex, valueVertex, edgeValue);
    }
    buildGraphFromOperation(valueVertex, edgeValue, operation, pathArrayVertex) {
        const operationVertex = this.addVertex(operation.operation);
        this.addEdge(valueVertex, operationVertex, OPERATION_EDGE);
        for (const operationValue of operation.values){
            this.buildGraphFromOperationValue(valueVertex, operationValue, edgeValue, pathArrayVertex);
        }
    }
    buildGraphFromOperationValue(valueVertex, operationValue, edgeValue) {
        let pathArrayVertex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : this.EMPTY_PATH_ARRAY_VERTEX;
        const operationValueVertex = this.addVertex(operationValue);
        this.addEdge(valueVertex, pathArrayVertex, PATH_ARRAY_EDGE);
        this.addEdge(valueVertex, operationValueVertex, OPERATION_VALUE_EDGE);
        const innerOperation = getOperation(operationValue);
        if (innerOperation) {
            this.buildGraphFromOperation(operationValueVertex, edgeValue, innerOperation, pathArrayVertex);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObjectLike"])(operationValue)) {
            this.buildGraphFromObject(operationValueVertex, edgeValue, operationValue, pathArrayVertex);
        }
    }
    buildDependencyGraph() {
        for(let i = 0; i < this.pendingProcessingEdgesFrom.length; i++){
            const valueVertex = this.pendingProcessingEdgesFrom[i];
            const operationKeyVertex = this.pendingProcessingEdgesTo[i];
            const operation = this.getVertexValue(operationKeyVertex);
            if (!isOperation(operation)) continue;
            const operationValues = this.neighboursWithEdgeValue(valueVertex, OPERATION_VALUE_EDGE);
            const operator = operations[operation];
            const dependenciesFn = typeof operator === "function" ? void 0 : operator.dependencies;
            dependenciesFn === null || dependenciesFn === void 0 ? void 0 : dependenciesFn(this, valueVertex, operationValues !== null && operationValues !== void 0 ? operationValues : []);
        }
        this.pendingProcessingEdgesFrom = [];
        this.pendingProcessingEdgesTo = [];
    }
    resolveVertex(vertex) {
        let object4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.resolved;
        const pathArray = this.getPathArray(vertex);
        this.resolveVertexInEdgePriority(vertex, object4, pathArray);
        this.resolveVertexAutoEnable(vertex, object4, pathArray);
        this.resolveVertexChildren(vertex, object4);
    }
    resolveVertexInEdgePriority(vertex, object4, pathArray) {
        const children = this.neighboursWithEdgeValue(vertex, PATH_EDGE);
        const [highestPriority] = _OptionsGraph.EDGE_PRIORITY;
        for (const edgeValue of _OptionsGraph.EDGE_PRIORITY){
            const valueVertex = this.findNeighbour(vertex, edgeValue);
            if (valueVertex == null) continue;
            const value = this.resolveVertexValueInternal(vertex, valueVertex);
            if (value == null && edgeValue !== highestPriority) continue;
            if (children && children.length > 0 && Array.isArray(value) && edgeValue !== highestPriority) continue;
            if (pathArray.length === 0) {
                if (value == null) continue;
                this.resolved = value;
            } else {
                setPathSafe(object4, pathArray, value);
            }
            break;
        }
    }
    resolveVertexValueInternal(vertex, valueVertex) {
        this.resolveVertexDependencies(valueVertex);
        const operation = this.findNeighbourValue(valueVertex, OPERATION_EDGE);
        if (operation && isOperation(operation)) {
            const operationValues = this.neighboursWithEdgeValue(valueVertex, OPERATION_VALUE_EDGE);
            const operator = operations[operation];
            const operatorFn = typeof operator === "function" ? operator : operator.resolve;
            const resolved = operatorFn === null || operatorFn === void 0 ? void 0 : operatorFn(this, vertex, operationValues !== null && operationValues !== void 0 ? operationValues : []);
            return resolved === RESOLVED_TO_BRANCH ? void 0 : resolved;
        }
        return this.resolveValueOrSymbol(this.getVertexValue(valueVertex));
    }
    resolveVertexAutoEnable(vertex, object4, pathArray) {
        var _this_neighboursWithEdgeValue;
        const autoEnableValueVertex = (_this_neighboursWithEdgeValue = this.neighboursWithEdgeValue(vertex, AUTO_ENABLE_VALUE_EDGE)) === null || _this_neighboursWithEdgeValue === void 0 ? void 0 : _this_neighboursWithEdgeValue[0];
        if (!autoEnableValueVertex) return;
        const defaultsEnabled = this.findNeighbourValue(autoEnableValueVertex, DEFAULTS_EDGE);
        const overridesEnabled = this.findNeighbourValue(autoEnableValueVertex, OVERRIDES_EDGE);
        const userOptionsEnabled = this.findNeighbourValue(autoEnableValueVertex, USER_OPTIONS_EDGE);
        if (userOptionsEnabled && userOptionsEnabled.enabled == null && !(defaultsEnabled === null || defaultsEnabled === void 0 ? void 0 : defaultsEnabled._enabledFromTheme) && !(overridesEnabled === null || overridesEnabled === void 0 ? void 0 : overridesEnabled._enabledFromTheme)) {
            setPathSafe(object4, pathArray, true);
        }
    }
    resolveVertexChildren(vertex, object4) {
        const children = this.neighboursWithEdgeValue(vertex, PATH_EDGE);
        if (!children) return;
        for (const child of children){
            const path = this.getVertexValue(child);
            if (children.length > 1 && isOperation(path)) continue;
            if (path === "_enabledFromTheme") continue;
            this.resolveVertex(child, object4);
        }
    }
    resolveVertexDependencies(vertex) {
        const dependencies = this.neighboursWithEdgeValue(vertex, DEPENDENCY_EDGE);
        if (!dependencies) return;
        for (const dependency of dependencies){
            this.resolveVertex(dependency);
        }
    }
    graftAndResolveChildren(remoteBranch, orphanBranch, contextPathArray, orphanPathArray) {
        const remoteChildren = this.neighboursWithEdgeValue(remoteBranch, PATH_EDGE);
        if (!remoteChildren) return;
        for (const remoteChild of remoteChildren){
            const remoteChildPath = this.getVertexValue(remoteChild);
            const childContextPathArray = [
                ...contextPathArray,
                remoteChildPath
            ];
            const childOrphanPathArray = [
                ...orphanPathArray,
                remoteChildPath
            ];
            const orphanChildPathVertex = this.addVertex(remoteChildPath);
            const defaultValue = this.findNeighbourValue(remoteChild, DEFAULTS_EDGE);
            this.addEdge(orphanBranch, orphanChildPathVertex, PATH_EDGE);
            const orphanChildPathArrayVertex = this.addVertex(childContextPathArray);
            this.addEdge(orphanChildPathVertex, orphanChildPathArrayVertex, PATH_ARRAY_EDGE);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPlainObject"])(defaultValue)) {
                this.buildGraphFromObject(orphanChildPathVertex, DEFAULTS_EDGE, defaultValue, orphanChildPathArrayVertex);
                const orphanChildValueVertex = this.findNeighbour(orphanChildPathVertex, DEFAULTS_EDGE);
                this.addEdge(orphanChildValueVertex, this.addVertex(childContextPathArray), PATH_ARRAY_EDGE);
                const operation = this.findNeighbourValue(orphanChildValueVertex, OPERATION_EDGE);
                if (isOperation(operation)) {
                    const operationValues = this.neighboursWithEdgeValue(orphanChildValueVertex, OPERATION_VALUE_EDGE);
                    const operator = operations[operation];
                    const dependenciesFn = typeof operator === "function" ? void 0 : operator.dependencies;
                    dependenciesFn === null || dependenciesFn === void 0 ? void 0 : dependenciesFn(this, orphanChildValueVertex, operationValues !== null && operationValues !== void 0 ? operationValues : []);
                }
            }
            this.graftAndResolveChildren(remoteChild, orphanChildPathVertex, childContextPathArray, childOrphanPathArray);
        }
    }
    resolveValueOrSymbol(value) {
        var _this_internalParams;
        return typeof value === "symbol" && ((_this_internalParams = this.internalParams) === null || _this_internalParams === void 0 ? void 0 : _this_internalParams.has(value)) ? this.internalParams.get(value) : value;
    }
    constructor(config = {}, userOptions = {}, params = void 0, palette = void 0, overrides = {}, internalParams = /* @__PURE__ */ new Map()){
        var _userOptions_theme, _userOptions_series_, _userOptions_series, _config_seriesType, _overrides_common, _config_seriesType1, _overrides_common1;
        super(PATH_EDGE, OPERATION_EDGE);
        this.config = config;
        this.userOptions = userOptions;
        this.overrides = overrides;
        this.internalParams = internalParams;
        this.resolvedParams = {};
        this.resolvedAnnotations = {};
        // The current value referenced by operations that use `$1`.
        // eslint-disable-next-line @typescript-eslint/prefer-readonly
        this.value$1 = {};
        this.cachedPathVertices = /* @__PURE__ */ new Map();
        this.EMPTY_PATH_ARRAY_VERTEX = this.addVertex([]);
        this.root = this.addVertex("root");
        this.params = this.addVertex("params");
        this.annotations = this.addVertex("annotations");
        this.config = config;
        this.overrides = overrides;
        this.internalParams = internalParams;
        this.palette = palette ? deepClone(palette) : {};
        this.palette.type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(userOptions === null || userOptions === void 0 ? void 0 : userOptions.theme) ? paletteType((_userOptions_theme = userOptions.theme) === null || _userOptions_theme === void 0 ? void 0 : _userOptions_theme.palette) : "inbuilt";
        const DEFAULT_SERIES_TYPE = "line";
        var _userOptions_series__type;
        const seriesType = (_userOptions_series__type = (_userOptions_series = userOptions.series) === null || _userOptions_series === void 0 ? void 0 : (_userOptions_series_ = _userOptions_series[0]) === null || _userOptions_series_ === void 0 ? void 0 : _userOptions_series_.type) !== null && _userOptions_series__type !== void 0 ? _userOptions_series__type : DEFAULT_SERIES_TYPE;
        const defaultAxes = seriesRegistry.cloneDefaultAxes(seriesType);
        var _defaultAxes_axes, _userOptions_axes;
        (_userOptions_axes = userOptions.axes) !== null && _userOptions_axes !== void 0 ? _userOptions_axes : userOptions.axes = (_defaultAxes_axes = defaultAxes === null || defaultAxes === void 0 ? void 0 : defaultAxes.axes) !== null && _defaultAxes_axes !== void 0 ? _defaultAxes_axes : [];
        this.buildGraphFromObject(this.root, USER_OPTIONS_EDGE, without(userOptions, [
            "theme"
        ]));
        this.buildGraphFromObject(this.root, DEFAULTS_EDGE, without(config[seriesType], _OptionsGraph.COMPLEX_KEYS));
        const seriesOverrides = overrides ? without(overrides[seriesType], _OptionsGraph.COMPLEX_KEYS) : {};
        if (Object.keys(seriesOverrides).length > 0) {
            this.buildGraphFromObject(this.root, OVERRIDES_EDGE, seriesOverrides);
        }
        const commonOverrides = overrides ? without(overrides.common, _OptionsGraph.COMPLEX_KEYS) : {};
        if (Object.keys(commonOverrides).length > 0) {
            this.buildGraphFromObject(this.root, OVERRIDES_EDGE, chartTypes2.isCartesian(seriesType) ? commonOverrides : without(commonOverrides, [
                "zoom",
                "navigator"
            ]));
        }
        if (params) {
            this.buildGraphFromObject(this.params, DEFAULTS_EDGE, params);
        }
        const axesVertex = this.findNeighbourWithValue(this.root, "axes", PATH_EDGE);
        const seriesVertex = this.findNeighbourWithValue(this.root, "series", PATH_EDGE);
        if (axesVertex) {
            this.buildGraphFromObject(axesVertex, DEFAULTS_EDGE, {
                $applyTheme: [
                    [
                        "/$seriesType/axes/$axisType/$position",
                        "/$seriesType/axes/$axisType"
                    ],
                    {
                        seriesType: {
                            $path: [
                                "/series/0/type",
                                "line"
                            ]
                        },
                        axisType: {
                            $path: [
                                "./type",
                                "category"
                            ]
                        },
                        position: {
                            $path: [
                                "./position"
                            ]
                        }
                    },
                    [
                        "top",
                        "right",
                        "bottom",
                        "left"
                    ]
                ]
            });
        }
        if (seriesVertex) {
            this.buildGraphFromObject(seriesVertex, DEFAULTS_EDGE, {
                $applyTheme: [
                    "/$seriesType/series",
                    {
                        seriesType: {
                            $path: [
                                "./type",
                                "line"
                            ]
                        }
                    }
                ]
            });
        }
        var _config_seriesType_annotations;
        const annotationsTypeConfig = without((_config_seriesType_annotations = (_config_seriesType = config[seriesType]) === null || _config_seriesType === void 0 ? void 0 : _config_seriesType.annotations) !== null && _config_seriesType_annotations !== void 0 ? _config_seriesType_annotations : {}, _OptionsGraph.ANNOTATIONS_OPTIONS_KEYS);
        if (Object.keys(annotationsTypeConfig).length > 0) {
            this.buildGraphFromObject(this.annotations, DEFAULTS_EDGE, annotationsTypeConfig);
        }
        var _overrides_common_annotations;
        const annotationsTypeOverrides = without((_overrides_common_annotations = overrides === null || overrides === void 0 ? void 0 : (_overrides_common = overrides.common) === null || _overrides_common === void 0 ? void 0 : _overrides_common.annotations) !== null && _overrides_common_annotations !== void 0 ? _overrides_common_annotations : {}, _OptionsGraph.ANNOTATIONS_OPTIONS_KEYS);
        if (Object.keys(annotationsTypeOverrides).length > 0) {
            this.buildGraphFromObject(this.annotations, OVERRIDES_EDGE, annotationsTypeOverrides);
        }
        var _config_seriesType_annotations1;
        const annotationsConfig = pick((_config_seriesType_annotations1 = (_config_seriesType1 = config[seriesType]) === null || _config_seriesType1 === void 0 ? void 0 : _config_seriesType1.annotations) !== null && _config_seriesType_annotations1 !== void 0 ? _config_seriesType_annotations1 : {}, _OptionsGraph.ANNOTATIONS_OPTIONS_KEYS);
        if (Object.keys(annotationsConfig).length > 0) {
            this.buildGraphFromObject(this.root, DEFAULTS_EDGE, {
                annotations: annotationsConfig
            });
        }
        var _overrides_common_annotations1;
        const annotationsOverrides = pick((_overrides_common_annotations1 = overrides === null || overrides === void 0 ? void 0 : (_overrides_common1 = overrides.common) === null || _overrides_common1 === void 0 ? void 0 : _overrides_common1.annotations) !== null && _overrides_common_annotations1 !== void 0 ? _overrides_common_annotations1 : {}, _OptionsGraph.ANNOTATIONS_OPTIONS_KEYS);
        if (Object.keys(annotationsOverrides).length > 0) {
            this.buildGraphFromObject(this.root, OVERRIDES_EDGE, {
                annotations: annotationsOverrides
            });
        }
        this.buildDependencyGraph();
    }
};
// The priority order in which to resolve options values.
_OptionsGraph.EDGE_PRIORITY = [
    USER_OPTIONS_EDGE,
    OVERRIDES_EDGE,
    DEFAULTS_EDGE
];
// These keys must be stored as shallow objects in the graph and not manipulated.
_OptionsGraph.SHALLOW_KEYS = /* @__PURE__ */ new Set([
    "context",
    "data",
    "topology"
]);
// These keys must be excluded when building the graph, they are instead resolved separately since they are objects
// that must be applied to arrays.
_OptionsGraph.COMPLEX_KEYS = [
    "annotations",
    "axes",
    "series"
];
_OptionsGraph.ANNOTATIONS_OPTIONS_KEYS = [
    "axesButtons",
    "data",
    "enabled",
    "optionsToolbar",
    "snap",
    "toolbar",
    "xKey",
    "volumeKey"
];
var OptionsGraph = _OptionsGraph;
// packages/ag-charts-community/src/module/optionsModule.ts
var stringFormat = (value)=>"'".concat(value, "'");
var _ChartOptions = class _ChartOptions {
    static isFastPathDelta(deltaOptions) {
        for (const key of Object.keys(deltaOptions !== null && deltaOptions !== void 0 ? deltaOptions : {})){
            if (!this.FAST_PATH_OPTIONS.has(key)) {
                _ChartOptions.perfDebug("ChartOptions.isFastPathDelta() - slow path required due to presence of: ", key);
                return false;
            }
        }
        _ChartOptions.perfDebug("ChartOptions.isFastPathDelta() - fast path possible.");
        return true;
    }
    fastSetup(deltaOptions, baseChartOptions) {
        const { activeTheme, processedOptions: baseOptions } = baseChartOptions;
        const { presetType } = this.optionMetadata;
        if (presetType != null && (deltaOptions === null || deltaOptions === void 0 ? void 0 : deltaOptions.data) != null) {
            const presetDef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].getPresetModule(presetType);
            if (presetDef === null || presetDef === void 0 ? void 0 : presetDef.processData) {
                const { series, data } = presetDef.processData(deltaOptions.data);
                deltaOptions = mergeDefaults({
                    series,
                    data
                }, deltaOptions);
            }
        }
        this.fastSeriesSetup(deltaOptions, baseOptions);
        const processedOptions = mergeDefaults(deltaOptions, baseOptions);
        _ChartOptions.debug("ChartOptions.fastSetup() - processed options", processedOptions);
        return {
            activeTheme,
            processedOptions,
            fastDelta: deltaOptions
        };
    }
    fastSeriesSetup(deltaOptions, baseOptions) {
        var _deltaOptions_series;
        if (!(deltaOptions === null || deltaOptions === void 0 ? void 0 : deltaOptions.series)) return;
        if ((_deltaOptions_series = deltaOptions.series) === null || _deltaOptions_series === void 0 ? void 0 : _deltaOptions_series.every((s, i)=>{
            var _baseOptions_series;
            var _baseOptions_series_i;
            return jsonPropertyCompare(s, (_baseOptions_series_i = (_baseOptions_series = baseOptions.series) === null || _baseOptions_series === void 0 ? void 0 : _baseOptions_series[i]) !== null && _baseOptions_series_i !== void 0 ? _baseOptions_series_i : {});
        })) {
            delete deltaOptions["series"];
        } else {
            deltaOptions.series = deltaOptions.series.map((s, i)=>{
                var _baseOptions_series;
                var _baseOptions_series_i;
                return merge(s, (_baseOptions_series_i = (_baseOptions_series = baseOptions.series) === null || _baseOptions_series === void 0 ? void 0 : _baseOptions_series[i]) !== null && _baseOptions_series_i !== void 0 ? _baseOptions_series_i : {});
            });
        }
    }
    slowSetup(processedOverrides, deltaOptions) {
        let stripSymbols = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        let options = deepClone(this.userOptions, _ChartOptions.OPTIONS_CLONE_OPTS_FAST);
        if (deltaOptions) {
            options = mergeDefaults(deltaOptions, options);
            if (stripSymbols) {
                this.removeLeftoverSymbols(options);
            }
        }
        const { presetType } = this.optionMetadata;
        if (presetType != null) {
            const presetDef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].getPresetModule(presetType);
            if (presetDef) {
                const { validate: validatePreset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"] } = presetDef;
                const presetParams = options;
                const presetSubType = options.type;
                const presetTheme = presetSubType != null ? getChartTheme(options.theme).presets[presetSubType] : void 0;
                const { cleared, invalid } = validatePreset(presetParams, presetDef.options, "");
                invalid.forEach((error)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn(error));
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasRequiredInPath"])(invalid, "")) {
                    options = {};
                } else {
                    _ChartOptions.debug(">>> AgCharts.createOrUpdate() - applying preset", cleared);
                    options = presetDef.create(cleared, presetTheme, ()=>this.activeTheme);
                }
            }
        }
        this.soloSeriesIntegrity(options);
        if (!enterpriseModule.isEnterprise) {
            removeUsedEnterpriseOptions(options);
        }
        const activeTheme = getChartTheme(options.theme);
        if (presetType != null) {
            activeTheme.templateTheme(options, false);
        }
        this.validateSeriesOptions(options);
        this.chartDef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].detectChartDefinition(options);
        if (!this.chartDef.placeholder) {
            const { validate: validateChart = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"] } = this.chartDef;
            const { cleared, invalid } = validateChart(options, this.chartDef.options, "");
            invalid.forEach((error)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn(error));
            options = cleared;
        }
        this.validateAxesOptions(options);
        this.removeDisabledOptions(options);
        let googleFonts = this.processFonts(activeTheme.params);
        googleFonts = this.processFonts(options, googleFonts);
        this.processSeriesOptions(options);
        const optionsGraph = createOptionsGraph(activeTheme, options);
        const resolvedOptions = optionsGraph.resolve();
        const themeParameters = optionsGraph.resolveParams();
        const annotationThemes = optionsGraph.resolveAnnotationThemes();
        optionsGraph.clear();
        const processedOptions = mergeDefaults(processedOverrides, resolvedOptions);
        removeUnusedEnterpriseOptions(processedOptions);
        if (!enterpriseModule.isEnterprise) {
            removeUsedEnterpriseOptions(processedOptions, true);
        }
        this.validateSeriesOptions(processedOptions);
        this.validateAxesOptions(processedOptions);
        this.validatePluginOptions(processedOptions);
        this.processMiniChartSeriesOptions(processedOptions);
        if (!processedOptions.loadGoogleFonts) {
            googleFonts.clear();
        }
        _ChartOptions.debug(()=>[
                "ChartOptions.slowSetup() - processed options",
                deepClone(processedOptions)
            ]);
        return {
            activeTheme,
            processedOptions,
            themeParameters,
            annotationThemes,
            googleFonts
        };
    }
    validatePluginOptions(options) {
        for (const pluginDef of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].listModulesByType(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleType"].Plugin)){
            var _this_chartDef;
            const pluginKey = pluginDef.name;
            if (pluginKey in options && (!pluginDef.chartType || pluginDef.chartType === ((_this_chartDef = this.chartDef) === null || _this_chartDef === void 0 ? void 0 : _this_chartDef.name))) {
                const { cleared, invalid } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"])(options[pluginKey], pluginDef.options, pluginDef.name);
                invalid.forEach((error)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn(error));
                options[pluginKey] = cleared;
            }
        }
    }
    validateSeriesOptions(options) {
        var _this_chartDef, _options_series;
        const chartType = (_this_chartDef = this.chartDef) === null || _this_chartDef === void 0 ? void 0 : _this_chartDef.name;
        const validatedSeriesOptions = [];
        var _options_series_length;
        const seriesCount = (_options_series_length = (_options_series = options.series) === null || _options_series === void 0 ? void 0 : _options_series.length) !== null && _options_series_length !== void 0 ? _options_series_length : 0;
        let validSeriesTypes;
        for(let index = 0; index < seriesCount; index++){
            const keyPath = "series[".concat(index, "]");
            const seriesOptions = options.series[index];
            const seriesDef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].getSeriesModule(seriesOptions.type);
            if (seriesDef == null) {
                validSeriesTypes !== null && validSeriesTypes !== void 0 ? validSeriesTypes : validSeriesTypes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinFormatted"])(Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].listModulesByType(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleType"].Series)).filter((def)=>!chartType || def.chartType === chartType).map((def)=>def.name), "or", stringFormat);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn(seriesOptions.type == null ? "Option `".concat(keyPath, ".type` is required and has not been provided; expecting ").concat(validSeriesTypes, ", ignoring.") : "Unknown type `".concat(seriesOptions.type, "` at `").concat(keyPath, ".type`; expecting ").concat(validSeriesTypes, ", ignoring."));
                continue;
            } else if (chartType && seriesDef.chartType !== chartType) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("Series type `".concat(seriesDef.name, "` at `").concat(keyPath, ".type` is not supported by chart type `").concat(chartType, "`, ignoring."));
                continue;
            }
            const { validate: validateSeries = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"] } = seriesDef;
            const { cleared, invalid } = validateSeries(seriesOptions, seriesDef.options, keyPath);
            invalid.forEach((error)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn(error));
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasRequiredInPath"])(invalid, keyPath)) {
                validatedSeriesOptions.push(cleared);
            }
        }
        options.series = validatedSeriesOptions;
    }
    validateAxesOptions(options) {
        var _this_chartDef;
        if (!("axes" in options) || !options.axes) return;
        const chartType = (_this_chartDef = this.chartDef) === null || _this_chartDef === void 0 ? void 0 : _this_chartDef.name;
        const validatedAxesOptions = [];
        var _options_axes_length;
        const axesCount = (_options_axes_length = options.axes.length) !== null && _options_axes_length !== void 0 ? _options_axes_length : 0;
        let validAxesTypes;
        for(let index = 0; index < axesCount; index++){
            const keyPath = "axes[".concat(index, "]");
            const axisOptions = options.axes[index];
            const axisDef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].getAxisModule(axisOptions.type);
            if (axisDef == null) {
                validAxesTypes !== null && validAxesTypes !== void 0 ? validAxesTypes : validAxesTypes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinFormatted"])(Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].listModulesByType(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleType"].Axis)).filter((def)=>def.chartType === chartType).map((def)=>def.name), "or", stringFormat);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("Unknown type `".concat(axisOptions.type, "` at  `").concat(keyPath, ".type`; expecting one of ").concat(validAxesTypes, ", ignoring all axes options."));
                delete options.axes;
                break;
            } else if (axisDef.chartType !== chartType) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("Axis type `".concat(axisDef.name, "` at  `").concat(keyPath, ".type` is not supported by chart type `").concat(chartType, "`, ignoring."));
                break;
            }
            const { validate: validateAxis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"] } = axisDef;
            const { cleared, invalid } = validateAxis(axisOptions, axisDef.options, keyPath);
            invalid.forEach((error)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn(error));
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasRequiredInPath"])(invalid, keyPath)) {
                validatedAxesOptions.push(cleared);
            }
        }
        options.axes = validatedAxesOptions;
    }
    diffOptions(other) {
        if (this === other) return {};
        if (other == null) return this.processedOptions;
        var _this_fastDelta;
        return (_this_fastDelta = this.fastDelta) !== null && _this_fastDelta !== void 0 ? _this_fastDelta : jsonDiff(other.processedOptions, this.processedOptions, _ChartOptions.JSON_DIFF_OPTS);
    }
    optionsType(options) {
        var _options_series_, _options_series;
        var _options_series__type;
        return (_options_series__type = (_options_series = options.series) === null || _options_series === void 0 ? void 0 : (_options_series_ = _options_series[0]) === null || _options_series_ === void 0 ? void 0 : _options_series_.type) !== null && _options_series__type !== void 0 ? _options_series__type : "line";
    }
    processSeriesOptions(options) {
        var _options_series;
        const processedSeries = (_options_series = options.series) === null || _options_series === void 0 ? void 0 : _options_series.map((series)=>{
            var _series_type;
            (_series_type = series.type) !== null && _series_type !== void 0 ? _series_type : series.type = "line";
            const seriesDef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].getSeriesModule(series.type);
            const visibleDefined = Boolean(seriesDef === null || seriesDef === void 0 ? void 0 : seriesDef.options.visible);
            const seriesOptions = mergeDefaults(this.getSeriesGroupingOptions(series), series, visibleDefined && {
                visible: true
            });
            return seriesOptions;
        });
        options.series = this.setSeriesGroupingOptions(processedSeries !== null && processedSeries !== void 0 ? processedSeries : []);
    }
    processMiniChartSeriesOptions(options) {
        var _options_navigator_miniChart, _options_navigator;
        const miniChartSeries = (_options_navigator = options.navigator) === null || _options_navigator === void 0 ? void 0 : (_options_navigator_miniChart = _options_navigator.miniChart) === null || _options_navigator_miniChart === void 0 ? void 0 : _options_navigator_miniChart.series;
        if (miniChartSeries == null) return;
        options.navigator.miniChart.series = this.setSeriesGroupingOptions(miniChartSeries);
    }
    getSeriesGroupingOptions(series) {
        const groupable = seriesRegistry.isGroupable(series.type);
        const stackable = seriesRegistry.isStackable(series.type);
        const stackedByDefault = seriesRegistry.isStackedByDefault(series.type);
        if (series.grouped && !groupable) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce('unsupported grouping of series type "'.concat(series.type, '".'));
        }
        if ((series.stacked || series.stackGroup) && !stackable) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce('unsupported stacking of series type "'.concat(series.type, '".'));
        }
        let { grouped, stacked } = series;
        stacked !== null && stacked !== void 0 ? stacked : stacked = (stackedByDefault || series.stackGroup != null) && !(groupable && grouped);
        grouped !== null && grouped !== void 0 ? grouped : grouped = true;
        return {
            stacked: stackable && stacked,
            grouped: groupable && grouped && !(stackable && stacked)
        };
    }
    setSeriesGroupingOptions(allSeries) {
        const seriesGroups = this.getSeriesGrouping(allSeries);
        _ChartOptions.debug("ChartOptions.setSeriesGroupingOptions() - series grouping: ", seriesGroups);
        const groupIdx = {};
        const groupCount2 = seriesGroups.reduce((countMap, seriesGroup)=>{
            var _a;
            if (seriesGroup.groupType === "default" /* DEFAULT */ ) {
                return countMap;
            }
            var _countMap_;
            (_countMap_ = countMap[_a = seriesGroup.seriesType]) !== null && _countMap_ !== void 0 ? _countMap_ : countMap[_a] = 0;
            countMap[seriesGroup.seriesType] += seriesGroup.groupType === "stack" /* STACK */  ? 1 : seriesGroup.series.length;
            return countMap;
        }, {});
        return seriesGroups.flatMap((seriesGroup)=>{
            var _a;
            var _groupIdx_;
            (_groupIdx_ = groupIdx[_a = seriesGroup.seriesType]) !== null && _groupIdx_ !== void 0 ? _groupIdx_ : groupIdx[_a] = 0;
            switch(seriesGroup.groupType){
                case "stack" /* STACK */ :
                    {
                        const groupIndex = groupIdx[seriesGroup.seriesType]++;
                        return seriesGroup.series.map((series, stackIndex)=>Object.assign(series, {
                                seriesGrouping: {
                                    groupId: seriesGroup.groupId,
                                    groupIndex,
                                    groupCount: groupCount2[seriesGroup.seriesType],
                                    stackIndex,
                                    stackCount: seriesGroup.series.length
                                }
                            }));
                    }
                case "group" /* GROUP */ :
                    return seriesGroup.series.map((series)=>Object.assign(series, {
                            seriesGrouping: {
                                groupId: seriesGroup.groupId,
                                groupIndex: groupIdx[seriesGroup.seriesType]++,
                                groupCount: groupCount2[seriesGroup.seriesType],
                                stackIndex: 0,
                                stackCount: 0
                            }
                        }));
            }
            return seriesGroup.series;
        }).map((param)=>{
            let { stacked: _, grouped: __, ...seriesOptions } = param;
            return seriesOptions;
        });
    }
    getSeriesGroupId(series) {
        var _series_stackGroup;
        return [
            series.type,
            series.xKey,
            series.stacked ? (_series_stackGroup = series.stackGroup) !== null && _series_stackGroup !== void 0 ? _series_stackGroup : "stacked" : "grouped"
        ].filter(Boolean).join("-");
    }
    getSeriesGrouping(allSeries) {
        const groupMap = /* @__PURE__ */ new Map();
        return allSeries.reduce((result, series)=>{
            const seriesType = series.type;
            if (!series.stacked && !series.grouped) {
                result.push({
                    groupType: "default" /* DEFAULT */ ,
                    seriesType,
                    series: [
                        series
                    ],
                    groupId: "__default__"
                });
            } else {
                const groupId = this.getSeriesGroupId(series);
                if (!groupMap.has(groupId)) {
                    const groupType = series.stacked ? "stack" /* STACK */  : "group" /* GROUP */ ;
                    const record = {
                        groupType,
                        seriesType,
                        series: [],
                        groupId
                    };
                    groupMap.set(groupId, record);
                    result.push(record);
                }
                groupMap.get(groupId).series.push(series);
            }
            return result;
        }, []);
    }
    soloSeriesIntegrity(options) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isArray"])(options.series)) return;
        const allSeries = options.series;
        if (allSeries && allSeries.length > 1 && allSeries.some((series)=>seriesRegistry.isSolo(series.type))) {
            const mainSeriesType = this.optionsType(options);
            if (seriesRegistry.isSolo(mainSeriesType)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("series[0] of type '".concat(mainSeriesType, "' is incompatible with other series types. Only processing series[0]"));
                options.series = allSeries.slice(0, 1);
            } else {
                const { solo, nonSolo } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["groupBy"])(allSeries, (s)=>seriesRegistry.isSolo(s.type) ? "solo" : "nonSolo");
                const rejects = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unique"])(solo.map((s)=>s.type)).join(", ");
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("Unable to mix these series types with the lead series type: ".concat(rejects));
                options.series = nonSolo;
            }
        }
    }
    static processFontOptions(node, _, __) {
        let googleFonts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : /* @__PURE__ */ new Set();
        if (typeof node === "object" && "fontFamily" in node) {
            if (Array.isArray(node.fontFamily)) {
                const fontFamily = [];
                for (const font2 of node.fontFamily){
                    if (typeof font2 === "object" && "googleFont" in font2) {
                        fontFamily.push(font2.googleFont);
                        googleFonts === null || googleFonts === void 0 ? void 0 : googleFonts.add(font2.googleFont);
                    } else {
                        fontFamily.push(font2);
                    }
                }
                node.fontFamily = fontFamily.join(", ");
            } else if (typeof node.fontFamily === "object" && "googleFont" in node.fontFamily) {
                node.fontFamily = node.fontFamily.googleFont;
                googleFonts === null || googleFonts === void 0 ? void 0 : googleFonts.add(node.fontFamily);
            }
        }
        return googleFonts;
    }
    processFonts(options) {
        let googleFonts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
        return jsonWalk(options, _ChartOptions.processFontOptions, /* @__PURE__ */ new Set([
            "data",
            "theme"
        ]), void 0, void 0, googleFonts);
    }
    static removeDisabledOptionJson(optionsNode) {
        if ("enabled" in optionsNode && optionsNode.enabled === false) {
            Object.keys(optionsNode).forEach((key)=>{
                if (key === "enabled") return;
                delete optionsNode[key];
            });
        }
    }
    removeDisabledOptions(options) {
        jsonWalk(options, _ChartOptions.removeDisabledOptionJson, /* @__PURE__ */ new Set([
            "data",
            "theme",
            "contextMenu"
        ]));
    }
    static removeLeftoverSymbolsJson(optionsNode) {
        if (!optionsNode || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(optionsNode)) return;
        for (const key of Object.keys(optionsNode)){
            const value = optionsNode[key];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSymbol"])(value)) {
                delete optionsNode[key];
            }
        }
    }
    removeLeftoverSymbols(options) {
        jsonWalk(options, _ChartOptions.removeLeftoverSymbolsJson, /* @__PURE__ */ new Set([
            "data"
        ]));
    }
    specialOverridesDefaults(options) {
        if (options.window == null) {
            options.window = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])();
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setWindow"])(options.window);
        }
        if (options.document == null) {
            options.document = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])();
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setDocument"])(options.document);
        }
        if (options.window == null) {
            throw new Error("AG Charts - unable to resolve global window");
        }
        if (options.document == null) {
            throw new Error("AG Charts - unable to resolve global document");
        }
        return options;
    }
    constructor(currentUserOptions, newUserOptions, processedOverrides, specialOverrides, metadata, deltaOptions, stripSymbols = false, apiStartTime){
        this.themeParameters = {};
        this.optionMetadata = metadata !== null && metadata !== void 0 ? metadata : {};
        this.processedOverrides = processedOverrides !== null && processedOverrides !== void 0 ? processedOverrides : {};
        let baseChartOptions = null;
        if (currentUserOptions instanceof _ChartOptions) {
            baseChartOptions = currentUserOptions;
            this.specialOverrides = baseChartOptions.specialOverrides;
            if (deltaOptions === void 0) {
                deltaOptions = jsonDiff(baseChartOptions.userOptions, newUserOptions, _ChartOptions.JSON_DIFF_OPTS);
            }
            this.userOptions = deepClone(merge(deltaOptions, baseChartOptions.userOptions), {
                ..._ChartOptions.OPTIONS_CLONE_OPTS_SLOW,
                seen: []
            });
        } else {
            this.userOptions = deepClone(currentUserOptions !== null && currentUserOptions !== void 0 ? currentUserOptions : newUserOptions, {
                ..._ChartOptions.OPTIONS_CLONE_OPTS_SLOW,
                seen: []
            });
            this.specialOverrides = this.specialOverridesDefaults({
                ...specialOverrides
            });
        }
        if (stripSymbols) {
            this.removeLeftoverSymbols(this.userOptions);
        }
        let activeTheme, processedOptions, fastDelta, themeParameters, annotationThemes, googleFonts;
        if (!stripSymbols && deltaOptions !== void 0 && _ChartOptions.isFastPathDelta(deltaOptions) && baseChartOptions != null) {
            ({ activeTheme, processedOptions, fastDelta } = this.fastSetup(deltaOptions, baseChartOptions));
            themeParameters = baseChartOptions.themeParameters;
            annotationThemes = baseChartOptions.annotationThemes;
        } else {
            _ChartOptions.perfDebug("ChartOptions.slowSetup()");
            ({ activeTheme, processedOptions, themeParameters, annotationThemes, googleFonts } = this.slowSetup(processedOverrides, deltaOptions, stripSymbols));
        }
        this.activeTheme = activeTheme;
        this.processedOptions = processedOptions;
        this.fastDelta = fastDelta !== null && fastDelta !== void 0 ? fastDelta : void 0;
        this.themeParameters = themeParameters;
        this.annotationThemes = annotationThemes;
        this.googleFonts = googleFonts;
        if (apiStartTime !== void 0 && typeof apiStartTime === "number" && !isNaN(apiStartTime)) {
            const endTime = performance.now();
            this.optionsProcessingTime = endTime - apiStartTime;
        }
        Debug.inDevelopmentMode(()=>deepFreeze(this));
    }
};
_ChartOptions.OPTIONS_CLONE_OPTS_SLOW = {
    shallow: /* @__PURE__ */ new Set([
        "data",
        "container"
    ]),
    assign: /* @__PURE__ */ new Set([
        "context",
        "theme"
    ])
};
_ChartOptions.OPTIONS_CLONE_OPTS_FAST = {
    shallow: /* @__PURE__ */ new Set([
        "container"
    ]),
    assign: /* @__PURE__ */ new Set([
        "data",
        "context",
        "theme"
    ])
};
_ChartOptions.JSON_DIFF_OPTS = /* @__PURE__ */ new Set([
    "data"
]);
_ChartOptions.perfDebug = Debug.create(true, "perf");
_ChartOptions.FAST_PATH_OPTIONS = /* @__PURE__ */ new Set([
    "data",
    "width",
    "height",
    "container"
]);
_ChartOptions.debug = Debug.create(true, "opts");
var ChartOptions = _ChartOptions;
// packages/ag-charts-community/src/chart/chartProxy.ts
var debug2 = Debug.create(true, "opts");
var DESTROYED_ERROR = "AG Charts - Chart was destroyed, cannot perform request.";
var _AgChartInstanceProxy = class _AgChartInstanceProxy {
    async update(options) {
        if (!this.chart) throw new Error(DESTROYED_ERROR);
        return debug2.group("AgChartInstance.update()", async ()=>{
            var _this_chart;
            const apiStartTime = Debug.check("scene:stats", "scene:stats:verbose") ? performance.now() : void 0;
            this.factoryApi.update(options, this, void 0, apiStartTime);
            await ((_this_chart = this.chart) === null || _this_chart === void 0 ? void 0 : _this_chart.waitForUpdate());
        });
    }
    async updateDelta(deltaOptions) {
        if (!this.chart) throw new Error(DESTROYED_ERROR);
        return debug2.group("AgChartInstance.updateDelta()", async ()=>{
            var _this_chart;
            const apiStartTime = Debug.check("scene:stats", "scene:stats:verbose") ? performance.now() : void 0;
            this.factoryApi.updateUserDelta(this, deltaOptions, apiStartTime);
            await ((_this_chart = this.chart) === null || _this_chart === void 0 ? void 0 : _this_chart.waitForUpdate());
        });
    }
    getOptions() {
        if (!this.chart) throw new Error(DESTROYED_ERROR);
        const options = deepClone(this.chart.getOptions(), ChartOptions.OPTIONS_CLONE_OPTS_FAST);
        for (const key of Object.keys(options)){
            if (key.startsWith("_")) {
                delete options[key];
            }
        }
        return options;
    }
    waitForUpdate() {
        if (!this.chart) throw new Error(DESTROYED_ERROR);
        return this.chart.waitForUpdate();
    }
    async download(opts) {
        if (!this.chart) throw new Error(DESTROYED_ERROR);
        const clone2 = await this.prepareResizedChart(this, this.chart, opts);
        try {
            var _clone2_chart;
            (_clone2_chart = clone2.chart) === null || _clone2_chart === void 0 ? void 0 : _clone2_chart.download(opts === null || opts === void 0 ? void 0 : opts.fileName, opts === null || opts === void 0 ? void 0 : opts.fileFormat);
        } finally{
            clone2.destroy();
        }
    }
    async __toSVG(opts) {
        if (!this.chart) throw new Error(DESTROYED_ERROR);
        const clone2 = await this.prepareResizedChart(this, this.chart, {
            width: 600,
            height: 300,
            ...opts
        });
        try {
            var _clone2_chart;
            return clone2 === null || clone2 === void 0 ? void 0 : (_clone2_chart = clone2.chart) === null || _clone2_chart === void 0 ? void 0 : _clone2_chart.toSVG();
        } finally{
            clone2 === null || clone2 === void 0 ? void 0 : clone2.destroy();
        }
    }
    async getImageDataURL(opts) {
        if (!this.chart) throw new Error(DESTROYED_ERROR);
        const clone2 = await this.prepareResizedChart(this, this.chart, opts);
        try {
            return clone2.chart.getCanvasDataURL(opts === null || opts === void 0 ? void 0 : opts.fileFormat);
        } finally{
            clone2.destroy();
        }
    }
    getState() {
        return this.factoryApi.caretaker.save(...this.getEnabledOriginators());
    }
    async setState(state) {
        const { chart } = this;
        if (!chart) return;
        const originators = this.getEnabledOriginators();
        if (!originators.includes(chart.ctx.legendManager)) {
            await this.setStateOriginators(state, originators);
            return;
        }
        await this.setStateOriginators(state, originators.filter((originator)=>originator !== chart.ctx.zoomManager));
        await this.setStateOriginators(state, [
            chart.ctx.zoomManager
        ]);
    }
    resetAnimations() {
        var _this_chart;
        (_this_chart = this.chart) === null || _this_chart === void 0 ? void 0 : _this_chart.resetAnimations();
    }
    skipAnimations() {
        var _this_chart;
        (_this_chart = this.chart) === null || _this_chart === void 0 ? void 0 : _this_chart.skipAnimations();
    }
    destroy() {
        if (this.releaseChart) {
            this.releaseChart();
            this.releaseChart = void 0;
        } else if (this.chart) {
            this.chart.publicApi = void 0;
            this.chart.destroy();
        }
        this.chart = void 0;
    }
    async prepareResizedChart(proxy, chart) {
        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var _this_chart, _cloneProxy_chart, _cloneProxy_chart1, _cloneProxy_chart2, _cloneProxy_chart3;
        var _opts_width, _ref;
        const width2 = (_ref = (_opts_width = opts.width) !== null && _opts_width !== void 0 ? _opts_width : chart.width) !== null && _ref !== void 0 ? _ref : chart.ctx.scene.canvas.width;
        var _opts_height, _ref1;
        const height2 = (_ref1 = (_opts_height = opts.height) !== null && _opts_height !== void 0 ? _opts_height : chart.height) !== null && _ref1 !== void 0 ? _ref1 : chart.ctx.scene.canvas.height;
        const state = proxy.getState();
        const isEnterprise = moduleRegistry.hasEnterpriseModules();
        const processedOverrides = {
            ...chart.chartOptions.processedOverrides,
            container: document.createElement("div"),
            width: width2,
            height: height2
        };
        if (opts.width != null && opts.height != null) {
            processedOverrides.overrideDevicePixelRatio = 1;
        }
        const userOptions = chart.getOptions();
        if (isEnterprise) {
            var _this_licenseManager;
            processedOverrides.animation = {
                enabled: false
            };
            if ((_this_licenseManager = this.licenseManager) === null || _this_licenseManager === void 0 ? void 0 : _this_licenseManager.isDisplayWatermark()) {
                processedOverrides.foreground = {
                    text: this.licenseManager.getWatermarkMessage(),
                    image: {
                        url: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=",
                        width: 170,
                        height: 25,
                        right: 25,
                        bottom: 50,
                        opacity: 0.7
                    }
                };
            }
        }
        const specialOverrides = {
            ...chart.chartOptions.specialOverrides
        };
        const optionsMetadata = {
            ...chart.chartOptions.optionMetadata
        };
        const data = await ((_this_chart = this.chart) === null || _this_chart === void 0 ? void 0 : _this_chart.ctx.dataService.getData());
        const cloneProxy = this.factoryApi.create(userOptions, processedOverrides, specialOverrides, optionsMetadata, data);
        await cloneProxy.setState(state);
        (_cloneProxy_chart = cloneProxy.chart) === null || _cloneProxy_chart === void 0 ? void 0 : _cloneProxy_chart.ctx.zoomManager.updateZoom("chartProxy", chart.ctx.zoomManager.getZoom());
        (_cloneProxy_chart1 = cloneProxy.chart) === null || _cloneProxy_chart1 === void 0 ? void 0 : _cloneProxy_chart1.ctx.legendManager.clearData();
        (_cloneProxy_chart2 = cloneProxy.chart) === null || _cloneProxy_chart2 === void 0 ? void 0 : _cloneProxy_chart2.ctx.legendManager.update(chart.ctx.legendManager.getData());
        chart.series.forEach((series, index)=>{
            cloneProxy.chart.series[index].visible = series.visible;
        });
        const legendPages = [];
        for (const legend of chart.modulesManager.legends()){
            var _legend_legend_pagination;
            var _legend_legend_pagination_currentPage;
            legendPages.push((_legend_legend_pagination_currentPage = (_legend_legend_pagination = legend.legend.pagination) === null || _legend_legend_pagination === void 0 ? void 0 : _legend_legend_pagination.currentPage) !== null && _legend_legend_pagination_currentPage !== void 0 ? _legend_legend_pagination_currentPage : 0);
        }
        for (const legend of cloneProxy.chart.modulesManager.legends()){
            var _legendPages_shift;
            const page = (_legendPages_shift = legendPages.shift()) !== null && _legendPages_shift !== void 0 ? _legendPages_shift : 0;
            if (!legend.legend.pagination) continue;
            legend.legend.pagination.setPage(page);
        }
        (_cloneProxy_chart3 = cloneProxy.chart) === null || _cloneProxy_chart3 === void 0 ? void 0 : _cloneProxy_chart3.update(0 /* FULL */ , {
            forceNodeDataRefresh: true
        });
        await cloneProxy.waitForUpdate();
        return cloneProxy;
    }
    getEnabledOriginators() {
        var _processedOptions_annotations, _processedOptions_navigator, _processedOptions_zoom;
        if (!this.chart) return [];
        const { chartOptions: { processedOptions, optionMetadata }, ctx: { annotationManager, chartTypeOriginator, zoomManager, legendManager } } = this.chart;
        const originators = [];
        if ("annotations" in processedOptions && ((_processedOptions_annotations = processedOptions.annotations) === null || _processedOptions_annotations === void 0 ? void 0 : _processedOptions_annotations.enabled)) {
            originators.push(annotationManager);
        }
        const isFinancialChart = optionMetadata.presetType === "price-volume";
        if (isFinancialChart) {
            originators.push(chartTypeOriginator);
        }
        if (((_processedOptions_navigator = processedOptions.navigator) === null || _processedOptions_navigator === void 0 ? void 0 : _processedOptions_navigator.enabled) || ((_processedOptions_zoom = processedOptions.zoom) === null || _processedOptions_zoom === void 0 ? void 0 : _processedOptions_zoom.enabled)) {
            originators.push(zoomManager);
        }
        if ("legend" in this.chart) {
            originators.push(legendManager);
        }
        return originators;
    }
    async setStateOriginators(state, originators) {
        var _this_chart, _this_chart1;
        this.factoryApi.caretaker.restore(state, ...originators);
        (_this_chart = this.chart) === null || _this_chart === void 0 ? void 0 : _this_chart.ctx.updateService.update(2 /* PROCESS_DATA */ , {
            forceNodeDataRefresh: true
        });
        await ((_this_chart1 = this.chart) === null || _this_chart1 === void 0 ? void 0 : _this_chart1.waitForUpdate());
    }
    constructor(chart, factoryApi, licenseManager){
        this.factoryApi = factoryApi;
        this.licenseManager = licenseManager;
        this.chart = chart;
    }
};
_AgChartInstanceProxy.chartInstances = /* @__PURE__ */ new WeakMap();
__decorateClass([
    ActionOnSet({
        oldValue (chart) {
            if (!chart.destroyed) {
                chart.publicApi = void 0;
            }
            _AgChartInstanceProxy.chartInstances.delete(chart);
        },
        newValue (chart) {
            if (!chart) return;
            chart.publicApi = this;
            _AgChartInstanceProxy.chartInstances.set(chart, this);
        }
    })
], _AgChartInstanceProxy.prototype, "chart", 2);
var AgChartInstanceProxy = _AgChartInstanceProxy;
// packages/ag-charts-community/src/locale/locale.ts
var Locale = class extends BaseModuleInstance {
    constructor(ctx){
        super();
        this.ctx = ctx;
        this.localeText = void 0;
    }
};
__decorateClass([
    ObserveChanges((target)=>{
        target.ctx.localeManager.setLocaleText(target.localeText);
    }),
    Property
], Locale.prototype, "localeText", 2);
__decorateClass([
    ObserveChanges((target)=>{
        target.ctx.localeManager.setLocaleTextFormatter(target.getLocaleText);
    }),
    Property
], Locale.prototype, "getLocaleText", 2);
// packages/ag-charts-community/src/locale/localeModule.ts
var LocaleModule = {
    type: "root",
    optionsKey: "locale",
    packageType: "community",
    chartTypes: [
        "cartesian",
        "polar",
        "topology",
        "standalone"
    ],
    moduleFactory: (ctx)=>new Locale(ctx)
};
// packages/ag-charts-community/src/chart/background/background.ts
var Background = class extends BaseModuleInstance {
    createNode() {
        return new Group({
            name: "background",
            zIndex: 0 /* CHART_BACKGROUND */ 
        });
    }
    onLayoutComplete(e) {
        const { width: width2, height: height2 } = e.chart;
        this.rectNode.width = width2;
        this.rectNode.height = height2;
    }
    constructor(ctx){
        super();
        this.ctx = ctx;
        this.rectNode = new Rect();
        this.textNode = new Text();
        this.fill = "white";
        this.node = this.createNode();
        this.node.append([
            this.rectNode,
            this.textNode
        ]);
        this.visible = true;
        this.cleanup.register(ctx.scene.attachNode(this.node), ctx.eventsHub.on("layout:complete", (e)=>this.onLayoutComplete(e)));
    }
};
__decorateClass([
    Property,
    ProxyPropertyOnWrite("node", "visible")
], Background.prototype, "visible", 2);
__decorateClass([
    Property,
    ProxyPropertyOnWrite("rectNode", "fill")
], Background.prototype, "fill", 2);
__decorateClass([
    Property
], Background.prototype, "image", 2);
__decorateClass([
    Property,
    ProxyPropertyOnWrite("textNode")
], Background.prototype, "text", 2);
// packages/ag-charts-community/src/chart/background/backgroundModule.ts
var BackgroundModule = {
    type: "root",
    optionsKey: "background",
    packageType: "community",
    chartTypes: [
        "cartesian",
        "polar",
        "topology",
        "standalone"
    ],
    moduleFactory: (ctx)=>new Background(ctx)
};
;
// packages/ag-charts-community/src/util/border.ts
var Border = class extends BaseProperties {
    constructor(node){
        super();
        this.node = node;
        this.enabled = false;
        this.stroke = "black";
        this.strokeOpacity = 1;
        this.strokeWidth = 1;
    }
};
__decorateClass([
    ActionOnSet({
        changeValue (newValue) {
            if (newValue) {
                this.node.strokeWidth = this.strokeWidth;
            } else {
                this.node.strokeWidth = 0;
            }
        }
    }),
    Property
], Border.prototype, "enabled", 2);
__decorateClass([
    ProxyPropertyOnWrite("node", "stroke"),
    Property
], Border.prototype, "stroke", 2);
__decorateClass([
    ProxyPropertyOnWrite("node", "strokeOpacity"),
    Property
], Border.prototype, "strokeOpacity", 2);
__decorateClass([
    ActionOnSet({
        changeValue (newValue) {
            if (this.enabled) {
                this.node.strokeWidth = newValue;
            } else {
                this.node.strokeWidth = 0;
            }
        }
    }),
    Property
], Border.prototype, "strokeWidth", 2);
// packages/ag-charts-community/src/chart/gridLayout.ts
function gridLayout(param) {
    let { orientation, bboxes, maxHeight, maxWidth, itemPaddingY = 0, itemPaddingX = 0, forceResult = false } = param;
    const horizontal = orientation === "horizontal";
    const primary = {
        max: horizontal ? maxWidth : maxHeight,
        fn: horizontal ? (b)=>b.width : (b)=>b.height,
        padding: horizontal ? itemPaddingX : itemPaddingY
    };
    const secondary = {
        max: horizontal ? maxHeight : maxWidth,
        fn: horizontal ? (b)=>b.height : (b)=>b.width,
        padding: horizontal ? itemPaddingY : itemPaddingX
    };
    let processedBBoxCount = 0;
    const rawPages = [];
    while(processedBBoxCount < bboxes.length){
        const unprocessedBBoxes = bboxes.slice(processedBBoxCount);
        const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);
        if (!result) {
            return;
        }
        processedBBoxCount += result.processedBBoxCount;
        rawPages.push(result.pageIndices);
    }
    return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);
}
function processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {
    const minGuess = 1;
    let startingGuess = estimateStartingGuess(bboxes, primary);
    if (startingGuess < minGuess) {
        if (!forceResult) {
            return;
        }
        startingGuess = minGuess;
    }
    let guess = startingGuess;
    while(guess >= minGuess){
        const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);
        if (pageIndices == null && guess <= minGuess) {
            return;
        }
        if (pageIndices == null) {
            guess--;
            continue;
        }
        if (typeof pageIndices === "number") {
            if (pageIndices <= minGuess) {
                return;
            }
            guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;
            guess--;
            continue;
        }
        const processedBBoxCount = pageIndices.length * pageIndices[0].length;
        return {
            processedBBoxCount,
            pageIndices
        };
    }
}
function calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {
    const result = [];
    let sumSecondary = 0;
    let currentMaxSecondary = 0;
    let currentPrimaryIndices = [];
    const maxPrimaryValues = [];
    for(let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++){
        const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;
        if (primaryValueIdx === 0) {
            sumSecondary += currentMaxSecondary;
            currentMaxSecondary = 0;
            if (currentPrimaryIndices.length > 0) {
                result.push(currentPrimaryIndices);
            }
            currentPrimaryIndices = [];
        }
        const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;
        var _maxPrimaryValues_primaryValueIdx;
        maxPrimaryValues[primaryValueIdx] = Math.max((_maxPrimaryValues_primaryValueIdx = maxPrimaryValues[primaryValueIdx]) !== null && _maxPrimaryValues_primaryValueIdx !== void 0 ? _maxPrimaryValues_primaryValueIdx : 0, primaryValue);
        currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);
        const currentSecondaryDimension = sumSecondary + currentMaxSecondary;
        const returnResult = !forceResult || result.length > 0;
        if (currentSecondaryDimension > secondary.max && returnResult) {
            currentPrimaryIndices = [];
            break;
        }
        const sumPrimary = maxPrimaryValues.reduce((sum2, next)=>sum2 + next, 0);
        if (sumPrimary > primary.max && !forceResult) {
            if (maxPrimaryValues.length < primaryCount) {
                return maxPrimaryValues.length;
            }
            return;
        }
        currentPrimaryIndices.push(bboxIndex + indexOffset);
    }
    if (currentPrimaryIndices.length > 0) {
        result.push(currentPrimaryIndices);
    }
    return result.length > 0 ? result : void 0;
}
function buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {
    let maxPageWidth = 0;
    let maxPageHeight = 0;
    const pages = rawPages.map((indices)=>{
        if (orientation === "horizontal") {
            indices = transpose(indices);
        }
        let endIndex = 0;
        const columns = indices.map((colIndices)=>{
            const colBBoxes = colIndices.map((bboxIndex)=>{
                endIndex = Math.max(bboxIndex, endIndex);
                return bboxes[bboxIndex];
            });
            let columnHeight = 0;
            let columnWidth = 0;
            colBBoxes.forEach((bbox)=>{
                columnHeight += bbox.height + itemPaddingY;
                columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);
            });
            return {
                indices: colIndices,
                bboxes: colBBoxes,
                columnHeight: Math.ceil(columnHeight),
                columnWidth: Math.ceil(columnWidth)
            };
        });
        let pageWidth = 0;
        let pageHeight = 0;
        columns.forEach((column)=>{
            pageWidth += column.columnWidth;
            pageHeight = Math.max(pageHeight, column.columnHeight);
        });
        maxPageWidth = Math.max(pageWidth, maxPageWidth);
        maxPageHeight = Math.max(pageHeight, maxPageHeight);
        return {
            columns,
            startIndex: indices[0][0],
            endIndex,
            pageWidth,
            pageHeight
        };
    });
    return {
        pages,
        maxPageWidth,
        maxPageHeight
    };
}
function transpose(data) {
    const result = [];
    for (const _ of data[0]){
        result.push([]);
    }
    data.forEach((innerData, dataIdx)=>{
        innerData.forEach((item, itemIdx)=>{
            result[itemIdx][dataIdx] = item;
        });
    });
    return result;
}
function estimateStartingGuess(bboxes, primary) {
    const n = bboxes.length;
    let primarySum = 0;
    for(let bboxIndex = 0; bboxIndex < n; bboxIndex++){
        primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;
        if (primarySum > primary.max) {
            const ratio11 = n / bboxIndex;
            if (ratio11 < 2) {
                return Math.ceil(n / 2);
            }
            return bboxIndex;
        }
    }
    return n;
}
;
var PaginationLabel = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.color = "black";
        this.fontStyle = void 0;
        this.fontWeight = void 0;
        this.fontSize = 12 /* SMALL */ ;
        this.fontFamily = "Verdana, sans-serif";
    }
};
__decorateClass([
    Property
], PaginationLabel.prototype, "color", 2);
__decorateClass([
    Property
], PaginationLabel.prototype, "fontStyle", 2);
__decorateClass([
    Property
], PaginationLabel.prototype, "fontWeight", 2);
__decorateClass([
    Property
], PaginationLabel.prototype, "fontSize", 2);
__decorateClass([
    Property
], PaginationLabel.prototype, "fontFamily", 2);
var PaginationMarkerStyle = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.size = 15;
        this.fill = void 0;
        this.fillOpacity = void 0;
        this.stroke = void 0;
        this.strokeWidth = 1;
        this.strokeOpacity = 1;
    }
};
__decorateClass([
    Property
], PaginationMarkerStyle.prototype, "size", 2);
__decorateClass([
    Property
], PaginationMarkerStyle.prototype, "fill", 2);
__decorateClass([
    Property
], PaginationMarkerStyle.prototype, "fillOpacity", 2);
__decorateClass([
    Property
], PaginationMarkerStyle.prototype, "stroke", 2);
__decorateClass([
    Property
], PaginationMarkerStyle.prototype, "strokeWidth", 2);
__decorateClass([
    Property
], PaginationMarkerStyle.prototype, "strokeOpacity", 2);
var PaginationMarker = class extends BaseProperties {
    constructor(parent){
        super();
        this.parent = parent;
        this.shape = "triangle";
        this.size = 15;
        this.padding = 8;
    }
};
__decorateClass([
    ActionOnSet({
        changeValue () {
            if (this.parent.marker === this) {
                this.parent.onMarkerShapeChange();
            }
        }
    })
], PaginationMarker.prototype, "shape", 2);
__decorateClass([
    Property
], PaginationMarker.prototype, "size", 2);
__decorateClass([
    Property
], PaginationMarker.prototype, "padding", 2);
var Pagination = class extends BaseProperties {
    set visible(value) {
        this._visible = value;
        this.updateGroupVisibility();
    }
    get visible() {
        return this._visible;
    }
    set enabled(value) {
        this._enabled = value;
        this.updateGroupVisibility();
    }
    get enabled() {
        return this._enabled;
    }
    updateGroupVisibility() {
        this.group.visible = this.enabled && this.visible;
    }
    set orientation(value) {
        this._orientation = value;
        switch(value){
            case "horizontal":
                {
                    this.previousButton.rotation = -Math.PI / 2;
                    this.nextButton.rotation = Math.PI / 2;
                    break;
                }
            case "vertical":
            default:
                {
                    this.previousButton.rotation = 0;
                    this.nextButton.rotation = Math.PI;
                }
        }
    }
    get orientation() {
        return this._orientation;
    }
    update() {
        this.updateLabel();
        this.updatePositions();
        this.enableOrDisableButtons();
    }
    updatePositions() {
        this.group.translationX = this.translationX;
        this.group.translationY = this.translationY;
        this.updateLabelPosition();
        this.updateNextButtonPosition();
    }
    updateLabelPosition() {
        const { size: markerSize, padding: markerPadding } = this.marker;
        this.nextButton.size = markerSize;
        this.previousButton.size = markerSize;
        this.labelNode.x = markerSize / 2 + markerPadding;
    }
    updateNextButtonPosition() {
        const labelBBox = this.labelNode.getBBox();
        this.nextButton.translationX = labelBBox.width + (this.marker.size / 2 + this.marker.padding) * 2;
    }
    updateLabel() {
        const { currentPage, totalPages: pages, labelNode, label: { color: color11, fontStyle, fontWeight, fontSize, fontFamily } } = this;
        labelNode.text = "".concat(currentPage + 1, " / ").concat(pages);
        labelNode.fill = color11;
        labelNode.fontStyle = fontStyle;
        labelNode.fontWeight = fontWeight;
        labelNode.fontSize = fontSize;
        labelNode.fontFamily = fontFamily;
    }
    updateMarkers() {
        const { nextButton, previousButton, nextButtonDisabled, previousButtonDisabled, activeStyle, inactiveStyle, highlightStyle, highlightActive } = this;
        const buttonStyle = (button, disabled)=>{
            if (disabled) {
                return inactiveStyle;
            } else if (button === highlightActive) {
                return highlightStyle;
            }
            return activeStyle;
        };
        this.updateMarker(nextButton, buttonStyle("next", nextButtonDisabled));
        this.updateMarker(previousButton, buttonStyle("previous", previousButtonDisabled));
    }
    updateMarker(marker, style) {
        const { shape, size } = this.marker;
        marker.shape = shape;
        marker.size = size;
        marker.fill = style.fill;
        var _style_fillOpacity;
        marker.fillOpacity = (_style_fillOpacity = style.fillOpacity) !== null && _style_fillOpacity !== void 0 ? _style_fillOpacity : 1;
        marker.stroke = style.stroke;
        marker.strokeWidth = style.strokeWidth;
        marker.strokeOpacity = style.strokeOpacity;
    }
    enableOrDisableButtons() {
        const { currentPage, totalPages } = this;
        const zeroPagesToDisplay = totalPages === 0;
        const onLastPage = currentPage === totalPages - 1;
        const onFirstPage = currentPage === 0;
        this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;
        this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;
    }
    setPage(pageNumber) {
        pageNumber = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, pageNumber, Math.max(0, this.totalPages - 1));
        if (this.currentPage !== pageNumber) {
            this.currentPage = pageNumber;
            this.onPaginationChanged();
        }
    }
    getCursor(node) {
        return ({
            previous: this.previousButtonDisabled,
            next: this.nextButtonDisabled
        })[node] ? void 0 : "pointer";
    }
    onClick(event, node) {
        event.preventDefault();
        if (node === "next" && !this.nextButtonDisabled) {
            this.incrementPage();
            this.onPaginationChanged();
        } else if (node === "previous" && !this.previousButtonDisabled) {
            this.decrementPage();
            this.onPaginationChanged();
        }
    }
    onMouseHover(node) {
        this.highlightActive = node;
        this.updateMarkers();
        this.chartUpdateCallback(7 /* SCENE_RENDER */ );
    }
    onPaginationChanged() {
        this.pageUpdateCallback(this.currentPage);
    }
    incrementPage() {
        this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);
    }
    decrementPage() {
        this.currentPage = Math.max(this.currentPage - 1, 0);
    }
    onMarkerShapeChange() {
        this.updatePositions();
        this.updateMarkers();
        this.chartUpdateCallback(7 /* SCENE_RENDER */ );
    }
    attachPagination(node) {
        node.append(this.group);
    }
    getBBox() {
        return this.group.getBBox();
    }
    computeCSSBounds() {
        const prev = Transformable.toCanvas(this.previousButton);
        const next = Transformable.toCanvas(this.nextButton);
        return {
            prev,
            next
        };
    }
    constructor(chartUpdateCallback, pageUpdateCallback){
        super();
        this.chartUpdateCallback = chartUpdateCallback;
        this.pageUpdateCallback = pageUpdateCallback;
        this.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createId"])(this);
        this.marker = new PaginationMarker(this);
        this.activeStyle = new PaginationMarkerStyle();
        this.inactiveStyle = new PaginationMarkerStyle();
        this.highlightStyle = new PaginationMarkerStyle();
        this.label = new PaginationLabel();
        this.group = new TranslatableGroup({
            name: "pagination"
        });
        this.labelNode = new Text();
        this.totalPages = 0;
        this.currentPage = 0;
        this.translationX = 0;
        this.translationY = 0;
        this.nextButtonDisabled = false;
        this.previousButtonDisabled = false;
        this._visible = true;
        this._enabled = true;
        this._orientation = "vertical";
        this.nextButton = new Marker();
        this.previousButton = new Marker();
        this.labelNode.setProperties({
            textBaseline: "middle",
            fontSize: 12 /* SMALL */ ,
            fontFamily: "Verdana, sans-serif",
            fill: "black",
            y: 1
        });
        this.group.append([
            this.nextButton,
            this.previousButton,
            this.labelNode
        ]);
        this.update();
        this.updateMarkers();
    }
};
Pagination.className = "Pagination";
__decorateClass([
    Property
], Pagination.prototype, "marker", 2);
__decorateClass([
    Property
], Pagination.prototype, "activeStyle", 2);
__decorateClass([
    Property
], Pagination.prototype, "inactiveStyle", 2);
__decorateClass([
    Property
], Pagination.prototype, "highlightStyle", 2);
__decorateClass([
    Property
], Pagination.prototype, "label", 2);
;
var LegendDOMProxy = class {
    initLegendList(params) {
        if (!this.dirty) return;
        const { ctx, itemSelection, datumReader, itemListener } = params;
        const lm = ctx.localeManager;
        const count = itemSelection.length;
        itemSelection.each((markerLabel, datum, index)=>{
            var _markerLabel_proxyButton;
            (_markerLabel_proxyButton = markerLabel.proxyButton) === null || _markerLabel_proxyButton === void 0 ? void 0 : _markerLabel_proxyButton.destroy();
            markerLabel.proxyButton = ctx.proxyInteractionService.createProxyElement({
                type: "listswitch",
                textContent: this.getItemAriaText(lm, datumReader.getItemLabel(datum), index, count),
                ariaChecked: !!markerLabel.datum.enabled,
                ariaDescribedBy: this.itemDescription.id,
                parent: this.itemList
            });
            const button = markerLabel.proxyButton;
            button.addListener("click", (ev)=>itemListener.onClick(ev.sourceEvent, markerLabel.datum, button));
            button.addListener("dblclick", (ev)=>itemListener.onDoubleClick(ev.sourceEvent, markerLabel.datum));
            button.addListener("mouseenter", (ev)=>itemListener.onHover(ev.sourceEvent, markerLabel));
            button.addListener("mouseleave", ()=>itemListener.onLeave());
            button.addListener("contextmenu", (ev)=>itemListener.onContextClick(ev, markerLabel));
            button.addListener("blur", ()=>itemListener.onLeave());
            button.addListener("focus", (ev)=>itemListener.onHover(ev.sourceEvent, markerLabel));
            button.addListener("drag-start", ()=>{});
        });
        this.dirty = false;
    }
    update(params) {
        if (params.visible) {
            this.initLegendList(params);
            this.updateItemProxyButtons(params);
            this.updatePaginationProxyButtons(params, true);
        }
        this.updateVisibility(params.visible);
    }
    updateVisibility(visible) {
        this.itemList.setHidden(!visible);
        this.paginationGroup.setHidden(!visible);
    }
    updateItemProxyButtons(param) {
        let { itemSelection, group, pagination, interactive } = param;
        const groupBBox = Transformable.toCanvas(group);
        this.itemList.setBounds(groupBBox);
        const maxHeight = Math.max(...itemSelection.nodes().map((l)=>l.getBBox().height));
        itemSelection.each((l, _datum)=>{
            if (l.proxyButton) {
                const visible = l.pageIndex === pagination.currentPage;
                const { x, y, height: height2, width: width2 } = Transformable.toCanvas(l);
                const margin = (maxHeight - height2) / 2;
                const bbox = {
                    x: x - groupBBox.x,
                    y: y - margin - groupBBox.y,
                    height: maxHeight,
                    width: width2
                };
                const enabled = interactive && visible;
                l.proxyButton.setCursor("pointer");
                l.proxyButton.setEnabled(enabled);
                l.proxyButton.setPointerEvents(enabled ? void 0 : "none");
                l.proxyButton.setBounds(bbox);
            }
        });
    }
    updatePaginationProxyButtons(params, init) {
        const { pagination } = params;
        this.paginationGroup.setHidden(!pagination.visible);
        if (init && "ctx" in params) {
            const { ctx, oldPages, newPages } = params;
            var _oldPages_length;
            const oldNeedsButtons = ((_oldPages_length = oldPages === null || oldPages === void 0 ? void 0 : oldPages.length) !== null && _oldPages_length !== void 0 ? _oldPages_length : newPages.length) > 1;
            const newNeedsButtons = newPages.length > 1;
            if (oldNeedsButtons !== newNeedsButtons) {
                if (newNeedsButtons) {
                    this.prevButton = ctx.proxyInteractionService.createProxyElement({
                        type: "button",
                        textContent: {
                            id: "ariaLabelLegendPagePrevious"
                        },
                        tabIndex: 0,
                        parent: this.paginationGroup
                    });
                    this.prevButton.addListener("click", (ev)=>this.onPageButton(params, ev, "previous"));
                    this.prevButton.addListener("mouseenter", ()=>pagination.onMouseHover("previous"));
                    this.prevButton.addListener("mouseleave", ()=>pagination.onMouseHover(void 0));
                    var _this_nextButton;
                    (_this_nextButton = this.nextButton) !== null && _this_nextButton !== void 0 ? _this_nextButton : this.nextButton = ctx.proxyInteractionService.createProxyElement({
                        type: "button",
                        textContent: {
                            id: "ariaLabelLegendPageNext"
                        },
                        tabIndex: 0,
                        parent: this.paginationGroup
                    });
                    this.nextButton.addListener("click", (ev)=>this.onPageButton(params, ev, "next"));
                    this.nextButton.addListener("mouseenter", ()=>pagination.onMouseHover("next"));
                    this.nextButton.addListener("mouseleave", ()=>pagination.onMouseHover(void 0));
                } else {
                    var _this_nextButton1, _this_prevButton;
                    (_this_nextButton1 = this.nextButton) === null || _this_nextButton1 === void 0 ? void 0 : _this_nextButton1.destroy();
                    (_this_prevButton = this.prevButton) === null || _this_prevButton === void 0 ? void 0 : _this_prevButton.destroy();
                    this.nextButton = void 0;
                    this.prevButton = void 0;
                }
            }
            this.paginationGroup.setAriaHidden(newNeedsButtons ? void 0 : true);
        }
        if (this.prevButton && this.nextButton) {
            const { prev, next } = pagination.computeCSSBounds();
            const group = BBox.merge([
                prev,
                next
            ]);
            prev.x -= group.x;
            prev.y -= group.y;
            next.x -= group.x;
            next.y -= group.y;
            this.paginationGroup.setBounds(group);
            this.prevButton.setBounds(prev);
            this.nextButton.setBounds(next);
            this.prevButton.setEnabled(pagination.currentPage !== 0);
            this.nextButton.setEnabled(pagination.currentPage !== pagination.totalPages - 1);
            this.nextButton.setCursor(pagination.getCursor("next"));
            this.prevButton.setCursor(pagination.getCursor("previous"));
        }
    }
    onPageButton(params, ev, node) {
        params.pagination.onClick(ev.sourceEvent, node);
        this.updatePaginationProxyButtons(params, false);
    }
    onDataUpdate(oldData, newData) {
        this.dirty = oldData.length !== newData.length || oldData.some((_v, index, _a)=>{
            const [newValue, oldValue] = [
                newData[index],
                oldData[index]
            ];
            return newValue.id !== oldValue.id;
        });
    }
    onLocaleChanged(localeManager, itemSelection, datumReader) {
        const count = itemSelection.length;
        itemSelection.each((param, datum, index)=>{
            let { proxyButton } = param;
            const button = proxyButton === null || proxyButton === void 0 ? void 0 : proxyButton.getElement();
            if (button != null) {
                const label = datumReader.getItemLabel(datum);
                button.textContent = this.getItemAriaText(localeManager, label, index, count);
            }
        });
        this.itemDescription.textContent = this.getItemAriaDescription(localeManager);
    }
    onPageChange(params) {
        this.updateItemProxyButtons(params);
        this.updatePaginationProxyButtons(params, false);
    }
    getItemAriaText(localeManager, label, index, count) {
        if (index >= 0 && label) {
            index++;
            return localeManager.t("ariaLabelLegendItem", {
                label,
                index,
                count
            });
        }
        return localeManager.t("ariaLabelLegendItemUnknown");
    }
    getItemAriaDescription(localeManager) {
        return localeManager.t("ariaDescriptionLegendItem");
    }
    constructor(ctx, idPrefix){
        this.dirty = true;
        this.itemList = ctx.proxyInteractionService.createProxyContainer({
            type: "list",
            domManagerId: "".concat(idPrefix, "-toolbar"),
            classList: [
                "ag-charts-proxy-legend-toolbar"
            ],
            ariaLabel: {
                id: "ariaLabelLegend"
            }
        });
        this.paginationGroup = ctx.proxyInteractionService.createProxyContainer({
            type: "group",
            domManagerId: "".concat(idPrefix, "-pagination"),
            classList: [
                "ag-charts-proxy-legend-pagination"
            ],
            ariaLabel: {
                id: "ariaLabelLegendPagination"
            }
        });
        this.itemDescription = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("p");
        this.itemDescription.style.display = "none";
        this.itemDescription.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementId"])();
        this.itemDescription.textContent = this.getItemAriaDescription(ctx.localeManager);
        this.itemList.getElement().append(this.itemDescription);
    }
};
// packages/ag-charts-community/src/chart/legend/legendEvent.ts
function makeLegendItemEvent(type, param, event) {
    let { itemId, seriesId, label: { text } } = param;
    const result = {
        defaultPrevented: false,
        apiEvent: {
            type,
            itemId,
            seriesId,
            text,
            event,
            preventDefault: ()=>result.defaultPrevented = true
        }
    };
    return result;
}
// packages/ag-charts-community/src/chart/legend/legendMarkerLabel.ts
var LegendMarkerLabel = class extends TranslatableGroup {
    destroy() {
        var _this_proxyButton;
        super.destroy();
        (_this_proxyButton = this.proxyButton) === null || _this_proxyButton === void 0 ? void 0 : _this_proxyButton.destroy();
    }
    setEnabled(enabled) {
        this.enabled = enabled;
        this.refreshVisibilities();
    }
    getTextMeasureBBox() {
        this.layout();
        return BBox.merge([
            this.symbolsGroup.getBBox(),
            this.label.getTextMeasureBBox()
        ]);
    }
    refreshVisibilities() {
        const opacity = this.enabled ? 1 : 0.5;
        this.label.opacity = opacity;
        this.opacity = opacity;
    }
    layout() {
        const { marker, line, length: length2, isCustomMarker } = this;
        let centerTranslateX = 0;
        let centerTranslateY = 0;
        if (marker.visible) {
            const { size } = marker;
            const anchor = Marker.anchor(marker.shape);
            centerTranslateX = (anchor.x - 0.5) * size + length2 / 2;
            centerTranslateY = (anchor.y - 0.5) * size;
            if (isCustomMarker) {
                marker.x = 0;
                marker.y = 0;
                marker.translationX = centerTranslateX;
                marker.translationY = centerTranslateY;
            } else {
                marker.x = centerTranslateX;
                marker.y = centerTranslateY;
                marker.translationX = 0;
                marker.translationY = 0;
            }
        }
        if (line.visible) {
            line.x1 = 0;
            line.x2 = length2;
            line.y1 = 0;
            line.y2 = 0;
        }
    }
    preRender(renderCtx) {
        const out = super.preRender(renderCtx);
        this.layout();
        return out;
    }
    layoutLabel() {
        const { length: length2, spacing } = this;
        this.label.x = length2 + spacing;
    }
    computeBBox() {
        this.layout();
        return super.computeBBox();
    }
    constructor(){
        super({
            name: "markerLabelGroup"
        });
        this.symbolsGroup = this.appendChild(new Group({
            name: "legend-markerLabel-symbols"
        }));
        this.label = this.appendChild(new Text());
        this.enabled = true;
        this.pageIndex = NaN;
        this.spacing = 0;
        this.length = 0;
        this.isCustomMarker = false;
        this.marker = this.symbolsGroup.appendChild(new Marker({
            zIndex: 1
        }));
        this.line = this.symbolsGroup.appendChild(new Line({
            zIndex: 0
        }));
        const { label, line, symbolsGroup } = this;
        line.visible = false;
        symbolsGroup.renderToOffscreenCanvas = true;
        symbolsGroup.optimizeForInfrequentRedraws = true;
        label.textBaseline = "middle";
        label.fontSize = 12;
        label.fontFamily = "Verdana, sans-serif";
        label.fill = "black";
        label.y = 1;
    }
};
LegendMarkerLabel.className = "MarkerLabel";
__decorateClass([
    ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "text", 2);
__decorateClass([
    ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "fontStyle", 2);
__decorateClass([
    ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "fontWeight", 2);
__decorateClass([
    ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "fontSize", 2);
__decorateClass([
    ProxyPropertyOnWrite("label")
], LegendMarkerLabel.prototype, "fontFamily", 2);
__decorateClass([
    ProxyPropertyOnWrite("label", "fill")
], LegendMarkerLabel.prototype, "color", 2);
__decorateClass([
    ObserveChanges((target)=>target.layoutLabel())
], LegendMarkerLabel.prototype, "spacing", 2);
__decorateClass([
    ObserveChanges((target)=>target.layoutLabel())
], LegendMarkerLabel.prototype, "length", 2);
__decorateClass([
    SceneChangeDetection()
], LegendMarkerLabel.prototype, "isCustomMarker", 2);
// packages/ag-charts-community/src/chart/legend/legendUtil.ts
function expandLegendPosition(position) {
    const { placement = "bottom", floating = false, xOffset = 0, yOffset = 0 } = typeof position === "string" ? {
        placement: position,
        floating: false
    } : position;
    return {
        placement,
        floating,
        xOffset,
        yOffset
    };
}
// packages/ag-charts-community/src/chart/legend/legend.ts
var LegendLabel = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.maxLength = void 0;
        this.color = "black";
        this.fontStyle = void 0;
        this.fontWeight = void 0;
        this.fontSize = 12 /* SMALL */ ;
        this.fontFamily = "Verdana, sans-serif";
    }
};
__decorateClass([
    Property
], LegendLabel.prototype, "maxLength", 2);
__decorateClass([
    Property
], LegendLabel.prototype, "color", 2);
__decorateClass([
    Property
], LegendLabel.prototype, "fontStyle", 2);
__decorateClass([
    Property
], LegendLabel.prototype, "fontWeight", 2);
__decorateClass([
    Property
], LegendLabel.prototype, "fontSize", 2);
__decorateClass([
    Property
], LegendLabel.prototype, "fontFamily", 2);
__decorateClass([
    Property
], LegendLabel.prototype, "formatter", 2);
var LegendMarker = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.shape = void 0;
        this.size = 15;
        this.padding = 8;
    }
};
__decorateClass([
    Property
], LegendMarker.prototype, "shape", 2);
__decorateClass([
    Property
], LegendMarker.prototype, "size", 2);
__decorateClass([
    Property
], LegendMarker.prototype, "padding", 2);
__decorateClass([
    Property
], LegendMarker.prototype, "strokeWidth", 2);
__decorateClass([
    Property
], LegendMarker.prototype, "enabled", 2);
var LegendLine = class extends BaseProperties {
};
__decorateClass([
    Property
], LegendLine.prototype, "strokeWidth", 2);
__decorateClass([
    Property
], LegendLine.prototype, "length", 2);
var LegendItem = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.paddingX = 16;
        this.paddingY = 8;
        this.showSeriesStroke = false;
        this.marker = new LegendMarker();
        this.label = new LegendLabel();
        this.line = new LegendLine();
    }
};
__decorateClass([
    Property
], LegendItem.prototype, "maxWidth", 2);
__decorateClass([
    Property
], LegendItem.prototype, "paddingX", 2);
__decorateClass([
    Property
], LegendItem.prototype, "paddingY", 2);
__decorateClass([
    Property
], LegendItem.prototype, "showSeriesStroke", 2);
__decorateClass([
    Property
], LegendItem.prototype, "marker", 2);
__decorateClass([
    Property
], LegendItem.prototype, "label", 2);
__decorateClass([
    Property
], LegendItem.prototype, "line", 2);
var LegendListeners = class extends BaseProperties {
};
__decorateClass([
    Property
], LegendListeners.prototype, "legendItemClick", 2);
__decorateClass([
    Property
], LegendListeners.prototype, "legendItemDoubleClick", 2);
var fillGradientDefaults = {
    type: "gradient",
    bounds: "item",
    gradient: "linear",
    colorStops: [
        {
            color: "black"
        }
    ],
    rotation: 0,
    reverse: false
};
var fillPatternDefaults = {
    type: "pattern",
    pattern: "forward-slanted-lines",
    width: 8,
    height: 8,
    padding: 1,
    fill: "black",
    fillOpacity: 1,
    backgroundFill: "white",
    backgroundFillOpacity: 1,
    stroke: "black",
    strokeOpacity: 1,
    strokeWidth: 1,
    rotation: 0,
    scale: 1
};
var fillImageDefaults = {
    type: "image",
    backgroundFill: "black",
    backgroundFillOpacity: 1,
    rotation: 0,
    repeat: "no-repeat",
    fit: "contain",
    width: 8,
    height: 8
};
var Legend = class extends BaseProperties {
    set data(value) {
        if (objectsEqual(value, this._data)) return;
        this.domProxy.onDataUpdate(this._data, value);
        this._data = value;
        this.updateGroupVisibility();
    }
    get data() {
        return this._data;
    }
    onLegendDataChange(param) {
        let { legendData = [] } = param;
        if (!this.enabled) return;
        this.data = legendData.filter((datum)=>!datum.hideInLegend);
    }
    destroy() {
        this.ctx.domManager.removeChild("canvas-overlay", "".concat(this.id, "-toolbar"));
        this.ctx.domManager.removeChild("canvas-overlay", "".concat(this.id, "-pagination"));
        this.cleanup.flush();
        this.itemSelection.clear();
    }
    getOrientation() {
        var _this_orientation;
        return (_this_orientation = this.orientation) !== null && _this_orientation !== void 0 ? _this_orientation : "horizontal";
    }
    set visible(value) {
        this._visible = value;
        this.updateGroupVisibility();
    }
    get visible() {
        return this._visible;
    }
    updateGroupVisibility() {
        this.group.visible = this.enabled && this.visible && this.data.length > 0;
    }
    attachLegend(scene) {
        scene.appendChild(this.group);
    }
    getItemLabel(datum) {
        const { formatter: formatter2 } = this.item.label;
        if (formatter2) {
            const seriesDatum = datum.datum;
            return this.cachedCallWithContext(formatter2, {
                itemId: datum.itemId,
                value: datum.label.text,
                seriesId: datum.seriesId,
                ...seriesDatum && {
                    datum: seriesDatum
                }
            });
        }
        return datum.label.text;
    }
    /**
   * The method is given the desired size of the legend, which only serves as a hint.
   * The vertically oriented legend will take as much horizontal space as needed, but will
   * respect the height constraints, and the horizontal legend will take as much vertical
   * space as needed in an attempt not to exceed the given width.
   * After the layout is done, the {@link size} will contain the actual size of the legend.
   * If the actual size is not the same as the previous actual size, the legend will fire
   * the 'layoutChange' event to communicate that another layout is needed, and the above
   * process should be repeated.
   * @param width
   * @param height
   */ calcLayout(width2, height2) {
        const { paddingX, paddingY, label, maxWidth, label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily } } = this.item;
        const data = [
            ...this.data
        ];
        if (this.reverseOrder) {
            data.reverse();
        }
        this.itemSelection.update(data);
        const bboxes = [];
        const measurer2 = CachedTextMeasurerPool.getMeasurer({
            font: label
        });
        const itemMaxWidthPercentage = 0.8;
        const maxItemWidth = maxWidth !== null && maxWidth !== void 0 ? maxWidth : width2 * itemMaxWidthPercentage;
        const { markerWidth, anyLineEnabled } = this.calculateMarkerWidth();
        this.itemSelection.each((markerLabel, datum)=>{
            markerLabel.fontStyle = fontStyle;
            markerLabel.fontWeight = fontWeight;
            markerLabel.fontSize = fontSize;
            markerLabel.fontFamily = fontFamily;
            const paddedSymbolWidth = this.updateMarkerLabel(markerLabel, datum, markerWidth, anyLineEnabled);
            var _datum_itemId;
            const id = (_datum_itemId = datum.itemId) !== null && _datum_itemId !== void 0 ? _datum_itemId : datum.id;
            const labelText = this.getItemLabel(datum);
            const text = (labelText !== null && labelText !== void 0 ? labelText : "<unknown>").replace(/\r?\n/g, " ");
            markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedSymbolWidth, measurer2, id);
            bboxes.push(markerLabel.getTextMeasureBBox());
        });
        width2 = Math.max(1, width2);
        height2 = Math.max(1, height2);
        if (!isFinite(width2)) {
            return {};
        }
        [width2, height2] = this.updateContainer(width2, height2);
        const size = this.size;
        const oldSize = this.oldSize;
        size[0] = width2;
        size[1] = height2;
        if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
            oldSize[0] = size[0];
            oldSize[1] = size[1];
        }
        const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width2, height2);
        const oldPages = this.pages;
        this.pages = pages;
        this.maxPageSize = [
            maxPageWidth - paddingX,
            maxPageHeight - paddingY
        ];
        const pageNumber = this.pagination.currentPage;
        const page = this.pages[pageNumber];
        if (this.pages.length < 1 || !page) {
            this.visible = false;
            return {
                oldPages
            };
        }
        this.visible = true;
        this.updatePositions(pageNumber);
        this.update();
        return {
            oldPages
        };
    }
    isCustomMarker(markerEnabled, shape) {
        return markerEnabled && shape !== void 0 && typeof shape !== "string";
    }
    calcSymbolsEnabled(symbol) {
        const { showSeriesStroke, marker } = this.item;
        var _symbol_marker_enabled;
        const markerEnabled = !!marker.enabled || !showSeriesStroke || ((_symbol_marker_enabled = symbol.marker.enabled) !== null && _symbol_marker_enabled !== void 0 ? _symbol_marker_enabled : true);
        const lineEnabled = !!(symbol.line && showSeriesStroke);
        const isCustomMarker = this.isCustomMarker(markerEnabled, symbol.marker.shape);
        return {
            markerEnabled,
            lineEnabled,
            isCustomMarker
        };
    }
    calcSymbolsLengths(symbol, markerEnabled, lineEnabled) {
        const { marker, line } = this.item;
        let customMarkerSize;
        const { shape } = symbol.marker;
        if (this.isCustomMarker(markerEnabled, shape)) {
            const tmpShape = new Marker();
            tmpShape.shape = shape;
            tmpShape.updatePath();
            const bbox = tmpShape.getBBox();
            customMarkerSize = Math.max(bbox.width, bbox.height);
        }
        const markerLength = markerEnabled ? marker.size : 0;
        var _line_length;
        const lineLength = lineEnabled ? (_line_length = line.length) !== null && _line_length !== void 0 ? _line_length : 25 : 0;
        return {
            markerLength,
            lineLength,
            customMarkerSize
        };
    }
    calculateMarkerWidth() {
        let markerWidth = 0;
        let anyLineEnabled = false;
        this.itemSelection.each((_, datum)=>{
            const { symbol } = datum;
            const { lineEnabled, markerEnabled } = this.calcSymbolsEnabled(symbol);
            const { markerLength, lineLength, customMarkerSize = -Infinity } = this.calcSymbolsLengths(symbol, markerEnabled, lineEnabled);
            markerWidth = Math.max(markerWidth, lineLength, customMarkerSize, markerLength);
            anyLineEnabled || (anyLineEnabled = lineEnabled);
        });
        return {
            markerWidth,
            anyLineEnabled
        };
    }
    updateMarkerLabel(markerLabel, datum, markerWidth, anyLineEnabled) {
        const { marker: itemMarker, paddingX } = this.item;
        const { symbol } = datum;
        let paddedSymbolWidth = paddingX;
        const { markerEnabled, isCustomMarker } = this.calcSymbolsEnabled(symbol);
        const spacing = itemMarker.padding;
        if (markerEnabled || anyLineEnabled) {
            paddedSymbolWidth += spacing + markerWidth;
        }
        const { marker, line } = markerLabel;
        marker.visible = markerEnabled;
        if (marker.visible) {
            var _itemMarker_shape, _ref;
            marker.shape = (_ref = (_itemMarker_shape = itemMarker.shape) !== null && _itemMarker_shape !== void 0 ? _itemMarker_shape : symbol.marker.shape) !== null && _ref !== void 0 ? _ref : "square";
            marker.size = itemMarker.size;
            applyShapeStyle(marker, this.getMarkerStyles(symbol));
        }
        line.visible = anyLineEnabled;
        if (line.visible) {
            applyShapeStyle(line, this.getLineStyles(symbol));
        }
        markerLabel.length = markerWidth;
        markerLabel.spacing = spacing;
        markerLabel.isCustomMarker = isCustomMarker;
        return paddedSymbolWidth;
    }
    updateContainer(width2, height2) {
        const containerStyles = this.getContainerStyles();
        this.containerNode.width = 0;
        this.containerNode.height = 0;
        applyShapeStyle(this.containerNode, containerStyles);
        this.containerNode.cornerRadius = containerStyles.cornerRadius;
        width2 -= containerStyles.strokeWidth * 2 + containerStyles.padding.left + containerStyles.padding.right;
        height2 -= containerStyles.strokeWidth * 2 + containerStyles.padding.top + containerStyles.padding.bottom;
        return [
            width2,
            height2
        ];
    }
    truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, measurer2, id) {
        let addEllipsis = false;
        if (text.length > maxCharLength) {
            text = text.substring(0, maxCharLength);
            addEllipsis = true;
        }
        const result = TextWrapper.truncateLine(text, measurer2, maxItemWidth - paddedMarkerWidth, addEllipsis);
        if (result.endsWith(TextUtils.EllipsisChar)) {
            this.truncatedItems.add(id);
        } else {
            this.truncatedItems.delete(id);
        }
        return result;
    }
    updatePagination(bboxes, width2, height2) {
        const orientation = this.getOrientation();
        const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);
        this.pagination.orientation = orientation;
        this.pagination.translationX = 0;
        this.pagination.translationY = 0;
        const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(bboxes, width2, height2);
        const newCurrentPage = pages.findIndex((p)=>p.endIndex >= trackingIndex);
        this.pagination.currentPage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, newCurrentPage, pages.length - 1);
        const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;
        const paginationComponentPadding = 8;
        const legendItemsWidth = maxPageWidth - itemPaddingX;
        const legendItemsHeight = maxPageHeight - itemPaddingY;
        let paginationX = 0;
        let paginationY = -paginationBBox.y - this.item.marker.size / 2;
        if (paginationVertical) {
            paginationY += legendItemsHeight + paginationComponentPadding;
        } else {
            paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;
            paginationY += (legendItemsHeight - paginationBBox.height) / 2;
        }
        this.pagination.translationX = paginationX;
        this.pagination.translationY = paginationY;
        this.pagination.update();
        this.pagination.updateMarkers();
        let pageIndex = 0;
        this.itemSelection.each((markerLabel, _, nodeIndex)=>{
            var _pages_pageIndex;
            var _pages_pageIndex_endIndex;
            if (nodeIndex > ((_pages_pageIndex_endIndex = (_pages_pageIndex = pages[pageIndex]) === null || _pages_pageIndex === void 0 ? void 0 : _pages_pageIndex.endIndex) !== null && _pages_pageIndex_endIndex !== void 0 ? _pages_pageIndex_endIndex : Infinity)) {
                pageIndex++;
            }
            markerLabel.pageIndex = pageIndex;
        });
        return {
            maxPageHeight,
            maxPageWidth,
            pages
        };
    }
    calculatePagination(bboxes, width2, height2) {
        const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;
        const vertPositions = [
            "left",
            "left-top",
            "left-bottom",
            "right",
            "right-top",
            "right-bottom"
        ];
        const { placement } = expandLegendPosition(this.position);
        const orientation = this.getOrientation();
        const paginationVertical = vertPositions.includes(placement);
        let paginationBBox = this.pagination.getBBox();
        let lastPassPaginationBBox = new BBox(0, 0, 0, 0);
        let pages = [];
        let maxPageWidth = 0;
        let maxPageHeight = 0;
        let count = 0;
        const stableOutput = (bbox)=>{
            return bbox.width === paginationBBox.width && bbox.height === paginationBBox.height;
        };
        const forceResult = this.maxWidth !== void 0 && this.maxHeight !== void 0;
        do {
            if (count++ > 10) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("unable to find stable legend layout.");
                break;
            }
            paginationBBox = lastPassPaginationBBox;
            const maxWidth = width2 - (paginationVertical ? 0 : paginationBBox.width);
            const maxHeight = height2 - (paginationVertical ? paginationBBox.height : 0);
            const layout = gridLayout({
                orientation,
                bboxes,
                maxHeight,
                maxWidth,
                itemPaddingY,
                itemPaddingX,
                forceResult
            });
            var _layout_pages;
            pages = (_layout_pages = layout === null || layout === void 0 ? void 0 : layout.pages) !== null && _layout_pages !== void 0 ? _layout_pages : [];
            var _layout_maxPageWidth;
            maxPageWidth = (_layout_maxPageWidth = layout === null || layout === void 0 ? void 0 : layout.maxPageWidth) !== null && _layout_maxPageWidth !== void 0 ? _layout_maxPageWidth : 0;
            var _layout_maxPageHeight;
            maxPageHeight = (_layout_maxPageHeight = layout === null || layout === void 0 ? void 0 : layout.maxPageHeight) !== null && _layout_maxPageHeight !== void 0 ? _layout_maxPageHeight : 0;
            const totalPages = pages.length;
            this.pagination.visible = totalPages > 1;
            this.pagination.totalPages = totalPages;
            this.pagination.update();
            this.pagination.updateMarkers();
            lastPassPaginationBBox = this.pagination.getBBox();
            if (!this.pagination.visible) {
                break;
            }
        }while (!stableOutput(lastPassPaginationBBox))
        return {
            maxPageWidth,
            maxPageHeight,
            pages,
            paginationBBox: lastPassPaginationBBox,
            paginationVertical
        };
    }
    updatePositions() {
        let pageNumber = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        const { item: { paddingY }, itemSelection, pages } = this;
        if (pages.length < 1 || !pages[pageNumber]) {
            return;
        }
        const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];
        let x = 0;
        let y = 0;
        const columnCount = columns.length;
        const rowCount = columns[0].indices.length;
        const horizontal = this.getOrientation() === "horizontal";
        const itemHeight = columns[0].bboxes[0].height + paddingY;
        const rowSumColumnWidths = [];
        itemSelection.each((markerLabel, _, i)=>{
            if (i < visibleStart || i > visibleEnd) {
                markerLabel.visible = false;
                return;
            }
            const pageIndex = i - visibleStart;
            let columnIndex;
            let rowIndex;
            if (horizontal) {
                columnIndex = pageIndex % columnCount;
                rowIndex = Math.floor(pageIndex / columnCount);
            } else {
                columnIndex = Math.floor(pageIndex / rowCount);
                rowIndex = pageIndex % rowCount;
            }
            markerLabel.visible = true;
            const column = columns[columnIndex];
            if (!column) {
                return;
            }
            y = Math.floor(itemHeight * rowIndex);
            var _rowSumColumnWidths_rowIndex;
            x = Math.floor((_rowSumColumnWidths_rowIndex = rowSumColumnWidths[rowIndex]) !== null && _rowSumColumnWidths_rowIndex !== void 0 ? _rowSumColumnWidths_rowIndex : 0);
            var _rowSumColumnWidths_rowIndex1;
            rowSumColumnWidths[rowIndex] = ((_rowSumColumnWidths_rowIndex1 = rowSumColumnWidths[rowIndex]) !== null && _rowSumColumnWidths_rowIndex1 !== void 0 ? _rowSumColumnWidths_rowIndex1 : 0) + column.columnWidth;
            markerLabel.translationX = x;
            markerLabel.translationY = y;
        });
    }
    updatePageNumber(pageNumber) {
        const { itemSelection, group, pagination, pages, toggleSeries: interactive } = this;
        const { startIndex, endIndex } = pages[pageNumber];
        if (startIndex === 0) {
            this.paginationTrackingIndex = 0;
        } else if (pageNumber === pages.length - 1) {
            this.paginationTrackingIndex = endIndex;
        } else {
            this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);
        }
        this.pagination.update();
        this.pagination.updateMarkers();
        this.updatePositions(pageNumber);
        this.domProxy.onPageChange({
            itemSelection,
            group,
            pagination,
            interactive
        });
        this.ctx.updateService.update(7 /* SCENE_RENDER */ );
    }
    update() {
        const { label: { color: color11 } } = this.item;
        this.itemSelection.each((markerLabel, datum)=>{
            markerLabel.setEnabled(datum.enabled);
            markerLabel.color = color11;
        });
        this.updateContextMenu();
    }
    updateContextMenu() {
        this.ctx.contextMenuRegistry.setVisible("toggle-series-visibility", this.toggleSeries);
        this.ctx.contextMenuRegistry.setVisible("toggle-other-series", this.toggleSeries);
    }
    getLineStyles(datum) {
        var _datum_line;
        const { stroke: stroke2, strokeOpacity = 1, strokeWidth, lineDash } = (_datum_line = datum.line) !== null && _datum_line !== void 0 ? _datum_line : {};
        const defaultLineStrokeWidth = Math.min(2, strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 1);
        var _this_item_line_strokeWidth;
        return {
            stroke: stroke2,
            strokeOpacity,
            strokeWidth: (_this_item_line_strokeWidth = this.item.line.strokeWidth) !== null && _this_item_line_strokeWidth !== void 0 ? _this_item_line_strokeWidth : defaultLineStrokeWidth,
            lineDash
        };
    }
    getMarkerStyles(param) {
        let { marker } = param;
        const { fill, stroke: stroke2, strokeOpacity = 1, fillOpacity = 1, strokeWidth, lineDash, lineDashOffset } = marker;
        const defaultLineStrokeWidth = Math.min(2, strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 1);
        if (isPatternFill(fill)) {
            fill.width = 8;
            fill.height = 8;
            fill.padding = 1;
            var _fill_strokeWidth;
            fill.strokeWidth = Math.min(2, (_fill_strokeWidth = fill.strokeWidth) !== null && _fill_strokeWidth !== void 0 ? _fill_strokeWidth : 2);
        }
        if (isImageFill(fill)) {
            fill.fit = "contain";
            fill.width = void 0;
            fill.height = void 0;
            fill.repeat = "no-repeat";
        }
        var _this_item_marker_strokeWidth;
        return getShapeStyle({
            fill,
            stroke: stroke2,
            strokeOpacity,
            fillOpacity,
            strokeWidth: (_this_item_marker_strokeWidth = this.item.marker.strokeWidth) !== null && _this_item_marker_strokeWidth !== void 0 ? _this_item_marker_strokeWidth : defaultLineStrokeWidth,
            lineDash,
            lineDashOffset
        }, fillGradientDefaults, fillPatternDefaults, fillImageDefaults);
    }
    getContainerStyles() {
        const { stroke: stroke2, strokeOpacity, strokeWidth } = this.border;
        const { cornerRadius, fill, fillOpacity, padding: padding2 } = this;
        const isPaddingNumber = typeof padding2 === "number";
        var _padding2_top, _padding2_right, _padding2_bottom, _padding2_left;
        return getShapeStyle({
            cornerRadius,
            fill,
            fillOpacity,
            padding: {
                top: isPaddingNumber ? padding2 : (_padding2_top = padding2.top) !== null && _padding2_top !== void 0 ? _padding2_top : 0,
                right: isPaddingNumber ? padding2 : (_padding2_right = padding2.right) !== null && _padding2_right !== void 0 ? _padding2_right : 0,
                bottom: isPaddingNumber ? padding2 : (_padding2_bottom = padding2.bottom) !== null && _padding2_bottom !== void 0 ? _padding2_bottom : 0,
                left: isPaddingNumber ? padding2 : (_padding2_left = padding2.left) !== null && _padding2_left !== void 0 ? _padding2_left : 0
            },
            stroke: stroke2,
            strokeOpacity,
            strokeWidth: this.border.enabled ? strokeWidth : 0
        }, fillGradientDefaults, fillPatternDefaults, fillImageDefaults);
    }
    computePagedBBox() {
        const actualBBox = Group.computeChildrenBBox(this.group.excludeChildren({
            name: "legend-container"
        }));
        if (this.pages.length > 1) {
            const [maxPageWidth, maxPageHeight] = this.maxPageSize;
            actualBBox.height = Math.max(maxPageHeight, actualBBox.height);
            actualBBox.width = Math.max(maxPageWidth, actualBBox.width);
        }
        const { strokeWidth, padding: padding2 } = this.getContainerStyles();
        actualBBox.grow(padding2).grow(strokeWidth);
        return actualBBox;
    }
    findNode(params) {
        var _this_itemSelection_select_;
        const { datum, proxyButton } = (_this_itemSelection_select_ = this.itemSelection.select((ml)=>{
            var _ml_datum;
            return ((_ml_datum = ml.datum) === null || _ml_datum === void 0 ? void 0 : _ml_datum.itemId) === params.itemId;
        })[0]) !== null && _this_itemSelection_select_ !== void 0 ? _this_itemSelection_select_ : {};
        if (datum === void 0 || proxyButton === void 0) {
            throw new Error("AG Charts - Missing required properties { datum: ".concat(datum, ", proxyButton: ").concat(JSON.stringify(proxyButton), " }"));
        }
        return {
            datum,
            proxyButton
        };
    }
    contextToggleVisibility(params) {
        const { datum, proxyButton } = this.findNode(params);
        this.doClick(params.event, datum, proxyButton);
    }
    contextToggleOtherSeries(params) {
        this.doDoubleClick(params.event, this.findNode(params).datum);
    }
    onContextClick(widgetEvent, node) {
        var _this_contextMenuDatum, _this_ctx_chartService_series__getLegendData_, _this_ctx_chartService_series_;
        const { sourceEvent } = widgetEvent;
        const legendItem = node.datum;
        if (this.preventHidingAll && ((_this_contextMenuDatum = this.contextMenuDatum) === null || _this_contextMenuDatum === void 0 ? void 0 : _this_contextMenuDatum.enabled) && this.getVisibleItemCount() <= 1) {
            this.ctx.contextMenuRegistry.builtins.items["toggle-series-visibility"].enabled = false;
        } else {
            this.ctx.contextMenuRegistry.builtins.items["toggle-series-visibility"].enabled = true;
        }
        const toggleOtherSeriesVisible = this.ctx.chartService.series.length > 1 && ((_this_ctx_chartService_series_ = this.ctx.chartService.series[0]) === null || _this_ctx_chartService_series_ === void 0 ? void 0 : (_this_ctx_chartService_series__getLegendData_ = _this_ctx_chartService_series_.getLegendData("category")[0]) === null || _this_ctx_chartService_series__getLegendData_ === void 0 ? void 0 : _this_ctx_chartService_series__getLegendData_.hideToggleOtherSeries) !== true;
        this.ctx.contextMenuRegistry.setVisible("toggle-other-series", toggleOtherSeriesVisible);
        const { offsetX, offsetY } = sourceEvent;
        const { x: canvasX, y: canvasY } = Transformable.toCanvasPoint(node, offsetX, offsetY);
        this.ctx.contextMenuRegistry.dispatchContext("legend-item", {
            widgetEvent,
            canvasX,
            canvasY
        }, {
            legendItem
        });
    }
    onClick(event, datum, proxyButton) {
        if (this.doClick(event, datum, proxyButton)) {
            event.preventDefault();
        }
    }
    getVisibleItemCount() {
        return this.ctx.chartService.series.flatMap((s)=>s.getLegendData("category")).filter((d)=>d.enabled).length;
    }
    doClick(event, datum, proxyButton) {
        const { listeners: { legendItemClick }, ctx: { chartService, highlightManager }, preventHidingAll, toggleSeries } = this;
        if (!datum) {
            return false;
        }
        const { legendType, seriesId, itemId, enabled, legendItemName } = datum;
        const series = chartService.series.find((s)=>s.id === seriesId);
        if (!series) {
            return false;
        }
        let newEnabled = enabled;
        const clickEvent = makeLegendItemEvent("click", datum, event);
        if (legendItemClick) {
            callWithContext([
                series.properties,
                this.ctx.chartService
            ], legendItemClick, clickEvent.apiEvent);
        }
        if (clickEvent.defaultPrevented) return true;
        if (toggleSeries) {
            newEnabled = !enabled;
            if (preventHidingAll && !newEnabled) {
                const numVisibleItems = this.getVisibleItemCount();
                if (numVisibleItems < 2) {
                    newEnabled = true;
                }
            }
            proxyButton.setChecked(newEnabled);
            this.ctx.eventsHub.emit("legend:item-click", {
                legendType,
                series,
                itemId,
                enabled: newEnabled,
                legendItemName
            });
        }
        if (newEnabled) {
            highlightManager.updateHighlight(this.id, {
                series,
                itemId,
                datum: void 0,
                datumIndex: void 0,
                legendItemName
            });
        } else {
            highlightManager.updateHighlight(this.id);
        }
        this.ctx.legendManager.update();
        var _datum_skipAnimations;
        this.ctx.updateService.update(2 /* PROCESS_DATA */ , {
            forceNodeDataRefresh: true,
            skipAnimations: (_datum_skipAnimations = datum.skipAnimations) !== null && _datum_skipAnimations !== void 0 ? _datum_skipAnimations : false
        });
        return true;
    }
    onDoubleClick(event, datum) {
        if (this.doDoubleClick(event, datum)) {
            event.preventDefault();
        }
    }
    doDoubleClick(event, datum) {
        const { listeners: { legendItemDoubleClick }, ctx: { chartService }, toggleSeries } = this;
        if (!datum) {
            return false;
        }
        const { legendType, id, itemId, seriesId } = datum;
        const series = chartService.series.find((s)=>s.id === id);
        if (!series) {
            return false;
        }
        const doubleClickEvent = makeLegendItemEvent("dblclick", datum, event);
        if (legendItemDoubleClick) {
            callWithContext([
                series.properties,
                this.ctx.chartService
            ], legendItemDoubleClick, doubleClickEvent.apiEvent);
        }
        if (doubleClickEvent.defaultPrevented) return true;
        if (toggleSeries) {
            const legendData = chartService.series.flatMap((s)=>s.getLegendData("category"));
            let numVisibleItems = 0;
            const visibleLegendItemNames = /* @__PURE__ */ new Set();
            for (const d of legendData){
                if (!d.enabled) continue;
                numVisibleItems += 1;
                if (d.legendItemName != null) {
                    visibleLegendItemNames.add(d.legendItemName);
                }
            }
            if (visibleLegendItemNames.size > 0) {
                numVisibleItems = visibleLegendItemNames.size;
            }
            const clickedItem = legendData.find((d)=>d.itemId === itemId && d.seriesId === seriesId);
            var _clickedItem_enabled;
            this.ctx.eventsHub.emit("legend:item-double-click", {
                legendType,
                series,
                itemId,
                numVisibleItems,
                enabled: (_clickedItem_enabled = clickedItem === null || clickedItem === void 0 ? void 0 : clickedItem.enabled) !== null && _clickedItem_enabled !== void 0 ? _clickedItem_enabled : false,
                legendItemName: clickedItem === null || clickedItem === void 0 ? void 0 : clickedItem.legendItemName
            });
        }
        this.ctx.legendManager.update();
        this.ctx.updateService.update(2 /* PROCESS_DATA */ , {
            forceNodeDataRefresh: true
        });
        return true;
    }
    toTooltipMeta(event, node) {
        let point;
        if (event instanceof FocusEvent) {
            point = Transformable.toCanvas(node).computeCenter();
        } else {
            event.preventDefault();
            point = Transformable.toCanvasPoint(node, event.offsetX, event.offsetY);
        }
        return {
            canvasX: point.x,
            canvasY: point.y,
            showArrow: false
        };
    }
    onHover(event, node) {
        if (!this.enabled) throw new Error("AG Charts - onHover handler called on disabled legend");
        this.pagination.setPage(node.pageIndex);
        const datum = node.datum;
        const series = datum ? this.ctx.chartService.series.find((s)=>s.id === (datum === null || datum === void 0 ? void 0 : datum.id)) : void 0;
        var _datum_itemId;
        if (datum && this.truncatedItems.has((_datum_itemId = datum.itemId) !== null && _datum_itemId !== void 0 ? _datum_itemId : datum.id)) {
            const meta = this.toTooltipMeta(event, node);
            this.ctx.tooltipManager.updateTooltip(this.id, meta, [
                {
                    type: "structured",
                    title: this.getItemLabel(datum)
                }
            ]);
        } else {
            this.ctx.tooltipManager.removeTooltip(this.id);
        }
        if ((datum === null || datum === void 0 ? void 0 : datum.enabled) && series) {
            this.updateHighlight({
                series,
                itemId: datum === null || datum === void 0 ? void 0 : datum.itemId,
                datum: void 0,
                datumIndex: void 0,
                legendItemName: datum === null || datum === void 0 ? void 0 : datum.legendItemName
            });
        } else {
            this.updateHighlight();
        }
    }
    onLeave() {
        this.ctx.tooltipManager.removeTooltip(this.id);
        this.updateHighlight();
    }
    updateHighlight(datum) {
        if (this.ctx.interactionManager.isState(32 /* Default */ )) {
            this.ctx.highlightManager.updateHighlight(this.id, datum);
        } else if (this.ctx.interactionManager.isState(2 /* Animation */ )) {
            this.pendingHighlightDatum = datum;
            this.ctx.animationManager.onBatchStop(()=>{
                this.ctx.highlightManager.updateHighlight(this.id, this.pendingHighlightDatum);
            });
        }
    }
    onLocaleChanged() {
        this.domProxy.onLocaleChanged(this.ctx.localeManager, this.itemSelection, this);
    }
    positionLegend(ctx) {
        const oldPages = this.positionLegendScene(ctx);
        this.positionLegendDOM(oldPages);
    }
    positionLegendScene(ctx) {
        if (!this.enabled || !this.data.length) return;
        const { placement, floating, xOffset, yOffset } = expandLegendPosition(this.position);
        const layoutBox = floating ? new BBox(0, 0, ctx.width, ctx.height) : ctx.layoutBox;
        const { x, y, width: width2, height: height2 } = layoutBox;
        const [legendWidth, legendHeight] = this.calculateLegendDimensions(layoutBox);
        const { oldPages } = this.calcLayout(legendWidth, legendHeight);
        const legendBBox = this.computePagedBBox();
        if (this.visible) {
            let unreachable2 = function(_a) {
                return void 0;
            };
            var unreachable = unreachable2;
            const legendSpacing = this.spacing;
            let translationX;
            let translationY;
            switch(placement){
                case "top":
                    translationX = (width2 - legendBBox.width) / 2;
                    translationY = 0;
                    break;
                case "bottom":
                    translationX = (width2 - legendBBox.width) / 2;
                    translationY = height2 - legendBBox.height;
                    break;
                case "right":
                    translationX = width2 - legendBBox.width;
                    translationY = (height2 - legendBBox.height) / 2;
                    break;
                case "left":
                    translationX = 0;
                    translationY = (height2 - legendBBox.height) / 2;
                    break;
                case "top-right":
                case "right-top":
                    translationX = width2 - legendBBox.width;
                    translationY = 0;
                    break;
                case "top-left":
                case "left-top":
                    translationX = 0;
                    translationY = 0;
                    break;
                case "bottom-right":
                case "right-bottom":
                    translationX = width2 - legendBBox.width;
                    translationY = height2 - legendBBox.height;
                    break;
                case "bottom-left":
                case "left-bottom":
                    translationX = 0;
                    translationY = height2 - legendBBox.height;
                    break;
                default:
                    unreachable2(placement);
            }
            if (!floating) {
                let shrinkAmount;
                let shrinkDirection;
                switch(placement){
                    case "top":
                    case "top-right":
                    case "top-left":
                        shrinkAmount = legendBBox.height + legendSpacing;
                        shrinkDirection = "top";
                        break;
                    case "bottom":
                    case "bottom-right":
                    case "bottom-left":
                        shrinkAmount = legendBBox.height + legendSpacing;
                        shrinkDirection = "bottom";
                        break;
                    case "left":
                    case "left-top":
                    case "left-bottom":
                        shrinkAmount = legendBBox.width + legendSpacing;
                        shrinkDirection = "left";
                        break;
                    case "right":
                    case "right-top":
                    case "right-bottom":
                        shrinkAmount = legendBBox.width + legendSpacing;
                        shrinkDirection = "right";
                        break;
                    default:
                        unreachable2(placement);
                }
                layoutBox.shrink(shrinkAmount, shrinkDirection);
            }
            translationX += xOffset;
            translationY += yOffset;
            this.group.translationX = Math.floor(x + translationX - legendBBox.x);
            this.group.translationY = Math.floor(y + translationY - legendBBox.y);
            this.containerNode.x = legendBBox.x;
            this.containerNode.y = legendBBox.y;
            this.containerNode.width = legendBBox.width;
            this.containerNode.height = legendBBox.height;
        }
        return oldPages;
    }
    positionLegendDOM(oldPages) {
        const { ctx, itemSelection, pagination, pages: newPages, toggleSeries, group, listeners: { legendItemClick, legendItemDoubleClick } } = this;
        const visible = this.visible && this.enabled;
        const interactive = toggleSeries || legendItemDoubleClick != null || legendItemClick != null;
        this.domProxy.update({
            visible,
            interactive,
            ctx,
            itemSelection,
            group,
            pagination,
            oldPages,
            newPages,
            datumReader: this,
            itemListener: this
        });
    }
    calculateLegendDimensions(shrinkRect) {
        const { width: width2, height: height2 } = shrinkRect;
        const { placement } = expandLegendPosition(this.position);
        const aspectRatio = width2 / height2;
        const maxCoefficient = 0.5;
        const minHeightCoefficient = 0.2;
        const minWidthCoefficient = 0.25;
        let legendWidth, legendHeight;
        function unreachable(_a) {
            return void 0;
        }
        switch(placement){
            case "top":
            case "top-left":
            case "top-right":
            case "bottom":
            case "bottom-left":
            case "bottom-right":
                {
                    const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;
                    legendWidth = this.maxWidth ? Math.min(this.maxWidth, width2) : width2;
                    legendHeight = this.maxHeight ? Math.min(this.maxHeight, height2) : Math.round(height2 * heightCoefficient);
                    break;
                }
            case "left":
            case "left-top":
            case "left-bottom":
            case "right":
            case "right-top":
            case "right-bottom":
                {
                    const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;
                    legendWidth = this.maxWidth ? Math.min(this.maxWidth, width2) : Math.round(width2 * widthCoefficient);
                    legendHeight = this.maxHeight ? Math.min(this.maxHeight, height2) : height2;
                    break;
                }
            default:
                unreachable(placement);
        }
        return [
            legendWidth,
            legendHeight
        ];
    }
    cachedCallWithContext(fn) {
        for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            params[_key - 1] = arguments[_key];
        }
        const { callbackCache, chartService } = this.ctx;
        return callbackCache.call([
            this,
            chartService
        ], fn, ...params);
    }
    constructor(ctx){
        super();
        this.ctx = ctx;
        this.id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createId"])(this);
        this.group = new TranslatableGroup({
            name: "legend",
            zIndex: 16 /* LEGEND */ 
        });
        this.itemSelection = Selection.select(this.group, LegendMarkerLabel);
        this.containerNode = this.group.appendChild(new Rect({
            name: "legend-container"
        }));
        this.oldSize = [
            0,
            0
        ];
        this.pages = [];
        this.maxPageSize = [
            0,
            0
        ];
        /** Item index to track on re-pagination, so current page updates appropriately. */ this.paginationTrackingIndex = 0;
        this.truncatedItems = /* @__PURE__ */ new Set();
        this._data = [];
        this.toggleSeries = true;
        this.item = new LegendItem();
        this.listeners = new LegendListeners();
        this.enabled = true;
        this.position = "bottom";
        this.border = new Border(this.containerNode);
        this.cornerRadius = 0;
        this.fillOpacity = 1;
        this.padding = 4;
        this.spacing = 20;
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.size = [
            0,
            0
        ];
        this._visible = true;
        this.pagination = new Pagination((type)=>ctx.updateService.update(type), (page)=>this.updatePageNumber(page));
        this.pagination.attachPagination(this.group);
        const { items } = ctx.contextMenuRegistry.builtins;
        items["toggle-series-visibility"].action = (params)=>this.contextToggleVisibility(params);
        items["toggle-other-series"].action = (params)=>this.contextToggleOtherSeries(params);
        this.cleanup.register(ctx.eventsHub.on("legend:change", this.onLegendDataChange.bind(this)), ctx.layoutManager.registerElement(1 /* Legend */ , (e)=>this.positionLegend(e)), ctx.eventsHub.on("locale:change", ()=>this.onLocaleChanged()), ()=>delete items["toggle-series-visibility"].action, ()=>delete items["toggle-other-series"].action, ()=>this.group.remove());
        this.domProxy = new LegendDOMProxy(this.ctx, this.id);
        this.ctx.historyManager.addMementoOriginator(ctx.legendManager);
    }
};
Legend.className = "Legend";
__decorateClass([
    Property
], Legend.prototype, "toggleSeries", 2);
__decorateClass([
    Property
], Legend.prototype, "pagination", 2);
__decorateClass([
    Property
], Legend.prototype, "item", 2);
__decorateClass([
    Property
], Legend.prototype, "listeners", 2);
__decorateClass([
    ObserveChanges((target, newValue, oldValue)=>{
        target.updateGroupVisibility();
        if (newValue === oldValue) {
            return;
        }
        const { ctx: { legendManager, stateManager } } = target;
        if (oldValue === false && newValue === true) {
            stateManager.restoreState(legendManager);
        }
    }),
    Property
], Legend.prototype, "enabled", 2);
__decorateClass([
    Property
], Legend.prototype, "position", 2);
__decorateClass([
    Property
], Legend.prototype, "maxWidth", 2);
__decorateClass([
    Property
], Legend.prototype, "maxHeight", 2);
__decorateClass([
    Property
], Legend.prototype, "reverseOrder", 2);
__decorateClass([
    Property
], Legend.prototype, "orientation", 2);
__decorateClass([
    Property
], Legend.prototype, "preventHidingAll", 2);
__decorateClass([
    Property
], Legend.prototype, "border", 2);
__decorateClass([
    Property
], Legend.prototype, "cornerRadius", 2);
__decorateClass([
    Property
], Legend.prototype, "fill", 2);
__decorateClass([
    Property
], Legend.prototype, "fillOpacity", 2);
__decorateClass([
    Property
], Legend.prototype, "padding", 2);
__decorateClass([
    Property
], Legend.prototype, "spacing", 2);
__decorateClass([
    Property
], Legend.prototype, "xOffset", 2);
__decorateClass([
    Property
], Legend.prototype, "yOffset", 2);
// packages/ag-charts-community/src/chart/legend/legendModule.ts
var CommunityLegendModule = {
    type: "legend",
    optionsKey: "legend",
    identifier: "category",
    chartTypes: [
        "cartesian",
        "polar",
        "topology",
        "standalone"
    ],
    moduleFactory: (ctx)=>new Legend(ctx),
    packageType: "community",
    removable: "standalone-only"
};
;
var SeriesArea = class extends BaseProperties {
    destroy() {
        this.cleanup.flush();
    }
    getPadding() {
        const { border, padding: padding2 } = this;
        const strokeWidth = border.enabled ? border.strokeWidth : 0;
        if (typeof padding2 === "number") {
            const total = padding2 + strokeWidth;
            return {
                top: total,
                right: total,
                bottom: total,
                left: total
            };
        }
        var _padding2_top, _padding2_right, _padding2_bottom, _padding2_left;
        return {
            top: ((_padding2_top = padding2.top) !== null && _padding2_top !== void 0 ? _padding2_top : 0) + strokeWidth,
            right: ((_padding2_right = padding2.right) !== null && _padding2_right !== void 0 ? _padding2_right : 0) + strokeWidth,
            bottom: ((_padding2_bottom = padding2.bottom) !== null && _padding2_bottom !== void 0 ? _padding2_bottom : 0) + strokeWidth,
            left: ((_padding2_left = padding2.left) !== null && _padding2_left !== void 0 ? _padding2_left : 0) + strokeWidth
        };
    }
    createNode() {
        return new Group({
            name: "series-area-container",
            zIndex: 4 /* SERIES_AREA_CONTAINER */ 
        });
    }
    onLayoutComplete(event) {
        const { x, y, width: width2, height: height2 } = event.series.paddedRect;
        this.rectNode.x = x;
        this.rectNode.y = y;
        this.rectNode.width = width2;
        this.rectNode.height = height2;
    }
    constructor(ctx){
        super();
        this.ctx = ctx;
        this.rectNode = new Rect();
        this.border = new Border(this.rectNode);
        this.cornerRadius = 0;
        this.padding = 0;
        this.cleanup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]();
        this.node = this.createNode();
        this.node.append([
            this.rectNode
        ]);
        this.rectNode.fill = void 0;
        this.cleanup.register(ctx.scene.attachNode(this.node), ctx.eventsHub.on("layout:complete", (e)=>this.onLayoutComplete(e)));
    }
};
__decorateClass([
    Property
], SeriesArea.prototype, "border", 2);
__decorateClass([
    Property
], SeriesArea.prototype, "clip", 2);
__decorateClass([
    ProxyPropertyOnWrite("rectNode", "cornerRadius"),
    Property
], SeriesArea.prototype, "cornerRadius", 2);
__decorateClass([
    Property
], SeriesArea.prototype, "padding", 2);
// packages/ag-charts-community/src/chart/series-area/seriesAreaModule.ts
var SeriesAreaModule = {
    type: "root",
    optionsKey: "seriesArea",
    packageType: "community",
    chartTypes: [
        "cartesian",
        "polar",
        "topology",
        "standalone"
    ],
    moduleFactory: (ctx)=>new SeriesArea(ctx)
};
;
// packages/ag-charts-community/src/motion/pathMotion.ts
function pathMotion(groupId, subId, animationManager, paths, fns) {
    const animate = (phase, path, collapsable, updateFn)=>{
        animationManager.animate({
            id: "".concat(groupId, "_").concat(subId, "_").concat(path.id, "_").concat(phase),
            groupId,
            from: collapsable ? 1 : 0,
            to: 1,
            ease: easeOut,
            collapsable,
            onUpdate (ratio11, preInit) {
                if (preInit && phase !== "removed") return;
                path.path.clear(true);
                updateFn(ratio11, path);
                path.checkPathDirty();
            },
            onStop () {
                if (phase !== "added") return;
                path.path.clear(true);
                updateFn(1, path);
                path.checkPathDirty();
            },
            phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]
        });
    };
    const tempPath = new Path();
    const resultsChange = (updateFn)=>{
        tempPath.resetPathDirty();
        updateFn(0, tempPath);
        tempPath.resetPathDirty();
        updateFn(1, tempPath);
        tempPath.checkPathDirty();
        return tempPath.isPathDirty();
    };
    const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;
    for (const path of paths){
        if (!animationManager.isSkipped()) {
            animate("removed", path, !resultsChange(removePhaseFn), removePhaseFn);
            animate("updated", path, !resultsChange(updatePhaseFn), updatePhaseFn);
        }
        animate("added", path, !resultsChange(addPhaseFn), addPhaseFn);
    }
}
// packages/ag-charts-community/src/chart/labelUtil.ts
function getLabelStyles(series, nodeDatum, params, label, highlighted, highlightState) {
    if (label.itemStyler) {
        const styleParams = {
            border: label.border,
            color: label.color,
            cornerRadius: label.cornerRadius,
            datum: nodeDatum === null || nodeDatum === void 0 ? void 0 : nodeDatum.datum,
            enabled: label.enabled,
            fill: label.fill,
            fillOpacity: label.fillOpacity,
            fontFamily: label.fontFamily,
            fontSize: label.fontSize,
            fontStyle: label.fontStyle,
            fontWeight: label.fontWeight,
            itemId: void 0,
            seriesId: series.id,
            padding: label.padding,
            highlighted,
            highlightState
        };
        return mergeDefaults(series.callWithContext(label.itemStyler, {
            ...params,
            ...styleParams
        }), styleParams);
    }
    return label;
}
function updateLabelNode(series, textNode, params, label, labelDatum, highlighted, highlightState) {
    if (label.enabled && labelDatum) {
        const style = getLabelStyles(series, labelDatum, params, label, highlighted, highlightState);
        textNode.visible = true;
        textNode.x = labelDatum.x;
        textNode.y = labelDatum.y;
        textNode.text = labelDatum.text;
        textNode.fill = style.color;
        textNode.setAlign(labelDatum);
        textNode.setFont(style);
        textNode.setBoxing(style);
    } else {
        textNode.visible = false;
    }
}
var placements = {
    "inside-start": {
        inside: true,
        direction: -1,
        textAlignment: 1
    },
    "inside-end": {
        inside: true,
        direction: 1,
        textAlignment: -1
    },
    "outside-start": {
        inside: false,
        direction: -1,
        textAlignment: -1
    },
    "outside-end": {
        inside: false,
        direction: 1,
        textAlignment: 1
    }
};
function adjustLabelPlacement(param) {
    let { isUpward, isVertical, placement, spacing = 0, rect } = param;
    let x = rect.x + rect.width / 2;
    let y = rect.y + rect.height / 2;
    let textAlign = "center";
    let textBaseline = "middle";
    if (placement !== "inside-center") {
        const barDirection = (isUpward ? 1 : -1) * (isVertical ? -1 : 1);
        const { direction, textAlignment } = placements[placement];
        const displacementRatio = (direction + 1) * 0.5;
        if (isVertical) {
            const y0 = isUpward ? rect.y + rect.height : rect.y;
            const height2 = rect.height * barDirection;
            y = y0 + height2 * displacementRatio + spacing * textAlignment * barDirection;
            textBaseline = textAlignment === barDirection ? "top" : "bottom";
        } else {
            const x0 = isUpward ? rect.x : rect.x + rect.width;
            const width2 = rect.width * barDirection;
            x = x0 + width2 * displacementRatio + spacing * textAlignment * barDirection;
            textAlign = textAlignment === barDirection ? "left" : "right";
        }
    }
    return {
        x,
        y,
        textAlign,
        textBaseline
    };
}
// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts
function seriesLabelFadeInAnimation(param, subId, animationManager) {
    let { id } = param;
    for(var _len = arguments.length, labelSelections = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
        labelSelections[_key - 3] = arguments[_key];
    }
    for (const labelSelection of labelSelections){
        labelSelection.cleanup();
    }
    staticFromToMotion(id, subId, animationManager, labelSelections, {
        opacity: 0
    }, {
        opacity: 1
    }, {
        phase: "trailing"
    });
}
function seriesLabelFadeOutAnimation(param, subId, animationManager) {
    let { id } = param;
    for(var _len = arguments.length, labelSelections = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
        labelSelections[_key - 3] = arguments[_key];
    }
    staticFromToMotion(id, subId, animationManager, labelSelections, {
        opacity: 1
    }, {
        opacity: 0
    }, {
        phase: "remove"
    });
}
function resetLabelFn(_node) {
    return {
        opacity: 1
    };
}
// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts
var ChangeDetectableProperties = class extends BaseProperties {
    markDirty() {
        this._dirty = true;
    }
    markClean(_opts) {
        this._dirty = false;
    }
    isDirty() {
        return this._dirty;
    }
    onChangeDetection(_property) {
        this.markDirty();
    }
    constructor(){
        super(...arguments);
        this._dirty = true;
    }
};
// packages/ag-charts-community/src/scene/dropShadow.ts
var DropShadow = class extends ChangeDetectableProperties {
    constructor(){
        super(...arguments);
        this.enabled = true;
        this.color = "rgba(0, 0, 0, 0.5)";
        this.xOffset = 0;
        this.yOffset = 0;
        this.blur = 5;
    }
};
__decorateClass([
    Property,
    SceneChangeDetection()
], DropShadow.prototype, "enabled", 2);
__decorateClass([
    Property,
    SceneChangeDetection()
], DropShadow.prototype, "color", 2);
__decorateClass([
    Property,
    SceneChangeDetection()
], DropShadow.prototype, "xOffset", 2);
__decorateClass([
    Property,
    SceneChangeDetection()
], DropShadow.prototype, "yOffset", 2);
__decorateClass([
    Property,
    SceneChangeDetection()
], DropShadow.prototype, "blur", 2);
// packages/ag-charts-community/src/chart/series/seriesMarker.ts
var SeriesMarker = class extends ChangeDetectableProperties {
    getStyle() {
        const { size, shape, fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
        return {
            size,
            shape,
            fill,
            fillOpacity,
            stroke: stroke2,
            strokeWidth,
            strokeOpacity,
            lineDash,
            lineDashOffset
        };
    }
    getDiameter() {
        return this.size + this.strokeWidth;
    }
    constructor(){
        super(...arguments);
        this.enabled = true;
        this.shape = "circle";
        this.size = 6;
        this.fillGradientDefaults = new FillGradientDefaults();
        this.fillPatternDefaults = new FillPatternDefaults();
        this.fillImageDefaults = new FillImageDefaults();
        this.fillOpacity = 1;
        this.strokeWidth = 1;
        this.strokeOpacity = 1;
        this.lineDash = [
            0
        ];
        this.lineDashOffset = 0;
    }
};
__decorateClass([
    Property,
    SceneChangeDetection()
], SeriesMarker.prototype, "enabled", 2);
__decorateClass([
    Property,
    SceneObjectChangeDetection({
        equals: TRIPLE_EQ
    })
], SeriesMarker.prototype, "shape", 2);
__decorateClass([
    Property,
    SceneChangeDetection()
], SeriesMarker.prototype, "size", 2);
__decorateClass([
    Property,
    SceneObjectChangeDetection({
        equals: objectsEqual
    })
], SeriesMarker.prototype, "fill", 2);
__decorateClass([
    Property
], SeriesMarker.prototype, "fillGradientDefaults", 2);
__decorateClass([
    Property
], SeriesMarker.prototype, "fillPatternDefaults", 2);
__decorateClass([
    Property
], SeriesMarker.prototype, "fillImageDefaults", 2);
__decorateClass([
    Property,
    SceneChangeDetection()
], SeriesMarker.prototype, "fillOpacity", 2);
__decorateClass([
    Property,
    SceneChangeDetection()
], SeriesMarker.prototype, "stroke", 2);
__decorateClass([
    Property,
    SceneChangeDetection()
], SeriesMarker.prototype, "strokeWidth", 2);
__decorateClass([
    Property,
    SceneChangeDetection()
], SeriesMarker.prototype, "strokeOpacity", 2);
__decorateClass([
    Property
], SeriesMarker.prototype, "lineDash", 2);
__decorateClass([
    Property
], SeriesMarker.prototype, "lineDashOffset", 2);
__decorateClass([
    Property,
    SceneObjectChangeDetection({
        equals: TRIPLE_EQ
    })
], SeriesMarker.prototype, "itemStyler", 2);
// packages/ag-charts-community/src/chart/series/seriesTooltip.ts
var SeriesTooltipInteraction = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.enabled = false;
    }
};
__decorateClass([
    Property
], SeriesTooltipInteraction.prototype, "enabled", 2);
var SeriesTooltip = class extends BaseProperties {
    formatTooltip(callers, content, params) {
        const overrides = this.renderer == null ? void 0 : callWithContext(callers, this.renderer, params);
        if (typeof overrides === "string") return {
            type: "raw",
            rawHtmlString: overrides
        };
        if (overrides != null) return {
            type: "structured",
            ...content,
            ...overrides
        };
        return {
            type: "structured",
            ...content
        };
    }
    constructor(){
        super(...arguments);
        this.interaction = new SeriesTooltipInteraction();
        this.position = new TooltipPosition();
        this.range = void 0;
        this.class = void 0;
    }
};
__decorateClass([
    Property
], SeriesTooltip.prototype, "enabled", 2);
__decorateClass([
    Property
], SeriesTooltip.prototype, "showArrow", 2);
__decorateClass([
    Property
], SeriesTooltip.prototype, "renderer", 2);
__decorateClass([
    Property
], SeriesTooltip.prototype, "interaction", 2);
__decorateClass([
    Property
], SeriesTooltip.prototype, "position", 2);
__decorateClass([
    Property
], SeriesTooltip.prototype, "range", 2);
__decorateClass([
    Property
], SeriesTooltip.prototype, "class", 2);
function makeSeriesTooltip() {
    return new SeriesTooltip();
}
;
// packages/ag-charts-community/src/scene/util/quadtree.ts
var QuadtreeNearest = class {
    clear(boundary) {
        this.root.clear(boundary);
    }
    addValue(hitTester, value) {
        const elem = {
            hitTester,
            value,
            distanceSquared: (x, y)=>{
                return hitTester.distanceSquared(x, y);
            }
        };
        this.root.addElem(elem);
    }
    find(x, y) {
        const arg = {
            best: {
                nearest: void 0,
                distanceSquared: Infinity
            }
        };
        this.root.find(x, y, arg);
        return arg.best;
    }
    constructor(capacity, maxdepth, boundary){
        this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);
    }
};
var QuadtreeSubdivisions = class {
    addElem(elem) {
        this.nw.addElem(elem);
        this.ne.addElem(elem);
        this.sw.addElem(elem);
        this.se.addElem(elem);
    }
    find(x, y, arg) {
        this.nw.find(x, y, arg);
        this.ne.find(x, y, arg);
        this.sw.find(x, y, arg);
        this.se.find(x, y, arg);
    }
    constructor(nw, ne, sw, se){
        this.nw = nw;
        this.ne = ne;
        this.sw = sw;
        this.se = se;
    }
};
var QuadtreeNode = class {
    clear(boundary) {
        this.elems.length = 0;
        this.boundary = boundary;
        this.subdivisions = void 0;
    }
    addElem(e) {
        if (this.addCondition(e)) {
            if (this.subdivisions === void 0) {
                if (this.maxdepth === 0 || this.elems.length < this.capacity) {
                    this.elems.push(e);
                } else {
                    this.subdivide(e);
                }
            } else {
                this.subdivisions.addElem(e);
            }
        }
    }
    find(x, y, arg) {
        if (this.findCondition(x, y, arg)) {
            if (this.subdivisions === void 0) {
                this.findAction(x, y, arg);
            } else {
                this.subdivisions.find(x, y, arg);
            }
        }
    }
    subdivide(newElem) {
        this.subdivisions = this.makeSubdivisions();
        for (const e of this.elems){
            this.subdivisions.addElem(e);
        }
        this.subdivisions.addElem(newElem);
        this.elems.length = 0;
    }
    makeSubdivisions() {
        const { x, y, width: width2, height: height2 } = this.boundary;
        const { capacity } = this;
        const depth = this.maxdepth - 1;
        const halfWidth = width2 / 2;
        const halfHeight = height2 / 2;
        const nwBoundary = new BBox(x, y, halfWidth, halfHeight);
        const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);
        const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);
        const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);
        return new QuadtreeSubdivisions(this.child(capacity, depth, nwBoundary), this.child(capacity, depth, neBoundary), this.child(capacity, depth, swBoundary), this.child(capacity, depth, seBoundary));
    }
    constructor(capacity, maxdepth, boundary){
        this.capacity = capacity;
        this.maxdepth = maxdepth;
        this.boundary = boundary !== null && boundary !== void 0 ? boundary : BBox.NaN;
        this.elems = [];
        this.subdivisions = void 0;
    }
};
var QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {
    addCondition(e) {
        const { x, y } = e.hitTester.midPoint;
        return this.boundary.containsPoint(x, y);
    }
    findCondition(x, y, arg) {
        const { best } = arg;
        return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;
    }
    findAction(x, y, arg) {
        const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);
        if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {
            arg.best = other;
        }
    }
    child(capacity, depth, boundary) {
        return new _QuadtreeNodeNearest(capacity, depth, boundary);
    }
};
;
var DataModelSeries = class extends Series {
    dataCount() {
        var _this_processedData_dataSources_get, _this_processedData_dataSources, _this_processedData;
        var _this_processedData_dataSources_get_length;
        return (_this_processedData_dataSources_get_length = (_this_processedData = this.processedData) === null || _this_processedData === void 0 ? void 0 : (_this_processedData_dataSources = _this_processedData.dataSources) === null || _this_processedData_dataSources === void 0 ? void 0 : (_this_processedData_dataSources_get = _this_processedData_dataSources.get(this.id)) === null || _this_processedData_dataSources_get === void 0 ? void 0 : _this_processedData_dataSources_get.length) !== null && _this_processedData_dataSources_get_length !== void 0 ? _this_processedData_dataSources_get_length : 0;
    }
    getScaleInformation(param) {
        let { xScale, yScale } = param;
        const isContinuousX = ContinuousScale.is(xScale);
        const isContinuousY = ContinuousScale.is(yScale);
        return {
            isContinuousX,
            isContinuousY,
            xScaleType: xScale === null || xScale === void 0 ? void 0 : xScale.type,
            yScaleType: yScale === null || yScale === void 0 ? void 0 : yScale.type
        };
    }
    getModulePropertyDefinitions() {
        var _this_axes_x, _this_axes_y;
        const xScale = (_this_axes_x = this.axes["x" /* X */ ]) === null || _this_axes_x === void 0 ? void 0 : _this_axes_x.scale;
        const yScale = (_this_axes_y = this.axes["y" /* Y */ ]) === null || _this_axes_y === void 0 ? void 0 : _this_axes_y.scale;
        return this.moduleMap.mapModules((mod)=>mod.getPropertyDefinitions(this.getScaleInformation({
                xScale,
                yScale
            }))).flat();
    }
    // Request data, but with message dispatching to series-options (modules).
    async requestDataModel(dataController, data, opts) {
        opts.props.push(...this.getModulePropertyDefinitions());
        const { dataModel, processedData } = await dataController.request(this.id, data !== null && data !== void 0 ? data : [], opts);
        this.dataModel = dataModel;
        this.processedData = processedData;
        this.events.emit("data-processed", {
            dataModel,
            processedData
        });
        return {
            dataModel,
            processedData
        };
    }
    isProcessedDataAnimatable() {
        var _processedData_reduced;
        const { processedData } = this;
        if (!processedData) return false;
        const validationResults = (_processedData_reduced = processedData.reduced) === null || _processedData_reduced === void 0 ? void 0 : _processedData_reduced.animationValidation;
        if (!validationResults) return true;
        const { orderedKeys, uniqueKeys } = validationResults;
        return orderedKeys && uniqueKeys;
    }
    checkProcessedDataAnimatable() {
        if (!this.isProcessedDataAnimatable()) {
            this.ctx.animationManager.skipCurrentBatch();
        }
    }
    pickFocus(opts) {
        const nodeData = this.getNodeData();
        if (nodeData === void 0 || nodeData.length === 0) {
            return;
        }
        const datumIndex = this.computeFocusDatumIndex(opts, nodeData);
        if (datumIndex === void 0) {
            return;
        }
        const { clipFocusBox } = this;
        const datum = nodeData[datumIndex];
        const derivedOpts = {
            ...opts,
            datumIndex
        };
        const bounds = this.computeFocusBounds(derivedOpts);
        if (bounds !== void 0) {
            return {
                bounds,
                clipFocusBox,
                datum,
                datumIndex
            };
        }
    }
    pickNodesExactShape(point) {
        const datums = super.pickNodesExactShape(point);
        datums.sort((a, b)=>a.datumIndex - b.datumIndex);
        return datums;
    }
    isDatumEnabled(nodeData, datumIndex) {
        const { missing = false, enabled = true, focusable = true } = nodeData[datumIndex];
        return !missing && enabled && focusable;
    }
    computeFocusDatumIndex(opts, nodeData) {
        const searchBackward = (datumIndex2, delta3)=>{
            while(datumIndex2 >= 0 && !this.isDatumEnabled(nodeData, datumIndex2)){
                datumIndex2 += delta3;
            }
            return datumIndex2 === -1 ? void 0 : datumIndex2;
        };
        const searchForward = (datumIndex2, delta3)=>{
            while(datumIndex2 < nodeData.length && !this.isDatumEnabled(nodeData, datumIndex2)){
                datumIndex2 += delta3;
            }
            return datumIndex2 === nodeData.length ? void 0 : datumIndex2;
        };
        let datumIndex;
        const clampedIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, opts.datumIndex, nodeData.length - 1);
        if (opts.datumIndexDelta < 0) {
            datumIndex = searchBackward(clampedIndex, opts.datumIndexDelta);
        } else if (opts.datumIndexDelta > 0) {
            datumIndex = searchForward(clampedIndex, opts.datumIndexDelta);
        } else {
            var _searchForward;
            datumIndex = (_searchForward = searchForward(clampedIndex, 1)) !== null && _searchForward !== void 0 ? _searchForward : searchBackward(clampedIndex, -1);
        }
        if (datumIndex === void 0) {
            if (opts.datumIndexDelta === 0) {
                return;
            } else {
                return opts.datumIndex - opts.datumIndexDelta;
            }
        } else {
            return datumIndex;
        }
    }
    // Workaround - it would be nice if this difference didn't exist
    dataModelPropertyIsKey(key) {
        const { processedData } = this;
        if (!processedData) return false;
        return processedData.defs.keys.some((def)=>{
            var _def_idsMap_get, _def_idsMap;
            return def.id === key && ((_def_idsMap = def.idsMap) === null || _def_idsMap === void 0 ? void 0 : (_def_idsMap_get = _def_idsMap.get(this.id)) === null || _def_idsMap_get === void 0 ? void 0 : _def_idsMap_get.has(key)) === true;
        });
    }
    keysOrValues(xKey) {
        const { dataModel, processedData } = this;
        if (!dataModel || !processedData) return [];
        return this.dataModelPropertyIsKey(xKey) ? dataModel.resolveKeysById(this, xKey, processedData) : dataModel.resolveColumnById(this, xKey, processedData);
    }
    sortOrder(xKey) {
        const { dataModel, processedData } = this;
        if (!dataModel || !processedData) return;
        return this.dataModelPropertyIsKey(xKey) ? dataModel.getKeySortOrder(this, xKey, processedData) : dataModel.getColumnSortOrder(this, xKey, processedData);
    }
    getCategoryKey() {
        return this.categoryKey;
    }
    getCategoryValue(datumIndex) {
        var _processedData_invalidData_get, _processedData_invalidData;
        const { processedData, dataModel } = this;
        const categoryKey = this.getCategoryKey();
        if (!processedData || !dataModel || !categoryKey) return;
        var _processedData_invalidData_get_datumIndex;
        const invalid = (_processedData_invalidData_get_datumIndex = (_processedData_invalidData = processedData.invalidData) === null || _processedData_invalidData === void 0 ? void 0 : (_processedData_invalidData_get = _processedData_invalidData.get(this.id)) === null || _processedData_invalidData_get === void 0 ? void 0 : _processedData_invalidData_get[datumIndex]) !== null && _processedData_invalidData_get_datumIndex !== void 0 ? _processedData_invalidData_get_datumIndex : false;
        return invalid ? void 0 : this.keysOrValues(categoryKey)[datumIndex];
    }
    datumIndexForCategoryValue(categoryValue) {
        var _processedData_invalidData;
        const { processedData, dataModel } = this;
        const categoryKey = this.getCategoryKey();
        if (!processedData || !dataModel || !categoryKey) return;
        categoryValue = categoryValue.valueOf();
        const invalidValues = (_processedData_invalidData = processedData.invalidData) === null || _processedData_invalidData === void 0 ? void 0 : _processedData_invalidData.get(this.id);
        const xValues = this.keysOrValues(categoryKey);
        for(let datumIndex = 0; datumIndex < xValues.length; datumIndex += 1){
            var _xValues_datumIndex;
            if ((invalidValues === null || invalidValues === void 0 ? void 0 : invalidValues[datumIndex]) === true) continue;
            const xValue = (_xValues_datumIndex = xValues[datumIndex]) === null || _xValues_datumIndex === void 0 ? void 0 : _xValues_datumIndex.valueOf();
            if (objectsEqual(categoryValue, xValue)) return datumIndex;
        }
    }
    constructor({ clipFocusBox, categoryKey, ...seriesOpts }){
        super(seriesOpts);
        this.categoryKey = categoryKey;
        this.clipFocusBox = clipFocusBox !== null && clipFocusBox !== void 0 ? clipFocusBox : true;
    }
};
// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts
var DEFAULT_CARTESIAN_DIRECTION_KEYS = {
    ["x" /* X */ ]: [
        "xKey"
    ],
    ["y" /* Y */ ]: [
        "yKey"
    ]
};
var DEFAULT_CARTESIAN_DIRECTION_NAMES = {
    ["x" /* X */ ]: [
        "xName"
    ],
    ["y" /* Y */ ]: [
        "yName"
    ]
};
var CartesianSeriesNodeEvent = class extends SeriesNodeEvent {
    constructor(type, nativeEvent, datum, series){
        super(type, nativeEvent, datum, series);
        this.xKey = series.properties.xKey;
        this.yKey = series.properties.yKey;
    }
};
var CartesianSeriesProperties = class extends SeriesProperties {
    constructor(){
        super(...arguments);
        this.pickOutsideVisibleMinorAxis = false;
    }
};
__decorateClass([
    Property
], CartesianSeriesProperties.prototype, "legendItemName", 2);
__decorateClass([
    Property
], CartesianSeriesProperties.prototype, "pickOutsideVisibleMinorAxis", 2);
var RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD = 100;
var CartesianSeries = class extends DataModelSeries {
    get contextNodeData() {
        return this._contextNodeData;
    }
    getNodeData() {
        var _this_contextNodeData;
        return (_this_contextNodeData = this.contextNodeData) === null || _this_contextNodeData === void 0 ? void 0 : _this_contextNodeData.nodeData;
    }
    attachSeries(seriesContentNode, seriesNode, annotationNode) {
        super.attachSeries(seriesContentNode, seriesNode, annotationNode);
        this.attachPaths(this.paths);
    }
    detachSeries(seriesContentNode, seriesNode, annotationNode) {
        super.detachSeries(seriesContentNode, seriesNode, annotationNode);
        this.detachPaths(this.paths);
    }
    updatedDomains() {
        this.animationState.transition("updateData");
    }
    attachPaths(paths) {
        for (const path of paths){
            this.contentGroup.appendChild(path);
        }
    }
    detachPaths(paths) {
        for (const path of paths){
            this.contentGroup.removeChild(path);
        }
    }
    renderToOffscreenCanvas() {
        const nodeData = this.getNodeData();
        return nodeData != null && nodeData.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD;
    }
    resetAnimation(phase) {
        if (phase === "initial") {
            this.animationState.transition("reset");
        } else if (phase === "ready") {
            this.animationState.transition("skip");
        } else if (phase === "disabled") {
            this.animationState.transition("disable");
        }
    }
    addChartEventListeners() {
        this.cleanup.register(this.ctx.eventsHub.on("legend:item-click", (event)=>this.onLegendItemClick(event)), this.ctx.eventsHub.on("legend:item-double-click", (event)=>this.onLegendItemDoubleClick(event)));
    }
    destroy() {
        super.destroy();
        this._contextNodeData = void 0;
    }
    isSeriesHighlighted(highlightedDatum) {
        const { series, legendItemName: activeLegendItemName } = highlightedDatum !== null && highlightedDatum !== void 0 ? highlightedDatum : {};
        const { legendItemName } = this.properties;
        return series === this || legendItemName != null && legendItemName === activeLegendItemName;
    }
    strokewidthChange() {
        var _this_properties_highlight_highlightedItem;
        var _ref;
        const unhighlightedStrokeWidth = (_ref = "strokeWidth" in this.properties && this.properties.strokeWidth) !== null && _ref !== void 0 ? _ref : 0;
        var _this_properties_highlight_highlightedSeries_strokeWidth;
        const highlightedSeriesStrokeWidth = (_this_properties_highlight_highlightedSeries_strokeWidth = this.properties.highlight.highlightedSeries.strokeWidth) !== null && _this_properties_highlight_highlightedSeries_strokeWidth !== void 0 ? _this_properties_highlight_highlightedSeries_strokeWidth : unhighlightedStrokeWidth;
        var _this_properties_highlight_highlightedItem_strokeWidth;
        const highlightedItemStrokeWidth = (_this_properties_highlight_highlightedItem_strokeWidth = (_this_properties_highlight_highlightedItem = this.properties.highlight.highlightedItem) === null || _this_properties_highlight_highlightedItem === void 0 ? void 0 : _this_properties_highlight_highlightedItem.strokeWidth) !== null && _this_properties_highlight_highlightedItem_strokeWidth !== void 0 ? _this_properties_highlight_highlightedItem_strokeWidth : unhighlightedStrokeWidth;
        return unhighlightedStrokeWidth > highlightedItemStrokeWidth || highlightedSeriesStrokeWidth > highlightedItemStrokeWidth;
    }
    update(param) {
        let { seriesRect } = param;
        const { _contextNodeData: previousContextData } = this;
        const resize = this.checkResize(seriesRect);
        const itemHighlighted = this.updateHighlightSelection();
        this.contentGroup.batchedUpdate(()=>{
            const dataChanged = this.updateSelections();
            this.updateNodes(itemHighlighted, resize || dataChanged);
        });
        const animationData = this.getAnimationData(seriesRect, previousContextData);
        if (!animationData) return;
        if (resize) {
            this.animationState.transition("resize", animationData);
        }
        this.animationState.transition("update", animationData);
    }
    updateSelections() {
        var _a;
        const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();
        if (!this.visible && animationSkipUpdate) {
            return false;
        }
        const { nodeDataRefresh } = this;
        if (!nodeDataRefresh && !this.isPathOrSelectionDirty()) {
            return false;
        }
        if (nodeDataRefresh) {
            this.nodeDataRefresh = false;
            this.debug("CartesianSeries.updateSelections() - calling createNodeData() for", this.id);
            this.markQuadtreeDirty();
            this._contextNodeData = this.createNodeData();
            const animationValid = this.isProcessedDataAnimatable();
            if (this._contextNodeData) {
                var _animationValid;
                (_animationValid = (_a = this._contextNodeData).animationValid) !== null && _animationValid !== void 0 ? _animationValid : _a.animationValid = animationValid;
            }
            const { dataModel, processedData } = this;
            if (dataModel !== void 0 && processedData !== void 0) {
                this.events.emit("data-update", {
                    dataModel,
                    processedData
                });
            }
            this.updateSeriesSelections();
        }
        return nodeDataRefresh;
    }
    updateSeriesSelections() {
        const { datumSelection, labelSelection, paths } = this;
        const contextData = this._contextNodeData;
        if (!contextData) return;
        const { nodeData, labelData, itemId } = contextData;
        this.updatePaths({
            itemId,
            contextData,
            paths
        });
        this.datumSelection = this.updateDatumSelection({
            nodeData,
            datumSelection
        });
        this.labelGroup.batchedUpdate(()=>{
            var _this_updateLabelSelection;
            this.labelSelection = (_this_updateLabelSelection = this.updateLabelSelection({
                labelData,
                labelSelection
            })) !== null && _this_updateLabelSelection !== void 0 ? _this_updateLabelSelection : labelSelection;
        });
    }
    getShapeFillBBox() {
        const { axes } = this;
        const xAxis = axes["x" /* X */ ];
        const yAxis = axes["y" /* Y */ ];
        var _xAxis_range;
        const [axisX1, axisX2] = findMinMax((_xAxis_range = xAxis === null || xAxis === void 0 ? void 0 : xAxis.range) !== null && _xAxis_range !== void 0 ? _xAxis_range : [
            0,
            1
        ]);
        var _yAxis_range;
        const [axisY1, axisY2] = findMinMax((_yAxis_range = yAxis === null || yAxis === void 0 ? void 0 : yAxis.range) !== null && _yAxis_range !== void 0 ? _yAxis_range : [
            0,
            1
        ]);
        const xSeriesDomain = this.getSeriesDomain("x" /* X */ );
        const xSeriesRange = [
            xAxis === null || xAxis === void 0 ? void 0 : xAxis.scale.convert(xSeriesDomain.at(0)),
            xAxis === null || xAxis === void 0 ? void 0 : xAxis.scale.convert(xSeriesDomain.at(-1))
        ];
        const ySeriesDomain = this.getSeriesDomain("y" /* Y */ );
        const ySeriesRange = [
            yAxis === null || yAxis === void 0 ? void 0 : yAxis.scale.convert(ySeriesDomain.at(0)),
            yAxis === null || yAxis === void 0 ? void 0 : yAxis.scale.convert(ySeriesDomain.at(-1))
        ];
        const [seriesX1, seriesX2] = findMinMax(xSeriesRange);
        const [seriesY1, seriesY2] = findMinMax(ySeriesRange);
        return {
            axis: new BBox(axisX1, axisY1, axisX2 - axisX1, axisY2 - axisY1),
            series: new BBox(seriesX1, seriesY1, seriesX2 - seriesX1, seriesY2 - seriesY1)
        };
    }
    updateNodes(itemHighlighted, nodeRefresh) {
        const { highlightSelection, datumSelection } = this;
        const animationEnabled = !this.ctx.animationManager.isSkipped();
        const visible = this.visible && this._contextNodeData != null;
        this.contentGroup.visible = animationEnabled || visible;
        this.highlightGroup.visible = (animationEnabled || visible) && itemHighlighted;
        this.updateDatumNodes({
            datumSelection: highlightSelection,
            isHighlight: true
        });
        this.animationState.transition("highlight", highlightSelection);
        const { dataNodeGroup, labelSelection, paths, labelGroup } = this;
        var _this_contextNodeData;
        const { itemId } = (_this_contextNodeData = this.contextNodeData) !== null && _this_contextNodeData !== void 0 ? _this_contextNodeData : {};
        this.updatePathNodes({
            itemId,
            paths,
            visible,
            animationEnabled
        });
        dataNodeGroup.visible = animationEnabled || visible;
        labelGroup.visible = visible;
        if (!dataNodeGroup.visible) {
            return;
        }
        const redrawAll = this.strokewidthChange() || this.hasChangesOnHighlight;
        if (nodeRefresh || redrawAll) {
            this.updateDatumNodes({
                datumSelection,
                isHighlight: false
            });
            if (!this.usesPlacedLabels) {
                this.labelGroup.batchedUpdate(()=>{
                    this.updateLabelNodes({
                        labelSelection,
                        isHighlight: false
                    });
                });
            }
        }
    }
    getHighlightLabelData(labelData, highlightedItem) {
        const labelItems = labelData.filter((ld)=>ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId);
        return labelItems.length === 0 ? void 0 : labelItems;
    }
    getHighlightData(_nodeData, highlightedItem) {
        return highlightedItem ? [
            highlightedItem
        ] : void 0;
    }
    updateHighlightSelection() {
        var _this_ctx_highlightManager;
        const { highlightSelection, _contextNodeData: contextNodeData } = this;
        if (!contextNodeData) return false;
        const highlightedDatum = (_this_ctx_highlightManager = this.ctx.highlightManager) === null || _this_ctx_highlightManager === void 0 ? void 0 : _this_ctx_highlightManager.getActiveHighlight();
        const seriesHighlighted = this.isSeriesHighlighted(highlightedDatum);
        const item = seriesHighlighted && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.datum) ? highlightedDatum : void 0;
        if (item == null) return false;
        const { nodeData } = contextNodeData;
        const highlightItems = this.getHighlightData(nodeData, item);
        this.highlightSelection = this.updateHighlightSelectionItem({
            items: highlightItems,
            highlightSelection
        });
        return true;
    }
    markQuadtreeDirty() {
        this.quadtree = void 0;
    }
    *datumNodesIter() {
        for (const { node } of this.datumSelection){
            if (node.datum.missing === true) continue;
            yield node;
        }
    }
    getQuadTree() {
        if (this.quadtree === void 0) {
            const { width: width2, height: height2 } = this.ctx.scene.canvas;
            const canvasRect = new BBox(0, 0, width2, height2);
            this.quadtree = new QuadtreeNearest(100, 10, canvasRect);
            this.initQuadTree(this.quadtree);
        }
        return this.quadtree;
    }
    initQuadTree(_quadtree) {}
    pickNodesExactShape(point) {
        const result = super.pickNodesExactShape(point);
        if (result.length !== 0) {
            return result;
        }
        const { x, y } = point;
        const { dataNodeGroup } = this;
        const matches = dataNodeGroup.pickNodes(x, y).filter((match)=>match.datum.missing !== true);
        if (matches.length !== 0) {
            const datums = matches.map((match)=>match.datum);
            return datums;
        }
        for (const mod of this.moduleMap.modules()){
            var _mod_pickNodeExact;
            const { datum } = (_mod_pickNodeExact = mod.pickNodeExact(point)) !== null && _mod_pickNodeExact !== void 0 ? _mod_pickNodeExact : {};
            if (datum == null) continue;
            if ((datum === null || datum === void 0 ? void 0 : datum.missing) === true) continue;
            return [
                datum
            ];
        }
        return [];
    }
    pickNodeClosestDatum(point) {
        const { x, y } = point;
        const { axes, _contextNodeData: contextNodeData } = this;
        if (!contextNodeData) return;
        const xAxis = axes["x" /* X */ ];
        const yAxis = axes["y" /* Y */ ];
        const hitPoint = {
            x,
            y
        };
        let minDistance = Infinity;
        let closestDatum;
        for (const datum of contextNodeData.nodeData){
            const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;
            if (isNaN(datumX) || isNaN(datumY)) {
                continue;
            }
            const isInRange = (xAxis === null || xAxis === void 0 ? void 0 : xAxis.inRange(datumX)) && (yAxis === null || yAxis === void 0 ? void 0 : yAxis.inRange(datumY));
            if (!isInRange) {
                continue;
            }
            const distance2 = Math.max((hitPoint.x - datumX) ** 2 + (hitPoint.y - datumY) ** 2, 0);
            if (distance2 < minDistance) {
                minDistance = distance2;
                closestDatum = datum;
            }
        }
        for (const mod of this.moduleMap.modules()){
            const modPick = mod.pickNodeNearest(point);
            if (modPick !== void 0 && modPick.distanceSquared < minDistance) {
                minDistance = modPick.distanceSquared;
                closestDatum = modPick.datum;
                break;
            }
        }
        if (closestDatum) {
            var _closestDatum_point;
            var _closestDatum_point_size;
            const distance2 = Math.max(Math.sqrt(minDistance) - ((_closestDatum_point_size = (_closestDatum_point = closestDatum.point) === null || _closestDatum_point === void 0 ? void 0 : _closestDatum_point.size) !== null && _closestDatum_point_size !== void 0 ? _closestDatum_point_size : 0) / 2, 0);
            return {
                datum: closestDatum,
                distance: distance2
            };
        }
    }
    pickNodeMainAxisFirst(point, requireCategoryAxis) {
        const { x, y } = point;
        const { axes, _contextNodeData: contextNodeData } = this;
        const { pickOutsideVisibleMinorAxis } = this.properties;
        if (!contextNodeData) return;
        const xAxis = axes["x" /* X */ ];
        const yAxis = axes["y" /* Y */ ];
        if (xAxis == null || yAxis == null) return;
        const directions2 = [
            xAxis,
            yAxis
        ].filter((axis)=>axis.isCategoryLike()).map((a)=>a.direction);
        if (requireCategoryAxis && directions2.length === 0) return;
        const [majorDirection = "x" /* X */ ] = directions2;
        const hitPointCoords = [
            x,
            y
        ];
        if (majorDirection !== "x" /* X */ ) hitPointCoords.reverse();
        const minDistance = [
            Infinity,
            Infinity
        ];
        let closestDatum;
        for (const datum of contextNodeData.nodeData){
            var _datum_point, _ref;
            const { x: datumX = NaN, y: datumY = NaN } = (_ref = (_datum_point = datum.point) !== null && _datum_point !== void 0 ? _datum_point : datum.midPoint) !== null && _ref !== void 0 ? _ref : {};
            if (isNaN(datumX) || isNaN(datumY) || datum.missing === true) continue;
            const visible = [
                xAxis === null || xAxis === void 0 ? void 0 : xAxis.inRange(datumX, 1),
                yAxis === null || yAxis === void 0 ? void 0 : yAxis.inRange(datumY, 1)
            ];
            if (majorDirection !== "x" /* X */ ) {
                visible.reverse();
            }
            if (!visible[0] || !pickOutsideVisibleMinorAxis && !visible[1]) continue;
            const datumPoint = [
                datumX,
                datumY
            ];
            if (majorDirection !== "x" /* X */ ) {
                datumPoint.reverse();
            }
            let newMinDistance = true;
            for(let i = 0; i < datumPoint.length; i++){
                const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);
                if (dist > minDistance[i]) {
                    newMinDistance = false;
                    break;
                } else if (dist < minDistance[i]) {
                    minDistance[i] = dist;
                    minDistance.fill(Infinity, i + 1, minDistance.length);
                }
            }
            if (newMinDistance) {
                closestDatum = datum;
            }
        }
        if (closestDatum) {
            var _closestDatum_point;
            var _closestDatum_point_size;
            let closestDistanceSquared = Math.max(minDistance[0] ** 2 + minDistance[1] ** 2 - ((_closestDatum_point_size = (_closestDatum_point = closestDatum.point) === null || _closestDatum_point === void 0 ? void 0 : _closestDatum_point.size) !== null && _closestDatum_point_size !== void 0 ? _closestDatum_point_size : 0), 0);
            for (const mod of this.moduleMap.modules()){
                const modPick = mod.pickNodeMainAxisFirst(point, majorDirection);
                if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {
                    closestDatum = modPick.datum;
                    closestDistanceSquared = modPick.distanceSquared;
                    break;
                }
            }
            return {
                datum: closestDatum,
                distance: Math.sqrt(closestDistanceSquared)
            };
        }
    }
    isPathOrSelectionDirty() {
        return false;
    }
    shouldFlipXY() {
        return false;
    }
    visibleRangeIndices(axisKey, visibleRange, indices, sortOrderParams) {
        let sortOrder;
        if (sortOrderParams == null) {
            const { processedData, dataModel } = this;
            var _dataModel_getColumnSortOrder;
            sortOrder = (_dataModel_getColumnSortOrder = dataModel.getColumnSortOrder(this, axisKey, processedData)) !== null && _dataModel_getColumnSortOrder !== void 0 ? _dataModel_getColumnSortOrder : 1;
        } else {
            sortOrder = sortOrderParams.sortOrder;
        }
        const xValues = this.keysOrValues(axisKey);
        const pixelSize = 0;
        var _indices_length;
        const [start2, end2] = visibleRangeIndices(sortOrder, (_indices_length = indices === null || indices === void 0 ? void 0 : indices.length) !== null && _indices_length !== void 0 ? _indices_length : xValues.length, visibleRange, (topIndex)=>{
            var _indices_topIndex;
            const datumIndex = (_indices_topIndex = indices === null || indices === void 0 ? void 0 : indices[topIndex]) !== null && _indices_topIndex !== void 0 ? _indices_topIndex : topIndex;
            return this.xCoordinateRange(xValues[datumIndex], pixelSize, datumIndex);
        });
        return start2 < end2 ? [
            start2,
            end2
        ] : [
            end2,
            start2
        ];
    }
    domainForVisibleRange(_direction, axisKeys, crossAxisKey, visibleRange, indices) {
        const { processedData, dataModel } = this;
        const [r0, r1] = visibleRange;
        const crossAxisValues = this.keysOrValues(crossAxisKey);
        const sortOrder = this.sortOrder(crossAxisKey);
        if (sortOrder != null) {
            const crossAxisRange = this.visibleRangeIndices(crossAxisKey, visibleRange, indices, {
                sortOrder
            });
            return dataModel.getDomainBetweenRange(this, axisKeys, crossAxisRange, processedData);
        }
        const allAxisValues = axisKeys.map((axisKey)=>this.keysOrValues(axisKey));
        let axisMin = Infinity;
        let axisMax = -Infinity;
        crossAxisValues.forEach((crossAxisValue, i)=>{
            const [x0, x1] = this.xCoordinateRange(crossAxisValue, 0, i);
            if (x1 < r0 || x0 > r1) return;
            for(let j = 0; j < axisKeys.length; j++){
                const axisValue = allAxisValues[j][i];
                axisMin = Math.min(axisMin, axisValue);
                axisMax = Math.max(axisMax, axisValue);
            }
        });
        if (axisMin > axisMax) return [
            NaN,
            NaN
        ];
        return [
            axisMin,
            axisMax
        ];
    }
    domainForClippedRange(direction, axisKeys, crossAxisKey) {
        const { processedData, dataModel, axes } = this;
        const crossDirection = direction === "x" /* X */  ? "y" /* Y */  : "x" /* X */ ;
        const crossAxisRange = axisExtent(axes[crossDirection]);
        if (!crossAxisRange) {
            return axisKeys.flatMap((axisKey)=>dataModel.getDomain(this, axisKey, "value", processedData));
        }
        const crossAxisValues = this.keysOrValues(crossAxisKey);
        const sortOrder = dataModel.getColumnSortOrder(this, crossAxisKey, processedData);
        if (sortOrder != null) {
            const crossRange = clippedRangeIndices(sortOrder, crossAxisValues.length, crossAxisRange, (index)=>crossAxisValues[index]);
            return dataModel.getDomainBetweenRange(this, axisKeys, crossRange, processedData);
        }
        const allAxisValues = axisKeys.map((axisKey)=>this.keysOrValues(axisKey));
        const range0 = crossAxisRange[0].valueOf();
        const range1 = crossAxisRange[1].valueOf();
        const axisValues = [];
        crossAxisValues.forEach((crossAxisValue, i)=>{
            const c = crossAxisValue.valueOf();
            if (c < range0 || c > range1) return;
            const values = allAxisValues.map((v)=>v[i]);
            if (c >= range0) {
                axisValues.push(...values);
            }
            if (c <= range1) {
                axisValues.push(...values);
            }
        });
        return axisValues;
    }
    countVisibleItems(crossAxisKey, axisKeys, xVisibleRange, yVisibleRange, minVisibleItems) {
        const { dataModel, processedData } = this;
        if (!dataModel || !processedData) return Infinity;
        const crossValues = this.keysOrValues(crossAxisKey);
        const allAxisValues = axisKeys.map((axisKey)=>dataModel.resolveColumnById(this, axisKey, processedData));
        const crossAxis = this.axes["x" /* X */ ];
        const axis = this.axes["y" /* Y */ ];
        const shouldFlipXY = this.shouldFlipXY();
        if (yVisibleRange == null) {
            const sortOrder = this.sortOrder(crossAxisKey);
            if (sortOrder == null) {
                yVisibleRange = [
                    0,
                    1
                ];
            } else {
                const crossScale = crossAxis.scale;
                const crossScaleRange = crossScale.range;
                crossScale.range = [
                    0,
                    1
                ];
                let [r0, r1] = this.visibleRangeIndices(crossAxisKey, xVisibleRange, void 0, {
                    sortOrder
                });
                const xValues = this.keysOrValues(crossAxisKey);
                const pixelSize2 = 0;
                if (this.xCoordinateRange(xValues[r0], pixelSize2, r0)[0] < xVisibleRange[0]) {
                    r0 += 1;
                }
                if (r1 < xValues.length && this.xCoordinateRange(xValues[r1], pixelSize2, r1)[1] > xVisibleRange[1]) {
                    r1 -= 1;
                }
                const xItemsVisible = Math.abs(r1 - r0);
                crossScale.range = crossScaleRange;
                return xItemsVisible;
            }
        }
        const convert = (d, r, v)=>{
            return d[0] + (v - r[0]) / (r[1] - r[0]) * (d[1] - d[0]);
        };
        const crossAxisRange = crossAxis.range;
        const range3 = axis.range;
        const crossMin = convert(crossAxisRange, crossAxis.visibleRange, xVisibleRange[0]);
        const crossMax = convert(crossAxisRange, crossAxis.visibleRange, xVisibleRange[1]);
        const axisMin = convert(range3, axis.visibleRange, shouldFlipXY ? yVisibleRange[0] : yVisibleRange[1]);
        const axisMax = convert(range3, axis.visibleRange, shouldFlipXY ? yVisibleRange[1] : yVisibleRange[0]);
        const startIndex = Math.round((xVisibleRange[0] + (xVisibleRange[1] - xVisibleRange[0]) / 2) * crossValues.length);
        const pixelSize = 0;
        return countExpandingSearch(0, crossValues.length - 1, startIndex, minVisibleItems, (index)=>{
            let [x0, x1] = this.xCoordinateRange(crossValues[index], pixelSize, index);
            let [y0, y1] = this.yCoordinateRange(allAxisValues.map((axisValues)=>axisValues[index]), pixelSize, index);
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(x0) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(x1) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(y0) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(y1)) {
                return false;
            }
            if (shouldFlipXY) [x0, x1, y0, y1] = [
                y0,
                y1,
                x0,
                x1
            ];
            return x0 >= crossMin && x1 <= crossMax && y0 >= axisMin && y1 <= axisMax;
        });
    }
    // @todo(AG-13777) - Remove this function.
    // We need data model updates to know if a data set is sorted & unique - and at the same time
    // it should generate the equivalent of `SMALLEST_KEY_INTERVAL`. We'll use that value here
    minTimeInterval() {
        let xValues;
        try {
            xValues = this.keysOrValues("xValue");
        } catch (e) {}
        if (xValues == null || xValues.length > 1e3) return;
        let minInterval = Infinity;
        let x0 = xValues[0];
        let sortOrder;
        for(let i = 1; i < xValues.length; i++){
            const x1 = xValues[i];
            if (x1 != null && x0 != null) {
                const interval = x1.valueOf() - x0.valueOf();
                const sign = Math.sign(interval);
                if (sign === 0) continue;
                if (sortOrder !== void 0 && sign !== sortOrder) return;
                minInterval = Math.min(minInterval, Math.abs(interval));
                sortOrder = sign;
            }
            x0 = x1;
        }
        if (Number.isFinite(minInterval)) return minInterval;
    }
    updateHighlightSelectionItem(opts) {
        const { items, highlightSelection } = opts;
        const nodeData = items !== null && items !== void 0 ? items : [];
        return this.updateDatumSelection({
            nodeData,
            datumSelection: highlightSelection
        });
    }
    updateHighlightSelectionLabel(opts) {
        var _opts_items;
        return this.updateLabelSelection({
            labelData: (_opts_items = opts.items) !== null && _opts_items !== void 0 ? _opts_items : [],
            labelSelection: opts.highlightLabelSelection
        });
    }
    updateDatumSelection(opts) {
        return opts.datumSelection;
    }
    updateDatumNodes(_opts) {}
    updatePaths(opts) {
        opts.paths.forEach((p)=>p.visible = false);
    }
    updatePathNodes(opts) {
        const { paths, visible } = opts;
        for (const path of paths){
            path.visible = visible;
        }
    }
    resetPathAnimation(data) {
        var _this_opts;
        var _this_opts_animationResetFns;
        const { path } = (_this_opts_animationResetFns = (_this_opts = this.opts) === null || _this_opts === void 0 ? void 0 : _this_opts.animationResetFns) !== null && _this_opts_animationResetFns !== void 0 ? _this_opts_animationResetFns : {};
        if (path) {
            data.paths.forEach((paths)=>{
                resetMotion([
                    paths
                ], path);
            });
        }
    }
    resetDatumAnimation(data) {
        var _this_opts;
        var _this_opts_animationResetFns;
        const { datum } = (_this_opts_animationResetFns = (_this_opts = this.opts) === null || _this_opts === void 0 ? void 0 : _this_opts.animationResetFns) !== null && _this_opts_animationResetFns !== void 0 ? _this_opts_animationResetFns : {};
        if (datum) {
            resetMotion([
                data.datumSelection
            ], datum);
        }
    }
    resetLabelAnimation(data) {
        var _this_opts;
        var _this_opts_animationResetFns;
        const { label } = (_this_opts_animationResetFns = (_this_opts = this.opts) === null || _this_opts === void 0 ? void 0 : _this_opts.animationResetFns) !== null && _this_opts_animationResetFns !== void 0 ? _this_opts_animationResetFns : {};
        if (label) {
            resetMotion([
                data.labelSelection
            ], label);
        }
    }
    resetAllAnimation(data) {
        var _data_contextData;
        this.ctx.animationManager.stopByAnimationGroupId(this.id);
        this.resetPathAnimation(data);
        this.resetDatumAnimation(data);
        this.resetLabelAnimation(data);
        if (((_data_contextData = data.contextData) === null || _data_contextData === void 0 ? void 0 : _data_contextData.animationValid) === false) {
            this.ctx.animationManager.skipCurrentBatch();
        }
    }
    animateEmptyUpdateReady(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation(data);
    }
    animateWaitingUpdateReady(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation(data);
    }
    animateReadyHighlight(data) {
        var _this_opts;
        var _this_opts_animationResetFns;
        const { datum } = (_this_opts_animationResetFns = (_this_opts = this.opts) === null || _this_opts === void 0 ? void 0 : _this_opts.animationResetFns) !== null && _this_opts_animationResetFns !== void 0 ? _this_opts_animationResetFns : {};
        if (datum) {
            resetMotion([
                data
            ], datum);
        }
    }
    animateReadyResize(data) {
        this.resetAllAnimation(data);
    }
    animateClearingUpdateEmpty(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation(data);
    }
    getAnimationData(seriesRect, previousContextData) {
        const { _contextNodeData: contextData } = this;
        if (!contextData) return;
        const animationData = {
            datumSelection: this.datumSelection,
            labelSelection: this.labelSelection,
            annotationSelections: [
                ...this.annotationSelections
            ],
            contextData,
            previousContextData,
            paths: this.paths,
            seriesRect
        };
        return animationData;
    }
    updateLabelSelection(opts) {
        return opts.labelSelection;
    }
    getScaling(scale2) {
        if (scale2 instanceof LogScale) {
            const { range: range3, domain } = scale2;
            return {
                type: "log",
                convert: (d)=>scale2.convert(d),
                domain: [
                    domain[0],
                    domain[1]
                ],
                range: [
                    range3[0],
                    range3[1]
                ]
            };
        } else if (scale2 instanceof ContinuousScale) {
            const { range: range3, domain } = scale2;
            return {
                type: "continuous",
                domain: [
                    domain[0],
                    domain[1]
                ],
                range: [
                    range3[0],
                    range3[1]
                ]
            };
        } else if (scale2 instanceof BandScale) {
            const domain = scale2 instanceof UnitTimeScale ? scale2.bands : scale2.domain;
            return {
                type: "category",
                domain,
                inset: scale2.inset,
                step: scale2.step
            };
        }
    }
    calculateScaling() {
        const result = {};
        for (const direction of Object.values(ChartAxisDirection)){
            const axis = this.axes[direction];
            if (!axis) continue;
            const scalingResult = this.getScaling(axis.scale);
            if (scalingResult != null) {
                result[direction] = scalingResult;
            }
        }
        return result;
    }
    constructor({ pathsPerSeries = [
        "path"
    ], pathsZIndexSubOrderOffset = [], datumSelectionGarbageCollection = true, animationAlwaysUpdateSelections = false, animationResetFns, propertyKeys, propertyNames, ...otherOpts }){
        super({
            propertyKeys,
            propertyNames,
            canHaveAxes: true,
            ...otherOpts
        });
        this.NodeEvent = CartesianSeriesNodeEvent;
        this.dataNodeGroup = this.contentGroup.appendChild(new Group({
            name: "".concat(this.id, "-series-dataNodes"),
            zIndex: 1
        }));
        this.labelGroup = this.contentGroup.appendChild(new TranslatableGroup({
            name: "".concat(this.id, "-series-labels")
        }));
        this.labelSelection = Selection.select(this.labelGroup, Text);
        this.highlightSelection = Selection.select(this.highlightGroup, ()=>this.nodeFactory());
        this.annotationSelections = /* @__PURE__ */ new Set();
        this.debug = Debug.create();
        if (!propertyKeys || !propertyNames) throw new Error("Unable to initialise series type ".concat(this.type));
        this.opts = {
            pathsPerSeries,
            pathsZIndexSubOrderOffset,
            propertyKeys,
            propertyNames,
            animationResetFns,
            animationAlwaysUpdateSelections,
            datumSelectionGarbageCollection
        };
        this.paths = pathsPerSeries.map((path)=>{
            return new Path({
                name: "".concat(this.id, "-").concat(path)
            });
        });
        this.datumSelection = Selection.select(this.dataNodeGroup, ()=>this.nodeFactory(), datumSelectionGarbageCollection);
        this.animationState = new StateMachine("empty", {
            empty: {
                update: {
                    target: "ready",
                    action: (data)=>this.animateEmptyUpdateReady(data)
                },
                reset: "empty",
                skip: "ready",
                disable: "disabled"
            },
            ready: {
                updateData: "waiting",
                clear: "clearing",
                highlight: (data)=>this.animateReadyHighlight(data),
                resize: (data)=>this.animateReadyResize(data),
                reset: "empty",
                skip: "ready",
                disable: "disabled"
            },
            waiting: {
                update: {
                    target: "ready",
                    action: (data)=>{
                        if (this.ctx.animationManager.isSkipped()) {
                            this.resetAllAnimation(data);
                        } else {
                            this.animateWaitingUpdateReady(data);
                        }
                    }
                },
                reset: "empty",
                skip: "ready",
                disable: "disabled"
            },
            disabled: {
                update: (data)=>this.resetAllAnimation(data),
                reset: "empty"
            },
            clearing: {
                update: {
                    target: "empty",
                    action: (data)=>this.animateClearingUpdateEmpty(data)
                },
                reset: "empty",
                skip: "ready"
            }
        }, ()=>this.checkProcessedDataAnimatable());
    }
};
function axisExtent(axis) {
    let min;
    let max;
    if (axis instanceof NumberAxis || axis instanceof TimeAxis) {
        ({ min, max } = axis);
    }
    if (min == null && max == null) return;
    min !== null && min !== void 0 ? min : min = -Infinity;
    max !== null && max !== void 0 ? max : max = Infinity;
    return [
        min,
        max
    ];
}
function clippedRangeIndices(sortOrder, length2, range3, xValue) {
    const range0 = range3[0].valueOf();
    const range1 = range3[1].valueOf();
    let xMinIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMinIndex"])(0, length2 - 1, (i)=>{
        var _xValue;
        const index = sortOrder === 1 ? i : length2 - i;
        const x = (_xValue = xValue(index)) === null || _xValue === void 0 ? void 0 : _xValue.valueOf();
        return !Number.isFinite(x) || x >= range0;
    });
    let xMaxIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMaxIndex"])(0, length2 - 1, (i)=>{
        var _xValue;
        const index = sortOrder === 1 ? i : length2 - i;
        const x = (_xValue = xValue(index)) === null || _xValue === void 0 ? void 0 : _xValue.valueOf();
        return !Number.isFinite(x) || x <= range1;
    });
    if (xMinIndex == null || xMaxIndex == null) return [
        0,
        0
    ];
    if (sortOrder === -1) {
        [xMinIndex, xMaxIndex] = [
            length2 - xMaxIndex,
            length2 - xMinIndex
        ];
    }
    xMinIndex = Math.max(xMinIndex, 0);
    xMaxIndex = Math.min(xMaxIndex + 1, length2);
    return [
        xMinIndex,
        xMaxIndex
    ];
}
// packages/ag-charts-community/src/chart/series/cartesian/interpolationProperties.ts
var InterpolationProperties = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.type = "linear";
        this.tension = 1;
        this.position = "end";
    }
};
__decorateClass([
    Property
], InterpolationProperties.prototype, "type", 2);
__decorateClass([
    Property
], InterpolationProperties.prototype, "tension", 2);
__decorateClass([
    Property
], InterpolationProperties.prototype, "position", 2);
// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts
var AreaSeriesProperties = class extends CartesianSeriesProperties {
    constructor(){
        super(...arguments);
        this.xName = void 0;
        this.fill = "#c16068";
        this.fillGradientDefaults = new FillGradientDefaults();
        this.fillPatternDefaults = new FillPatternDefaults();
        this.fillImageDefaults = new FillImageDefaults();
        this.fillOpacity = 1;
        this.stroke = "#874349";
        this.strokeWidth = 2;
        this.strokeOpacity = 1;
        this.lineDash = [
            0
        ];
        this.lineDashOffset = 0;
        this.interpolation = new InterpolationProperties();
        this.shadow = new DropShadow();
        this.marker = new SeriesMarker();
        this.label = new Label();
        this.tooltip = makeSeriesTooltip();
        this.connectMissingData = false;
    }
};
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "xKey", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "xName", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "yKey", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "yName", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "fill", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "stroke", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "interpolation", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "shadow", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "marker", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "label", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
    Property
], AreaSeriesProperties.prototype, "connectMissingData", 2);
// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolation.ts
function spanRange(span) {
    switch(span.type){
        case "linear":
        case "step":
            return [
                {
                    x: span.x0,
                    y: span.y0
                },
                {
                    x: span.x1,
                    y: span.y1
                }
            ];
        case "cubic":
            return [
                {
                    x: span.cp0x,
                    y: span.cp0y
                },
                {
                    x: span.cp3x,
                    y: span.cp3y
                }
            ];
    }
}
function spanRangeNormalized(span) {
    const range3 = spanRange(span);
    if (range3[0].x > range3[1].x) {
        range3.reverse();
    }
    return range3;
}
function collapseSpanToPoint(span, point) {
    const { x, y } = point;
    switch(span.type){
        case "linear":
            return {
                type: "linear",
                moveTo: span.moveTo,
                x0: x,
                y0: y,
                x1: x,
                y1: y
            };
        case "step":
            return {
                type: "step",
                moveTo: span.moveTo,
                x0: x,
                y0: y,
                x1: x,
                y1: y,
                stepX: x
            };
        case "cubic":
            return {
                type: "cubic",
                moveTo: span.moveTo,
                cp0x: x,
                cp0y: y,
                cp1x: x,
                cp1y: y,
                cp2x: x,
                cp2y: y,
                cp3x: x,
                cp3y: y
            };
    }
}
function rescaleSpan(span, nextStart, nextEnd) {
    const [prevStart, prevEnd] = spanRange(span);
    const widthScale = prevEnd.x !== prevStart.x ? (nextEnd.x - nextStart.x) / (prevEnd.x - prevStart.x) : 0;
    const heightScale = prevEnd.y !== prevStart.y ? (nextEnd.y - nextStart.y) / (prevEnd.y - prevStart.y) : 0;
    switch(span.type){
        case "linear":
            return {
                type: "linear",
                moveTo: span.moveTo,
                x0: nextStart.x,
                y0: nextStart.y,
                x1: nextEnd.x,
                y1: nextEnd.y
            };
        case "cubic":
            return {
                type: "cubic",
                moveTo: span.moveTo,
                cp0x: nextStart.x,
                cp0y: nextStart.y,
                cp1x: nextEnd.x - (span.cp2x - prevStart.x) * widthScale,
                cp1y: nextEnd.y - (span.cp2y - prevStart.y) * heightScale,
                cp2x: nextEnd.x - (span.cp1x - prevStart.x) * widthScale,
                cp2y: nextEnd.y - (span.cp1y - prevStart.y) * heightScale,
                cp3x: nextEnd.x,
                cp3y: nextEnd.y
            };
        case "step":
            return {
                type: "step",
                moveTo: span.moveTo,
                x0: nextStart.x,
                y0: nextStart.y,
                x1: nextEnd.x,
                y1: nextEnd.y,
                stepX: nextEnd.x - (span.stepX - prevStart.x) * widthScale
            };
    }
}
function clipSpanX(span, x0, x1) {
    const { moveTo } = span;
    const [start2, end2] = spanRangeNormalized(span);
    const { x: spanX0, y: spanY0 } = start2;
    const { x: spanX1, y: spanY1 } = end2;
    if (x1 < spanX0) {
        return rescaleSpan(span, start2, start2);
    } else if (x0 > spanX1) {
        return rescaleSpan(span, end2, end2);
    }
    switch(span.type){
        case "linear":
            {
                const m = spanY0 === spanY1 ? void 0 : (spanY1 - spanY0) / (spanX1 - spanX0);
                const y0 = m == null ? spanY0 : m * (x0 - spanX0) + spanY0;
                const y1 = m == null ? spanY0 : m * (x1 - spanX0) + spanY0;
                return {
                    type: "linear",
                    moveTo,
                    x0,
                    y0,
                    x1,
                    y1
                };
            }
        case "step":
            if (x1 <= span.stepX) {
                const y = span.y0;
                return {
                    type: "step",
                    moveTo,
                    x0,
                    y0: y,
                    x1,
                    y1: y,
                    stepX: x1
                };
            } else if (x0 >= span.stepX) {
                const y = span.y1;
                return {
                    type: "step",
                    moveTo,
                    x0,
                    y0: y,
                    x1,
                    y1: y,
                    stepX: x0
                };
            } else {
                const { y0, y1, stepX } = span;
                return {
                    type: "step",
                    moveTo,
                    x0,
                    y0,
                    x1,
                    y1,
                    stepX
                };
            }
        case "cubic":
            {
                const t0 = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x0);
                let [_unused, bezier] = splitBezier2D(span.cp0x, span.cp0y, span.cp1x, span.cp1y, span.cp2x, span.cp2y, span.cp3x, span.cp3y, t0);
                const t1 = solveBezier(bezier[0].x, bezier[1].x, bezier[2].x, bezier[3].x, x1);
                [bezier, _unused] = splitBezier2D(bezier[0].x, bezier[0].y, bezier[1].x, bezier[1].y, bezier[2].x, bezier[2].y, bezier[3].x, bezier[3].y, t1);
                return {
                    type: "cubic",
                    moveTo,
                    cp0x: bezier[0].x,
                    cp0y: bezier[0].y,
                    cp1x: bezier[1].x,
                    cp1y: bezier[1].y,
                    cp2x: bezier[2].x,
                    cp2y: bezier[2].y,
                    cp3x: bezier[3].x,
                    cp3y: bezier[3].y
                };
            }
    }
}
function linearPoints(points) {
    const spans = [];
    let i = 0;
    let x0 = NaN;
    let y0 = NaN;
    for (const { x: x1, y: y1 } of points){
        if (i > 0) {
            const moveTo = i === 1;
            spans.push({
                type: "linear",
                moveTo,
                x0,
                y0,
                x1,
                y1
            });
        }
        i += 1;
        x0 = x1;
        y0 = y1;
    }
    return spans;
}
var lineSteps = {
    start: 0,
    middle: 0.5,
    end: 1
};
function stepPoints(points, position) {
    const spans = [];
    let i = 0;
    let x0 = NaN;
    let y0 = NaN;
    const p0 = typeof position === "number" ? position : lineSteps[position];
    for (const { x: x1, y: y1 } of points){
        if (i > 0) {
            const moveTo = i === 1;
            const stepX = x0 + (x1 - x0) * p0;
            spans.push({
                type: "step",
                moveTo,
                x0,
                y0,
                x1,
                y1,
                stepX
            });
        }
        i += 1;
        x0 = x1;
        y0 = y1;
    }
    return spans;
}
var flatnessRatio = 0.05;
function smoothPoints(iPoints, tension) {
    const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);
    if (points.length <= 1) return [];
    const gradients = points.map((c, i)=>{
        const p = i === 0 ? c : points[i - 1];
        const n = i === points.length - 1 ? c : points[i + 1];
        const isTerminalPoint = i === 0 || i === points.length - 1;
        if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {
            return 0;
        }
        if (!isTerminalPoint) {
            const range3 = Math.abs(p.y - n.y);
            const prevRatio = Math.abs(c.y - p.y) / range3;
            const nextRatio = Math.abs(c.y - n.y) / range3;
            if (prevRatio <= flatnessRatio || 1 - prevRatio <= flatnessRatio || nextRatio <= flatnessRatio || 1 - nextRatio <= flatnessRatio) {
                return 0;
            }
        }
        return (n.y - p.y) / (n.x - p.x);
    });
    if (gradients[1] === 0) {
        gradients[0] *= 2;
    }
    if (gradients[gradients.length - 2] === 0) {
        gradients[gradients.length - 1] *= 2;
    }
    const spans = [];
    for(let i = 1; i < points.length; i += 1){
        const prev = points[i - 1];
        const prevM = gradients[i - 1];
        const cur = points[i];
        const curM = gradients[i];
        const dx = cur.x - prev.x;
        const dy = cur.y - prev.y;
        let dcp1x = dx * tension / 3;
        let dcp1y = dx * prevM * tension / 3;
        let dcp2x = dx * tension / 3;
        let dcp2y = dx * curM * tension / 3;
        if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {
            dcp1x *= Math.abs(dy / dcp1y);
            dcp1y = Math.sign(dcp1y) * Math.abs(dy);
        }
        if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {
            dcp2x *= Math.abs(dy / dcp2y);
            dcp2y = Math.sign(dcp2y) * Math.abs(dy);
        }
        spans.push({
            type: "cubic",
            moveTo: i === 1,
            cp0x: prev.x,
            cp0y: prev.y,
            cp1x: prev.x + dcp1x,
            cp1y: prev.y + dcp1y,
            cp2x: cur.x - dcp2x,
            cp2y: cur.y - dcp2y,
            cp3x: cur.x,
            cp3y: cur.y
        });
    }
    return spans;
}
// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationPlotting.ts
function lerp2(a, b, ratio11) {
    return (b - a) * ratio11 + a;
}
function linearSupertype(span, stepX) {
    const { x0, y0, x1, y1 } = span;
    const m = (y1 - y0) / (x1 - x0);
    const stepY = m * (stepX - x0) + y0;
    return {
        leftCp1x: x0,
        leftCp1y: y0,
        leftCp2x: stepX,
        leftCp2y: stepY,
        stepX,
        stepY0: stepY,
        stepY1: stepY,
        rightCp1x: stepX,
        rightCp1y: stepY,
        rightCp2x: x1,
        rightCp2y: y1
    };
}
function bezierSupertype(span, stepX) {
    const { cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y } = span;
    const t = solveBezier(cp0x, cp1x, cp2x, cp3x, stepX);
    const [left, right] = splitBezier2D(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, t);
    const stepY = left[3].y;
    return {
        leftCp1x: left[1].x,
        leftCp1y: left[1].y,
        leftCp2x: left[2].x,
        leftCp2y: left[2].y,
        stepX,
        stepY0: stepY,
        stepY1: stepY,
        rightCp1x: right[1].x,
        rightCp1y: right[1].y,
        rightCp2x: right[2].x,
        rightCp2y: right[2].y
    };
}
function stepSupertype(span) {
    const { x0, y0, x1, y1, stepX } = span;
    return {
        leftCp1x: (x0 + stepX) / 2,
        leftCp1y: y0,
        leftCp2x: (x0 + stepX) / 2,
        leftCp2y: y0,
        stepX,
        stepY0: y0,
        stepY1: y1,
        rightCp1x: (stepX + x1) / 2,
        rightCp1y: y1,
        rightCp2x: (stepX + x1) / 2,
        rightCp2y: y1
    };
}
function spanSupertype(span, stepX) {
    if (span.type === "linear") {
        return linearSupertype(span, stepX);
    } else if (span.type === "cubic") {
        return bezierSupertype(span, stepX);
    } else {
        return stepSupertype(span);
    }
}
function plotStart(path, moveTo, x0, y0, x1, y1, reversed) {
    switch(moveTo){
        case 0 /* MoveTo */ :
            if (reversed) {
                path.moveTo(x1, y1);
            } else {
                path.moveTo(x0, y0);
            }
            break;
        case 1 /* LineTo */ :
            if (reversed) {
                path.lineTo(x1, y1);
            } else {
                path.lineTo(x0, y0);
            }
            break;
    }
}
function plotLinear(path, x0, y0, x1, y1, reversed) {
    if (reversed) {
        path.lineTo(x0, y0);
    } else {
        path.lineTo(x1, y1);
    }
}
function plotCubic(path, cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, reversed) {
    if (reversed) {
        path.cubicCurveTo(cp2x, cp2y, cp1x, cp1y, cp0x, cp0y);
    } else {
        path.cubicCurveTo(cp1x, cp1y, cp2x, cp2y, cp3x, cp3y);
    }
}
function plotStep(path, x0, y0, x1, y1, stepX, reversed) {
    if (reversed) {
        path.lineTo(stepX, y1);
        path.lineTo(stepX, y0);
        path.lineTo(x0, y0);
    } else {
        path.lineTo(stepX, y0);
        path.lineTo(stepX, y1);
        path.lineTo(x1, y1);
    }
}
function plotSpan(path, span, moveTo, reversed) {
    const [start2, end2] = spanRange(span);
    plotStart(path, moveTo, start2.x, start2.y, end2.x, end2.y, reversed);
    switch(span.type){
        case "linear":
            plotLinear(path, span.x0, span.y0, span.x1, span.y1, reversed);
            break;
        case "cubic":
            plotCubic(path, span.cp0x, span.cp0y, span.cp1x, span.cp1y, span.cp2x, span.cp2y, span.cp3x, span.cp3y, reversed);
            break;
        case "step":
            plotStep(path, span.x0, span.y0, span.x1, span.y1, span.stepX, reversed);
            break;
    }
}
function interpolatedSpanRange(a, b, ratio11) {
    const [aStart, aEnd] = spanRange(a);
    const [bStart, bEnd] = spanRange(b);
    const x0 = lerp2(aStart.x, bStart.x, ratio11);
    const y0 = lerp2(aStart.y, bStart.y, ratio11);
    const x1 = lerp2(aEnd.x, bEnd.x, ratio11);
    const y1 = lerp2(aEnd.y, bEnd.y, ratio11);
    return [
        {
            x: x0,
            y: y0
        },
        {
            x: x1,
            y: y1
        }
    ];
}
function plotInterpolatedSpans(path, a, b, ratio11, moveTo, reversed) {
    const [{ x: x0, y: y0 }, { x: x1, y: y1 }] = interpolatedSpanRange(a, b, ratio11);
    plotStart(path, moveTo, x0, y0, x1, y1, reversed);
    if (a.type === "cubic" && b.type === "cubic") {
        const cp1x = lerp2(a.cp1x, b.cp1x, ratio11);
        const cp1y = lerp2(a.cp1y, b.cp1y, ratio11);
        const cp2x = lerp2(a.cp2x, b.cp2x, ratio11);
        const cp2y = lerp2(a.cp2y, b.cp2y, ratio11);
        plotCubic(path, x0, y0, cp1x, cp1y, cp2x, cp2y, x1, y1, reversed);
    } else if (a.type === "step" && b.type === "step") {
        const stepX = lerp2(a.stepX, b.stepX, ratio11);
        plotStep(path, x0, y0, x1, y1, stepX, reversed);
    } else if (a.type === "linear" && b.type === "linear") {
        plotLinear(path, x0, y0, x1, y1, reversed);
    } else {
        let defaultStepX;
        if (a.type === "step") {
            defaultStepX = a.stepX;
        } else if (b.type === "step") {
            defaultStepX = b.stepX;
        } else {
            defaultStepX = (x0 + x1) / 2;
        }
        const as = spanSupertype(a, defaultStepX);
        const bs = spanSupertype(b, defaultStepX);
        const leftCp1x = lerp2(as.leftCp1x, bs.leftCp1x, ratio11);
        const leftCp1y = lerp2(as.leftCp1y, bs.leftCp1y, ratio11);
        const leftCp2x = lerp2(as.leftCp2x, bs.leftCp2x, ratio11);
        const leftCp2y = lerp2(as.leftCp2y, bs.leftCp2y, ratio11);
        const stepX = lerp2(as.stepX, bs.stepX, ratio11);
        const stepY0 = lerp2(as.stepY0, bs.stepY0, ratio11);
        const stepY1 = lerp2(as.stepY1, bs.stepY1, ratio11);
        const rightCp1x = lerp2(as.rightCp1x, bs.rightCp1x, ratio11);
        const rightCp1y = lerp2(as.rightCp1y, bs.rightCp1y, ratio11);
        const rightCp2x = lerp2(as.rightCp2x, bs.rightCp2x, ratio11);
        const rightCp2y = lerp2(as.rightCp2y, bs.rightCp2y, ratio11);
        if (reversed) {
            path.cubicCurveTo(rightCp2x, rightCp2y, rightCp1x, rightCp1y, stepX, stepY1);
            path.lineTo(stepX, stepY0);
            path.cubicCurveTo(leftCp2x, leftCp2y, leftCp1x, leftCp1y, x0, y0);
        } else {
            path.cubicCurveTo(leftCp1x, leftCp1y, leftCp2x, leftCp2y, stepX, stepY0);
            path.lineTo(stepX, stepY1);
            path.cubicCurveTo(rightCp1x, rightCp1y, rightCp2x, rightCp2y, x1, y1);
        }
    }
}
// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationUtil.ts
var MAX_CATEGORIES = 1e3;
var CollapseMode = /* @__PURE__ */ ((CollapseMode2)=>{
    CollapseMode2[CollapseMode2["Zero"] = 0] = "Zero";
    CollapseMode2[CollapseMode2["Split"] = 1] = "Split";
    return CollapseMode2;
})(CollapseMode || {});
function integratedCategoryMatch(a, b) {
    if (a == null || b == null) return false;
    if (typeof a !== "object" || typeof b !== "object") return false;
    if ("id" in a && "id" in b) {
        return a.id === b.id;
    }
    return a.toString() === b.toString();
}
function toAxisValue(value) {
    return transformIntegratedCategoryValue(value).valueOf();
}
function scale(val, scaling) {
    if (!scaling) return NaN;
    if (val instanceof Date) {
        val = val.getTime();
    }
    if (scaling.type === "continuous" && typeof val === "number") {
        const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);
        return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];
    }
    if (scaling.type === "log" && typeof val === "number") {
        return scaling.convert(val);
    }
    if (scaling.type !== "category") return NaN;
    const axisValue = toAxisValue(val);
    let matchingIndex = scaling.domain.findIndex((d)=>toAxisValue(d) === axisValue);
    if (matchingIndex === -1) {
        matchingIndex = scaling.domain.findIndex((d)=>integratedCategoryMatch(val, d));
    }
    if (matchingIndex >= 0) {
        return scaling.inset + scaling.step * matchingIndex;
    }
    return NaN;
}
function getAxisIndices(param, values) {
    let { data } = param;
    return data.map((datum, datumIndex)=>({
            xValue0Index: values.indexOf(toAxisValue(datum.xValue0)),
            xValue1Index: values.indexOf(toAxisValue(datum.xValue1)),
            datumIndex
        }));
}
function isValidScaling(data) {
    return Object.values(data.scales).every((s)=>{
        if (s.type === "category") {
            return s.domain.length < MAX_CATEGORIES;
        }
        return true;
    });
}
function validateCategorySorting(newData, oldData) {
    const oldScale = oldData.scales.x;
    const newScale = newData.scales.x;
    if ((oldScale === null || oldScale === void 0 ? void 0 : oldScale.type) !== "category" || (newScale === null || newScale === void 0 ? void 0 : newScale.type) !== "category") return true;
    let x0 = -Infinity;
    for (const oldValue of oldScale.domain){
        const x = scale(oldValue, newScale);
        if (!Number.isFinite(x)) continue;
        if (x < x0) {
            return false;
        } else {
            x0 = x;
        }
    }
    return true;
}
function validateAxisEntriesOrder(axisValues, data) {
    let x0 = -Infinity;
    for (const axisValue of axisValues){
        const x = scale(axisValue.value, data.scales.x);
        if (!Number.isFinite(x)) continue;
        if (x < x0) {
            return false;
        } else {
            x0 = x;
        }
    }
    return true;
}
function spanAxisContext(newData, oldData) {
    const allAxisEntries = /* @__PURE__ */ new Map();
    for (const { xValue0, xValue1 } of newData.data){
        const xValue0Value = toAxisValue(xValue0);
        const xValue1Value = toAxisValue(xValue1);
        allAxisEntries.set(xValue0Value, xValue0).set(xValue1Value, xValue1);
    }
    const newAxisEntries = Array.from(allAxisEntries, (param)=>{
        let [axisValue, value] = param;
        return {
            axisValue,
            value
        };
    });
    newAxisEntries.sort((a, b)=>{
        return scale(a.value, newData.scales.x) - scale(b.value, newData.scales.x);
    });
    const exclusivelyOldAxisEntries = [];
    for (const { xValue0, xValue1 } of oldData.data){
        const xValue0Value = toAxisValue(xValue0);
        const xValue1Value = toAxisValue(xValue1);
        if (!allAxisEntries.has(xValue0Value)) {
            allAxisEntries.set(xValue0Value, xValue0);
            exclusivelyOldAxisEntries.push({
                axisValue: xValue0Value,
                value: xValue0
            });
        }
        if (!allAxisEntries.has(xValue1Value)) {
            allAxisEntries.set(xValue1Value, xValue1);
            exclusivelyOldAxisEntries.push({
                axisValue: xValue1Value,
                value: xValue1
            });
        }
    }
    exclusivelyOldAxisEntries.sort((a, b)=>{
        return scale(a.value, oldData.scales.x) - scale(b.value, oldData.scales.x);
    });
    const axisEntries = newAxisEntries;
    let insertionIndex = 0;
    for (const oldAxisEntry of exclusivelyOldAxisEntries){
        for(let i = axisEntries.length - 1; i >= insertionIndex; i -= 1){
            const oldValueX = scale(oldAxisEntry.value, oldData.scales.x);
            const newValueX = scale(axisEntries[i].value, oldData.scales.x);
            if (oldValueX > newValueX) {
                insertionIndex = i + 1;
                break;
            }
        }
        axisEntries.splice(insertionIndex, 0, oldAxisEntry);
        insertionIndex += 1;
    }
    if (!validateAxisEntriesOrder(axisEntries, oldData)) return;
    const axisValues = axisEntries.map((axisEntry)=>axisEntry.axisValue);
    const oldDataAxisIndices = getAxisIndices(oldData, axisValues);
    const newDataAxisIndices = getAxisIndices(newData, axisValues);
    return {
        axisValues,
        oldDataAxisIndices,
        newDataAxisIndices
    };
}
function clipSpan(span, xValue0Index, xIndices) {
    if (xIndices.xValue1Index === xIndices.xValue0Index + 1) return span;
    const range3 = spanRange(span);
    const step = (range3[1].x - range3[0].x) / (xIndices.xValue1Index - xIndices.xValue0Index);
    const start2 = range3[0].x + (xValue0Index - xIndices.xValue0Index) * step;
    const end2 = start2 + step;
    return clipSpanX(span, start2, end2);
}
function axisZeroSpan(span, data) {
    const [r0, r1] = spanRange(span);
    const y0 = scale(0, data.scales.y);
    return rescaleSpan(span, {
        x: r0.x,
        y: y0
    }, {
        x: r1.x,
        y: y0
    });
}
function collapseSpanToMidpoint(span) {
    const [r0, r1] = spanRange(span);
    return collapseSpanToPoint(span, {
        x: (r0.x + r1.x) / 2,
        y: (r0.y + r1.y) / 2
    });
}
function collapseSpan(span, collapseMode, data, axisIndices, indices, range3) {
    let xValue;
    let yValue;
    if (indices.xValue0Index >= range3.xValue1Index) {
        var _axisIndices_findLast;
        const datumIndex = (_axisIndices_findLast = axisIndices.findLast((i)=>i.xValue1Index <= range3.xValue1Index)) === null || _axisIndices_findLast === void 0 ? void 0 : _axisIndices_findLast.datumIndex;
        const datum = datumIndex != null ? data.data[datumIndex] : void 0;
        xValue = datum === null || datum === void 0 ? void 0 : datum.xValue1;
        yValue = datum === null || datum === void 0 ? void 0 : datum.yValue1;
    } else if (indices.xValue0Index <= range3.xValue0Index) {
        var _axisIndices_find;
        const datumIndex = (_axisIndices_find = axisIndices.find((i)=>i.xValue0Index >= range3.xValue0Index)) === null || _axisIndices_find === void 0 ? void 0 : _axisIndices_find.datumIndex;
        const datum = datumIndex != null ? data.data[datumIndex] : void 0;
        xValue = datum === null || datum === void 0 ? void 0 : datum.xValue0;
        yValue = datum === null || datum === void 0 ? void 0 : datum.yValue0;
    }
    if (xValue == null || yValue == null) {
        switch(collapseMode){
            case 0 /* Zero */ :
                return axisZeroSpan(span, data);
            case 1 /* Split */ :
                return collapseSpanToMidpoint(span);
        }
    }
    const x = scale(xValue, data.scales.x);
    const y = scale(yValue, data.scales.y);
    const point = {
        x,
        y
    };
    return rescaleSpan(span, point, point);
}
function zeroDataSpan(spanDatum, zeroData) {
    var _zeroData_find;
    if (zeroData == null) return;
    const newSpanXValue0 = toAxisValue(spanDatum.xValue0);
    const newSpanXValue1 = toAxisValue(spanDatum.xValue1);
    return (_zeroData_find = zeroData.find((zeroSpanDatum)=>toAxisValue(zeroSpanDatum.xValue0) === newSpanXValue0 && toAxisValue(zeroSpanDatum.xValue1) === newSpanXValue1)) === null || _zeroData_find === void 0 ? void 0 : _zeroData_find.span;
}
function addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range3, out) {
    const newSpanDatum = newData.data[newIndices.datumIndex];
    const newSpan = newSpanDatum.span;
    const zeroSpan = zeroDataSpan(newSpanDatum, oldZeroData);
    if (zeroSpan != null) {
        out.removed.push({
            from: zeroSpan,
            to: zeroSpan
        });
        out.moved.push({
            from: zeroSpan,
            to: newSpan
        });
        out.added.push({
            from: newSpan,
            to: newSpan
        });
    } else {
        const oldSpan = collapseSpan(newSpan, collapseMode, newData, newAxisIndices, newIndices, range3);
        out.added.push({
            from: oldSpan,
            to: newSpan
        });
    }
}
function removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range3, out) {
    const oldSpanDatum = oldData.data[oldIndices.datumIndex];
    const oldSpan = oldSpanDatum.span;
    const zeroSpan = zeroDataSpan(oldSpanDatum, newZeroData);
    if (zeroSpan != null) {
        out.removed.push({
            from: oldSpan,
            to: oldSpan
        });
        out.moved.push({
            from: oldSpan,
            to: zeroSpan
        });
        out.added.push({
            from: zeroSpan,
            to: zeroSpan
        });
    } else {
        const newSpan = collapseSpan(oldSpan, collapseMode, oldData, oldAxisIndices, oldIndices, range3);
        out.removed.push({
            from: oldSpan,
            to: newSpan
        });
    }
}
function alignSpanToContainingSpan(span, axisValues, preData, postData, postSpanIndices) {
    const startXValue0 = axisValues[postSpanIndices.xValue0Index];
    const startDatum = preData.data.find((spanDatum)=>toAxisValue(spanDatum.xValue0) === startXValue0);
    const endXValue1 = axisValues[postSpanIndices.xValue1Index];
    const endDatum = preData.data.find((spanDatum)=>toAxisValue(spanDatum.xValue1) === endXValue1);
    if (startDatum == null || endDatum == null) return;
    const [{ x: x0 }, { x: x1 }] = spanRange(span);
    const startX = scale(startDatum.xValue0, preData.scales.x);
    const startY = scale(startDatum.yValue0, preData.scales.y);
    const endX = scale(endDatum.xValue1, preData.scales.x);
    const endY = scale(endDatum.yValue1, preData.scales.y);
    let altSpan = postData.data[postSpanIndices.datumIndex].span;
    altSpan = rescaleSpan(altSpan, {
        x: startX,
        y: startY
    }, {
        x: endX,
        y: endY
    });
    altSpan = clipSpanX(altSpan, x0, x1);
    return altSpan;
}
function appendSpanPhases(newData, oldData, collapseMode, axisValues, xValue0Index, newAxisIndices, oldAxisIndices, range3, out) {
    const xValue1Index = xValue0Index + 1;
    const oldIndices = oldAxisIndices.find((i)=>i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);
    const newIndices = newAxisIndices.find((i)=>i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);
    const oldZeroData = oldData.zeroData;
    const newZeroData = newData.zeroData;
    if (oldIndices == null && newIndices != null) {
        addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range3, out);
        return;
    } else if (oldIndices != null && newIndices == null) {
        removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range3, out);
        return;
    } else if (oldIndices == null || newIndices == null) {
        return;
    }
    let ordering;
    if (oldIndices.xValue0Index === newIndices.xValue0Index && oldIndices.xValue1Index === newIndices.xValue1Index) {
        ordering = 0;
    } else if (oldIndices.xValue0Index <= newIndices.xValue0Index && oldIndices.xValue1Index >= newIndices.xValue1Index) {
        ordering = -1;
    } else if (oldIndices.xValue0Index >= newIndices.xValue0Index && oldIndices.xValue1Index <= newIndices.xValue1Index) {
        ordering = 1;
    } else {
        ordering = 0;
    }
    const oldSpanDatum = oldData.data[oldIndices.datumIndex];
    const clippedOldSpanOldScale = clipSpan(oldSpanDatum.span, xValue0Index, oldIndices);
    const newSpanDatum = newData.data[newIndices.datumIndex];
    const clippedNewSpanNewScale = clipSpan(newSpanDatum.span, xValue0Index, newIndices);
    if (ordering === 1) {
        const clippedPostRemoveOldSpanOldScale = alignSpanToContainingSpan(clippedOldSpanOldScale, axisValues, oldData, newData, newIndices);
        if (clippedPostRemoveOldSpanOldScale != null) {
            out.removed.push({
                from: clippedOldSpanOldScale,
                to: clippedPostRemoveOldSpanOldScale
            });
            out.moved.push({
                from: clippedPostRemoveOldSpanOldScale,
                to: clippedNewSpanNewScale
            });
            out.added.push({
                from: clippedNewSpanNewScale,
                to: clippedNewSpanNewScale
            });
        } else {
            removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range3, out);
        }
    } else if (ordering === -1) {
        const clippedPreAddedNewSpanNewScale = alignSpanToContainingSpan(clippedNewSpanNewScale, axisValues, newData, oldData, oldIndices);
        if (clippedPreAddedNewSpanNewScale != null) {
            out.removed.push({
                from: clippedOldSpanOldScale,
                to: clippedOldSpanOldScale
            });
            out.moved.push({
                from: clippedOldSpanOldScale,
                to: clippedPreAddedNewSpanNewScale
            });
            out.added.push({
                from: clippedPreAddedNewSpanNewScale,
                to: clippedNewSpanNewScale
            });
        } else {
            addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range3, out);
        }
    } else {
        out.removed.push({
            from: clippedOldSpanOldScale,
            to: clippedOldSpanOldScale
        });
        out.moved.push({
            from: clippedOldSpanOldScale,
            to: clippedNewSpanNewScale
        });
        out.added.push({
            from: clippedNewSpanNewScale,
            to: clippedNewSpanNewScale
        });
    }
}
function phaseAnimation(axisContext, newData, oldData, collapseMode) {
    var _oldDataAxisIndices_at, _newDataAxisIndices_at, _oldDataAxisIndices_at1, _newDataAxisIndices_at1;
    const out = {
        removed: [],
        moved: [],
        added: []
    };
    const { axisValues, oldDataAxisIndices, newDataAxisIndices } = axisContext;
    var _oldDataAxisIndices_at_xValue0Index, _newDataAxisIndices_at_xValue0Index, _oldDataAxisIndices_at_xValue1Index, _newDataAxisIndices_at_xValue1Index;
    const range3 = {
        xValue0Index: Math.max((_oldDataAxisIndices_at_xValue0Index = (_oldDataAxisIndices_at = oldDataAxisIndices.at(0)) === null || _oldDataAxisIndices_at === void 0 ? void 0 : _oldDataAxisIndices_at.xValue0Index) !== null && _oldDataAxisIndices_at_xValue0Index !== void 0 ? _oldDataAxisIndices_at_xValue0Index : -Infinity, (_newDataAxisIndices_at_xValue0Index = (_newDataAxisIndices_at = newDataAxisIndices.at(0)) === null || _newDataAxisIndices_at === void 0 ? void 0 : _newDataAxisIndices_at.xValue0Index) !== null && _newDataAxisIndices_at_xValue0Index !== void 0 ? _newDataAxisIndices_at_xValue0Index : -Infinity),
        xValue1Index: Math.min((_oldDataAxisIndices_at_xValue1Index = (_oldDataAxisIndices_at1 = oldDataAxisIndices.at(-1)) === null || _oldDataAxisIndices_at1 === void 0 ? void 0 : _oldDataAxisIndices_at1.xValue1Index) !== null && _oldDataAxisIndices_at_xValue1Index !== void 0 ? _oldDataAxisIndices_at_xValue1Index : Infinity, (_newDataAxisIndices_at_xValue1Index = (_newDataAxisIndices_at1 = newDataAxisIndices.at(-1)) === null || _newDataAxisIndices_at1 === void 0 ? void 0 : _newDataAxisIndices_at1.xValue1Index) !== null && _newDataAxisIndices_at_xValue1Index !== void 0 ? _newDataAxisIndices_at_xValue1Index : Infinity)
    };
    for(let xValue0Index = 0; xValue0Index < axisValues.length - 1; xValue0Index += 1){
        appendSpanPhases(newData, oldData, collapseMode, axisValues, xValue0Index, newDataAxisIndices, oldDataAxisIndices, range3, out);
    }
    return out;
}
function resetSpan(data, spanDatum, collapseMode) {
    const { span } = spanDatum;
    switch(collapseMode){
        case 0 /* Zero */ :
            var _zeroDataSpan;
            return (_zeroDataSpan = zeroDataSpan(spanDatum, data.zeroData)) !== null && _zeroDataSpan !== void 0 ? _zeroDataSpan : axisZeroSpan(span, data);
        case 1 /* Split */ :
            return collapseSpanToMidpoint(span);
    }
}
function resetAnimation(newData, oldData, collapseMode) {
    const added = [];
    const removed = [];
    for (const oldSpanDatum of oldData.data){
        const oldSpan = oldSpanDatum.span;
        const collapsedSpan = resetSpan(oldData, oldSpanDatum, collapseMode);
        removed.push({
            from: oldSpan,
            to: collapsedSpan
        });
    }
    for (const newSpanDatum of newData.data){
        const newSpan = newSpanDatum.span;
        const collapsedSpan = resetSpan(newData, newSpanDatum, collapseMode);
        added.push({
            from: collapsedSpan,
            to: newSpan
        });
    }
    return {
        removed,
        moved: [],
        added
    };
}
function pairUpSpans(newData, oldData, collapseMode) {
    if (!isValidScaling(newData) || !isValidScaling(oldData)) return;
    if (!validateCategorySorting(newData, oldData)) return;
    const axisContext = spanAxisContext(newData, oldData);
    return axisContext == null ? resetAnimation(newData, oldData, collapseMode) : phaseAnimation(axisContext, newData, oldData, collapseMode);
}
;
function isContinuousScaling(scaling) {
    return scaling.type === "continuous" || scaling.type === "log";
}
function isCategoryScaling(scaling) {
    return scaling.type === "category";
}
function areScalingEqual(a, b) {
    if (a === void 0 || b === void 0) {
        return a !== void 0 || b !== void 0;
    }
    if (isContinuousScaling(a) && isContinuousScaling(b)) {
        return a.type === b.type && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraysEqual"])(a.domain, b.domain) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraysEqual"])(a.range, b.range);
    }
    if (isCategoryScaling(a) && isCategoryScaling(b)) {
        return a.inset === b.inset && a.step === b.step && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraysEqual"])(a.domain, b.domain);
    }
    return false;
}
function isScaleValid(scale2) {
    if (scale2 == null) return false;
    if (scale2.type === "category") return scale2.domain.every((v)=>v != null);
    return scale2.domain.every((v)=>Number.isFinite(v) || v instanceof Date) && scale2.range.every((v)=>Number.isFinite(v));
}
// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts
function interpolatePoints(points, interpolation) {
    let spans;
    const pointsIter = points.map((point)=>point.point);
    switch(interpolation.type){
        case "linear":
            spans = linearPoints(pointsIter);
            break;
        case "smooth":
            spans = smoothPoints(pointsIter, interpolation.tension);
            break;
        case "step":
            spans = stepPoints(pointsIter, interpolation.position);
            break;
    }
    return spans.map((span, i)=>({
            span,
            xValue0: points[i].xDatum,
            yValue0: points[i].yDatum,
            xValue1: points[i + 1].xDatum,
            yValue1: points[i + 1].yDatum
        }));
}
function pointsEq(a, b) {
    let delta3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-3;
    return Math.abs(a.x - b.x) < delta3 && Math.abs(a.y - b.y) < delta3;
}
function plotLinePathStroke(param, spans) {
    let { path } = param;
    let lastPoint;
    for (const { span } of spans){
        const [start2, end2] = spanRange(span);
        const join = lastPoint != null && pointsEq(lastPoint, start2) ? 1 /* LineTo */  : 0 /* MoveTo */ ;
        plotSpan(path, span, join, false);
        lastPoint = end2;
    }
}
function plotInterpolatedLinePathStroke(ratio11, path, spans) {
    let lastPoint;
    for (const span of spans){
        const [start2, end2] = interpolatedSpanRange(span.from, span.to, ratio11);
        const join = lastPoint != null && pointsEq(lastPoint, start2) ? 1 /* LineTo */  : 0 /* MoveTo */ ;
        plotInterpolatedSpans(path.path, span.from, span.to, ratio11, join, false);
        lastPoint = end2;
    }
}
function prepareLinePathStrokeAnimationFns(status, spans, visibleToggleMode) {
    const removePhaseFn = (ratio11, path)=>plotInterpolatedLinePathStroke(ratio11, path, spans.removed);
    const updatePhaseFn = (ratio11, path)=>plotInterpolatedLinePathStroke(ratio11, path, spans.moved);
    const addPhaseFn = (ratio11, path)=>plotInterpolatedLinePathStroke(ratio11, path, spans.added);
    const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
    return {
        status,
        path: {
            addPhaseFn,
            updatePhaseFn,
            removePhaseFn
        },
        pathProperties
    };
}
function prepareLinePathPropertyAnimation(status, visibleToggleMode) {
    const phase = visibleToggleMode === "none" ? "updated" : status;
    const result = {
        fromFn: (_path)=>{
            let mixin;
            if (status === "removed") {
                mixin = {
                    finish: {
                        visible: false
                    }
                };
            } else if (status === "added") {
                mixin = {
                    start: {
                        visible: true
                    }
                };
            } else {
                mixin = {};
            }
            return {
                phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase],
                ...mixin
            };
        },
        toFn: (_path)=>{
            return {
                phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]
            };
        }
    };
    if (visibleToggleMode === "fade") {
        return {
            fromFn: (path)=>{
                const opacity = status === "added" ? 0 : path.opacity;
                return {
                    opacity,
                    ...result.fromFn(path)
                };
            },
            toFn: (path)=>{
                const opacity = status === "removed" ? 0 : 1;
                return {
                    opacity,
                    ...result.toFn(path)
                };
            }
        };
    }
    return result;
}
function prepareLinePathAnimation(newData, oldData, diff2) {
    var _newData_scales_x, _oldData_scales_x;
    const isCategoryBased = ((_newData_scales_x = newData.scales.x) === null || _newData_scales_x === void 0 ? void 0 : _newData_scales_x.type) === "category";
    const wasCategoryBased = ((_oldData_scales_x = oldData.scales.x) === null || _oldData_scales_x === void 0 ? void 0 : _oldData_scales_x.type) === "category";
    if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {
        return;
    }
    if (newData.strokeData == null || oldData.strokeData == null) {
        return;
    }
    let status = "updated";
    if (oldData.visible && !newData.visible) {
        status = "removed";
    } else if (!oldData.visible && newData.visible) {
        status = "added";
    }
    const strokeSpans = pairUpSpans({
        scales: newData.scales,
        data: newData.strokeData.spans
    }, {
        scales: oldData.scales,
        data: oldData.strokeData.spans
    }, 1 /* Split */ );
    if (strokeSpans == null) return;
    const stroke2 = prepareLinePathStrokeAnimationFns(status, strokeSpans, "fade");
    var _diff2_changed;
    const hasMotion = ((_diff2_changed = diff2 === null || diff2 === void 0 ? void 0 : diff2.changed) !== null && _diff2_changed !== void 0 ? _diff2_changed : true) || !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y) || status !== "updated";
    return {
        status,
        stroke: stroke2,
        hasMotion
    };
}
// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts
function plotAreaPathFill(param, param1) {
    let { path } = param, { spans, phantomSpans } = param1;
    let phantomSpanIndex = 0;
    let sp = {
        x: NaN,
        y: NaN
    };
    let pp = {
        x: NaN,
        y: NaN
    };
    for(let i = 0; i < spans.length; i += 1){
        const { span } = spans[i];
        const { span: phantomSpan } = phantomSpans[i];
        const { 0: sp0, 1: sp1 } = spanRange(span);
        const { 0: pp0, 1: pp1 } = spanRange(phantomSpan);
        if (pointsEq(sp, sp0) && pointsEq(pp, pp0)) {
            plotSpan(path, span, 1 /* LineTo */ , false);
        } else {
            for(let j = i - 1; j >= phantomSpanIndex; j -= 1){
                plotSpan(path, phantomSpans[j].span, 1 /* LineTo */ , true);
            }
            path.closePath();
            plotSpan(path, span, 0 /* MoveTo */ , false);
            phantomSpanIndex = i;
        }
        sp = sp1;
        pp = pp1;
    }
    for(let j = spans.length - 1; j >= phantomSpanIndex; j -= 1){
        plotSpan(path, phantomSpans[j].span, 1 /* LineTo */ , true);
    }
    path.closePath();
}
function plotInterpolatedAreaSeriesFillSpans(ratio11, param, spans, fillPhantomSpans) {
    let { path } = param;
    for(let i = 0; i < spans.length; i += 1){
        const span = spans[i];
        const reversedPhantomSpan = fillPhantomSpans[i];
        plotInterpolatedSpans(path, span.from, span.to, ratio11, 0 /* MoveTo */ , false);
        plotInterpolatedSpans(path, reversedPhantomSpan.from, reversedPhantomSpan.to, ratio11, 1 /* LineTo */ , true);
        path.closePath();
    }
}
function prepareAreaFillAnimationFns(status, spans, fillPhantomSpans, visibleToggleMode) {
    const removePhaseFn = (ratio11, path)=>plotInterpolatedAreaSeriesFillSpans(ratio11, path, spans.removed, fillPhantomSpans.removed);
    const updatePhaseFn = (ratio11, path)=>plotInterpolatedAreaSeriesFillSpans(ratio11, path, spans.moved, fillPhantomSpans.moved);
    const addPhaseFn = (ratio11, path)=>plotInterpolatedAreaSeriesFillSpans(ratio11, path, spans.added, fillPhantomSpans.added);
    const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
    return {
        status,
        path: {
            addPhaseFn,
            updatePhaseFn,
            removePhaseFn
        },
        pathProperties
    };
}
function prepareAreaPathAnimation(newData, oldData) {
    var _newData_scales_x, _oldData_scales_x;
    const isCategoryBased = ((_newData_scales_x = newData.scales.x) === null || _newData_scales_x === void 0 ? void 0 : _newData_scales_x.type) === "category";
    const wasCategoryBased = ((_oldData_scales_x = oldData.scales.x) === null || _oldData_scales_x === void 0 ? void 0 : _oldData_scales_x.type) === "category";
    if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {
        return;
    }
    let status = "updated";
    if (oldData.visible && !newData.visible) {
        status = "removed";
    } else if (!oldData.visible && newData.visible) {
        status = "added";
    }
    const fillSpans = pairUpSpans({
        scales: newData.scales,
        data: newData.fillData.spans
    }, {
        scales: oldData.scales,
        data: oldData.fillData.spans
    }, 0 /* Zero */ );
    if (fillSpans == null) return;
    const fillPhantomSpans = pairUpSpans({
        scales: newData.scales,
        data: newData.fillData.phantomSpans
    }, {
        scales: oldData.scales,
        data: oldData.fillData.phantomSpans
    }, 0 /* Zero */ );
    if (fillPhantomSpans == null) return;
    const strokeSpans = pairUpSpans({
        scales: newData.scales,
        data: newData.strokeData.spans,
        zeroData: newData.fillData.phantomSpans
    }, {
        scales: oldData.scales,
        data: oldData.strokeData.spans,
        zeroData: oldData.fillData.phantomSpans
    }, 0 /* Zero */ );
    if (strokeSpans == null) return;
    const fadeMode = "none";
    const fill = prepareAreaFillAnimationFns(status, fillSpans, fillPhantomSpans, fadeMode);
    const stroke2 = prepareLinePathStrokeAnimationFns(status, strokeSpans, fadeMode);
    return {
        status,
        fill,
        stroke: stroke2
    };
}
// packages/ag-charts-community/src/chart/series/aggregation.ts
var AGGREGATION_INDEX_X_MIN = 0;
var AGGREGATION_INDEX_X_MAX = 1;
var AGGREGATION_INDEX_Y_MIN = 2;
var AGGREGATION_INDEX_Y_MAX = 3;
var AGGREGATION_SPAN = 4;
function aggregationRangeFittingPoints(data) {
    let power = Math.ceil(Math.log2(data.length)) - 1;
    power = Math.min(Math.max(power, 0), 24);
    return 2 ** power | 0;
}
function aggregationDomain(scale2, domain) {
    switch(scale2){
        case "category":
            return [
                NaN,
                NaN
            ];
        case "number":
        case "time":
        case "ordinal-time":
        case "unit-time":
            {
                let min = Infinity;
                let max = -Infinity;
                for (const d of domain){
                    const value = Number(d);
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
                return [
                    min,
                    max
                ];
            }
        case "color":
        case "log":
        case "mercator":
            return [
                0,
                0
            ];
    }
}
function aggregationXRatioForDatumIndex(datumIndex, domainCount) {
    return datumIndex / domainCount;
}
function aggregationXRatioForXValue(xValue, d0, d1) {
    return (xValue.valueOf() - d0) / (d1 - d0);
}
function aggregationIndexForXRatio(xRatio, maxRange) {
    return Math.min(Math.floor(xRatio * maxRange), maxRange - 1) * AGGREGATION_SPAN | 0;
}
function createAggregationIndices(xValues, yMaxValues, yMinValues, d0, d1, maxRange) {
    const indexData = new Int32Array(maxRange * AGGREGATION_SPAN).fill(-1);
    const valueData = new Float64Array(maxRange * AGGREGATION_SPAN).fill(NaN);
    const continuous = Number.isFinite(d0) && Number.isFinite(d1);
    const domainCount = xValues.length;
    for(let datumIndex = 0; datumIndex < xValues.length; datumIndex += 1){
        const xValue = xValues[datumIndex];
        if (xValue == null) continue;
        const xRatio = continuous ? aggregationXRatioForXValue(xValue, d0, d1) : aggregationXRatioForDatumIndex(datumIndex, domainCount);
        const aggIndex = aggregationIndexForXRatio(xRatio, maxRange);
        const yMaxValue = yMaxValues[datumIndex];
        const yMinValue = yMinValues[datumIndex];
        const yMax = yMaxValue != null ? yMaxValue.valueOf() : NaN;
        const yMin = yMinValue != null ? yMinValue.valueOf() : NaN;
        const unset = indexData[aggIndex + AGGREGATION_INDEX_X_MIN] === -1;
        if (unset || xRatio < valueData[aggIndex + AGGREGATION_INDEX_X_MIN]) {
            indexData[aggIndex + AGGREGATION_INDEX_X_MIN] = datumIndex;
            valueData[aggIndex + AGGREGATION_INDEX_X_MIN] = xRatio;
        }
        if (unset || xRatio > valueData[aggIndex + AGGREGATION_INDEX_X_MAX]) {
            indexData[aggIndex + AGGREGATION_INDEX_X_MAX] = datumIndex;
            valueData[aggIndex + AGGREGATION_INDEX_X_MAX] = xRatio;
        }
        if (!Number.isNaN(yMin) && (unset || yMin < valueData[aggIndex + AGGREGATION_INDEX_Y_MIN])) {
            indexData[aggIndex + AGGREGATION_INDEX_Y_MIN] = datumIndex;
            valueData[aggIndex + AGGREGATION_INDEX_Y_MIN] = yMin;
        }
        if (!Number.isNaN(yMax) && (unset || yMax > valueData[aggIndex + AGGREGATION_INDEX_Y_MAX])) {
            indexData[aggIndex + AGGREGATION_INDEX_Y_MAX] = datumIndex;
            valueData[aggIndex + AGGREGATION_INDEX_Y_MAX] = yMax;
        }
    }
    return {
        indexData,
        valueData
    };
}
function compactAggregationIndices(indexData, valueData, maxRange) {
    let { inPlace = false } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const nextMaxRange = maxRange / 2 | 0;
    const nextIndexData = !inPlace ? new Int32Array(nextMaxRange * AGGREGATION_SPAN) : indexData;
    const nextValueData = !inPlace ? new Float64Array(nextMaxRange * AGGREGATION_SPAN) : valueData;
    for(let i = 0; i < nextMaxRange; i += 1){
        const aggIndex = i * AGGREGATION_SPAN | 0;
        const index0 = aggIndex * 2 | 0;
        const index1 = index0 + AGGREGATION_SPAN | 0;
        const index1Unset = indexData[index1 + AGGREGATION_INDEX_X_MIN] === -1;
        const xMinAggIndex = index1Unset || valueData[index0 + AGGREGATION_INDEX_X_MIN] < valueData[index1 + AGGREGATION_INDEX_X_MIN] ? index0 : index1;
        nextIndexData[aggIndex + AGGREGATION_INDEX_X_MIN] = indexData[xMinAggIndex + AGGREGATION_INDEX_X_MIN];
        nextValueData[aggIndex + AGGREGATION_INDEX_X_MIN] = valueData[xMinAggIndex + AGGREGATION_INDEX_X_MIN];
        const xMaxAggIndex = index1Unset || valueData[index0 + AGGREGATION_INDEX_X_MAX] > valueData[index1 + AGGREGATION_INDEX_X_MAX] ? index0 : index1;
        nextIndexData[aggIndex + AGGREGATION_INDEX_X_MAX] = indexData[xMaxAggIndex + AGGREGATION_INDEX_X_MAX];
        nextValueData[aggIndex + AGGREGATION_INDEX_X_MAX] = valueData[xMaxAggIndex + AGGREGATION_INDEX_X_MAX];
        const yMinAggIndex = index1Unset || valueData[index0 + AGGREGATION_INDEX_Y_MIN] < valueData[index1 + AGGREGATION_INDEX_Y_MIN] ? index0 : index1;
        nextIndexData[aggIndex + AGGREGATION_INDEX_Y_MIN] = indexData[yMinAggIndex + AGGREGATION_INDEX_Y_MIN];
        nextValueData[aggIndex + AGGREGATION_INDEX_Y_MIN] = valueData[yMinAggIndex + AGGREGATION_INDEX_Y_MIN];
        const yMaxAggIndex = index1Unset || valueData[index0 + AGGREGATION_INDEX_Y_MAX] > valueData[index1 + AGGREGATION_INDEX_Y_MAX] ? index0 : index1;
        nextIndexData[aggIndex + AGGREGATION_INDEX_Y_MAX] = indexData[yMaxAggIndex + AGGREGATION_INDEX_Y_MAX];
        nextValueData[aggIndex + AGGREGATION_INDEX_Y_MAX] = valueData[yMaxAggIndex + AGGREGATION_INDEX_Y_MAX];
    }
    return {
        maxRange: nextMaxRange,
        indexData: nextIndexData,
        valueData: nextValueData
    };
}
// packages/ag-charts-community/src/chart/series/cartesian/lineAggregation.ts
var AGGREGATION_THRESHOLD = 1e3;
var MAX_POINTS = 10;
function aggregationContainsIndex(xValues, d0, d1, indexData, maxRange, datumIndex) {
    const xValue = xValues[datumIndex];
    if (xValue == null) return false;
    const xRatio = Number.isFinite(d0) ? aggregationXRatioForXValue(xValue, d0, d1) : aggregationXRatioForDatumIndex(datumIndex, xValues.length);
    const aggIndex = aggregationIndexForXRatio(xRatio, maxRange);
    return datumIndex === indexData[aggIndex + AGGREGATION_INDEX_X_MIN] || datumIndex === indexData[aggIndex + AGGREGATION_INDEX_X_MAX] || datumIndex === indexData[aggIndex + AGGREGATION_INDEX_Y_MIN] || datumIndex === indexData[aggIndex + AGGREGATION_INDEX_Y_MAX];
}
function aggregateLineData(scale2, xValues, yValues, domain) {
    if (xValues.length < AGGREGATION_THRESHOLD) return;
    const [d0, d1] = aggregationDomain(scale2, domain);
    let maxRange = aggregationRangeFittingPoints(xValues);
    const { indexData, valueData } = createAggregationIndices(xValues, yValues, yValues, d0, d1, maxRange);
    let indices = [];
    for(let datumIndex = 0; datumIndex < xValues.length; datumIndex += 1){
        if (aggregationContainsIndex(xValues, d0, d1, indexData, maxRange, datumIndex)) {
            indices.push(datumIndex);
        }
    }
    const filters = [
        {
            maxRange,
            indices
        }
    ];
    while(indices.length > MAX_POINTS && maxRange > 64){
        ({ maxRange } = compactAggregationIndices(indexData, valueData, maxRange, {
            inPlace: true
        }));
        indices = indices.filter(aggregationContainsIndex.bind(null, xValues, d0, d1, indexData, maxRange));
        filters.push({
            maxRange,
            indices
        });
    }
    filters.reverse();
    return filters;
}
;
function markerFadeInAnimation(param, animationManager, status) {
    let { id } = param;
    for(var _len = arguments.length, markerSelections = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
        markerSelections[_key - 3] = arguments[_key];
    }
    const params = {
        phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : "trailing"
    };
    staticFromToMotion(id, "markers", animationManager, markerSelections, {
        opacity: 0
    }, {
        opacity: 1
    }, params);
    markerSelections.forEach((s)=>s.cleanup());
}
function markerScaleInAnimation(param, animationManager) {
    let { id } = param;
    for(var _len = arguments.length, markerSelections = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
        markerSelections[_key - 2] = arguments[_key];
    }
    staticFromToMotion(id, "markers", animationManager, markerSelections, {
        scalingX: 0,
        scalingY: 0
    }, {
        scalingX: 1,
        scalingY: 1
    }, {
        phase: "initial"
    });
    markerSelections.forEach((s)=>s.cleanup());
}
function markerSwipeScaleInAnimation(param, animationManager) {
    let { id, nodeDataDependencies } = param;
    for(var _len = arguments.length, markerSelections = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
        markerSelections[_key - 2] = arguments[_key];
    }
    const seriesWidth = nodeDataDependencies.seriesRectWidth;
    const fromFn = (_, datum)=>{
        var _datum_midPoint;
        var _datum_midPoint_x;
        const x = (_datum_midPoint_x = (_datum_midPoint = datum.midPoint) === null || _datum_midPoint === void 0 ? void 0 : _datum_midPoint.x) !== null && _datum_midPoint_x !== void 0 ? _datum_midPoint_x : seriesWidth;
        let delay = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, inverseEaseOut(x / seriesWidth), 1);
        if (isNaN(delay)) {
            delay = 0;
        }
        return {
            scalingX: 0,
            scalingY: 0,
            delay,
            duration: QUICK_TRANSITION,
            phase: "initial"
        };
    };
    const toFn = ()=>{
        return {
            scalingX: 1,
            scalingY: 1
        };
    };
    fromToMotion(id, "markers", animationManager, markerSelections, {
        fromFn,
        toFn
    });
}
function resetMarkerFn(_node) {
    return {
        opacity: 1,
        scalingX: 1,
        scalingY: 1
    };
}
function resetMarkerPositionFn(_node, datum) {
    var _datum_point, _datum_point1, _datum_point2, _datum_point3;
    var _datum_point_x, _datum_point_y, _datum_point_x1, _datum_point_y1;
    return {
        x: (_datum_point_x = (_datum_point = datum.point) === null || _datum_point === void 0 ? void 0 : _datum_point.x) !== null && _datum_point_x !== void 0 ? _datum_point_x : NaN,
        y: (_datum_point_y = (_datum_point1 = datum.point) === null || _datum_point1 === void 0 ? void 0 : _datum_point1.y) !== null && _datum_point_y !== void 0 ? _datum_point_y : NaN,
        scalingCenterX: (_datum_point_x1 = (_datum_point2 = datum.point) === null || _datum_point2 === void 0 ? void 0 : _datum_point2.x) !== null && _datum_point_x1 !== void 0 ? _datum_point_x1 : NaN,
        scalingCenterY: (_datum_point_y1 = (_datum_point3 = datum.point) === null || _datum_point3 === void 0 ? void 0 : _datum_point3.y) !== null && _datum_point_y1 !== void 0 ? _datum_point_y1 : NaN
    };
}
function computeMarkerFocusBounds(series, param) {
    let { datumIndex } = param;
    const nodeData = series.getNodeData();
    if (nodeData === void 0) return void 0;
    const datum = nodeData[datumIndex];
    const { point } = datum !== null && datum !== void 0 ? datum : {};
    if (datum == null || point == null) return void 0;
    const style = series.getFormattedMarkerStyle(datum);
    const anchor = Marker.anchor(style.shape);
    var _point_focusSize;
    const size = (_point_focusSize = point.focusSize) !== null && _point_focusSize !== void 0 ? _point_focusSize : style.size;
    const paddedSize = 4 + size;
    const paddedRadius = paddedSize / 2;
    const anchorX = (anchor.x - 0.5) * size;
    const anchorY = (anchor.y - 0.5) * size;
    const x = datum.point.x - paddedRadius - anchorX;
    const y = datum.point.y - paddedRadius - anchorY;
    return Transformable.toCanvas(series.contentGroup, new BBox(x, y, paddedSize, paddedSize));
}
// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts
function pathSwipeInAnimation(param, animationManager) {
    let { id, visible, nodeDataDependencies } = param;
    for(var _len = arguments.length, paths = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
        paths[_key - 2] = arguments[_key];
    }
    const { seriesRectWidth: width2, seriesRectHeight: height2 } = nodeDataDependencies;
    staticFromToMotion(id, "path_properties", animationManager, paths, {
        clipX: 0
    }, {
        clipX: width2
    }, {
        phase: "initial",
        start: {
            clip: true,
            clipY: height2,
            visible
        },
        finish: {
            clip: false,
            visible
        }
    });
}
function pathFadeInAnimation(param, subId, animationManager) {
    let { id } = param, phase = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "add";
    for(var _len = arguments.length, selection = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){
        selection[_key - 4] = arguments[_key];
    }
    staticFromToMotion(id, subId, animationManager, selection, {
        opacity: 0
    }, {
        opacity: 1
    }, {
        phase
    });
}
function buildResetPathFn(opts) {
    return (_node)=>({
            visible: opts.getVisible(),
            opacity: opts.getOpacity(),
            clipScalingX: 1,
            clip: false
        });
}
function updateClipPath(param, path) {
    let { nodeDataDependencies } = param;
    const toFinite = (value)=>isFinite(value) ? value : 0;
    path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);
    path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);
}
// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts
var CROSS_FILTER_AREA_FILL_OPACITY_FACTOR = 0.125;
var CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR = 0.25;
var memoizedAggregateLineData = simpleMemorize2(aggregateLineData);
var AreaSeries = class extends CartesianSeries {
    get pickModeAxis() {
        return "main";
    }
    renderToOffscreenCanvas() {
        return super.renderToOffscreenCanvas() || this.contextNodeData != null && (this.contextNodeData.fillData.spans.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD || this.contextNodeData.strokeData.spans.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD);
    }
    attachSeries(seriesContentNode, seriesNode, annotationNode) {
        super.attachSeries(seriesContentNode, seriesNode, annotationNode);
        seriesContentNode.appendChild(this.backgroundGroup);
    }
    detachSeries(seriesContentNode, seriesNode, annotationNode) {
        super.detachSeries(seriesContentNode, seriesNode, annotationNode);
        seriesContentNode === null || seriesContentNode === void 0 ? void 0 : seriesContentNode.removeChild(this.backgroundGroup);
    }
    attachPaths(param) {
        let [fill, stroke2] = param;
        this.backgroundGroup.appendChild(fill);
        this.contentGroup.appendChild(stroke2);
        stroke2.zIndex = -1;
    }
    detachPaths(param) {
        let [fill, stroke2] = param;
        this.backgroundGroup.removeChild(fill);
        this.contentGroup.removeChild(stroke2);
    }
    isStacked() {
        var _this_seriesGrouping;
        var _this_seriesGrouping_stackCount;
        const stackCount = (_this_seriesGrouping_stackCount = (_this_seriesGrouping = this.seriesGrouping) === null || _this_seriesGrouping === void 0 ? void 0 : _this_seriesGrouping.stackCount) !== null && _this_seriesGrouping_stackCount !== void 0 ? _this_seriesGrouping_stackCount : 1;
        return stackCount > 1;
    }
    setSeriesIndex(index) {
        const isStacked = this.isStacked();
        const isStackedChanged = isStacked === this._isStacked;
        this._isStacked = isStackedChanged;
        return super.setSeriesIndex(index, isStackedChanged);
    }
    setZIndex(zIndex) {
        super.setZIndex(zIndex);
        if (this.isStacked()) {
            this.backgroundGroup.zIndex = [
                0 /* BACKGROUND */ ,
                zIndex
            ];
            this.contentGroup.zIndex = [
                1 /* ANY_CONTENT */ ,
                zIndex,
                0 /* FOREGROUND */ 
            ];
        } else {
            this.backgroundGroup.zIndex = [
                1 /* ANY_CONTENT */ ,
                zIndex,
                0 /* FOREGROUND */ ,
                0
            ];
            this.contentGroup.zIndex = [
                1 /* ANY_CONTENT */ ,
                zIndex,
                0 /* FOREGROUND */ ,
                1
            ];
        }
    }
    async processData(dataController) {
        var _this_axes_x, _this_axes_y;
        if (this.data == null) return;
        const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;
        const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;
        const animationEnabled = !this.ctx.animationManager.isSkipped();
        const xScale = (_this_axes_x = this.axes["x" /* X */ ]) === null || _this_axes_x === void 0 ? void 0 : _this_axes_x.scale;
        const yScale = (_this_axes_y = this.axes["y" /* Y */ ]) === null || _this_axes_y === void 0 ? void 0 : _this_axes_y.scale;
        const { xScaleType, yScaleType } = this.getScaleInformation({
            xScale,
            yScale
        });
        const stacked = stackCount > 1 || normalizedTo != null;
        const idMap = {
            value: "area-stack-".concat(groupIndex, "-yValue"),
            values: "area-stack-".concat(groupIndex, "-yValues"),
            stack: "area-stack-".concat(groupIndex, "-yValue-stack"),
            marker: "area-stack-".concat(groupIndex, "-yValues-marker")
        };
        const common = {
            invalidValue: null
        };
        if (((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(normalizedTo) || connectMissingData) && stackCount > 1) {
            common.invalidValue = 0;
        }
        if (!visible) {
            common.forceValue = 0;
        }
        const props = [
            keyProperty(xKey, xScaleType, {
                id: "xValue"
            }),
            valueProperty(yKey, yScaleType, {
                id: "yValueRaw",
                ...common
            }),
            ...yFilterKey != null ? [
                valueProperty(yFilterKey, yScaleType, {
                    id: "yFilterRaw"
                })
            ] : [],
            ...groupStackValueProperty(yKey, yScaleType, {
                id: "yValueStack",
                ...common,
                groupId: idMap.stack
            }),
            valueProperty(yKey, yScaleType, {
                id: "yValue",
                ...common,
                groupId: idMap.value
            })
        ];
        if (stacked) {
            props.push(...groupAccumulativeValueProperty(yKey, "window", "current", {
                id: "yValueEnd",
                ...common,
                groupId: idMap.values
            }, yScaleType), ...groupAccumulativeValueProperty(yKey, "normal", "current", {
                id: "yValueCumulative",
                ...common,
                groupId: idMap.marker
            }, yScaleType));
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(normalizedTo)) {
            props.push(normaliseGroupTo(Object.values(idMap), normalizedTo));
        }
        if (animationEnabled) {
            props.push(animationValidation());
        }
        const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
            props,
            groupByKeys: stacked,
            groupByData: !stacked
        });
        this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
        this.animationState.transition("updateData");
    }
    xCoordinateRange(xValue, pixelSize) {
        const { marker } = this.properties;
        const x = this.axes["x" /* X */ ].scale.convert(xValue);
        const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
        return [
            x - r,
            x + r
        ];
    }
    yCoordinateRange(yValues, pixelSize) {
        const { marker } = this.properties;
        const y = this.axes["y" /* Y */ ].scale.convert(yValues[0]);
        const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
        return [
            y - r,
            y + r
        ];
    }
    yCumulativeKey(processData) {
        return processData.type === "grouped" ? "yValueCumulative" : "yValue";
    }
    getSeriesDomain(direction) {
        const { processedData, dataModel, axes } = this;
        if (!processedData || !dataModel) return [];
        const yAxis = axes["y" /* Y */ ];
        if (direction === "x" /* X */ ) {
            const keyDef = dataModel.resolveProcessedDataDefById(this, "xValue");
            const keys = dataModel.getDomain(this, "xValue", "key", processedData);
            if ((keyDef === null || keyDef === void 0 ? void 0 : keyDef.def.type) === "key" && keyDef.def.valueType === "category") {
                return keys;
            }
            return fixNumericExtent(extent(keys));
        }
        const yExtent = this.domainForClippedRange("y" /* Y */ , [
            this.yCumulativeKey(processedData)
        ], "xValue");
        if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {
            return fixNumericExtent(yExtent);
        } else {
            const fixedYExtent = Number.isFinite(yExtent[1] - yExtent[0]) ? [
                yExtent[0] > 0 ? 0 : yExtent[0],
                yExtent[1] < 0 ? 0 : yExtent[1]
            ] : [];
            return fixNumericExtent(fixedYExtent);
        }
    }
    getSeriesRange(_direction, visibleRange) {
        const [y0, y1] = this.domainForVisibleRange("y" /* Y */ , [
            this.yCumulativeKey(this.processedData)
        ], "xValue", visibleRange);
        return [
            Math.min(y0, 0),
            Math.max(y1, 0)
        ];
    }
    getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
        return this.countVisibleItems("xValue", [
            this.yCumulativeKey(this.processedData)
        ], xVisibleRange, yVisibleRange, minVisibleItems);
    }
    aggregateData(dataModel, processedData) {
        if (processedData.type === "grouped") return;
        if (processedDataIsAnimatable(processedData)) return;
        const xAxis = this.axes["x" /* X */ ];
        if (xAxis == null) return;
        const { scale: scale2 } = xAxis;
        const xValues = dataModel.resolveColumnById(this, "xValue", processedData);
        const yValues = dataModel.resolveColumnById(this, "yValueRaw", processedData);
        const domain = dataModel.getDomain(this, "xValue", "value", processedData);
        return memoizedAggregateLineData(scale2.type, xValues, yValues, domain);
    }
    createNodeData() {
        var _this_seriesGrouping;
        const { axes, data, processedData, dataModel, dataAggregationFilters } = this;
        const xAxis = axes["x" /* X */ ];
        const yAxis = axes["y" /* Y */ ];
        if (!xAxis || !yAxis || !data || !dataModel || !processedData) return;
        const { yKey, xKey, xName, yName, yFilterKey, marker, label, fill: seriesFill, stroke: seriesStroke, connectMissingData, interpolation } = this.properties;
        const { scale: xScale } = xAxis;
        const { scale: yScale } = yAxis;
        const yDomain = this.getSeriesDomain("y" /* Y */ );
        const { isContinuousY } = this.getScaleInformation({
            xScale,
            yScale
        });
        var _xScale_bandwidth;
        const xOffset = ((_xScale_bandwidth = xScale.bandwidth) !== null && _xScale_bandwidth !== void 0 ? _xScale_bandwidth : 0) / 2;
        const stacked = processedData.type === "grouped";
        const xValues = dataModel.resolveKeysById(this, "xValue", processedData);
        const yRawValues = dataModel.resolveColumnById(this, "yValueRaw", processedData);
        const yCumulativeValues = stacked ? dataModel.resolveColumnById(this, "yValueCumulative", processedData) : yRawValues;
        const yFilterValues = yFilterKey != null ? dataModel.resolveColumnById(this, "yFilterRaw", processedData) : void 0;
        const yStackValues = processedData.type === "grouped" ? dataModel.resolveColumnById(this, "yValueStack", processedData) : void 0;
        const labelData = [];
        const markerData = [];
        const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
        let crossFiltering = false;
        const { dataSources } = processedData;
        var _dataSources_get;
        const rawData = (_dataSources_get = dataSources.get(this.id)) !== null && _dataSources_get !== void 0 ? _dataSources_get : [];
        const [r0, r1] = xScale.range;
        const range3 = Math.abs(r1 - r0);
        const dataAggregationFilter = dataAggregationFilters === null || dataAggregationFilters === void 0 ? void 0 : dataAggregationFilters.find((f)=>f.maxRange > range3);
        let startIndex = 0;
        let endIndex = 0;
        const indices = dataAggregationFilter === null || dataAggregationFilter === void 0 ? void 0 : dataAggregationFilter.indices;
        [startIndex, endIndex] = this.visibleRangeIndices("xValue", xAxis.range, indices);
        startIndex = Math.max(startIndex - 1, 0);
        var _indices_length;
        endIndex = Math.min(endIndex + 1, (_indices_length = indices === null || indices === void 0 ? void 0 : indices.length) !== null && _indices_length !== void 0 ? _indices_length : xValues.length);
        if (processedData.input.count < 1e3) {
            startIndex = 0;
            endIndex = processedData.input.count;
        }
        const createMarkerCoordinate = (xDatum, yEnd, rawYDatum)=>{
            let currY;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {
                currY = yEnd;
            }
            return {
                x: xScale.convert(xDatum) + xOffset,
                y: yScale.convert(currY),
                size: marker.size
            };
        };
        const handleDatum = (datumIndex)=>{
            const xDatum = xValues[datumIndex];
            if (xDatum == null) return;
            const seriesDatum = rawData[datumIndex];
            const yDatum = yRawValues[datumIndex];
            const yValueCumulative = yCumulativeValues[datumIndex];
            const validPoint = Number.isFinite(yDatum);
            const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);
            const selected = yFilterValues != null ? yFilterValues[datumIndex] === yDatum : void 0;
            if (selected === false) {
                crossFiltering = true;
            }
            if (validPoint && marker) {
                var _marker_fill, _marker_stroke, _marker_strokeWidth;
                markerData.push({
                    series: this,
                    itemId: yKey,
                    datum: seriesDatum,
                    datumIndex,
                    midPoint: {
                        x: point.x,
                        y: point.y
                    },
                    cumulativeValue: yValueCumulative,
                    yValue: yDatum,
                    xValue: xDatum,
                    yKey,
                    xKey,
                    point,
                    fill: (_marker_fill = marker.fill) !== null && _marker_fill !== void 0 ? _marker_fill : seriesFill,
                    stroke: (_marker_stroke = marker.stroke) !== null && _marker_stroke !== void 0 ? _marker_stroke : seriesStroke,
                    strokeWidth: (_marker_strokeWidth = marker.strokeWidth) !== null && _marker_strokeWidth !== void 0 ? _marker_strokeWidth : this.properties.strokeWidth,
                    selected
                });
            }
            if (label.enabled && validPoint) {
                const labelText = this.getLabelText(yDatum, seriesDatum, yKey, "y", yDomain, label, {
                    value: yDatum,
                    datum: seriesDatum,
                    xKey,
                    yKey,
                    xName,
                    yName
                });
                labelData.push({
                    series: this,
                    itemId: yKey,
                    datum: seriesDatum,
                    datumIndex,
                    x: point.x,
                    y: point.y,
                    labelText
                });
            }
        };
        if (processedData.type === "grouped") {
            for (const { datumIndex } of dataModel.forEachGroupDatum(this, processedData)){
                handleDatum(datumIndex);
            }
        } else {
            for(let i = startIndex; i < endIndex; i += 1){
                var _indices_i;
                const datumIndex = (_indices_i = indices === null || indices === void 0 ? void 0 : indices[i]) !== null && _indices_i !== void 0 ? _indices_i : i;
                if (xValues[datumIndex] == null) continue;
                handleDatum(datumIndex);
            }
        }
        const spansForPoints = (points)=>{
            return points.flatMap((p)=>{
                return Array.isArray(p) ? interpolatePoints(p, interpolation) : new Array(p.skip).fill(null);
            });
        };
        const createPoint = (xDatum, yDatum)=>({
                point: {
                    x: xScale.convert(xDatum) + xOffset,
                    y: yScale.convert(yDatum)
                },
                xDatum,
                yDatum
            });
        const getSeriesSpans = (index)=>{
            const points = [];
            const handleSeriesPoint = (pIdx, datumIndex, nIdx)=>{
                const xDatum = xValues[datumIndex];
                const yDatum = yStackValues != null ? yStackValues === null || yStackValues === void 0 ? void 0 : yStackValues[datumIndex][index] : yRawValues[datumIndex];
                if (connectMissingData && !Number.isFinite(yRawValues[datumIndex])) return;
                const yDatumIsFinite = Number.isFinite(yDatum);
                let yValueEndBackwards = 0;
                let yBackwardsFinite = true;
                let yValueEndForwards = 0;
                let yForwardsFinite = true;
                if (yStackValues == null) {
                    yBackwardsFinite = pIdx == null || Number.isFinite(yRawValues[pIdx]);
                    yForwardsFinite = nIdx == null || Number.isFinite(yRawValues[nIdx]);
                    yValueEndBackwards = pIdx != null && Number.isFinite(yRawValues[pIdx]) ? yDatum : 0;
                    yValueEndForwards = nIdx != null && Number.isFinite(yRawValues[nIdx]) ? yDatum : 0;
                } else {
                    const yValueStack = yStackValues[datumIndex];
                    const lastYValueStack = pIdx != null ? yStackValues[pIdx] : void 0;
                    const nextYValueStack = nIdx != null ? yStackValues[nIdx] : void 0;
                    for(let j = 0; j <= index; j += 1){
                        const value = yValueStack[j];
                        if (Number.isFinite(value)) {
                            const lastWasFinite = lastYValueStack == null || Number.isFinite(lastYValueStack[j]);
                            const nextWasFinite = nextYValueStack == null || Number.isFinite(nextYValueStack[j]);
                            if (lastWasFinite) {
                                yValueEndBackwards += value;
                            } else {
                                yBackwardsFinite = false;
                            }
                            if (nextWasFinite) {
                                yValueEndForwards += value;
                            } else {
                                yForwardsFinite = false;
                            }
                        }
                    }
                }
                const currentPoints = points[points.length - 1];
                if (!connectMissingData && (!yBackwardsFinite || !yForwardsFinite || !yDatumIsFinite || yValueEndBackwards !== yValueEndForwards)) {
                    if (!yDatumIsFinite && Array.isArray(currentPoints) && currentPoints.length === 1) {
                        points[points.length - 1] = {
                            skip: 1
                        };
                    } else {
                        const pointBackwards = createPoint(xDatum, yValueEndBackwards);
                        const pointForwards = createPoint(xDatum, yValueEndForwards);
                        if (Array.isArray(currentPoints)) {
                            currentPoints.push(pointBackwards);
                        } else if (currentPoints != null) {
                            currentPoints.skip += 1;
                        }
                        points.push(yDatumIsFinite ? [
                            pointForwards
                        ] : {
                            skip: 0
                        });
                    }
                } else {
                    const yValue = connectMissingData ? yDatum : Math.max(yValueEndBackwards, yValueEndForwards);
                    const point = createPoint(xDatum, yValue);
                    if (Array.isArray(currentPoints)) {
                        currentPoints.push(point);
                    } else if (currentPoints != null) {
                        currentPoints.skip += 1;
                        points.push([
                            point
                        ]);
                    } else {
                        points.push([
                            point
                        ]);
                    }
                }
            };
            if (processedData.type === "grouped") {
                for (const { datumIndexes: [pIdx, datumIndex, nIdx] } of dataModel.forEachGroupDatumTuple(this, processedData)){
                    handleSeriesPoint(pIdx, datumIndex, nIdx);
                }
            } else {
                let pIdx;
                let datumIndex;
                for(let i = startIndex; i < endIndex; i += 1){
                    var _indices_i;
                    const nIdx = (_indices_i = indices === null || indices === void 0 ? void 0 : indices[i]) !== null && _indices_i !== void 0 ? _indices_i : i;
                    if (xValues[nIdx] == null) continue;
                    if (datumIndex != null) {
                        handleSeriesPoint(pIdx, datumIndex, nIdx);
                    }
                    pIdx = datumIndex;
                    datumIndex = nIdx;
                }
                if (datumIndex != null) {
                    handleSeriesPoint(pIdx, datumIndex, void 0);
                }
            }
            return spansForPoints(points);
        };
        var _this_seriesGrouping_stackIndex;
        const stackIndex = (_this_seriesGrouping_stackIndex = (_this_seriesGrouping = this.seriesGrouping) === null || _this_seriesGrouping === void 0 ? void 0 : _this_seriesGrouping.stackIndex) !== null && _this_seriesGrouping_stackIndex !== void 0 ? _this_seriesGrouping_stackIndex : 0;
        const getAxisSpans = ()=>{
            const getPoint = (datumIndex)=>{
                const xDatum = xValues[datumIndex];
                var _yStackValues_datumIndex_stackIndex;
                const yDatum = (_yStackValues_datumIndex_stackIndex = yStackValues === null || yStackValues === void 0 ? void 0 : yStackValues[datumIndex][stackIndex]) !== null && _yStackValues_datumIndex_stackIndex !== void 0 ? _yStackValues_datumIndex_stackIndex : yRawValues[datumIndex];
                if (connectMissingData && !Number.isFinite(yDatum)) return;
                return createPoint(xDatum, 0);
            };
            let yValueZeroPoints;
            if (processedData.type === "grouped") {
                yValueZeroPoints = Array.from(dataModel.forEachGroupDatum(this, processedData), (param)=>{
                    let { datumIndex } = param;
                    return getPoint(datumIndex);
                });
            } else {
                yValueZeroPoints = [];
                for(let i = startIndex; i < endIndex; i += 1){
                    var _indices_i;
                    const datumIndex = (_indices_i = indices === null || indices === void 0 ? void 0 : indices[i]) !== null && _indices_i !== void 0 ? _indices_i : i;
                    if (xValues[datumIndex] == null) continue;
                    yValueZeroPoints.push(getPoint(datumIndex));
                }
            }
            yValueZeroPoints = yValueZeroPoints.filter((x)=>x != null);
            return interpolatePoints(yValueZeroPoints, interpolation);
        };
        const currentSeriesSpans = getSeriesSpans(stackIndex);
        const phantomSpans = currentSeriesSpans.map(()=>null);
        for(let j = stackIndex - 1; j >= -1; j -= 1){
            let spans;
            for(let i = 0; i < phantomSpans.length; i += 1){
                if (phantomSpans[i] != null) continue;
                spans !== null && spans !== void 0 ? spans : spans = j !== -1 ? getSeriesSpans(j) : getAxisSpans();
                phantomSpans[i] = spans[i];
            }
        }
        const fillSpans = currentSeriesSpans.map((span, index)=>span !== null && span !== void 0 ? span : phantomSpans[index]);
        const strokeSpans = currentSeriesSpans.filter((span)=>span != null);
        const context = {
            itemId: yKey,
            fillData: {
                itemId: yKey,
                spans: fillSpans,
                phantomSpans
            },
            strokeData: {
                itemId: yKey,
                spans: strokeSpans
            },
            labelData,
            nodeData: markerData,
            scales: this.calculateScaling(),
            visible: this.visible,
            stackVisible: visibleSameStackCount > 0,
            crossFiltering
        };
        return context;
    }
    isPathOrSelectionDirty() {
        return this.properties.marker.isDirty();
    }
    updatePathNodes(opts) {
        var _this_contextNodeData;
        const { visible, animationEnabled } = opts;
        const [fill, stroke2] = opts.paths;
        const crossFiltering = ((_this_contextNodeData = this.contextNodeData) === null || _this_contextNodeData === void 0 ? void 0 : _this_contextNodeData.crossFiltering) === true;
        const { strokeWidth, stroke: strokeColor, strokeOpacity, lineDash, lineDashOffset, fill: fillColor, fillOpacity, opacity } = mergeDefaults(this.getHighlightStyle(), this.properties);
        stroke2.setProperties({
            fill: void 0,
            lineCap: "round",
            lineJoin: "round",
            pointerEvents: 1 /* None */ ,
            stroke: strokeColor,
            strokeWidth,
            strokeOpacity: strokeOpacity * (crossFiltering ? CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR : 1),
            lineDash,
            lineDashOffset,
            opacity,
            visible: visible || animationEnabled
        });
        const seriesFill = getShapeFill(fillColor, this.properties.fillGradientDefaults, this.properties.fillPatternDefaults, this.properties.fillImageDefaults);
        applyShapeStyle(fill, {
            fill: seriesFill,
            stroke: void 0,
            fillOpacity: fillOpacity * (crossFiltering ? CROSS_FILTER_AREA_FILL_OPACITY_FACTOR : 1)
        }, this.getShapeFillBBox());
        fill.setProperties({
            lineJoin: "round",
            pointerEvents: 1 /* None */ ,
            fillShadow: this.properties.shadow,
            opacity,
            visible: visible || animationEnabled
        });
        updateClipPath(this, stroke2);
        updateClipPath(this, fill);
    }
    updatePaths(opts) {
        this.updateAreaPaths(opts.paths, opts.contextData);
    }
    updateAreaPaths(paths, contextData) {
        for (const path of paths){
            path.visible = contextData.visible;
        }
        if (contextData.visible) {
            this.updateFillPath(paths, contextData);
            this.updateStrokePath(paths, contextData);
        } else {
            for (const path of paths){
                path.path.clear();
                path.markDirty("AreaSeries");
            }
        }
    }
    updateFillPath(paths, contextData) {
        const [fill] = paths;
        fill.path.clear();
        plotAreaPathFill(fill, contextData.fillData);
        fill.markDirty("AreaSeries");
    }
    updateStrokePath(paths, contextData) {
        const { spans } = contextData.strokeData;
        const [, stroke2] = paths;
        stroke2.path.clear();
        plotLinePathStroke(stroke2, spans);
        stroke2.markDirty("AreaSeries");
    }
    updateDatumSelection(opts) {
        var _this_contextNodeData;
        const { nodeData, datumSelection } = opts;
        const markersEnabled = this.properties.marker.enabled || ((_this_contextNodeData = this.contextNodeData) === null || _this_contextNodeData === void 0 ? void 0 : _this_contextNodeData.crossFiltering) === true;
        if (this.properties.marker.isDirty()) {
            datumSelection.clear();
            datumSelection.cleanup();
        }
        return datumSelection.update(markersEnabled ? nodeData : []);
    }
    updateDatumNodes(opts) {
        const { datumSelection, isHighlight } = opts;
        const { xKey, yKey, marker, stroke: stroke2, strokeWidth, strokeOpacity } = this.properties;
        const xDomain = this.getSeriesDomain("x" /* X */ );
        const yDomain = this.getSeriesDomain("y" /* Y */ );
        const fillBBox = this.getShapeFillBBox();
        datumSelection.each((node, datum)=>{
            const { xValue, yValue } = datum;
            const params = datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain);
            const style = this.getMarkerStyle(marker, datum, params, isHighlight, void 0, {
                stroke: stroke2,
                strokeWidth,
                strokeOpacity
            });
            this.applyMarkerStyle(style, node, datum.point, fillBBox, {
                selected: datum.selected
            });
        });
        if (!isHighlight) {
            this.properties.marker.markClean();
        }
        if (!isHighlight) {
            this.properties.marker.markClean();
        }
    }
    updateLabelSelection(opts) {
        const { labelData, labelSelection } = opts;
        return labelSelection.update(labelData);
    }
    updateLabelNodes(opts) {
        var _this_ctx_highlightManager;
        const { isHighlight = false } = opts;
        const activeHighlight = (_this_ctx_highlightManager = this.ctx.highlightManager) === null || _this_ctx_highlightManager === void 0 ? void 0 : _this_ctx_highlightManager.getActiveHighlight();
        opts.labelSelection.each((text, datum)=>{
            const { x, y, labelText } = datum;
            const highlighted = isHighlight || this.isSeriesHighlighted(activeHighlight);
            const highlightState = this.getHighlightStateString(activeHighlight, highlighted, datum.datumIndex);
            const style = getLabelStyles(this, datum, this.properties, this.properties.label, highlighted, highlightState);
            const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color: color11 } = style;
            if (labelText && labelEnabled && this.visible) {
                text.fontStyle = fontStyle;
                text.fontWeight = fontWeight;
                text.fontSize = fontSize;
                text.fontFamily = fontFamily;
                text.textAlign = "center";
                text.textBaseline = "bottom";
                text.text = labelText;
                text.x = x;
                text.y = y - 10;
                text.fill = color11;
                var _this_getHighlightStyle_opacity;
                text.fillOpacity = (_this_getHighlightStyle_opacity = this.getHighlightStyle(isHighlight, datum.datumIndex).opacity) !== null && _this_getHighlightStyle_opacity !== void 0 ? _this_getHighlightStyle_opacity : 1;
                text.visible = true;
                text.setBoxing(style);
            } else {
                text.visible = false;
            }
        });
    }
    getTooltipContent(datumIndex) {
        var _processedData_dataSources_get;
        const { id: seriesId, dataModel, processedData, axes, properties } = this;
        const { xKey, xName, yKey, yName, tooltip, marker, legendItemName } = properties;
        const xAxis = axes["x" /* X */ ];
        const yAxis = axes["y" /* Y */ ];
        if (!dataModel || !processedData || !xAxis || !yAxis) return;
        const datum = (_processedData_dataSources_get = processedData.dataSources.get(this.id)) === null || _processedData_dataSources_get === void 0 ? void 0 : _processedData_dataSources_get[datumIndex];
        const xValue = dataModel.resolveKeysById(this, "xValue", processedData)[datumIndex];
        const yValue = dataModel.resolveColumnById(this, "yValueRaw", processedData)[datumIndex];
        const { xDomain, yDomain } = this.cachedDatumCallback("domain", ()=>({
                xDomain: this.getSeriesDomain("x" /* X */ ),
                yDomain: this.getSeriesDomain("y" /* Y */ )
            }));
        if (xValue == null) return;
        const activeStyle = this.getMarkerStyle(marker, {
            datum,
            datumIndex
        }, datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain), false);
        return this.formatTooltipWithContext(tooltip, {
            heading: this.getAxisValueText(xAxis, "tooltip", xValue, datum, xKey, legendItemName),
            symbol: this.legendItemSymbol(),
            data: [
                {
                    label: yName,
                    fallbackLabel: yKey,
                    value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
                }
            ]
        }, {
            seriesId,
            datum,
            title: yName,
            xKey,
            xName,
            yKey,
            yName,
            ...activeStyle,
            ...this.getModuleTooltipParams()
        });
    }
    legendItemSymbol() {
        const { fill, stroke: stroke2, fillOpacity, strokeOpacity, strokeWidth, lineDash, marker, fillGradientDefaults: fillGradientDefaults2, fillPatternDefaults: fillPatternDefaults2, fillImageDefaults: fillImageDefaults2 } = this.properties;
        const useAreaFill = !marker.enabled || marker.fill === void 0;
        const legendMarkerFill = useAreaFill ? getShapeFill(fill, fillGradientDefaults2, fillPatternDefaults2, fillImageDefaults2) : getShapeFill(marker.fill, marker.fillGradientDefaults, marker.fillPatternDefaults, marker.fillImageDefaults);
        const markerStyle = this.getMarkerStyle(marker, {}, void 0, false, {
            size: marker.size,
            fill: legendMarkerFill,
            fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity
        }, void 0, false);
        return {
            marker: {
                ...markerStyle,
                enabled: marker.enabled || strokeWidth <= 0
            },
            line: {
                stroke: stroke2,
                strokeOpacity,
                strokeWidth,
                lineDash
            }
        };
    }
    getLegendData(legendType) {
        if (legendType !== "category") {
            return [];
        }
        const { id: seriesId, ctx: { legendManager }, visible } = this;
        const { yKey: itemId, yName, legendItemName, showInLegend } = this.properties;
        var _ref;
        return [
            {
                legendType,
                id: seriesId,
                itemId,
                seriesId,
                enabled: visible && legendManager.getItemEnabled({
                    seriesId,
                    itemId
                }),
                label: {
                    text: (_ref = legendItemName !== null && legendItemName !== void 0 ? legendItemName : yName) !== null && _ref !== void 0 ? _ref : itemId
                },
                symbol: this.legendItemSymbol(),
                legendItemName,
                hideInLegend: !showInLegend
            }
        ];
    }
    animateEmptyUpdateReady(animationData) {
        const { datumSelection, labelSelection, contextData, paths } = animationData;
        const { animationManager } = this.ctx;
        this.updateAreaPaths(paths, contextData);
        pathSwipeInAnimation(this, animationManager, ...paths);
        resetMotion([
            datumSelection
        ], resetMarkerPositionFn);
        markerSwipeScaleInAnimation(this, animationManager, datumSelection);
        seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
    }
    animateReadyResize(animationData) {
        const { contextData, paths } = animationData;
        this.updateAreaPaths(paths, contextData);
        super.animateReadyResize(animationData);
    }
    animateWaitingUpdateReady(animationData) {
        const { animationManager } = this.ctx;
        const { datumSelection, labelSelection, contextData, paths, previousContextData } = animationData;
        const [fill, stroke2] = paths;
        if (contextData.visible === false && (previousContextData === null || previousContextData === void 0 ? void 0 : previousContextData.visible) === false) return;
        if (fill == null && stroke2 == null) return;
        this.resetDatumAnimation(animationData);
        this.resetLabelAnimation(animationData);
        const update = ()=>{
            this.resetPathAnimation(animationData);
            this.updateAreaPaths(paths, contextData);
        };
        const skip = ()=>{
            animationManager.skipCurrentBatch();
            update();
        };
        if (contextData == null || previousContextData == null) {
            update();
            markerFadeInAnimation(this, animationManager, "added", datumSelection);
            pathFadeInAnimation(this, "fill_path_properties", animationManager, "add", fill);
            pathFadeInAnimation(this, "stroke_path_properties", animationManager, "add", stroke2);
            seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
            return;
        }
        if (contextData.crossFiltering !== previousContextData.crossFiltering) {
            skip();
            return;
        }
        const fns = prepareAreaPathAnimation(contextData, previousContextData);
        if (fns === void 0) {
            skip();
            return;
        } else if (fns.status === "no-op") {
            return;
        }
        markerFadeInAnimation(this, animationManager, void 0, datumSelection);
        fromToMotion(this.id, "fill_path_properties", animationManager, [
            fill
        ], fns.fill.pathProperties);
        pathMotion(this.id, "fill_path_update", animationManager, [
            fill
        ], fns.fill.path);
        fromToMotion(this.id, "stroke_path_properties", animationManager, [
            stroke2
        ], fns.stroke.pathProperties);
        pathMotion(this.id, "stroke_path_update", animationManager, [
            stroke2
        ], fns.stroke.path);
        seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
        this.ctx.animationManager.animate({
            id: this.id,
            groupId: "reset_after_animation",
            phase: "trailing",
            from: {},
            to: {},
            onComplete: ()=>this.updateAreaPaths(paths, contextData)
        });
    }
    isLabelEnabled() {
        return this.properties.label.enabled;
    }
    nodeFactory() {
        return new Marker();
    }
    getFormattedMarkerStyle(datum) {
        const { xValue, yValue, xKey, yKey } = datum;
        const xDomain = this.getSeriesDomain("x" /* X */ );
        const yDomain = this.getSeriesDomain("y" /* Y */ );
        return this.getMarkerStyle(this.properties.marker, datum, datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain), true);
    }
    computeFocusBounds(opts) {
        return computeMarkerFocusBounds(this, opts);
    }
    hasItemStylers() {
        return this.properties.marker.itemStyler != null || this.properties.label.itemStyler != null;
    }
    constructor(moduleCtx){
        super({
            moduleCtx,
            propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
            propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
            categoryKey: "xValue",
            pathsPerSeries: [
                "fill",
                "stroke"
            ],
            pathsZIndexSubOrderOffset: [
                0,
                1e3
            ],
            datumSelectionGarbageCollection: false,
            pickModes: [
                2 /* AXIS_ALIGNED */ ,
                0 /* EXACT_SHAPE_MATCH */ 
            ],
            animationResetFns: {
                path: buildResetPathFn({
                    getVisible: ()=>this.visible,
                    getOpacity: ()=>this.getOpacity()
                }),
                label: resetLabelFn,
                datum: (node, datum)=>({
                        ...resetMarkerFn(node),
                        ...resetMarkerPositionFn(node, datum)
                    })
            },
            clipFocusBox: false
        });
        this.properties = new AreaSeriesProperties();
        this.connectsToYAxis = true;
        this.dataAggregationFilters = void 0;
        this.backgroundGroup = new Group({
            name: "".concat(this.id, "-background"),
            zIndex: 0 /* BACKGROUND */ 
        });
        this._isStacked = void 0;
    }
};
AreaSeries.className = "AreaSeries";
AreaSeries.type = "area";
// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts
var AreaSeriesModule = {
    type: "series",
    optionsKey: "series[]",
    packageType: "community",
    chartTypes: [
        "cartesian"
    ],
    identifier: "area",
    moduleFactory: (ctx)=>new AreaSeries(ctx),
    stackable: true,
    defaultAxes: [
        {
            type: "number" /* NUMBER */ ,
            position: "left" /* LEFT */ 
        },
        {
            type: "category" /* CATEGORY */ ,
            position: "bottom" /* BOTTOM */ 
        }
    ],
    themeTemplate: {
        series: {
            nodeClickRange: "nearest",
            fill: {
                $palette: "fill"
            },
            fillGradientDefaults: FILL_GRADIENT_LINEAR_DEFAULTS,
            fillPatternDefaults: FILL_PATTERN_DEFAULTS,
            fillImageDefaults: FILL_IMAGE_DEFAULTS,
            stroke: {
                $palette: "stroke"
            },
            fillOpacity: 0.8,
            strokeOpacity: 1,
            strokeWidth: {
                $isUserOption: [
                    "./stroke",
                    2,
                    0
                ]
            },
            lineDash: [
                0
            ],
            lineDashOffset: 0,
            shadow: {
                enabled: false,
                color: DEFAULT_SHADOW_COLOUR,
                xOffset: 3,
                yOffset: 3,
                blur: 5
            },
            interpolation: {
                type: "linear"
            },
            marker: {
                enabled: false,
                shape: "circle",
                size: 7,
                strokeWidth: {
                    $isUserOption: [
                        "./stroke",
                        1,
                        0
                    ]
                },
                fill: {
                    $palette: "fill"
                },
                stroke: {
                    $palette: "stroke"
                },
                // @ts-expect-error undocumented option
                fillGradientDefaults: FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
                fillPatternDefaults: FILL_PATTERN_DEFAULTS
            },
            label: {
                ...LABEL_BOXING_DEFAULTS,
                enabled: false,
                fontSize: {
                    $ref: "fontSize"
                },
                fontFamily: {
                    $ref: "fontFamily"
                },
                fontWeight: {
                    $ref: "fontWeight"
                },
                color: {
                    $ref: "textColor"
                }
            },
            tooltip: {
                range: {
                    $path: [
                        "/tooltip/range",
                        "nearest"
                    ]
                },
                position: {
                    anchorTo: {
                        $path: [
                            "/tooltip/position/anchorTo",
                            "node"
                        ]
                    }
                }
            },
            highlight: multiSeriesHighlightStyle()
        }
    }
};
var NewAreaSeriesModule = {
    type: "series",
    name: "area",
    chartType: "cartesian",
    options: areaSeriesOptionsDef,
    create: (ctx)=>new AreaSeries(ctx)
};
;
// packages/ag-charts-community/src/scene/shape/barShape.ts
var BarShape = class extends Rect {
    get feathered() {
        return Math.abs(this.featherRatio) > 1e-6;
    }
    isPointInPath(x, y) {
        if (!this.feathered) {
            return super.isPointInPath(x, y);
        }
        const bbox = this.getBBox();
        return bbox.containsPoint(x, y);
    }
    updatePath() {
        if (!this.feathered) {
            super.updatePath();
            return;
        }
        const { path, x, y, width: width2, height: height2, direction, featherRatio } = this;
        path.clear();
        if (direction === "x") {
            const featherInsetX = Math.abs(featherRatio) * width2;
            if (featherRatio > 0) {
                path.moveTo(x, y);
                path.lineTo(x + width2 - featherInsetX, y);
                path.lineTo(x + width2, y + height2 / 2);
                path.lineTo(x + width2 - featherInsetX, y + height2);
                path.lineTo(x, y + height2);
                path.closePath();
            } else {
                path.moveTo(x + featherInsetX, y);
                path.lineTo(x + width2, y);
                path.lineTo(x + width2, y + height2);
                path.lineTo(x + featherInsetX, y + height2);
                path.lineTo(x, y + height2 / 2);
                path.closePath();
            }
        } else {
            const featherInsetY = Math.abs(featherRatio) * height2;
            if (featherRatio > 0) {
                path.moveTo(x, y + featherInsetY);
                path.lineTo(x + width2 / 2, y);
                path.lineTo(x + width2, y + featherInsetY);
                path.lineTo(x + width2, y + height2);
                path.lineTo(x, y + height2);
                path.closePath();
            } else {
                path.moveTo(x, y);
                path.lineTo(x + width2, y);
                path.lineTo(x + width2, y + height2 - featherInsetY);
                path.lineTo(x + width2 / 2, y + height2);
                path.lineTo(x, y + height2 - featherInsetY);
                path.closePath();
            }
        }
    }
    constructor(){
        super(...arguments);
        this.direction = "x";
        this.featherRatio = 0;
    }
};
__decorateClass([
    SceneChangeDetection()
], BarShape.prototype, "direction", 2);
__decorateClass([
    SceneChangeDetection()
], BarShape.prototype, "featherRatio", 2);
;
;
function addHitTestersToQuadtree(quadtree, hitTesters) {
    for (const node of hitTesters){
        const datum = node.datum;
        if (datum === void 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].error("undefined datum");
        } else {
            quadtree.addValue(node, datum);
        }
    }
}
function findQuadtreeMatch(series, point) {
    const { x, y } = point;
    const { nearest, distanceSquared: distanceSquared2 } = series.getQuadTree().find(x, y);
    if (nearest !== void 0) {
        return {
            datum: nearest.value,
            distance: Math.sqrt(distanceSquared2)
        };
    }
    return void 0;
}
// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts
var AbstractBarSeriesProperties = class extends CartesianSeriesProperties {
    constructor(){
        super(...arguments);
        this.direction = "vertical";
    }
};
__decorateClass([
    Property
], AbstractBarSeriesProperties.prototype, "direction", 2);
var AbstractBarSeries = class extends CartesianSeries {
    padBandExtent(keys, alignStart) {
        const ratio11 = typeof alignStart === "boolean" ? 1 : 0.5;
        const scalePadding = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(this.smallestDataInterval) ? this.smallestDataInterval * ratio11 : 0;
        var _extent;
        const keysExtent = (_extent = extent(keys)) !== null && _extent !== void 0 ? _extent : [
            NaN,
            NaN
        ];
        if (typeof alignStart === "boolean") {
            keysExtent[alignStart ? 0 : 1] -= (alignStart ? 1 : -1) * scalePadding;
        } else {
            keysExtent[0] -= scalePadding;
            keysExtent[1] += scalePadding;
        }
        return fixNumericExtent(keysExtent);
    }
    getBandScalePadding() {
        return {
            inner: 0.3,
            outer: 0.15
        };
    }
    shouldFlipXY() {
        return !this.isVertical();
    }
    isVertical() {
        return this.properties.direction === "vertical";
    }
    getBarDirection() {
        return this.shouldFlipXY() ? "x" /* X */  : "y" /* Y */ ;
    }
    getCategoryDirection() {
        return this.shouldFlipXY() ? "y" /* Y */  : "x" /* X */ ;
    }
    getValueAxis() {
        const direction = this.getBarDirection();
        return this.axes[direction];
    }
    getCategoryAxis() {
        const direction = this.getCategoryDirection();
        return this.axes[direction];
    }
    getBandwidth(xAxis, minWidth) {
        return ContinuousScale.is(xAxis.scale) ? xAxis.scale.calcBandwidth(this.smallestDataInterval, minWidth) : xAxis.scale.bandwidth;
    }
    xCoordinateRange(xValue) {
        const xAxis = this.axes[this.getCategoryDirection()];
        const xScale = xAxis.scale;
        var _this_getBandwidth;
        const bandWidth = (_this_getBandwidth = this.getBandwidth(xAxis, 0)) !== null && _this_getBandwidth !== void 0 ? _this_getBandwidth : 0;
        const barOffset = ContinuousScale.is(xScale) ? bandWidth * -0.5 : 0;
        const x = xScale.convert(xValue) + barOffset;
        return [
            x,
            x + bandWidth
        ];
    }
    yCoordinateRange(yValues) {
        const yAxis = this.axes[this.getBarDirection()];
        const yScale = yAxis.scale;
        const ys = yValues.map((yValue)=>yScale.convert(yValue));
        if (ys.length === 1) {
            const y0 = yScale.convert(0);
            return [
                Math.min(ys[0], y0),
                Math.max(ys[0], y0)
            ];
        }
        return [
            Math.min(...ys),
            Math.max(...ys)
        ];
    }
    updateGroupScale(xAxis) {
        const domain = [];
        const { groupScale } = this;
        const xBandWidth = this.getBandwidth(xAxis);
        const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
        for(let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++){
            domain.push(String(groupIdx));
        }
        groupScale.domain = domain;
        groupScale.range = [
            0,
            xBandWidth !== null && xBandWidth !== void 0 ? xBandWidth : 0
        ];
        if (xAxis instanceof GroupedCategoryAxis) {
            groupScale.paddingInner = xAxis.groupPaddingInner;
        } else if (xAxis instanceof CategoryAxis) {
            groupScale.paddingInner = xAxis.groupPaddingInner;
            groupScale.round = groupScale.padding !== 0;
        } else {
            groupScale.padding = 0;
        }
        const barWidth = groupScale.bandwidth >= 1 ? // Pixel-rounded value for low-volume bar charts.
        groupScale.bandwidth : // Handle high-volume bar charts gracefully.
        groupScale.rawBandwidth;
        return {
            barWidth,
            groupIndex
        };
    }
    resolveKeyDirection(direction) {
        if (this.getBarDirection() === "x" /* X */ ) {
            if (direction === "x" /* X */ ) {
                return "y" /* Y */ ;
            }
            return "x" /* X */ ;
        }
        return direction;
    }
    initQuadTree(quadtree) {
        addHitTestersToQuadtree(quadtree, this.datumNodesIter());
    }
    pickNodesExactShape(point) {
        const item = findQuadtreeMatch(this, point);
        return item != null && item.distance <= 0 ? [
            item.datum
        ] : [];
    }
    pickNodeClosestDatum(point) {
        return findQuadtreeMatch(this, point);
    }
    constructor(){
        super(...arguments);
        /**
     * Used to get the position of bars within each group.
     */ this.groupScale = new CategoryScale();
        this.smallestDataInterval = void 0;
        this.largestDataInterval = void 0;
    }
};
// packages/ag-charts-community/src/chart/series/cartesian/barAggregation.ts
var BAR_X_MIN = AGGREGATION_INDEX_X_MIN;
var BAR_X_MAX = AGGREGATION_INDEX_X_MAX;
var BAR_Y_MIN = AGGREGATION_INDEX_Y_MIN;
var BAR_Y_MAX = AGGREGATION_INDEX_Y_MAX;
var BAR_SPAN = AGGREGATION_SPAN;
var AGGREGATION_THRESHOLD2 = 1e3;
function getIndices(maxRange, indexData) {
    return Array.from({
        length: maxRange
    }, (_, index)=>{
        const aggIndex = index * AGGREGATION_SPAN;
        const xMinIndex = indexData[aggIndex + AGGREGATION_INDEX_X_MIN];
        const xMaxIndex = indexData[aggIndex + AGGREGATION_INDEX_X_MAX];
        return (xMinIndex + xMaxIndex) / 2 | 0;
    });
}
function aggregateBarData(scale2, xValues, yValues, domain) {
    if (xValues.length < AGGREGATION_THRESHOLD2) return;
    const [d0, d1] = aggregationDomain(scale2, domain);
    let maxRange = aggregationRangeFittingPoints(xValues);
    let { indexData, valueData } = createAggregationIndices(xValues, yValues, yValues, d0, d1, maxRange);
    let indices = getIndices(maxRange, indexData);
    const filters = [
        {
            maxRange,
            indexData,
            indices
        }
    ];
    while(maxRange > 64){
        ({ indexData, valueData, maxRange } = compactAggregationIndices(indexData, valueData, maxRange));
        indices = getIndices(maxRange, indexData);
        filters.push({
            maxRange,
            indexData,
            indices
        });
    }
    filters.reverse();
    return filters;
}
// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts
var BarSeriesLabel = class extends Label {
    constructor(){
        super(...arguments);
        this.placement = "inside-center";
        this.spacing = 0;
    }
};
__decorateClass([
    Property
], BarSeriesLabel.prototype, "placement", 2);
__decorateClass([
    Property
], BarSeriesLabel.prototype, "spacing", 2);
var BarSeriesProperties = class extends AbstractBarSeriesProperties {
    getStyle() {
        const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = this;
        return {
            fill,
            fillOpacity,
            stroke: stroke2,
            strokeWidth,
            strokeOpacity,
            lineDash,
            lineDashOffset,
            cornerRadius,
            opacity: 1
        };
    }
    constructor(){
        super(...arguments);
        this.fill = "#c16068";
        this.fillGradientDefaults = new FillGradientDefaults();
        this.fillPatternDefaults = new FillPatternDefaults();
        this.fillImageDefaults = new FillImageDefaults();
        this.fillOpacity = 1;
        this.stroke = "#874349";
        this.strokeWidth = 1;
        this.strokeOpacity = 1;
        this.lineDash = [
            0
        ];
        this.lineDashOffset = 0;
        this.cornerRadius = 0;
        this.crisp = void 0;
        this.shadow = new DropShadow();
        this.label = new BarSeriesLabel();
        this.tooltip = makeSeriesTooltip();
        this.sparklineMode = false;
    }
};
__decorateClass([
    Property
], BarSeriesProperties.prototype, "xKey", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "xName", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "yKey", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "yName", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "stackGroup", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "fill", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "stroke", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "crisp", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "shadow", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "label", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
    Property
], BarSeriesProperties.prototype, "sparklineMode", 2);
;
function checkCrisp(scale2, visibleRange, smallestDataInterval, largestDataInterval) {
    if (visibleRange != null) {
        const [visibleMin, visibleMax] = visibleRange;
        const isZoomed = visibleMin !== 0 || visibleMax !== 1;
        if (isZoomed) return false;
    }
    if (ContinuousScale.is(scale2)) {
        const spacing = scale2.calcBandwidth(largestDataInterval) - scale2.calcBandwidth(smallestDataInterval);
        if (spacing > 0 && spacing < 1) return false;
    }
    if (BandScale.is(scale2)) {
        const { bandwidth, step } = scale2;
        if (bandwidth > 0 && bandwidth < 1) return false;
        const spacing = step - bandwidth;
        if (spacing > 0 && spacing < 1) return false;
    }
    return true;
}
var isDatumNegative = (datum)=>{
    var _datum_yValue;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNegative"])((_datum_yValue = datum.yValue) !== null && _datum_yValue !== void 0 ? _datum_yValue : 0);
};
function collapsedStartingBarPosition(isVertical, axes, mode) {
    const { startingX, startingY } = getStartingValues(isVertical, axes);
    const calculate = (datum, prevDatum)=>{
        let x = isVertical ? datum.x : startingX;
        let y = isVertical ? startingY : datum.y;
        let width2 = isVertical ? datum.width : 0;
        let height2 = isVertical ? 0 : datum.height;
        const { opacity = 1 } = datum;
        if (prevDatum && (isNaN(x) || isNaN(y))) {
            ({ x, y } = prevDatum);
            width2 = isVertical ? prevDatum.width : 0;
            height2 = isVertical ? 0 : prevDatum.height;
            if (isVertical && !isDatumNegative(prevDatum)) {
                y += prevDatum.height;
            } else if (!isVertical && isDatumNegative(prevDatum)) {
                x += prevDatum.width;
            }
        }
        let clipBBox;
        if (datum.clipBBox == null) {
            clipBBox = void 0;
        } else if (isDatumNegative(datum)) {
            clipBBox = isVertical ? new BBox(x, y - height2, width2, height2) : new BBox(x - width2, y, width2, height2);
        } else {
            clipBBox = new BBox(x, y, width2, height2);
        }
        return {
            x,
            y,
            width: width2,
            height: height2,
            clipBBox,
            opacity
        };
    };
    return {
        isVertical,
        calculate,
        mode
    };
}
function midpointStartingBarPosition(isVertical, mode) {
    return {
        isVertical,
        calculate: (datum)=>{
            var _datum_opacity;
            return {
                x: isVertical ? datum.x : datum.x + datum.width / 2,
                y: isVertical ? datum.y + datum.height / 2 : datum.y,
                width: isVertical ? datum.width : 0,
                height: isVertical ? 0 : datum.height,
                clipBBox: datum.clipBBox,
                opacity: (_datum_opacity = datum.opacity) !== null && _datum_opacity !== void 0 ? _datum_opacity : 1
            };
        },
        mode
    };
}
function prepareBarAnimationFunctions(initPos) {
    const isRemoved = (datum)=>datum == null || isNaN(datum.x) || isNaN(datum.y);
    const fromFn = (rect, datum, status)=>{
        if (status === "updated" && isRemoved(datum)) {
            status = "removed";
        } else if (status === "updated" && isRemoved(rect.previousDatum)) {
            status = "added";
        }
        let source;
        if (status === "added" && rect.previousDatum == null && initPos.mode === "fade") {
            source = {
                ...resetBarSelectionsFn(rect, datum),
                opacity: 0
            };
        } else if (status === "unknown" || status === "added") {
            source = initPos.calculate(datum, rect.previousDatum);
        } else {
            var _rect_opacity;
            source = {
                x: rect.x,
                y: rect.y,
                width: rect.width,
                height: rect.height,
                clipBBox: rect.clipBBox,
                opacity: (_rect_opacity = rect.opacity) !== null && _rect_opacity !== void 0 ? _rect_opacity : 1
            };
        }
        const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
        return {
            ...source,
            phase
        };
    };
    const toFn = (rect, datum, status)=>{
        if (status === "removed" && rect.datum == null && initPos.mode === "fade") {
            return {
                ...resetBarSelectionsFn(rect, datum),
                opacity: 0
            };
        } else if (status === "removed" || isRemoved(datum)) {
            return initPos.calculate(datum, rect.previousDatum);
        } else {
            var _datum_opacity;
            return {
                x: datum.x,
                y: datum.y,
                width: datum.width,
                height: datum.height,
                clipBBox: datum.clipBBox,
                opacity: (_datum_opacity = datum.opacity) !== null && _datum_opacity !== void 0 ? _datum_opacity : 1
            };
        }
    };
    const applyFn = (rect, datum, status)=>{
        var _rect_datum;
        rect.setProperties(datum);
        var _rect_datum_crisp;
        rect.crisp = status === "end" && ((_rect_datum_crisp = (_rect_datum = rect.datum) === null || _rect_datum === void 0 ? void 0 : _rect_datum.crisp) !== null && _rect_datum_crisp !== void 0 ? _rect_datum_crisp : false);
    };
    return {
        toFn,
        fromFn,
        applyFn
    };
}
function getStartingValues(isVertical, axes) {
    const axis = axes[isVertical ? "y" /* Y */  : "x" /* X */ ];
    let startingX = Infinity;
    let startingY = 0;
    if (!axis) {
        return {
            startingX,
            startingY
        };
    }
    if (isVertical) {
        startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));
    } else {
        startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));
    }
    return {
        startingX,
        startingY
    };
}
function resetBarSelectionsFn(rect, param) {
    let { x, y, width: width2, height: height2, clipBBox, opacity = 1 } = param;
    var _rect_datum;
    var _rect_datum_crisp;
    return {
        x,
        y,
        width: width2,
        height: height2,
        clipBBox,
        opacity,
        crisp: (_rect_datum_crisp = (_rect_datum = rect.datum) === null || _rect_datum === void 0 ? void 0 : _rect_datum.crisp) !== null && _rect_datum_crisp !== void 0 ? _rect_datum_crisp : false
    };
}
function computeBarFocusBounds(series, datum) {
    if (datum === void 0) return void 0;
    const { x, y, width: width2, height: height2 } = datum;
    return Transformable.toCanvas(series.contentGroup, new BBox(x, y, width2, height2));
}
// packages/ag-charts-community/src/chart/series/cartesian/diffUtil.ts
function calculateDataDiff(seriesId, datumSelection, getDatumId, contextNodeData, previousContextNodeData, processedData) {
    var _processedData_reduced_diff, _processedData_reduced, _processedData_reduced1;
    let dataDiff = processedData === null || processedData === void 0 ? void 0 : (_processedData_reduced = processedData.reduced) === null || _processedData_reduced === void 0 ? void 0 : (_processedData_reduced_diff = _processedData_reduced.diff) === null || _processedData_reduced_diff === void 0 ? void 0 : _processedData_reduced_diff[seriesId];
    if (dataDiff === null || dataDiff === void 0 ? void 0 : dataDiff.changed) {
        return dataDiff;
    }
    const scalingChanged = hasScalingChanged(contextNodeData, previousContextNodeData);
    if (dataDiff == null && (processedData === null || processedData === void 0 ? void 0 : (_processedData_reduced1 = processedData.reduced) === null || _processedData_reduced1 === void 0 ? void 0 : _processedData_reduced1.diff) != null) {
        dataDiff = {
            changed: true,
            added: /* @__PURE__ */ new Set(),
            updated: /* @__PURE__ */ new Set(),
            removed: /* @__PURE__ */ new Set(),
            moved: /* @__PURE__ */ new Set()
        };
        if (scalingChanged) {
            dataDiff.updated = new Set(Array.from(datumSelection, (param)=>{
                let { datum } = param;
                return getDatumId(datum);
            }));
        } else {
            dataDiff.added = new Set(Array.from(datumSelection, (param)=>{
                let { datum } = param;
                return getDatumId(datum);
            }));
        }
    } else if (scalingChanged) {
        dataDiff = {
            changed: true,
            added: /* @__PURE__ */ new Set(),
            updated: new Set(Array.from(datumSelection, (param)=>{
                let { datum } = param;
                return getDatumId(datum);
            })),
            removed: /* @__PURE__ */ new Set(),
            moved: /* @__PURE__ */ new Set()
        };
    }
    return dataDiff;
}
function isGroupScaleContext(ctx) {
    return typeof ctx === "object" && ctx !== null && "groupScale" in ctx;
}
function hasScalingChanged(contextNodeData, previousContextNodeData) {
    if (!previousContextNodeData) return false;
    const scales = contextNodeData.scales;
    const prevScales = previousContextNodeData.scales;
    if (!areScalingEqual(scales.x, prevScales.x)) return true;
    if (!areScalingEqual(scales.y, prevScales.y)) return true;
    if (!isGroupScaleContext(contextNodeData) || !isGroupScaleContext(previousContextNodeData)) return false;
    const groupScale = contextNodeData.groupScale;
    const prevGroupScale = previousContextNodeData.groupScale;
    return !areScalingEqual(groupScale, prevGroupScale);
}
// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts
var memoizedAggregateBarData = simpleMemorize2(aggregateBarData);
var BarSeries = class extends AbstractBarSeries {
    get pickModeAxis() {
        return this.properties.sparklineMode ? "main" : void 0;
    }
    crossFilteringEnabled() {
        return this.properties.yFilterKey != null && (this.seriesGrouping == null || this.seriesGrouping.stackIndex === 0);
    }
    async processData(dataController) {
        var _this_seriesGrouping, _this_getCategoryAxis, _this_getValueAxis, _processedData_reduced, _processedData_reduced1;
        if (!this.data) return;
        const { xKey, yKey, yFilterKey, normalizedTo } = this.properties;
        const { seriesGrouping: { groupIndex = this.id } = {}, data } = this;
        var _this_seriesGrouping_stackCount;
        const stackCount = (_this_seriesGrouping_stackCount = (_this_seriesGrouping = this.seriesGrouping) === null || _this_seriesGrouping === void 0 ? void 0 : _this_seriesGrouping.stackCount) !== null && _this_seriesGrouping_stackCount !== void 0 ? _this_seriesGrouping_stackCount : 0;
        const stacked = stackCount > 1 || normalizedTo != null;
        const grouped = stacked;
        const animationEnabled = !this.ctx.animationManager.isSkipped();
        const xScale = (_this_getCategoryAxis = this.getCategoryAxis()) === null || _this_getCategoryAxis === void 0 ? void 0 : _this_getCategoryAxis.scale;
        const yScale = (_this_getValueAxis = this.getValueAxis()) === null || _this_getValueAxis === void 0 ? void 0 : _this_getValueAxis.scale;
        const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({
            xScale,
            yScale
        });
        const stackGroupName = "bar-stack-".concat(groupIndex, "-yValues");
        const stackGroupTrailingName = "".concat(stackGroupName, "-trailing");
        const visibleProps = this.visible ? {} : {
            forceValue: 0
        };
        const props = [
            keyProperty(xKey, xScaleType, {
                id: "xValue"
            }),
            valueProperty(yKey, yScaleType, {
                id: "yValue-raw",
                invalidValue: null,
                ...visibleProps
            })
        ];
        if (this.crossFilteringEnabled()) {
            props.push(valueProperty(yFilterKey, yScaleType, {
                id: "yFilterValue",
                invalidValue: null,
                ...visibleProps
            }));
        }
        if (stacked) {
            props.push(...groupAccumulativeValueProperty(yKey, "normal", "current", {
                id: "yValue-end",
                rangeId: "yValue-range",
                invalidValue: null,
                missingValue: 0,
                groupId: stackGroupName,
                separateNegative: true,
                ...visibleProps
            }, yScaleType), ...groupAccumulativeValueProperty(yKey, "trailing", "current", {
                id: "yValue-start",
                invalidValue: null,
                missingValue: 0,
                groupId: stackGroupTrailingName,
                separateNegative: true,
                ...visibleProps
            }, yScaleType));
        }
        if (isContinuousX) {
            props.push(SMALLEST_KEY_INTERVAL, LARGEST_KEY_INTERVAL);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFiniteNumber"])(normalizedTo)) {
            props.push(normaliseGroupTo([
                stackGroupName,
                stackGroupTrailingName
            ], Math.abs(normalizedTo)));
        }
        if (animationEnabled && this.processedData) {
            props.push(diff(this.id, this.processedData));
        }
        if (animationEnabled || !grouped) {
            props.push(animationValidation());
        }
        const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
            props,
            groupByKeys: grouped,
            groupByData: !grouped
        });
        this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
        this.smallestDataInterval = (_processedData_reduced = processedData.reduced) === null || _processedData_reduced === void 0 ? void 0 : _processedData_reduced.smallestKeyInterval;
        this.largestDataInterval = (_processedData_reduced1 = processedData.reduced) === null || _processedData_reduced1 === void 0 ? void 0 : _processedData_reduced1.largestKeyInterval;
        this.animationState.transition("updateData");
    }
    getSeriesDomain(direction) {
        var _this_dataModel;
        const { processedData, dataModel } = this;
        if (dataModel == null || processedData == null) return [];
        if (direction === this.getCategoryDirection()) {
            const keyDef = dataModel.resolveProcessedDataDefById(this, "xValue");
            const keys = dataModel.getDomain(this, "xValue", "key", processedData);
            if ((keyDef === null || keyDef === void 0 ? void 0 : keyDef.def.type) === "key" && keyDef.def.valueType === "category") {
                return keys;
            }
            return this.padBandExtent(keys);
        }
        const yKey = ((_this_dataModel = this.dataModel) === null || _this_dataModel === void 0 ? void 0 : _this_dataModel.hasColumnById(this, "yValue-end")) ? "yValue-end" : "yValue-raw";
        let yExtent = this.domainForClippedRange(direction, [
            yKey
        ], "xValue");
        const yFilterExtent = this.crossFilteringEnabled() ? dataModel.getDomain(this, "yFilterValue", "value", processedData) : void 0;
        if (yFilterExtent != null) {
            yExtent = [
                Math.min(yExtent[0], yFilterExtent[0]),
                Math.max(yExtent[1], yFilterExtent[1])
            ];
        }
        if (this.getValueAxis() instanceof LogAxis) {
            return fixNumericExtent(yExtent);
        } else {
            const fixedYExtent = Number.isFinite(yExtent[1] - yExtent[0]) ? [
                Math.min(0, yExtent[0]),
                Math.max(0, yExtent[1])
            ] : [];
            return fixNumericExtent(fixedYExtent);
        }
    }
    getSeriesRange(_direction, visibleRange) {
        var _this_dataModel;
        const yKey = ((_this_dataModel = this.dataModel) === null || _this_dataModel === void 0 ? void 0 : _this_dataModel.hasColumnById(this, "yValue-end")) ? "yValue-end" : "yValue-raw";
        const [y0, y1] = this.domainForVisibleRange("y" /* Y */ , [
            yKey
        ], "xValue", visibleRange);
        return [
            Math.min(y0, 0),
            Math.max(y1, 0)
        ];
    }
    getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
        var _this_dataModel;
        const yKey = ((_this_dataModel = this.dataModel) === null || _this_dataModel === void 0 ? void 0 : _this_dataModel.hasColumnById(this, "yValue-end")) ? "yValue-end" : "yValue-raw";
        return this.countVisibleItems("xValue", [
            yKey
        ], xVisibleRange, yVisibleRange, minVisibleItems);
    }
    aggregateData(dataModel, processedData) {
        if (processedData.type !== "ungrouped") return;
        if (processedDataIsAnimatable(processedData)) return;
        const xAxis = this.axes["x" /* X */ ];
        if (xAxis == null) return;
        const xValues = dataModel.resolveKeysById(this, "xValue", processedData);
        const yValues = dataModel.resolveColumnById(this, "yValue-raw", processedData);
        const { index } = dataModel.resolveProcessedDataDefById(this, "xValue");
        const domain = processedData.domain.keys[index];
        return memoizedAggregateBarData(xAxis.scale.type, xValues, yValues, domain);
    }
    createNodeData() {
        var _this = this;
        var _processedData_dataSources;
        const { dataModel, processedData, groupScale, dataAggregationFilters } = this;
        const xAxis = this.getCategoryAxis();
        const yAxis = this.getValueAxis();
        if (!dataModel || !processedData || !xAxis || !yAxis) return;
        const rawData = (_processedData_dataSources = processedData.dataSources) === null || _processedData_dataSources === void 0 ? void 0 : _processedData_dataSources.get(this.id);
        if (rawData == null) return;
        const xScale = xAxis.scale;
        const yScale = yAxis.scale;
        const { xKey, yKey, xName, yName, legendItemName, label } = this.properties;
        const yDomain = this.getSeriesDomain("y" /* Y */ );
        const yReversed = yAxis.isReversed();
        const { barWidth, groupIndex: groupScaleIndex } = this.updateGroupScale(xAxis);
        const groupOffset = groupScale.convert(String(groupScaleIndex));
        const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;
        const xValues = dataModel.resolveKeysById(this, "xValue", processedData);
        const yRawValues = dataModel.resolveColumnById(this, "yValue-raw", processedData);
        const yFilterValues = this.crossFilteringEnabled() ? dataModel.resolveColumnById(this, "yFilterValue", processedData) : void 0;
        const animationEnabled = !this.ctx.animationManager.isSkipped();
        const xPosition = (index)=>xScale.convert(xValues[index]) + groupOffset + barOffset;
        var _this_properties_crisp;
        const crisp = (_this_properties_crisp = this.properties.crisp) !== null && _this_properties_crisp !== void 0 ? _this_properties_crisp : checkCrisp(xAxis === null || xAxis === void 0 ? void 0 : xAxis.scale, xAxis === null || xAxis === void 0 ? void 0 : xAxis.visibleRange, this.smallestDataInterval, this.largestDataInterval);
        const bboxBottom = yScale.convert(0);
        const nodeDatum = (param)=>{
            let { datum, datumIndex, xValue, yValue, cumulativeValue, phantom, currY, prevY, x, width: width2, isPositive, yRange, labelText, opacity, featherRatio, crossScale = 1 } = param;
            const isUpward = isPositive !== yReversed;
            const y = yScale.convert(currY);
            const bottomY = yScale.convert(prevY);
            const bboxHeight = yScale.convert(yRange);
            const barAlongX = this.getBarDirection() === "x" /* X */ ;
            const xOffset = width2 * 0.5 * (1 - crossScale);
            const rect = {
                x: barAlongX ? Math.min(y, bottomY) : x + xOffset,
                y: barAlongX ? x + xOffset : Math.min(y, bottomY),
                width: barAlongX ? Math.abs(bottomY - y) : width2 * crossScale,
                height: barAlongX ? width2 * crossScale : Math.abs(bottomY - y)
            };
            const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);
            const barRect = {
                x: barAlongX ? Math.min(bboxBottom, bboxHeight) : x + xOffset,
                y: barAlongX ? x + xOffset : Math.min(bboxBottom, bboxHeight),
                width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : width2 * crossScale,
                height: barAlongX ? width2 * crossScale : Math.abs(bboxBottom - bboxHeight)
            };
            const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;
            const spacing = label.spacing + (typeof label.padding === "number" ? label.padding : 0);
            return {
                series: this,
                itemId: phantom ? createDatumId(yKey, phantom) : yKey,
                datum,
                datumIndex,
                cumulativeValue,
                phantom,
                xValue,
                yValue,
                yKey,
                xKey,
                capDefaults: {
                    lengthRatioMultiplier,
                    lengthMax: lengthRatioMultiplier
                },
                x: barRect.x,
                y: barRect.y,
                width: barRect.width,
                height: barRect.height,
                midPoint: {
                    x: rect.x + rect.width / 2,
                    y: rect.y + rect.height / 2
                },
                opacity,
                featherRatio,
                topLeftCornerRadius: barAlongX !== isUpward,
                topRightCornerRadius: isUpward,
                bottomRightCornerRadius: barAlongX === isUpward,
                bottomLeftCornerRadius: !isUpward,
                clipBBox,
                crisp,
                label: labelText != null ? {
                    text: labelText,
                    ...adjustLabelPlacement({
                        isUpward,
                        isVertical: !barAlongX,
                        placement: label.placement,
                        spacing,
                        rect
                    })
                } : void 0,
                missing: yValue == null,
                focusable: !phantom
            };
        };
        const phantomNodes = [];
        const nodes = [];
        const labels = [];
        const handleDatum = function(datumIndex, x, width2, yStart, yEnd, yRange) {
            let featherRatio = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0, opacity = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 1;
            const xValue = xValues[datumIndex];
            if (xValue == null) return;
            const datum = rawData[datumIndex];
            const yRawValue = yRawValues[datumIndex];
            const yFilterValue = yFilterValues != null ? Number(yFilterValues[datumIndex]) : void 0;
            const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);
            if (!Number.isFinite(yEnd)) return;
            if (yFilterValue != null && !Number.isFinite(yFilterValue)) return;
            const labelText = label.enabled && yRawValue != null ? _this.getLabelText(yFilterValue !== null && yFilterValue !== void 0 ? yFilterValue : yRawValue, datum, yKey, "y", yDomain, label, {
                datum,
                value: yFilterValue !== null && yFilterValue !== void 0 ? yFilterValue : yRawValue,
                xKey,
                yKey,
                xName,
                yName,
                legendItemName
            }) : void 0;
            const inset = yFilterValue != null && yFilterValue > yRawValue;
            const nodeData = nodeDatum({
                datum,
                datumIndex,
                xValue,
                yValue: yFilterValue !== null && yFilterValue !== void 0 ? yFilterValue : yRawValue,
                cumulativeValue: yFilterValue !== null && yFilterValue !== void 0 ? yFilterValue : yEnd,
                phantom: false,
                currY: yFilterValue != null ? yStart + yFilterValue : yEnd,
                prevY: yStart,
                x,
                width: width2,
                isPositive,
                yRange: Math.max(yStart + (yFilterValue !== null && yFilterValue !== void 0 ? yFilterValue : -Infinity), yRange),
                labelText,
                opacity,
                featherRatio,
                crossScale: inset ? 0.6 : void 0
            });
            nodes.push(nodeData);
            labels.push(nodeData);
            if (yFilterValue != null) {
                const phantomNodeData = nodeDatum({
                    datum: rawData[datumIndex],
                    datumIndex,
                    xValue,
                    yValue: yFilterValue,
                    cumulativeValue: yFilterValue,
                    phantom: true,
                    currY: yEnd,
                    prevY: yStart,
                    x,
                    width: width2,
                    isPositive,
                    yRange,
                    labelText: void 0,
                    opacity,
                    featherRatio,
                    crossScale: void 0
                });
                phantomNodes.push(phantomNodeData);
            }
        };
        const [r0, r1] = xScale.range;
        const range3 = Math.abs(r1 - r0);
        const dataAggregationFilter = dataAggregationFilters === null || dataAggregationFilters === void 0 ? void 0 : dataAggregationFilters.find((f)=>f.maxRange > range3);
        if (processedData.type === "grouped") {
            const width2 = barWidth;
            const stacked = dataModel.hasColumnById(this, "yValue-start");
            const yStartValues = stacked ? dataModel.resolveColumnById(this, "yValue-start", processedData) : void 0;
            const yEndValues = stacked ? dataModel.resolveColumnById(this, "yValue-end", processedData) : void 0;
            const yRangeIndex = stacked ? dataModel.resolveProcessedDataIndexById(this, "yValue-range") : -1;
            for (const { datumIndex, group: { aggregation } } of dataModel.forEachGroupDatum(this, processedData)){
                const x = xPosition(datumIndex);
                const yRawValue = yRawValues[datumIndex];
                const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);
                const yStart = stacked ? Number(yStartValues === null || yStartValues === void 0 ? void 0 : yStartValues[datumIndex]) : 0;
                const yEnd = stacked ? Number(yEndValues === null || yEndValues === void 0 ? void 0 : yEndValues[datumIndex]) : yRawValue;
                let yRange = yEnd;
                if (stacked) {
                    yRange = aggregation[yRangeIndex][isPositive ? 1 : 0];
                }
                handleDatum(datumIndex, x, width2, yStart, yEnd, yRange);
            }
        } else if (dataAggregationFilter == null) {
            var _processedData_invalidData;
            const invalidData = (_processedData_invalidData = processedData.invalidData) === null || _processedData_invalidData === void 0 ? void 0 : _processedData_invalidData.get(this.id);
            const width2 = barWidth;
            let [start2, end2] = this.visibleRangeIndices("xValue", xAxis.range);
            if (processedData.input.count < 1e3) {
                start2 = 0;
                end2 = processedData.input.count;
            }
            for(let datumIndex = start2; datumIndex < end2; datumIndex += 1){
                if ((invalidData === null || invalidData === void 0 ? void 0 : invalidData[datumIndex]) === true) continue;
                const x = xPosition(datumIndex);
                const yEnd = Number(yRawValues[datumIndex]);
                handleDatum(datumIndex, x, width2, 0, yEnd, yEnd);
            }
        } else {
            const { indexData, indices } = dataAggregationFilter;
            const [start2, end2] = this.visibleRangeIndices("xValue", xAxis.range, indices);
            const sign = yReversed ? -1 : 1;
            for(let i = start2; i < end2; i += 1){
                const aggIndex = i * BAR_SPAN;
                const xMinIndex = indexData[aggIndex + BAR_X_MIN];
                const xMaxIndex = indexData[aggIndex + BAR_X_MAX];
                const yMinIndex = indexData[aggIndex + BAR_Y_MIN];
                const yMaxIndex = indexData[aggIndex + BAR_Y_MAX];
                if (xMinIndex === -1) continue;
                const x = xPosition((xMinIndex + xMaxIndex) / 2 | 0);
                const width2 = Math.abs(xPosition(xMaxIndex) - xPosition(xMinIndex)) + barWidth;
                const bandCount = Math.abs(xMaxIndex - xMinIndex);
                const opacity = BandScale.is(xScale) ? xScale.bandwidth * Math.max(bandCount - 1, 1) / (xScale.step * bandCount) : 1;
                const yEndMax = xValues[yMaxIndex] != null ? Number(yRawValues[yMaxIndex]) : NaN;
                const yEndMin = xValues[yMinIndex] != null ? Number(yRawValues[yMinIndex]) : NaN;
                if (yEndMax > 0) {
                    const featherRatio = yEndMin >= 0 ? sign * (1 - yEndMin / yEndMax) : sign;
                    handleDatum(yMaxIndex, x, width2, 0, yEndMax, yEndMax, featherRatio, opacity);
                }
                if (yEndMin < 0) {
                    const featherRatio = yEndMax <= 0 ? -sign * (1 - yEndMax / yEndMin) : -sign;
                    handleDatum(yMinIndex, x, width2, 0, yEndMin, yEndMin, featherRatio, opacity);
                }
            }
        }
        return {
            itemId: yKey,
            nodeData: phantomNodes.length > 0 ? [
                ...phantomNodes,
                ...nodes
            ] : nodes,
            labelData: labels,
            scales: this.calculateScaling(),
            visible: this.visible || animationEnabled,
            groupScale: this.getScaling(this.groupScale)
        };
    }
    nodeFactory() {
        return new BarShape();
    }
    getHighlightData(nodeData, highlightedItem) {
        const highlightItem = nodeData.find((nodeDatum)=>nodeDatum.datum === highlightedItem.datum && !nodeDatum.phantom);
        return highlightItem != null ? [
            highlightItem
        ] : void 0;
    }
    updateDatumSelection(opts) {
        return opts.datumSelection.update(opts.nodeData, void 0, (datum)=>this.getDatumId(datum));
    }
    getItemStyle(nodeDatum, isHighlight) {
        const { id: seriesId, properties } = this;
        const { xKey, yKey, itemStyler, fillGradientDefaults: fillGradientDefaults2, fillPatternDefaults: fillPatternDefaults2, fillImageDefaults: fillImageDefaults2 } = properties;
        const { xValue, yValue, datum, datumIndex } = nodeDatum;
        const highlightStyle = this.getHighlightStyle(isHighlight, datumIndex);
        let style = getShapeStyle(mergeDefaults(highlightStyle, properties.getStyle()), fillGradientDefaults2, fillPatternDefaults2, fillImageDefaults2);
        if (itemStyler && nodeDatum != null) {
            const { xDomain, yDomain } = this.cachedDatumCallback("domain", ()=>({
                    xDomain: this.getSeriesDomain("x" /* X */ ),
                    yDomain: this.getSeriesDomain("y" /* Y */ )
                }));
            const overrides = this.cachedDatumCallback(createDatumId(this.getDatumId(nodeDatum), isHighlight ? "highlight" : "node"), ()=>{
                var _this_ctx_highlightManager;
                const activeHighlight = (_this_ctx_highlightManager = this.ctx.highlightManager) === null || _this_ctx_highlightManager === void 0 ? void 0 : _this_ctx_highlightManager.getActiveHighlight();
                const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datumIndex);
                return this.callWithContext(itemStyler, {
                    seriesId,
                    ...datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain),
                    datum,
                    xValue,
                    yValue,
                    highlighted: isHighlight,
                    highlightState,
                    ...style
                });
            });
            if (overrides) {
                style = getShapeStyle(mergeDefaults(overrides, style), fillGradientDefaults2, fillPatternDefaults2, fillImageDefaults2);
            }
        }
        return style;
    }
    updateDatumNodes(opts) {
        const { shadow } = this.properties;
        const categoryAlongX = this.getCategoryDirection() === "x" /* X */ ;
        const fillBBox = this.getShapeFillBBox();
        const direction = this.getBarDirection();
        opts.datumSelection.each((rect, datum)=>{
            var _datum_clipBBox, _datum_clipBBox1;
            const style = this.getItemStyle(datum, opts.isHighlight);
            applyShapeStyle(rect, style, fillBBox);
            var _style_cornerRadius;
            const cornerRadius = (_style_cornerRadius = style.cornerRadius) !== null && _style_cornerRadius !== void 0 ? _style_cornerRadius : 0;
            rect.topLeftCornerRadius = datum.topLeftCornerRadius ? cornerRadius : 0;
            rect.topRightCornerRadius = datum.topRightCornerRadius ? cornerRadius : 0;
            rect.bottomRightCornerRadius = datum.bottomRightCornerRadius ? cornerRadius : 0;
            rect.bottomLeftCornerRadius = datum.bottomLeftCornerRadius ? cornerRadius : 0;
            var _datum_clipBBox_width, _datum_clipBBox_height;
            rect.visible = categoryAlongX ? ((_datum_clipBBox_width = (_datum_clipBBox = datum.clipBBox) === null || _datum_clipBBox === void 0 ? void 0 : _datum_clipBBox.width) !== null && _datum_clipBBox_width !== void 0 ? _datum_clipBBox_width : datum.width) > 0 : ((_datum_clipBBox_height = (_datum_clipBBox1 = datum.clipBBox) === null || _datum_clipBBox1 === void 0 ? void 0 : _datum_clipBBox1.height) !== null && _datum_clipBBox_height !== void 0 ? _datum_clipBBox_height : datum.height) > 0;
            rect.direction = direction;
            rect.featherRatio = datum.featherRatio;
            rect.crisp = datum.crisp;
            rect.fillShadow = shadow;
        });
    }
    updateLabelSelection(opts) {
        const data = this.isLabelEnabled() ? opts.labelData : [];
        return opts.labelSelection.update(data, (text)=>{
            text.pointerEvents = 1 /* None */ ;
        });
    }
    updateLabelNodes(opts) {
        const { isHighlight = false } = opts;
        var _this_properties_xName, _this_properties_yName, _this_properties_legendItemName, _ref;
        const params = {
            xKey: this.properties.xKey,
            xName: (_this_properties_xName = this.properties.xName) !== null && _this_properties_xName !== void 0 ? _this_properties_xName : this.properties.xKey,
            yKey: this.properties.yKey,
            yName: (_this_properties_yName = this.properties.yName) !== null && _this_properties_yName !== void 0 ? _this_properties_yName : this.properties.yKey,
            legendItemName: (_ref = (_this_properties_legendItemName = this.properties.legendItemName) !== null && _this_properties_legendItemName !== void 0 ? _this_properties_legendItemName : this.properties.xName) !== null && _ref !== void 0 ? _ref : this.properties.xKey
        };
        opts.labelSelection.each((textNode, datum)=>{
            var _this_ctx_highlightManager;
            var _this_getHighlightStyle_opacity;
            textNode.fillOpacity = (_this_getHighlightStyle_opacity = this.getHighlightStyle(isHighlight, datum === null || datum === void 0 ? void 0 : datum.datumIndex).opacity) !== null && _this_getHighlightStyle_opacity !== void 0 ? _this_getHighlightStyle_opacity : 1;
            const activeHighlight = (_this_ctx_highlightManager = this.ctx.highlightManager) === null || _this_ctx_highlightManager === void 0 ? void 0 : _this_ctx_highlightManager.getActiveHighlight();
            const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datum.datumIndex);
            updateLabelNode(this, textNode, params, this.properties.label, datum.label, isHighlight, highlightState);
        });
    }
    getTooltipContent(datumIndex) {
        var _this_contextNodeData_nodeData, _this_contextNodeData, _processedData_dataSources_get;
        const { id: seriesId, dataModel, processedData, properties } = this;
        const { xKey, xName, yKey, yName, legendItemName, stackGroup, tooltip } = properties;
        const xAxis = this.getCategoryAxis();
        const yAxis = this.getValueAxis();
        const nodeDatum = (_this_contextNodeData = this.contextNodeData) === null || _this_contextNodeData === void 0 ? void 0 : (_this_contextNodeData_nodeData = _this_contextNodeData.nodeData) === null || _this_contextNodeData_nodeData === void 0 ? void 0 : _this_contextNodeData_nodeData[datumIndex];
        if (!dataModel || !processedData || !xAxis || !yAxis || !nodeDatum) {
            return;
        }
        const datum = (_processedData_dataSources_get = processedData.dataSources.get(this.id)) === null || _processedData_dataSources_get === void 0 ? void 0 : _processedData_dataSources_get[datumIndex];
        const xValue = dataModel.resolveKeysById(this, "xValue", processedData)[datumIndex];
        const yValue = dataModel.resolveColumnById(this, "yValue-raw", processedData)[datumIndex];
        if (xValue == null) return;
        const format = this.getItemStyle(nodeDatum, false);
        return this.formatTooltipWithContext(tooltip, {
            heading: this.getAxisValueText(xAxis, "tooltip", xValue, datum, xKey, legendItemName),
            symbol: this.legendItemSymbol(),
            data: [
                {
                    label: yName,
                    fallbackLabel: yKey,
                    value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
                }
            ]
        }, {
            seriesId,
            datum,
            title: yName,
            xKey,
            xName,
            yKey,
            yName,
            legendItemName,
            stackGroup,
            ...format,
            ...this.getModuleTooltipParams()
        });
    }
    legendItemSymbol() {
        const { fill, stroke: stroke2, strokeWidth, fillOpacity, strokeOpacity, lineDash, lineDashOffset, fillGradientDefaults: fillGradientDefaults2, fillPatternDefaults: fillPatternDefaults2, fillImageDefaults: fillImageDefaults2 } = this.properties;
        return {
            marker: getShapeStyle({
                fill: fill !== null && fill !== void 0 ? fill : "rgba(0, 0, 0, 0)",
                stroke: stroke2 !== null && stroke2 !== void 0 ? stroke2 : "rgba(0, 0, 0, 0)",
                fillOpacity,
                strokeOpacity,
                strokeWidth,
                lineDash,
                lineDashOffset
            }, fillGradientDefaults2, fillPatternDefaults2, fillImageDefaults2)
        };
    }
    getLegendData(legendType) {
        const { showInLegend } = this.properties;
        if (legendType !== "category") {
            return [];
        }
        const { id: seriesId, ctx: { legendManager }, visible } = this;
        const { yKey: itemId, yName, legendItemName } = this.properties;
        var _ref;
        return [
            {
                legendType: "category",
                id: seriesId,
                itemId,
                seriesId,
                enabled: visible && legendManager.getItemEnabled({
                    seriesId,
                    itemId
                }),
                label: {
                    text: (_ref = legendItemName !== null && legendItemName !== void 0 ? legendItemName : yName) !== null && _ref !== void 0 ? _ref : itemId
                },
                symbol: this.legendItemSymbol(),
                legendItemName,
                hideInLegend: !showInLegend
            }
        ];
    }
    animateEmptyUpdateReady(param) {
        let { datumSelection, labelSelection, annotationSelections } = param;
        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, "normal"));
        fromToMotion(this.id, "nodes", this.ctx.animationManager, [
            datumSelection
        ], fns);
        seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
        seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
    }
    animateWaitingUpdateReady(data) {
        const { datumSelection, labelSelection, annotationSelections, contextData, previousContextData } = data;
        this.ctx.animationManager.stopByAnimationGroupId(this.id);
        const dataDiff = calculateDataDiff(this.id, datumSelection, this.getDatumId.bind(this), data.contextData, previousContextData, this.processedData);
        const mode = previousContextData == null ? "fade" : "normal";
        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));
        fromToMotion(this.id, "nodes", this.ctx.animationManager, [
            datumSelection
        ], fns, (_, datum)=>this.getDatumId(datum), dataDiff);
        if ((dataDiff === null || dataDiff === void 0 ? void 0 : dataDiff.changed) || !areScalingEqual(contextData.groupScale, previousContextData === null || previousContextData === void 0 ? void 0 : previousContextData.groupScale)) {
            seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
            seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
        }
    }
    getDatumId(datum) {
        return createDatumId(datum.xValue, datum.phantom);
    }
    isLabelEnabled() {
        return this.properties.label.enabled;
    }
    computeFocusBounds(param) {
        let { datumIndex } = param;
        var _this_contextNodeData;
        const datumBox = (_this_contextNodeData = this.contextNodeData) === null || _this_contextNodeData === void 0 ? void 0 : _this_contextNodeData.nodeData[datumIndex].clipBBox;
        return computeBarFocusBounds(this, datumBox);
    }
    hasItemStylers() {
        return this.properties.itemStyler != null || this.properties.label.itemStyler != null;
    }
    constructor(moduleCtx){
        super({
            moduleCtx,
            propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
            propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
            categoryKey: "xValue",
            pickModes: [
                2 /* AXIS_ALIGNED */ ,
                // Only used in sparklineMode
                1 /* NEAREST_NODE */ ,
                0 /* EXACT_SHAPE_MATCH */ 
            ],
            pathsPerSeries: [],
            datumSelectionGarbageCollection: false,
            animationAlwaysUpdateSelections: true,
            animationResetFns: {
                datum: resetBarSelectionsFn,
                label: resetLabelFn
            }
        });
        this.properties = new BarSeriesProperties();
        this.connectsToYAxis = true;
        this.dataAggregationFilters = void 0;
    }
};
BarSeries.className = "BarSeries";
BarSeries.type = "bar";
// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts
var BarSeriesModule = {
    type: "series",
    optionsKey: "series[]",
    packageType: "community",
    chartTypes: [
        "cartesian"
    ],
    identifier: "bar",
    moduleFactory: (ctx)=>new BarSeries(ctx),
    stackable: true,
    groupable: true,
    defaultAxes: DIRECTION_SWAP_AXES,
    themeTemplate: {
        series: {
            direction: "vertical",
            fill: {
                $palette: "fill"
            },
            stroke: {
                $palette: "stroke"
            },
            // @ts-expect-error undocumented option
            fillGradientDefaults: FILL_GRADIENT_LINEAR_DEFAULTS,
            fillPatternDefaults: FILL_PATTERN_DEFAULTS,
            fillImageDefaults: FILL_IMAGE_DEFAULTS,
            fillOpacity: 1,
            strokeWidth: {
                $isUserOption: [
                    "./stroke",
                    2,
                    0
                ]
            },
            lineDash: [
                0
            ],
            lineDashOffset: 0,
            label: {
                ...LABEL_BOXING_DEFAULTS,
                padding: {
                    $isUserOption: [
                        "./spacing",
                        0,
                        8
                    ]
                },
                // compatibility with old `padding` property (now named `spacing`).
                enabled: false,
                fontWeight: {
                    $ref: "fontWeight"
                },
                fontSize: {
                    $ref: "fontSize"
                },
                fontFamily: {
                    $ref: "fontFamily"
                },
                color: {
                    $if: [
                        {
                            $or: [
                                {
                                    $eq: [
                                        {
                                            $path: "./placement"
                                        },
                                        "outside-start"
                                    ]
                                },
                                {
                                    $eq: [
                                        {
                                            $path: "./placement"
                                        },
                                        "outside-end"
                                    ]
                                }
                            ]
                        },
                        {
                            $ref: "textColor"
                        },
                        {
                            $ref: "chartBackgroundColor"
                        }
                    ]
                },
                placement: "inside-center"
            },
            shadow: {
                enabled: false,
                color: DEFAULT_SHADOW_COLOUR,
                xOffset: 3,
                yOffset: 3,
                blur: 5
            },
            errorBar: {
                cap: {
                    lengthRatio: 0.3
                }
            },
            highlight: multiSeriesHighlightStyle()
        }
    }
};
var NewBarSeriesModule = {
    type: "series",
    name: "bar",
    chartType: "cartesian",
    options: barSeriesOptionsDef,
    create: (ctx)=>new BarSeries(ctx)
};
;
var SIZE_QUANTIZATION = 3;
var FILTER_DATUM_THRESHOLD = 5;
function getPrimaryDatumIndex(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1) {
    let currentIndex = 0;
    let currentDistanceSquared = Infinity;
    const midX = (x0 + x1) / 2;
    const midY = (y0 + y1) / 2;
    for (const datumIndex of indices){
        const xValue = xValues[datumIndex];
        const yValue = yValues[datumIndex];
        if (xValue == null || yValue == null) continue;
        const xRatio = aggregationXRatioForXValue(xValue, xd0, xd1);
        const yRatio = aggregationXRatioForXValue(yValue, yd0, yd1);
        const distanceSquared2 = (xRatio - midX) ** 2 + (yRatio - midY) ** 2;
        if (distanceSquared2 < currentDistanceSquared) {
            currentDistanceSquared = distanceSquared2;
            currentIndex = datumIndex;
        }
    }
    return currentIndex;
}
function countVisibleItems(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1) {
    let count = 0;
    for (const datumIndex of indices){
        const xValue = xValues[datumIndex];
        const yValue = yValues[datumIndex];
        if (xValue == null || yValue == null) continue;
        const xRatio = aggregationXRatioForXValue(xValue, xd0, xd1);
        const yRatio = aggregationXRatioForXValue(yValue, yd0, yd1);
        if (xRatio >= x0 && xRatio <= x1 && yRatio >= y0 && yRatio <= y1) {
            count += 1;
        }
    }
    return count;
}
function aggregateQuad(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1) {
    if (indices.length < FILTER_DATUM_THRESHOLD) {
        return;
    } else if (x0 === x1 && y0 === y1) {
        const primaryDatumIndex2 = getPrimaryDatumIndex(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1);
        return {
            scale: 0,
            x0,
            y0,
            x1,
            y1,
            indices,
            primaryDatumIndex: primaryDatumIndex2,
            children: null
        };
    }
    const childBuckets = [
        {
            x0: 1,
            y0: 1,
            x1: 0,
            y1: 0,
            indices: []
        },
        {
            x0: 1,
            y0: 1,
            x1: 0,
            y1: 0,
            indices: []
        },
        {
            x0: 1,
            y0: 1,
            x1: 0,
            y1: 0,
            indices: []
        },
        {
            x0: 1,
            y0: 1,
            x1: 0,
            y1: 0,
            indices: []
        }
    ];
    const midX = (x0 + x1) / 2;
    const midY = (y0 + y1) / 2;
    for (const datumIndex of indices){
        const xValue = xValues[datumIndex];
        const yValue = yValues[datumIndex];
        if (xValue == null || yValue == null) continue;
        const xRatio = aggregationXRatioForXValue(xValue, xd0, xd1);
        const yRatio = aggregationXRatioForXValue(yValue, yd0, yd1);
        const childIndex = (xRatio > midX ? 1 : 0) + (yRatio > midY ? 2 : 0);
        const childBucket = childBuckets[childIndex];
        childBucket.indices.push(datumIndex);
        childBucket.x0 = Math.min(childBucket.x0, xRatio);
        childBucket.y0 = Math.min(childBucket.y0, yRatio);
        childBucket.x1 = Math.max(childBucket.x1, xRatio);
        childBucket.y1 = Math.max(childBucket.y1, yRatio);
    }
    let children = [];
    for (const childBucket of childBuckets){
        const { indices: childIndices, x0: cx0, x1: cx1, y0: cy0, y1: cy1 } = childBucket;
        const child = aggregateQuad(xValues, yValues, xd0, yd0, xd1, yd1, childIndices, cx0, cy0, cx1, cy1);
        if (child != null) children.push(child);
    }
    if (children.length === 1) {
        return children[0];
    } else if (children.length === 0) {
        children = null;
    }
    const scale2 = Math.hypot(x1 - x0, y1 - y0);
    const primaryDatumIndex = getPrimaryDatumIndex(xValues, yValues, xd0, yd0, xd1, yd1, indices, x0, y0, x1, y1);
    return {
        scale: scale2,
        x0,
        y0,
        x1,
        y1,
        indices,
        primaryDatumIndex,
        children
    };
}
function aggregateBubbleData(xScale, yScale, xValues, yValues, sizeValues, xDomain, yDomain, sizeDomain) {
    const [xd0, xd1] = aggregationDomain(xScale, xDomain);
    const [yd0, yd1] = aggregationDomain(yScale, yDomain);
    const [sd0, sd1] = sizeDomain;
    const filters = [];
    if (sizeValues != null && sd1 > sd0) {
        const sizeIndices = Array.from({
            length: SIZE_QUANTIZATION
        }, ()=>[]);
        for(let datumIndex = 0; datumIndex < sizeValues.length; datumIndex += 1){
            const sizeValue = sizeValues[datumIndex];
            const sizeRatio = (sizeValue - sd0) / (sd1 - sd0);
            const sizeIndex = sizeRatio * SIZE_QUANTIZATION | 0;
            if (sizeIndex >= 0 && sizeIndex < SIZE_QUANTIZATION) {
                sizeIndices[sizeIndex].push(datumIndex);
            }
        }
        for(let i = 0; i < sizeIndices.length; i += 1){
            const indices = sizeIndices[i];
            const node = aggregateQuad(xValues, yValues, xd0, yd0, xd1, yd1, indices, 0, 0, 1, 1);
            if (node != null) {
                const sizeRatio = i / SIZE_QUANTIZATION;
                filters.push({
                    sizeRatio,
                    node
                });
            }
        }
    } else {
        const indices = xValues.map((_, i)=>i);
        const node = aggregateQuad(xValues, yValues, xd0, yd0, xd1, yd1, indices, 0, 0, 1, 1);
        if (node != null) {
            filters.push({
                sizeRatio: 0,
                node
            });
        }
    }
    return filters.length > 0 ? {
        xValues,
        yValues,
        xd0,
        xd1,
        yd0,
        yd1,
        filters
    } : void 0;
}
function computeBubbleAggregationCountIndices(dilation, dataAggregation, options, counter, groupedAggregation, singleDatumIndices) {
    const { xRange, yRange, xVisibleRange: [xvr0, xvr1], yVisibleRange: [yvr0, yvr1], minSize, maxSize } = options;
    const { xValues, yValues, xd0, xd1, yd0, yd1 } = dataAggregation;
    const baseScalingFactor = 1 / Math.min(xRange / (xvr1 - xvr0), yRange / (yvr1 - yvr0));
    for (const { sizeRatio, node } of dataAggregation.filters){
        const radius = 0.5 * (minSize + sizeRatio * (maxSize - minSize));
        const baseMinScale = radius * baseScalingFactor;
        const minScale = dilation * baseMinScale;
        const x0 = xvr0 - radius / xRange;
        const x1 = xvr1 + radius / xRange;
        const y0 = yvr0 - radius / yRange;
        const y1 = yvr1 + radius / yRange;
        const queue = [
            node
        ];
        while(queue.length > 0){
            const item = queue.pop();
            if (item.x1 < x0 || item.x0 > x1 || item.y1 < y0 || item.y0 > y1) {
                continue;
            }
            if (item.scale <= minScale) {
                if (counter != null) {
                    counter.count += 1;
                }
                groupedAggregation === null || groupedAggregation === void 0 ? void 0 : groupedAggregation.push({
                    datumIndex: item.primaryDatumIndex,
                    count: item.indices.length,
                    dilation: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(1, item.scale / baseMinScale, dilation)
                });
            } else if (item.children == null) {
                const { indices } = item;
                if (counter != null) {
                    const fullyVisible = item.x0 >= xvr0 && item.x1 <= xvr1 && item.y0 >= yvr0 && item.y1 <= yvr1;
                    const itemCount = fullyVisible ? indices.length : countVisibleItems(xValues, yValues, xd0, yd0, xd1, yd1, indices, xvr0, yvr0, xvr1, yvr1);
                    counter.count += itemCount;
                }
                singleDatumIndices === null || singleDatumIndices === void 0 ? void 0 : singleDatumIndices.push(...indices);
            } else {
                queue.push(...item.children);
            }
        }
    }
}
function computeBubbleAggregationCount(dilation, dataAggregation, options) {
    const counter = {
        count: 0
    };
    computeBubbleAggregationCountIndices(dilation, dataAggregation, options, counter, void 0, void 0);
    return counter.count;
}
var MAX_AGGREGATION_DILATION = 100;
var DILATION_ITERATIONS = 12;
function computeBubbleAggregationDilation(dataAggregation, aggregationOptions, maxRenderedItems) {
    let minDilation = 1;
    let maxDilation = 2;
    while(computeBubbleAggregationCount(maxDilation, dataAggregation, aggregationOptions) > maxRenderedItems && maxDilation < MAX_AGGREGATION_DILATION){
        minDilation *= 2;
        maxDilation *= 2;
    }
    for(let i = 0; i < DILATION_ITERATIONS; i += 1){
        const dilation = (maxDilation + minDilation) / 2;
        const count = computeBubbleAggregationCount(dilation, dataAggregation, aggregationOptions);
        if (count > maxRenderedItems) {
            minDilation = dilation;
        } else {
            maxDilation = dilation;
        }
    }
    return minDilation;
}
function computeBubbleAggregationData(dilation, dataAggregation, options) {
    const groupedAggregation = [];
    const singleDatumIndices = [];
    computeBubbleAggregationCountIndices(dilation, dataAggregation, options, void 0, groupedAggregation, singleDatumIndices);
    return {
        groupedAggregation,
        singleDatumIndices
    };
}
// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts
var BubbleSeriesMarker = class extends SeriesMarker {
    constructor(){
        super(...arguments);
        this.maxSize = 30;
    }
};
__decorateClass([
    Property,
    SceneChangeDetection()
], BubbleSeriesMarker.prototype, "maxSize", 2);
__decorateClass([
    Property,
    SceneArrayChangeDetection()
], BubbleSeriesMarker.prototype, "domain", 2);
var BubbleSeriesLabel = class extends Label {
    constructor(){
        super(...arguments);
        this.placement = "top";
    }
};
__decorateClass([
    Property
], BubbleSeriesLabel.prototype, "placement", 2);
var BubbleSeriesProperties = class extends CartesianSeriesProperties {
    constructor(){
        super(...arguments);
        this.label = new BubbleSeriesLabel();
        this.tooltip = makeSeriesTooltip();
        this.maxRenderedItems = Infinity;
        // No validation. Not a part of the options contract.
        this.marker = new BubbleSeriesMarker();
    }
};
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "xKey", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "yKey", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "xFilterKey", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "sizeFilterKey", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "xName", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "yName", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "sizeName", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "labelName", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "title", 2);
__decorateClass([
    ProxyProperty("marker.shape")
], BubbleSeriesProperties.prototype, "shape", 2);
__decorateClass([
    ProxyProperty("marker.size")
], BubbleSeriesProperties.prototype, "size", 2);
__decorateClass([
    ProxyProperty("marker.maxSize")
], BubbleSeriesProperties.prototype, "maxSize", 2);
__decorateClass([
    ProxyProperty("marker.domain")
], BubbleSeriesProperties.prototype, "domain", 2);
__decorateClass([
    ProxyProperty("marker.fillGradientDefaults")
], BubbleSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
    ProxyProperty("marker.fillPatternDefaults")
], BubbleSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
    ProxyProperty("marker.fillImageDefaults")
], BubbleSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
    ProxyProperty("marker.fill")
], BubbleSeriesProperties.prototype, "fill", 2);
__decorateClass([
    ProxyProperty("marker.fillOpacity")
], BubbleSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
    ProxyProperty("marker.stroke")
], BubbleSeriesProperties.prototype, "stroke", 2);
__decorateClass([
    ProxyProperty("marker.strokeWidth")
], BubbleSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
    ProxyProperty("marker.strokeOpacity")
], BubbleSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
    ProxyProperty("marker.lineDash")
], BubbleSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
    ProxyProperty("marker.lineDashOffset")
], BubbleSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
    ProxyProperty("marker.itemStyler")
], BubbleSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "label", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
    Property
], BubbleSeriesProperties.prototype, "maxRenderedItems", 2);
// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts
var BubbleScatterSeriesNodeEvent = class extends CartesianSeriesNodeEvent {
    constructor(type, nativeEvent, datum, series){
        super(type, nativeEvent, datum, series);
        this.sizeKey = series.properties.sizeKey;
    }
};
var BubbleSeries = class extends CartesianSeries {
    get pickModeAxis() {
        return "main-category";
    }
    async processData(dataController) {
        var _this_axes_x, _this_axes_y;
        if (this.data == null || !this.visible) return;
        const xScale = (_this_axes_x = this.axes["x" /* X */ ]) === null || _this_axes_x === void 0 ? void 0 : _this_axes_x.scale;
        const yScale = (_this_axes_y = this.axes["y" /* Y */ ]) === null || _this_axes_y === void 0 ? void 0 : _this_axes_y.scale;
        const { xScaleType, yScaleType } = this.getScaleInformation({
            xScale,
            yScale
        });
        const sizeScaleType = this.sizeScale.type;
        const { xKey, yKey, sizeKey, xFilterKey, yFilterKey, sizeFilterKey, labelKey, marker } = this.properties;
        const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {
            props: [
                valueProperty(xKey, xScaleType, {
                    id: "xValue"
                }),
                valueProperty(yKey, yScaleType, {
                    id: "yValue"
                }),
                ...xFilterKey != null ? [
                    valueProperty(xFilterKey, xScaleType, {
                        id: "xFilterValue"
                    })
                ] : [],
                ...yFilterKey != null ? [
                    valueProperty(yFilterKey, yScaleType, {
                        id: "yFilterValue"
                    })
                ] : [],
                ...sizeFilterKey != null ? [
                    valueProperty(sizeFilterKey, sizeScaleType, {
                        id: "sizeFilterValue"
                    })
                ] : [],
                ...sizeKey ? [
                    valueProperty(sizeKey, sizeScaleType, {
                        id: "sizeValue"
                    })
                ] : [],
                ...labelKey ? [
                    valueProperty(labelKey, "category", {
                        id: "labelValue"
                    })
                ] : []
            ]
        });
        this.dataAggregation = this.aggregateData(dataModel, processedData);
        const sizeKeyIdx = sizeKey ? dataModel.resolveProcessedDataIndexById(this, "sizeValue") : void 0;
        const mutableMarkerDomain = marker.domain ? [
            marker.domain[0],
            marker.domain[1]
        ] : void 0;
        var _ref;
        this.sizeScale.domain = (_ref = mutableMarkerDomain !== null && mutableMarkerDomain !== void 0 ? mutableMarkerDomain : sizeKeyIdx == null ? void 0 : processedData.domain.values[sizeKeyIdx]) !== null && _ref !== void 0 ? _ref : [];
        this.animationState.transition("updateData");
    }
    xCoordinateRange(xValue, pixelSize, index) {
        const { properties, sizeScale } = this;
        const { size, sizeKey } = properties;
        const x = this.axes["x" /* X */ ].scale.convert(xValue);
        const sizeValues = sizeKey != null ? this.dataModel.resolveColumnById(this, "sizeValue", this.processedData) : void 0;
        const sizeValue = sizeValues != null ? sizeScale.convert(sizeValues[index]) : size;
        const r = 0.5 * sizeValue * pixelSize;
        return [
            x - r,
            x + r
        ];
    }
    yCoordinateRange(yValues, pixelSize, index) {
        const { properties, sizeScale } = this;
        const { size, sizeKey } = properties;
        const y = this.axes["y" /* Y */ ].scale.convert(yValues[0]);
        const sizeValues = sizeKey != null ? this.dataModel.resolveColumnById(this, "sizeValue", this.processedData) : void 0;
        const sizeValue = sizeValues != null ? sizeScale.convert(sizeValues[index]) : size;
        const r = 0.5 * sizeValue * pixelSize;
        return [
            y - r,
            y + r
        ];
    }
    getSeriesDomain(direction) {
        const { dataModel, processedData } = this;
        if (!processedData || !dataModel) return [];
        const dataValues = {
            ["x" /* X */ ]: "xValue",
            ["y" /* Y */ ]: "yValue"
        };
        const id = dataValues[direction];
        const dataDef = dataModel.resolveProcessedDataDefById(this, id);
        const domain = dataModel.getDomain(this, id, "value", processedData);
        if ((dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.type) === "value" && (dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.valueType) === "category") {
            return domain;
        }
        const crossDirection = direction === "x" /* X */  ? "y" /* Y */  : "x" /* X */ ;
        const crossId = dataValues[crossDirection];
        const ext = this.domainForClippedRange(direction, [
            id
        ], crossId);
        return fixNumericExtent(extent(ext));
    }
    getSeriesRange(_direction, visibleRange) {
        return this.domainForVisibleRange("y" /* Y */ , [
            "yValue"
        ], "xValue", visibleRange);
    }
    getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
        const { dataAggregation, axes } = this;
        const xAxis = axes["x" /* X */ ];
        const yAxis = axes["y" /* Y */ ];
        if (dataAggregation == null || xAxis == null || yAxis == null) {
            return this.countVisibleItems("xValue", [
                "yValue"
            ], xVisibleRange, yVisibleRange, minVisibleItems);
        }
        const aggregationOptions = this.aggregationOptions(xAxis, yAxis, xVisibleRange, yVisibleRange !== null && yVisibleRange !== void 0 ? yVisibleRange : [
            0,
            1
        ]);
        return computeBubbleAggregationCount(0, dataAggregation, aggregationOptions);
    }
    aggregateData(dataModel, processedData) {
        if (processedData.type === "grouped") return;
        if (processedData.input.count <= this.properties.maxRenderedItems) return;
        const xAxis = this.axes["x" /* X */ ];
        const yAxis = this.axes["y" /* Y */ ];
        if (xAxis == null || yAxis == null) return;
        const xScale = xAxis.scale;
        const yScale = yAxis.scale;
        if (!ContinuousScale.is(xScale) || !ContinuousScale.is(yScale)) return;
        const { sizeScale, properties } = this;
        const { sizeKey } = properties;
        const xValues = dataModel.resolveColumnById(this, "xValue", processedData);
        const yValues = dataModel.resolveColumnById(this, "yValue", processedData);
        const sizeValues = sizeKey ? dataModel.resolveColumnById(this, "sizeValue", processedData) : void 0;
        const xDomain = dataModel.getDomain(this, "xValue", "value", processedData);
        const yDomain = dataModel.getDomain(this, "yValue", "value", processedData);
        const sizeDomain = sizeKey ? sizeScale.domain : [
            0,
            0
        ];
        return aggregateBubbleData(xScale.type, yScale.type, xValues, yValues, sizeValues, xDomain, yDomain, sizeDomain);
    }
    aggregationOptions(xAxis, yAxis) {
        let xVisibleRange = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : xAxis.visibleRange, yVisibleRange = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : yAxis.visibleRange;
        const { sizeKey, marker } = this.properties;
        const xRange = Math.abs(xAxis.range[1] - xAxis.range[0]);
        const yRange = Math.abs(yAxis.range[1] - yAxis.range[0]);
        const minSize = marker.size;
        const maxSize = sizeKey ? marker.maxSize : minSize;
        return {
            xRange,
            yRange,
            minSize,
            maxSize,
            xVisibleRange,
            yVisibleRange
        };
    }
    createNodeData() {
        const { axes, dataModel, processedData, sizeScale, visible } = this;
        const { xKey, yKey, sizeKey, xFilterKey, yFilterKey, sizeFilterKey, labelKey, xName, yName, sizeName, labelName, label, marker, maxRenderedItems } = this.properties;
        const { enabled: labelEnabled, placement } = label;
        const anchor = Marker.anchor(marker.shape);
        const xAxis = axes["x" /* X */ ];
        const yAxis = axes["y" /* Y */ ];
        if (!(dataModel && processedData && visible && xAxis && yAxis)) {
            return;
        }
        const xDataValues = dataModel.resolveColumnById(this, "xValue", processedData);
        const yDataValues = dataModel.resolveColumnById(this, "yValue", processedData);
        const sizeDataValues = sizeKey != null ? dataModel.resolveColumnById(this, "sizeValue", processedData) : void 0;
        const labelDataValues = labelKey != null ? dataModel.resolveColumnById(this, "labelValue", processedData) : void 0;
        const xFilterDataValues = xFilterKey != null ? dataModel.resolveColumnById(this, "xFilterValue", processedData) : void 0;
        const yFilterDataValues = yFilterKey != null ? dataModel.resolveColumnById(this, "yFilterValue", processedData) : void 0;
        const sizeFilterDataValues = sizeFilterKey != null ? dataModel.resolveColumnById(this, "sizeFilterValue", processedData) : void 0;
        let labelTextDomain;
        if (labelKey) {
            labelTextDomain = [];
        } else if (sizeKey) {
            labelTextDomain = dataModel.getDomain(this, "sizeValue", "value", processedData);
        } else {
            labelTextDomain = [];
        }
        const xScale = xAxis.scale;
        const yScale = yAxis.scale;
        var _xScale_bandwidth;
        const xOffset = ((_xScale_bandwidth = xScale.bandwidth) !== null && _xScale_bandwidth !== void 0 ? _xScale_bandwidth : 0) / 2;
        var _yScale_bandwidth;
        const yOffset = ((_yScale_bandwidth = yScale.bandwidth) !== null && _yScale_bandwidth !== void 0 ? _yScale_bandwidth : 0) / 2;
        const nodeData = [];
        sizeScale.range = [
            marker.size,
            marker.maxSize
        ];
        const textMeasurer = CachedTextMeasurerPool.getMeasurer({
            font: label
        });
        const rawData = processedData.dataSources.get(this.id);
        if (rawData == null) return;
        const padding2 = expandLabelPadding(label);
        const handleDatum = (datumIndex, count, dilation)=>{
            const datum = rawData[datumIndex];
            const xDatum = xDataValues[datumIndex];
            const yDatum = yDataValues[datumIndex];
            const sizeValue = sizeDataValues === null || sizeDataValues === void 0 ? void 0 : sizeDataValues[datumIndex];
            const x = xScale.convert(xDatum) + xOffset;
            const y = yScale.convert(yDatum) + yOffset;
            let selected;
            if (xFilterDataValues != null && yFilterDataValues != null) {
                selected = xFilterDataValues[datumIndex] === xDatum && yFilterDataValues[datumIndex] === yDatum;
                if (sizeFilterDataValues != null) {
                    selected && (selected = sizeFilterDataValues[datumIndex] === sizeValue);
                }
            }
            let nodeLabel;
            if (labelEnabled) {
                let labelTextValue;
                let labelTextKey;
                let labelTextProperty;
                if (labelKey && labelDataValues) {
                    labelTextValue = labelDataValues[datumIndex];
                    labelTextKey = labelKey;
                    labelTextProperty = "label";
                } else if (sizeKey) {
                    labelTextValue = sizeValue;
                    labelTextKey = sizeKey;
                    labelTextProperty = "size";
                } else {
                    labelTextValue = yDatum;
                    labelTextKey = yKey;
                    labelTextProperty = "y";
                }
                const labelText = this.getLabelText(labelTextValue, datum, labelTextKey, labelTextProperty, labelTextDomain, label, {
                    value: labelTextValue,
                    datum,
                    xKey,
                    yKey,
                    sizeKey,
                    labelKey,
                    xName,
                    yName,
                    sizeName,
                    labelName
                });
                const size = textMeasurer.measureText(String(labelText));
                size.width += padding2.left + padding2.right;
                size.height += padding2.bottom + padding2.top;
                nodeLabel = {
                    text: labelText,
                    ...size
                };
            } else {
                nodeLabel = {
                    text: "",
                    width: 0,
                    height: 0
                };
            }
            const markerSize = sizeValue != null ? sizeScale.convert(sizeValue) : marker.size;
            nodeData.push({
                series: this,
                itemId: yKey,
                yKey,
                xKey,
                datum,
                datumIndex,
                xValue: xDatum,
                yValue: yDatum,
                sizeValue,
                capDefaults: {
                    lengthRatioMultiplier: marker.getDiameter(),
                    lengthMax: Infinity
                },
                point: {
                    x,
                    y,
                    size: Math.sqrt(dilation) * markerSize
                },
                midPoint: {
                    x,
                    y
                },
                label: nodeLabel,
                anchor,
                placement,
                count,
                dilation,
                selected
            });
        };
        const { dataAggregation } = this;
        if (dataAggregation == null) {
            for(let datumIndex = 0; datumIndex < rawData.length; datumIndex++){
                handleDatum(datumIndex, 1, 1);
            }
        } else {
            const aggregationOptions = this.aggregationOptions(xAxis, yAxis);
            const aggregationDilation = computeBubbleAggregationDilation(dataAggregation, aggregationOptions, maxRenderedItems);
            const { groupedAggregation, singleDatumIndices } = computeBubbleAggregationData(aggregationDilation, dataAggregation, aggregationOptions);
            for (const { datumIndex, count, dilation } of groupedAggregation){
                handleDatum(datumIndex, count, dilation);
            }
            for (const datumIndex of singleDatumIndices){
                handleDatum(datumIndex, 1, 1);
            }
        }
        return {
            itemId: yKey,
            nodeData,
            labelData: labelEnabled ? nodeData : [],
            scales: this.calculateScaling(),
            visible: this.visible
        };
    }
    isPathOrSelectionDirty() {
        return this.properties.marker.isDirty();
    }
    getLabelData() {
        var _this_contextNodeData;
        if (!this.isLabelEnabled()) return [];
        var _this_contextNodeData_labelData;
        return (_this_contextNodeData_labelData = (_this_contextNodeData = this.contextNodeData) === null || _this_contextNodeData === void 0 ? void 0 : _this_contextNodeData.labelData) !== null && _this_contextNodeData_labelData !== void 0 ? _this_contextNodeData_labelData : [];
    }
    updateDatumSelection(opts) {
        const { nodeData, datumSelection } = opts;
        const { sizeKey } = this.properties;
        if (this.properties.marker.isDirty()) {
            datumSelection.clear();
            datumSelection.cleanup();
        }
        const data = this.properties.marker.enabled ? nodeData : [];
        let getId;
        if (sizeKey) {
            getId = (datum)=>createDatumId([
                    datum.xValue,
                    datum.yValue,
                    datum.sizeValue,
                    datum.label.text
                ]);
        }
        return datumSelection.update(data, void 0, getId);
    }
    updateDatumNodes(opts) {
        const { datumSelection, isHighlight } = opts;
        const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;
        this.sizeScale.range = [
            marker.size,
            marker.maxSize
        ];
        const fillBBox = this.getShapeFillBBox();
        const aggregated = this.dataAggregation != null;
        const params = {
            xKey,
            yKey,
            sizeKey,
            labelKey
        };
        datumSelection.each((node, datum, index)=>{
            const { count, dilation } = datum;
            const style = this.getMarkerStyle(marker, datum, params, isHighlight);
            var _style_fillOpacity;
            style.fillOpacity = (1 - (1 - ((_style_fillOpacity = style.fillOpacity) !== null && _style_fillOpacity !== void 0 ? _style_fillOpacity : 1)) ** count) / Math.sqrt(dilation);
            this.applyMarkerStyle(style, node, datum.point, fillBBox, {
                selected: datum.selected
            });
            node.zIndex = aggregated ? [
                -count,
                index
            ] : 0;
        });
        if (!isHighlight) {
            this.properties.marker.markClean();
        }
    }
    updatePlacedLabelData(labelData) {
        this.labelSelection.update(labelData.map((v)=>({
                ...v.datum,
                point: {
                    x: v.x,
                    y: v.y,
                    size: v.datum.point.size
                }
            })), (text)=>{
            text.pointerEvents = 1 /* None */ ;
        });
        this.updateLabelNodes({
            labelSelection: this.labelSelection
        });
    }
    updateLabelNodes(opts) {
        var _this_ctx_highlightManager;
        const { isHighlight = false } = opts;
        const activeHighlight = (_this_ctx_highlightManager = this.ctx.highlightManager) === null || _this_ctx_highlightManager === void 0 ? void 0 : _this_ctx_highlightManager.getActiveHighlight();
        opts.labelSelection.each((text, datum)=>{
            var _datum_point, _datum_point1;
            const highlighted = isHighlight || this.isSeriesHighlighted(activeHighlight);
            const highlightState = this.getHighlightStateString(activeHighlight, highlighted, datum.datumIndex);
            const style = getLabelStyles(this, datum, this.properties, this.properties.label, highlighted, highlightState);
            text.text = datum.label.text;
            text.fill = style.color;
            var _datum_point_x;
            text.x = (_datum_point_x = (_datum_point = datum.point) === null || _datum_point === void 0 ? void 0 : _datum_point.x) !== null && _datum_point_x !== void 0 ? _datum_point_x : 0;
            var _datum_point_y;
            text.y = (_datum_point_y = (_datum_point1 = datum.point) === null || _datum_point1 === void 0 ? void 0 : _datum_point1.y) !== null && _datum_point_y !== void 0 ? _datum_point_y : 0;
            text.fontStyle = style.fontStyle;
            text.fontWeight = style.fontWeight;
            text.fontSize = style.fontSize;
            text.fontFamily = style.fontFamily;
            text.textAlign = "left";
            text.textBaseline = "top";
            var _this_getHighlightStyle_opacity;
            text.fillOpacity = (_this_getHighlightStyle_opacity = this.getHighlightStyle(isHighlight, datum.datumIndex).opacity) !== null && _this_getHighlightStyle_opacity !== void 0 ? _this_getHighlightStyle_opacity : 1;
            text.setBoxing(style);
        });
    }
    getTooltipContent(datumIndex) {
        var _processedData_dataSources_get, _this_contextNodeData;
        const { id: seriesId, dataModel, processedData, axes, properties, ctx } = this;
        const { formatManager } = ctx;
        const { xKey, xName, yKey, yName, sizeKey, sizeName, labelKey, labelName, title, tooltip, marker, legendItemName } = properties;
        const xAxis = axes["x" /* X */ ];
        const yAxis = axes["y" /* Y */ ];
        if (!dataModel || !processedData || !xAxis || !yAxis) return;
        const datum = (_processedData_dataSources_get = processedData.dataSources.get(this.id)) === null || _processedData_dataSources_get === void 0 ? void 0 : _processedData_dataSources_get[datumIndex];
        const xValue = dataModel.resolveColumnById(this, "xValue", processedData)[datumIndex];
        const yValue = dataModel.resolveColumnById(this, "yValue", processedData)[datumIndex];
        const nodeDatum = (_this_contextNodeData = this.contextNodeData) === null || _this_contextNodeData === void 0 ? void 0 : _this_contextNodeData.nodeData[datumIndex];
        if (xValue == null || nodeDatum == null) return;
        const data = [];
        if (this.isLabelEnabled() && labelKey != null) {
            const value = dataModel.resolveColumnById(this, "labelValue", processedData)[datumIndex];
            const content = formatManager.format(this.callWithContext.bind(this), {
                type: "category",
                value,
                datum,
                seriesId,
                legendItemName,
                key: labelKey,
                source: "tooltip",
                property: "label",
                domain: [],
                boundSeries: this.getFormatterContext("label")
            });
            data.push({
                label: labelName,
                fallbackLabel: labelKey,
                value: content !== null && content !== void 0 ? content : formatValue(value)
            });
        }
        data.push({
            label: xName,
            fallbackLabel: xKey,
            value: this.getAxisValueText(xAxis, "tooltip", xValue, datum, xKey, legendItemName)
        }, {
            label: yName,
            fallbackLabel: yKey,
            value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
        });
        if (sizeKey != null) {
            const value = dataModel.resolveColumnById(this, "sizeValue", processedData)[datumIndex];
            const domain = dataModel.getDomain(this, "sizeValue", "value", processedData);
            const content = formatManager.format(this.callWithContext.bind(this), {
                type: "number",
                value,
                datum,
                seriesId,
                legendItemName,
                key: sizeKey,
                source: "tooltip",
                property: "size",
                boundSeries: this.getFormatterContext("size"),
                domain,
                fractionDigits: void 0
            });
            data.push({
                label: sizeName,
                fallbackLabel: sizeKey,
                value: content !== null && content !== void 0 ? content : formatValue(value)
            });
        }
        const activeStyle = this.getMarkerStyle(marker, {
            datum,
            datumIndex
        }, {
            xKey,
            yKey,
            sizeKey,
            labelKey,
            highlighted: true
        }, false);
        return this.formatTooltipWithContext(tooltip, {
            title,
            symbol: this.legendItemSymbol(),
            data
        }, {
            seriesId,
            datum,
            title: yKey,
            xKey,
            xName,
            yKey,
            yName,
            sizeKey,
            sizeName,
            labelKey,
            labelName,
            ...activeStyle,
            ...this.getModuleTooltipParams()
        });
    }
    legendItemSymbol() {
        const marker = this.getMarkerStyle(this.properties.marker, {}, void 0, false, void 0, void 0, false);
        return {
            marker
        };
    }
    getLegendData() {
        const { id: seriesId, ctx: { legendManager }, visible } = this;
        const { yKey: itemId, yName, title } = this.properties;
        var _ref;
        return [
            {
                legendType: "category",
                id: seriesId,
                itemId,
                seriesId,
                enabled: visible && legendManager.getItemEnabled({
                    seriesId,
                    itemId
                }),
                label: {
                    text: (_ref = title !== null && title !== void 0 ? title : yName) !== null && _ref !== void 0 ? _ref : itemId
                },
                symbol: this.legendItemSymbol()
            }
        ];
    }
    animateEmptyUpdateReady(param) {
        let { datumSelection, labelSelection } = param;
        markerScaleInAnimation(this, this.ctx.animationManager, datumSelection);
        seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
    }
    isLabelEnabled() {
        return this.properties.label.enabled;
    }
    nodeFactory() {
        return new Marker();
    }
    getFormattedMarkerStyle(datum) {
        const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;
        return this.getMarkerStyle(marker, datum, {
            xKey,
            yKey,
            sizeKey,
            labelKey
        }, false);
    }
    computeFocusBounds(opts) {
        return computeMarkerFocusBounds(this, opts);
    }
    hasItemStylers() {
        const { itemStyler, marker, label } = this.properties;
        var _ref;
        return !!((_ref = itemStyler !== null && itemStyler !== void 0 ? itemStyler : marker.itemStyler) !== null && _ref !== void 0 ? _ref : label.itemStyler);
    }
    constructor(moduleCtx){
        super({
            moduleCtx,
            propertyKeys: {
                ...DEFAULT_CARTESIAN_DIRECTION_KEYS,
                label: [
                    "labelKey"
                ],
                size: [
                    "sizeKey"
                ]
            },
            propertyNames: {
                ...DEFAULT_CARTESIAN_DIRECTION_NAMES,
                label: [
                    "labelName"
                ],
                size: [
                    "sizeName"
                ]
            },
            categoryKey: void 0,
            pickModes: [
                2 /* AXIS_ALIGNED */ ,
                1 /* NEAREST_NODE */ ,
                0 /* EXACT_SHAPE_MATCH */ 
            ],
            pathsPerSeries: [],
            datumSelectionGarbageCollection: false,
            animationResetFns: {
                label: resetLabelFn,
                datum: resetMarkerFn
            },
            usesPlacedLabels: true,
            clipFocusBox: false
        });
        this.NodeEvent = BubbleScatterSeriesNodeEvent;
        this.properties = new BubbleSeriesProperties();
        this.dataAggregation = void 0;
        this.sizeScale = new LinearScale();
    }
};
BubbleSeries.className = "BubbleSeries";
BubbleSeries.type = "bubble";
// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts
var BubbleSeriesModule = {
    type: "series",
    optionsKey: "series[]",
    packageType: "community",
    chartTypes: [
        "cartesian"
    ],
    identifier: "bubble",
    moduleFactory: (ctx)=>new BubbleSeries(ctx),
    defaultAxes: [
        {
            type: "number" /* NUMBER */ ,
            position: "bottom" /* BOTTOM */ 
        },
        {
            type: "number" /* NUMBER */ ,
            position: "left" /* LEFT */ 
        }
    ],
    themeTemplate: {
        series: {
            shape: "circle",
            size: 7,
            maxSize: 30,
            fill: {
                $palette: "fill"
            },
            stroke: {
                $palette: "stroke"
            },
            // @ts-expect-error undocumented option
            fillGradientDefaults: FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
            fillPatternDefaults: FILL_PATTERN_DEFAULTS,
            fillImageDefaults: FILL_IMAGE_DEFAULTS,
            fillOpacity: 0.8,
            maxRenderedItems: 1e4,
            label: {
                ...LABEL_BOXING_DEFAULTS,
                enabled: false,
                fontSize: {
                    $ref: "fontSize"
                },
                fontFamily: {
                    $ref: "fontFamily"
                },
                fontWeight: {
                    $ref: "fontWeight"
                },
                color: {
                    $ref: "textColor"
                }
            },
            tooltip: {
                range: {
                    $path: [
                        "/tooltip/range",
                        "nearest"
                    ]
                },
                position: {
                    anchorTo: {
                        $path: [
                            "/tooltip/position/anchorTo",
                            "node"
                        ]
                    }
                }
            },
            highlight: multiSeriesHighlightStyle()
        }
    }
};
var NewBubbleSeriesModule = {
    type: "series",
    name: "bubble",
    chartType: "cartesian",
    options: bubbleSeriesOptionsDef,
    create: (ctx)=>new BubbleSeries(ctx)
};
;
// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts
var HistogramSeriesProperties = class extends CartesianSeriesProperties {
    getStyle() {
        const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = this;
        return {
            fill,
            fillOpacity,
            stroke: stroke2,
            strokeWidth,
            strokeOpacity,
            lineDash,
            lineDashOffset,
            cornerRadius,
            opacity: 1
        };
    }
    constructor(){
        super(...arguments);
        this.fillGradientDefaults = new FillGradientDefaults();
        this.fillPatternDefaults = new FillPatternDefaults();
        this.fillImageDefaults = new FillImageDefaults();
        this.fillOpacity = 1;
        this.strokeWidth = 1;
        this.strokeOpacity = 1;
        this.lineDash = [
            0
        ];
        this.lineDashOffset = 0;
        this.cornerRadius = 0;
        this.areaPlot = false;
        this.aggregation = "sum";
        this.shadow = new DropShadow();
        this.label = new Label();
        this.tooltip = makeSeriesTooltip();
    }
};
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "xKey", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "yKey", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "xName", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "yName", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "fill", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "stroke", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "areaPlot", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "bins", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "aggregation", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "binCount", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "shadow", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "label", 2);
__decorateClass([
    Property
], HistogramSeriesProperties.prototype, "tooltip", 2);
// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts
var defaultBinCount = 10;
var HistogramSeries = class extends CartesianSeries {
    // During processData phase, used to unify different ways of the user specifying
    // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].
    deriveBins(xDomain) {
        const binStarts = createTicks(xDomain[0], xDomain[1], defaultBinCount).ticks;
        const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);
        const [firstBinEnd] = binStarts;
        const expandStartToBin = (n)=>[
                n,
                n + binSize
            ];
        return [
            [
                firstBinEnd - binSize,
                firstBinEnd
            ],
            ...binStarts.map(expandStartToBin)
        ];
    }
    calculateNiceBins(domain, binCount) {
        const startGuess = Math.floor(domain[0]);
        const stop = domain[1];
        const segments = binCount || 1;
        const { start: start2, binSize } = this.calculateNiceStart(startGuess, stop, segments);
        return this.getBins(start2, stop, binSize, segments);
    }
    getBins(start2, stop, step, count) {
        const bins = [];
        const precision = this.calculatePrecision(step);
        for(let i = 0; i < count; i++){
            const a = Math.round((start2 + i * step) * precision) / precision;
            let b = Math.round((start2 + (i + 1) * step) * precision) / precision;
            if (i === count - 1) {
                b = Math.max(b, stop);
            }
            bins[i] = [
                a,
                b
            ];
        }
        return bins;
    }
    calculatePrecision(step) {
        let precision = 10;
        if (isFinite(step) && step > 0) {
            while(step < 1){
                precision *= 10;
                step *= 10;
            }
        }
        return precision;
    }
    calculateNiceStart(a, b, segments) {
        const binSize = Math.abs(b - a) / segments;
        const order = Math.floor(Math.log10(binSize));
        const magnitude = Math.pow(10, order);
        const start2 = Math.floor(a / magnitude) * magnitude;
        return {
            start: start2,
            binSize
        };
    }
    async processData(dataController) {
        var _this_axes_x, _this_axes_y;
        if (!this.visible) {
            this.processedData = void 0;
            this.animationState.transition("updateData");
        }
        const { xKey, yKey, areaPlot, aggregation } = this.properties;
        const xScale = (_this_axes_x = this.axes["x" /* X */ ]) === null || _this_axes_x === void 0 ? void 0 : _this_axes_x.scale;
        const yScale = (_this_axes_y = this.axes["y" /* Y */ ]) === null || _this_axes_y === void 0 ? void 0 : _this_axes_y.scale;
        const { xScaleType, yScaleType } = this.getScaleInformation({
            yScale,
            xScale
        });
        const props = [
            keyProperty(xKey, xScaleType),
            SORT_DOMAIN_GROUPS
        ];
        if (yKey) {
            let aggProp = groupCount("groupAgg");
            if (aggregation === "count") {} else if (aggregation === "sum") {
                aggProp = groupSum("groupAgg");
            } else if (aggregation === "mean") {
                aggProp = groupAverage("groupAgg");
            }
            if (areaPlot) {
                aggProp = area("groupAgg", aggProp);
            }
            props.push(valueProperty(yKey, yScaleType, {
                invalidValue: void 0
            }), aggProp);
        } else {
            props.push(rowCountProperty("count"));
            let aggProp = groupCount("groupAgg");
            if (areaPlot) {
                aggProp = area("groupAgg", aggProp);
            }
            props.push(aggProp);
        }
        const groupByFn = (dataSet)=>{
            const xExtent = fixNumericExtent(dataSet.domain.keys[0]);
            if (xExtent.length === 0) {
                dataSet.domain.groups = [];
                return ()=>[];
            }
            var _this_properties_bins;
            const bins = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : (_this_properties_bins = this.properties.bins) !== null && _this_properties_bins !== void 0 ? _this_properties_bins : this.deriveBins(xExtent);
            const binCount = bins.length;
            this.calculatedBins = [
                ...bins
            ];
            return (keys)=>{
                let xValue = keys[0];
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDate"])(xValue)) {
                    xValue = xValue.getTime();
                }
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(xValue)) return [];
                for(let i = 0; i < binCount; i++){
                    const nextBin = bins[i];
                    if (xValue >= nextBin[0] && xValue < nextBin[1]) {
                        return nextBin;
                    }
                    if (i === binCount - 1 && xValue <= nextBin[1]) {
                        return nextBin;
                    }
                }
                return [];
            };
        };
        if (!this.ctx.animationManager.isSkipped() && this.processedData) {
            props.push(diff(this.id, this.processedData, false));
        }
        await this.requestDataModel(dataController, this.data, {
            props,
            groupByFn
        });
        this.animationState.transition("updateData");
    }
    xCoordinateRange() {
        return [
            NaN,
            NaN
        ];
    }
    yCoordinateRange() {
        return [
            NaN,
            NaN
        ];
    }
    getSeriesDomain(direction) {
        var _this_calculatedBins, _this_calculatedBins1, _this_calculatedBins2;
        const { processedData, dataModel } = this;
        if (!processedData || !dataModel || !this.calculatedBins.length) return [];
        const yDomain = dataModel.getDomain(this, "groupAgg", "aggregate", processedData);
        const xDomainMin = (_this_calculatedBins = this.calculatedBins) === null || _this_calculatedBins === void 0 ? void 0 : _this_calculatedBins[0][0];
        var _this_calculatedBins_length;
        const xDomainMax = (_this_calculatedBins2 = this.calculatedBins) === null || _this_calculatedBins2 === void 0 ? void 0 : _this_calculatedBins2[((_this_calculatedBins_length = (_this_calculatedBins1 = this.calculatedBins) === null || _this_calculatedBins1 === void 0 ? void 0 : _this_calculatedBins1.length) !== null && _this_calculatedBins_length !== void 0 ? _this_calculatedBins_length : 0) - 1][1];
        if (direction === "x" /* X */ ) {
            return fixNumericExtent([
                xDomainMin,
                xDomainMax
            ]);
        }
        return fixNumericExtent(yDomain);
    }
    getSeriesRange(_direction, param) {
        let [r0, r1] = param;
        const { dataModel, processedData } = this;
        if (!dataModel || (processedData === null || processedData === void 0 ? void 0 : processedData.type) !== "grouped") return [
            NaN,
            NaN
        ];
        const xScale = this.axes["x" /* X */ ].scale;
        const yMin = 0;
        let yMax = -Infinity;
        processedData.groups.forEach((param)=>{
            let { keys, aggregation } = param;
            const [[negativeAgg, positiveAgg] = [
                0,
                0
            ]] = aggregation;
            const [xDomainMin, xDomainMax] = keys;
            const [x0, x1] = findMinMax([
                xScale.convert(xDomainMin),
                xScale.convert(xDomainMax)
            ]);
            if (x1 >= r0 && x0 <= r1) {
                const total = negativeAgg + positiveAgg;
                yMax = Math.max(yMax, total);
            }
        });
        if (yMin > yMax) return [
            NaN,
            NaN
        ];
        return [
            yMin,
            yMax
        ];
    }
    frequency(group) {
        return group.datumIndices.reduce((acc, datumIndices)=>acc + datumIndices.length, 0);
    }
    createNodeData() {
        const { axes, processedData, dataModel } = this;
        const xAxis = axes["x" /* X */ ];
        const yAxis = axes["y" /* Y */ ];
        if (!xAxis || !yAxis || !dataModel) {
            return;
        }
        const { scale: xScale } = xAxis;
        const { scale: yScale } = yAxis;
        const { xKey, yKey, xName, yName, label } = this.properties;
        const nodeData = [];
        var _this_properties_yKey;
        const context = {
            itemId: (_this_properties_yKey = this.properties.yKey) !== null && _this_properties_yKey !== void 0 ? _this_properties_yKey : this.id,
            nodeData,
            labelData: nodeData,
            scales: this.calculateScaling(),
            animationValid: true,
            visible: this.visible
        };
        if (!this.visible || processedData == null || processedData.type !== "grouped") {
            return context;
        }
        processedData.groups.forEach((group, groupIndex)=>{
            const { keys, aggregation } = group;
            const [[negativeAgg, positiveAgg] = [
                0,
                0
            ]] = aggregation;
            const frequency = this.frequency(group);
            const domain = keys;
            const [xDomainMin, xDomainMax] = domain;
            const datum = [
                ...dataModel.forEachDatum(this, processedData, group)
            ];
            const xMinPx = xScale.convert(xDomainMin);
            const xMaxPx = xScale.convert(xDomainMax);
            const total = negativeAgg + positiveAgg;
            const yZeroPx = yScale.convert(0);
            const yMaxPx = yScale.convert(total);
            const w = Math.abs(xMaxPx - xMinPx);
            const h = Math.abs(yMaxPx - yZeroPx);
            const x = Math.min(xMinPx, xMaxPx);
            const y = Math.min(yZeroPx, yMaxPx);
            let selectionDatumLabel = void 0;
            if (label.enabled && total !== 0) {
                selectionDatumLabel = {
                    x: x + w / 2,
                    y: y + h / 2,
                    text: this.getLabelText(total, datum, yKey, "y", [], label, {
                        value: total,
                        datum,
                        xKey,
                        yKey,
                        xName,
                        yName
                    })
                };
            }
            const nodeMidPoint = {
                x: x + w / 2,
                y: y + h / 2
            };
            const yAxisReversed = yAxis.isReversed();
            nodeData.push({
                series: this,
                datumIndex: groupIndex,
                datum,
                // required by SeriesNodeDatum, but might not make sense here
                // since each selection is an aggregation of multiple data.
                aggregatedValue: total,
                frequency,
                domain,
                yKey,
                xKey,
                x,
                y,
                xValue: xMinPx,
                yValue: yMaxPx,
                width: w,
                height: h,
                midPoint: nodeMidPoint,
                topLeftCornerRadius: !yAxisReversed,
                topRightCornerRadius: !yAxisReversed,
                bottomRightCornerRadius: yAxisReversed,
                bottomLeftCornerRadius: yAxisReversed,
                label: selectionDatumLabel,
                crisp: true
            });
        });
        nodeData.sort((a, b)=>a.x - b.x);
        return context;
    }
    nodeFactory() {
        return new Rect();
    }
    updateDatumSelection(opts) {
        const { nodeData, datumSelection } = opts;
        return datumSelection.update(nodeData, void 0, (datum)=>datum.domain.join("_"));
    }
    getItemStyle(isHighlight, datum) {
        const { properties } = this;
        const highlightStyle = this.getHighlightStyle(isHighlight, datum === null || datum === void 0 ? void 0 : datum.datumIndex);
        return getShapeStyle(mergeDefaults(highlightStyle, properties.getStyle()), properties.fillGradientDefaults, properties.fillPatternDefaults, properties.fillImageDefaults);
    }
    updateDatumNodes(opts) {
        const { isHighlight } = opts;
        const { shadow } = this.properties;
        const fillBBox = this.getShapeFillBBox();
        opts.datumSelection.each((rect, datum)=>{
            const style = this.getItemStyle(isHighlight, datum);
            const { cornerRadius = 0 } = style;
            const { topLeftCornerRadius, topRightCornerRadius, bottomRightCornerRadius, bottomLeftCornerRadius } = datum;
            applyShapeStyle(rect, style, fillBBox);
            rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;
            rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;
            rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;
            rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;
            rect.crisp = datum.crisp;
            rect.fillShadow = shadow;
            rect.visible = datum.height > 0;
        });
    }
    updateLabelSelection(opts) {
        const { labelData, labelSelection } = opts;
        return labelSelection.update(labelData, (text)=>{
            text.pointerEvents = 1 /* None */ ;
            text.textAlign = "center";
            text.textBaseline = "middle";
        });
    }
    updateLabelNodes(opts) {
        const labelEnabled = this.isLabelEnabled();
        opts.labelSelection.each((text, datum)=>{
            const style = getLabelStyles(this, datum, this.properties, this.properties.label);
            const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color: color11 } = style;
            if (enabled && labelEnabled && (datum === null || datum === void 0 ? void 0 : datum.label)) {
                text.text = datum.label.text;
                text.x = datum.label.x;
                text.y = datum.label.y;
                text.fontStyle = fontStyle;
                text.fontWeight = fontWeight;
                text.fontFamily = fontFamily;
                text.fontSize = fontSize;
                text.fill = color11;
                text.visible = true;
                var _this_getHighlightStyle_opacity;
                text.fillOpacity = (_this_getHighlightStyle_opacity = this.getHighlightStyle(false, datum.datumIndex).opacity) !== null && _this_getHighlightStyle_opacity !== void 0 ? _this_getHighlightStyle_opacity : 1;
                text.setBoxing(style);
            } else {
                text.visible = false;
            }
        });
    }
    initQuadTree(quadtree) {
        const { value: childNode } = this.contentGroup.children().next();
        if (childNode instanceof Group) {
            addHitTestersToQuadtree(quadtree, childNode.children());
        }
    }
    pickNodeClosestDatum(point) {
        return findQuadtreeMatch(this, point);
    }
    getTooltipContent(datumIndex) {
        const { id: seriesId, dataModel, processedData, axes, properties, ctx: { localeManager } } = this;
        const { xKey, xName, yKey, yName, tooltip, legendItemName } = properties;
        const xAxis = axes["x" /* X */ ];
        const yAxis = axes["y" /* Y */ ];
        if (!dataModel || (processedData === null || processedData === void 0 ? void 0 : processedData.type) !== "grouped" || !xAxis || !yAxis) {
            return;
        }
        const group = processedData.groups[datumIndex];
        const { aggregation, keys } = group;
        const [[negativeAgg, positiveAgg] = [
            0,
            0
        ]] = aggregation;
        const frequency = this.frequency(group);
        const domain = keys;
        const [rangeMin, rangeMax] = domain;
        const aggregatedValue = negativeAgg + positiveAgg;
        const datum = {
            data: [
                ...dataModel.forEachDatum(this, processedData, group)
            ],
            aggregatedValue,
            frequency,
            domain
        };
        const data = [
            {
                label: xName,
                fallbackLabel: xKey,
                value: "".concat(this.getAxisValueText(xAxis, "tooltip", rangeMin, datum, xKey, legendItemName), " - ").concat(this.getAxisValueText(xAxis, "tooltip", rangeMax, datum, xKey, legendItemName))
            },
            {
                label: localeManager.t("seriesHistogramTooltipFrequency"),
                value: this.getAxisValueText(yAxis, "tooltip", frequency, datum, yKey, legendItemName)
            }
        ];
        if (yKey != null) {
            let label;
            switch(properties.aggregation){
                case "sum":
                    label = localeManager.t("seriesHistogramTooltipSum", {
                        yName: yName !== null && yName !== void 0 ? yName : yKey
                    });
                    break;
                case "mean":
                    label = localeManager.t("seriesHistogramTooltipMean", {
                        yName: yName !== null && yName !== void 0 ? yName : yKey
                    });
                    break;
                case "count":
                    label = localeManager.t("seriesHistogramTooltipCount", {
                        yName: yName !== null && yName !== void 0 ? yName : yKey
                    });
                    break;
            }
            data.push({
                label,
                value: this.getAxisValueText(yAxis, "tooltip", aggregatedValue, datum, yKey, legendItemName)
            });
        }
        return this.formatTooltipWithContext(tooltip, {
            symbol: this.legendItemSymbol(),
            data
        }, {
            seriesId,
            datum,
            title: yName,
            xKey,
            // HistogramSeries is an outlier since it's callbacks don't use TDatum.
            xName,
            yKey,
            // HistogramSeries is an outlier since it's callbacks don't use TDatum.
            yName,
            xRange: [
                rangeMin,
                rangeMax
            ],
            frequency,
            ...this.getItemStyle(false)
        });
    }
    legendItemSymbol() {
        const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, fillGradientDefaults: fillGradientDefaults2, fillPatternDefaults: fillPatternDefaults2, fillImageDefaults: fillImageDefaults2 } = this.properties;
        return {
            marker: getShapeStyle({
                fill: fill !== null && fill !== void 0 ? fill : "rgba(0, 0, 0, 0)",
                stroke: stroke2 !== null && stroke2 !== void 0 ? stroke2 : "rgba(0, 0, 0, 0)",
                fillOpacity,
                strokeOpacity,
                strokeWidth,
                lineDash,
                lineDashOffset
            }, fillGradientDefaults2, fillPatternDefaults2, fillImageDefaults2)
        };
    }
    getLegendData(legendType) {
        if (legendType !== "category") {
            return [];
        }
        const { id: seriesId, ctx: { legendManager }, visible } = this;
        const { xKey: itemId, yName, showInLegend } = this.properties;
        var _ref;
        return [
            {
                legendType: "category",
                id: seriesId,
                itemId,
                seriesId,
                enabled: visible && legendManager.getItemEnabled({
                    seriesId,
                    itemId
                }),
                label: {
                    text: (_ref = yName !== null && yName !== void 0 ? yName : itemId) !== null && _ref !== void 0 ? _ref : "Frequency"
                },
                symbol: this.legendItemSymbol(),
                hideInLegend: !showInLegend
            }
        ];
    }
    animateEmptyUpdateReady(param) {
        let { datumSelection, labelSelection } = param;
        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, "normal"));
        fromToMotion(this.id, "datums", this.ctx.animationManager, [
            datumSelection
        ], fns);
        seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
    }
    animateWaitingUpdateReady(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetDatumAnimation(data);
    }
    isLabelEnabled() {
        return this.properties.label.enabled;
    }
    computeFocusBounds(param) {
        let { datumIndex } = param;
        var _this_contextNodeData;
        return computeBarFocusBounds(this, (_this_contextNodeData = this.contextNodeData) === null || _this_contextNodeData === void 0 ? void 0 : _this_contextNodeData.nodeData[datumIndex]);
    }
    hasItemStylers() {
        return this.properties.label.itemStyler != null;
    }
    constructor(moduleCtx){
        super({
            moduleCtx,
            propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
            propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
            categoryKey: void 0,
            pickModes: [
                1 /* NEAREST_NODE */ ,
                0 /* EXACT_SHAPE_MATCH */ 
            ],
            datumSelectionGarbageCollection: true,
            animationResetFns: {
                datum: resetBarSelectionsFn,
                label: resetLabelFn
            }
        });
        this.properties = new HistogramSeriesProperties();
        this.calculatedBins = [];
    }
};
HistogramSeries.className = "HistogramSeries";
HistogramSeries.type = "histogram";
// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts
var HistogramSeriesModule = {
    type: "series",
    optionsKey: "series[]",
    packageType: "community",
    chartTypes: [
        "cartesian"
    ],
    identifier: "histogram",
    moduleFactory: (ctx)=>new HistogramSeries(ctx),
    defaultAxes: [
        {
            type: "number" /* NUMBER */ ,
            position: "bottom" /* BOTTOM */ 
        },
        {
            type: "number" /* NUMBER */ ,
            position: "left" /* LEFT */ 
        }
    ],
    themeTemplate: {
        series: {
            fill: {
                $palette: "fill"
            },
            stroke: {
                $palette: "stroke"
            },
            // @ts-expect-error undocumented option
            fillGradientDefaults: FILL_GRADIENT_LINEAR_DEFAULTS,
            fillPatternDefaults: FILL_PATTERN_DEFAULTS,
            fillImageDefaults: FILL_IMAGE_DEFAULTS,
            strokeWidth: 1,
            fillOpacity: 1,
            strokeOpacity: 1,
            lineDash: [
                0
            ],
            lineDashOffset: 0,
            label: {
                ...LABEL_BOXING_DEFAULTS,
                enabled: false,
                fontSize: {
                    $ref: "fontSize"
                },
                fontFamily: {
                    $ref: "fontFamily"
                },
                fontWeight: {
                    $ref: "fontWeight"
                },
                color: {
                    $ref: "chartBackgroundColor"
                }
            },
            shadow: {
                enabled: false,
                color: DEFAULT_SHADOW_COLOUR,
                xOffset: 3,
                yOffset: 3,
                blur: 5
            },
            highlight: multiSeriesHighlightStyle()
        }
    }
};
var NewHistogramSeriesModule = {
    type: "series",
    name: "histogram",
    chartType: "cartesian",
    enterprise: true,
    options: histogramSeriesOptionsDef,
    create: (ctx)=>new HistogramSeries(ctx)
};
;
// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts
var LineSeriesProperties = class extends CartesianSeriesProperties {
    constructor(){
        super(...arguments);
        this.stroke = "#874349";
        this.strokeWidth = 2;
        this.strokeOpacity = 1;
        this.lineDash = [
            0
        ];
        this.lineDashOffset = 0;
        this.interpolation = new InterpolationProperties();
        this.marker = new SeriesMarker();
        this.label = new Label();
        this.tooltip = makeSeriesTooltip();
        this.connectMissingData = false;
        this.sparklineMode = false;
    }
};
__decorateClass([
    Property
], LineSeriesProperties.prototype, "xKey", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "yKey", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "xName", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "yName", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "stackGroup", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "title", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "stroke", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "interpolation", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "marker", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "label", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "connectMissingData", 2);
__decorateClass([
    Property
], LineSeriesProperties.prototype, "sparklineMode", 2);
// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts
var CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR = 0.25;
var memoizedAggregateLineData2 = simpleMemorize2(aggregateLineData);
var LineSeries = class extends CartesianSeries {
    get pickModeAxis() {
        return this.properties.sparklineMode ? "main" : "main-category";
    }
    async processData(dataController) {
        var _this_axes_x, _this_axes_y;
        if (this.data == null) return;
        const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 0 } = {} } = this;
        const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;
        const animationEnabled = !this.ctx.animationManager.isSkipped();
        const xScale = (_this_axes_x = this.axes["x" /* X */ ]) === null || _this_axes_x === void 0 ? void 0 : _this_axes_x.scale;
        const yScale = (_this_axes_y = this.axes["y" /* Y */ ]) === null || _this_axes_y === void 0 ? void 0 : _this_axes_y.scale;
        const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({
            xScale,
            yScale
        });
        const stacked = stackCount > 1 || normalizedTo != null;
        const common = {
            invalidValue: null
        };
        if (connectMissingData && stacked) {
            common.invalidValue = 0;
        }
        if (stacked && !visible) {
            common.forceValue = 0;
        }
        const props = [];
        if (!isContinuousX || stacked) {
            props.push(keyProperty(xKey, xScaleType, {
                id: "xKey"
            }));
        }
        props.push(valueProperty(xKey, xScaleType, {
            id: "xValue"
        }), valueProperty(yKey, yScaleType, {
            id: "yValueRaw",
            ...common,
            invalidValue: void 0
        }));
        if (yFilterKey != null) {
            props.push(valueProperty(yFilterKey, yScaleType, {
                id: "yFilterRaw"
            }));
        }
        if (stacked) {
            const ids = [
                "line-stack-".concat(groupIndex, "-yValues"),
                "line-stack-".concat(groupIndex, "-yValues-trailing"),
                "line-stack-".concat(groupIndex, "-yValues-marker")
            ];
            props.push(...groupAccumulativeValueProperty(yKey, "window", "current", {
                id: "yValueEnd",
                ...common,
                groupId: ids[0]
            }, yScaleType), ...groupAccumulativeValueProperty(yKey, "window-trailing", "current", {
                id: "yValueStart",
                ...common,
                groupId: ids[1]
            }, yScaleType), ...groupAccumulativeValueProperty(yKey, "normal", "current", {
                id: "yValueCumulative",
                ...common,
                groupId: ids[2]
            }, yScaleType));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDefined"])(normalizedTo)) {
                props.push(normaliseGroupTo([
                    ids[0],
                    ids[1],
                    ids[2]
                ], normalizedTo));
            }
        }
        if (animationEnabled) {
            props.push(animationValidation(isContinuousX ? [
                "xValue"
            ] : void 0));
            if (this.processedData) {
                props.push(diff(this.id, this.processedData));
            }
        }
        const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
            props,
            groupByKeys: stacked,
            groupByData: !stacked
        });
        this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
        this.animationState.transition("updateData");
    }
    xCoordinateRange(xValue, pixelSize) {
        const { marker } = this.properties;
        const x = this.axes["x" /* X */ ].scale.convert(xValue);
        const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
        return [
            x - r,
            x + r
        ];
    }
    yCoordinateRange(yValues, pixelSize) {
        const { marker } = this.properties;
        const y = this.axes["y" /* Y */ ].scale.convert(yValues[0]);
        const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
        return [
            y - r,
            y + r
        ];
    }
    getSeriesDomain(direction) {
        var _this_dataModel;
        const { dataModel, processedData } = this;
        if (!dataModel || !processedData) return [];
        if (direction === "x" /* X */ ) {
            const xDef = dataModel.resolveProcessedDataDefById(this, "xValue");
            const domain = dataModel.getDomain(this, "xValue", "value", processedData);
            if ((xDef === null || xDef === void 0 ? void 0 : xDef.def.type) === "value" && xDef.def.valueType === "category") {
                return domain;
            }
            return fixNumericExtent(extent(domain));
        }
        const yKey = ((_this_dataModel = this.dataModel) === null || _this_dataModel === void 0 ? void 0 : _this_dataModel.hasColumnById(this, "yValueEnd")) ? "yValueEnd" : "yValueRaw";
        const yExtent = this.domainForClippedRange("y" /* Y */ , [
            yKey
        ], "xValue");
        return fixNumericExtent(yExtent);
    }
    getSeriesRange(_direction, visibleRange) {
        var _this_dataModel;
        const yKey = ((_this_dataModel = this.dataModel) === null || _this_dataModel === void 0 ? void 0 : _this_dataModel.hasColumnById(this, "yValueEnd")) ? "yValueEnd" : "yValueRaw";
        return this.domainForVisibleRange("y" /* Y */ , [
            yKey
        ], "xValue", visibleRange);
    }
    getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
        var _this_dataModel;
        const yKey = ((_this_dataModel = this.dataModel) === null || _this_dataModel === void 0 ? void 0 : _this_dataModel.hasColumnById(this, "yValueEnd")) ? "yValueEnd" : "yValueRaw";
        return this.countVisibleItems("xValue", [
            yKey
        ], xVisibleRange, yVisibleRange, minVisibleItems);
    }
    aggregateData(dataModel, processedData) {
        if (processedData.type !== "ungrouped") return;
        if (processedDataIsAnimatable(processedData)) return;
        const xAxis = this.axes["x" /* X */ ];
        if (xAxis == null) return;
        const { scale: scale2 } = xAxis;
        const xValues = dataModel.resolveColumnById(this, "xValue", processedData);
        const yValues = dataModel.resolveColumnById(this, "yValueRaw", processedData);
        const domain = dataModel.getDomain(this, "xValue", "value", processedData);
        return memoizedAggregateLineData2(scale2.type, xValues, yValues, domain);
    }
    createNodeData() {
        var _this_dataModel;
        const { dataModel, processedData, axes, dataAggregationFilters } = this;
        const xAxis = axes["x" /* X */ ];
        const yAxis = axes["y" /* Y */ ];
        if (!dataModel || !processedData || !xAxis || !yAxis) return;
        const { xKey, yKey, yFilterKey, xName, yName, marker, label, connectMissingData, interpolation, legendItemName } = this.properties;
        const stacked = (_this_dataModel = this.dataModel) === null || _this_dataModel === void 0 ? void 0 : _this_dataModel.hasColumnById(this, "yValueEnd");
        const xScale = xAxis.scale;
        const yScale = yAxis.scale;
        var _xScale_bandwidth;
        const xOffset = ((_xScale_bandwidth = xScale.bandwidth) !== null && _xScale_bandwidth !== void 0 ? _xScale_bandwidth : 0) / 2;
        var _yScale_bandwidth;
        const yOffset = ((_yScale_bandwidth = yScale.bandwidth) !== null && _yScale_bandwidth !== void 0 ? _yScale_bandwidth : 0) / 2;
        const size = marker.enabled ? marker.size : 0;
        var _processedData_dataSources_get;
        const rawData = (_processedData_dataSources_get = processedData.dataSources.get(this.id)) !== null && _processedData_dataSources_get !== void 0 ? _processedData_dataSources_get : [];
        const xValues = dataModel.resolveColumnById(this, "xValue", processedData);
        const yValues = dataModel.resolveColumnById(this, "yValueRaw", processedData);
        const yEndValues = stacked ? dataModel.resolveColumnById(this, "yValueEnd", processedData) : void 0;
        const yCumulativeValues = stacked ? dataModel.resolveColumnById(this, "yValueCumulative", processedData) : yValues;
        const selectionValues = yFilterKey != null ? dataModel.resolveColumnById(this, "yFilterRaw", processedData) : void 0;
        const yDomain = this.getSeriesDomain("y" /* Y */ );
        const capDefaults = {
            lengthRatioMultiplier: this.properties.marker.getDiameter(),
            lengthMax: Infinity
        };
        const nodeData = [];
        const spanPoints = [];
        const handleDatum = (datumIndex)=>{
            const datum = rawData[datumIndex];
            const xDatum = xValues[datumIndex];
            const yDatum = yValues[datumIndex];
            const yEndDatum = yEndValues === null || yEndValues === void 0 ? void 0 : yEndValues[datumIndex];
            const selected = selectionValues === null || selectionValues === void 0 ? void 0 : selectionValues[datumIndex];
            const x = xScale.convert(xDatum) + xOffset;
            const y = yScale.convert(yCumulativeValues[datumIndex]) + yOffset;
            if (!Number.isFinite(x)) return;
            if (yDatum != null) {
                const labelText = label.enabled ? this.getLabelText(yDatum, datum, yKey, "y", yDomain, label, {
                    value: yDatum,
                    datum,
                    xKey,
                    yKey,
                    xName,
                    yName,
                    legendItemName
                }) : void 0;
                nodeData.push({
                    series: this,
                    datum,
                    datumIndex,
                    yKey,
                    xKey,
                    point: {
                        x,
                        y,
                        size
                    },
                    midPoint: {
                        x,
                        y
                    },
                    cumulativeValue: yEndDatum,
                    yValue: yDatum,
                    xValue: xDatum,
                    capDefaults,
                    labelText,
                    selected
                });
            }
            const currentSpanPoints = spanPoints[spanPoints.length - 1];
            if (yDatum != null) {
                const spanPoint = {
                    point: {
                        x,
                        y
                    },
                    xDatum,
                    yDatum
                };
                if (Array.isArray(currentSpanPoints)) {
                    currentSpanPoints.push(spanPoint);
                } else if (currentSpanPoints != null) {
                    currentSpanPoints.skip += 1;
                    spanPoints.push([
                        spanPoint
                    ]);
                } else {
                    spanPoints.push([
                        spanPoint
                    ]);
                }
            } else if (!connectMissingData) {
                if (Array.isArray(currentSpanPoints) || currentSpanPoints == null) {
                    spanPoints.push({
                        skip: 0
                    });
                } else {
                    currentSpanPoints.skip += 1;
                }
            }
        };
        const [r0, r1] = xScale.range;
        const range3 = Math.abs(r1 - r0);
        const dataAggregationFilter = dataAggregationFilters === null || dataAggregationFilters === void 0 ? void 0 : dataAggregationFilters.find((f)=>f.maxRange > range3);
        const indices = dataAggregationFilter === null || dataAggregationFilter === void 0 ? void 0 : dataAggregationFilter.indices;
        let [start2, end2] = this.visibleRangeIndices("xValue", xAxis.range, indices);
        start2 = Math.max(start2 - 1, 0);
        var _indices_length;
        end2 = Math.min(end2 + 1, (_indices_length = indices === null || indices === void 0 ? void 0 : indices.length) !== null && _indices_length !== void 0 ? _indices_length : xValues.length);
        if (processedData.input.count < 1e3) {
            start2 = 0;
            end2 = processedData.input.count;
        }
        for(let i = start2; i < end2; i += 1){
            var _indices_i;
            handleDatum((_indices_i = indices === null || indices === void 0 ? void 0 : indices[i]) !== null && _indices_i !== void 0 ? _indices_i : i);
        }
        const strokeSpans = spanPoints.flatMap((p)=>{
            return Array.isArray(p) ? interpolatePoints(p, interpolation) : [];
        });
        const strokeData = {
            itemId: yKey,
            spans: strokeSpans
        };
        var _selectionValues_some;
        const crossFiltering = (_selectionValues_some = selectionValues === null || selectionValues === void 0 ? void 0 : selectionValues.some((selectionValue, index)=>selectionValue === yValues[index])) !== null && _selectionValues_some !== void 0 ? _selectionValues_some : false;
        return {
            itemId: yKey,
            nodeData,
            labelData: nodeData,
            strokeData,
            scales: this.calculateScaling(),
            visible: this.visible,
            crossFiltering
        };
    }
    isPathOrSelectionDirty() {
        return this.properties.marker.isDirty();
    }
    updatePathNodes(opts) {
        var _this_contextNodeData;
        const { paths: [lineNode], visible, animationEnabled } = opts;
        const crossFiltering = ((_this_contextNodeData = this.contextNodeData) === null || _this_contextNodeData === void 0 ? void 0 : _this_contextNodeData.crossFiltering) === true;
        const { strokeWidth, stroke: stroke2, strokeOpacity, lineDash, lineDashOffset, opacity } = mergeDefaults(this.getHighlightStyle(), this.properties);
        lineNode.setProperties({
            fill: void 0,
            lineJoin: "round",
            pointerEvents: 1 /* None */ ,
            opacity,
            stroke: stroke2,
            strokeWidth,
            strokeOpacity: strokeOpacity * (crossFiltering ? CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR : 1),
            lineDash,
            lineDashOffset
        });
        if (!animationEnabled) {
            lineNode.visible = visible;
        }
        updateClipPath(this, lineNode);
    }
    updateDatumSelection(opts) {
        var _this_contextNodeData;
        let { nodeData } = opts;
        const { datumSelection } = opts;
        const markersEnabled = this.properties.marker.enabled || ((_this_contextNodeData = this.contextNodeData) === null || _this_contextNodeData === void 0 ? void 0 : _this_contextNodeData.crossFiltering) === true;
        nodeData = markersEnabled ? nodeData : [];
        if (this.properties.marker.isDirty()) {
            datumSelection.clear();
            datumSelection.cleanup();
        }
        return datumSelection.update(nodeData, void 0, (datum)=>createDatumId(datum.xValue));
    }
    updateDatumNodes(opts) {
        const { datumSelection, isHighlight } = opts;
        const { xKey, yKey, marker, stroke: stroke2, strokeWidth, strokeOpacity } = this.properties;
        const xDomain = this.getSeriesDomain("x" /* X */ );
        const yDomain = this.getSeriesDomain("y" /* Y */ );
        const applyTranslation = this.ctx.animationManager.isSkipped();
        const fillBBox = this.getShapeFillBBox();
        datumSelection.each((node, datum)=>{
            const { xValue, yValue } = datum;
            const params = datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain);
            const style = this.getMarkerStyle(marker, datum, params, isHighlight, void 0, {
                stroke: stroke2,
                strokeWidth,
                strokeOpacity
            });
            this.applyMarkerStyle(style, node, datum.point, fillBBox, {
                applyTranslation,
                selected: datum.selected
            });
        });
        if (!isHighlight) {
            marker.markClean();
        }
    }
    updateLabelSelection(opts) {
        return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);
    }
    updateLabelNodes(opts) {
        var _this_ctx_highlightManager;
        const { isHighlight = false } = opts;
        const activeHighlight = (_this_ctx_highlightManager = this.ctx.highlightManager) === null || _this_ctx_highlightManager === void 0 ? void 0 : _this_ctx_highlightManager.getActiveHighlight();
        opts.labelSelection.each((text, datum)=>{
            const highlighted = isHighlight || this.isSeriesHighlighted(activeHighlight);
            const highlightState = this.getHighlightStateString(activeHighlight, highlighted, datum.datumIndex);
            const style = getLabelStyles(this, datum, this.properties, this.properties.label, highlighted, highlightState);
            const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color: color11 } = style;
            if (enabled && (datum === null || datum === void 0 ? void 0 : datum.labelText)) {
                text.fontStyle = fontStyle;
                text.fontWeight = fontWeight;
                text.fontSize = fontSize;
                text.fontFamily = fontFamily;
                text.textAlign = "center";
                text.textBaseline = "bottom";
                text.text = datum.labelText;
                text.x = datum.point.x;
                text.y = datum.point.y - 10;
                text.fill = color11;
                text.visible = true;
                var _this_getHighlightStyle_opacity;
                text.fillOpacity = (_this_getHighlightStyle_opacity = this.getHighlightStyle(isHighlight, datum.datumIndex).opacity) !== null && _this_getHighlightStyle_opacity !== void 0 ? _this_getHighlightStyle_opacity : 1;
                text.setBoxing(style);
            } else {
                text.visible = false;
            }
        });
    }
    getTooltipContent(datumIndex) {
        var _processedData_dataSources_get;
        const { id: seriesId, dataModel, processedData, axes, properties } = this;
        const { xKey, xName, yKey, yName, tooltip, legendItemName } = properties;
        const xAxis = axes["x" /* X */ ];
        const yAxis = axes["y" /* Y */ ];
        if (!dataModel || !processedData || !xAxis || !yAxis) return;
        const datum = (_processedData_dataSources_get = processedData.dataSources.get(this.id)) === null || _processedData_dataSources_get === void 0 ? void 0 : _processedData_dataSources_get[datumIndex];
        const xValue = dataModel.resolveColumnById(this, "xValue", processedData)[datumIndex];
        const yValue = dataModel.resolveColumnById(this, "yValueRaw", processedData)[datumIndex];
        if (xValue == null) return;
        const xDomain = this.getSeriesDomain("x" /* X */ );
        const yDomain = this.getSeriesDomain("y" /* Y */ );
        const params = datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain);
        const format = this.getMarkerStyle(this.properties.marker, {
            datumIndex,
            datum
        }, params, false);
        return this.formatTooltipWithContext(tooltip, {
            heading: this.getAxisValueText(xAxis, "tooltip", xValue, datum, xKey, legendItemName),
            symbol: this.legendItemSymbol(),
            data: [
                {
                    label: yName,
                    fallbackLabel: yKey,
                    value: this.getAxisValueText(yAxis, "tooltip", yValue, datum, yKey, legendItemName)
                }
            ]
        }, {
            seriesId,
            datum,
            title: yName,
            xKey,
            xName,
            yKey,
            yName,
            ...format,
            ...this.getModuleTooltipParams()
        });
    }
    legendItemSymbol() {
        const color0 = "rgba(0, 0, 0, 0)";
        const { stroke: stroke2, strokeOpacity, strokeWidth, lineDash, marker } = this.properties;
        var _marker_fill, _marker_stroke, _ref;
        const markerStyle = this.getMarkerStyle(marker, {}, void 0, false, {
            size: marker.size,
            fill: (_marker_fill = marker.fill) !== null && _marker_fill !== void 0 ? _marker_fill : color0,
            stroke: (_ref = (_marker_stroke = marker.stroke) !== null && _marker_stroke !== void 0 ? _marker_stroke : stroke2) !== null && _ref !== void 0 ? _ref : color0
        }, void 0, false);
        return {
            marker: {
                ...markerStyle,
                enabled: marker.enabled
            },
            line: {
                stroke: stroke2 !== null && stroke2 !== void 0 ? stroke2 : color0,
                strokeOpacity,
                strokeWidth,
                lineDash
            }
        };
    }
    getLegendData(legendType) {
        if (legendType !== "category") {
            return [];
        }
        const { id: seriesId, ctx: { legendManager }, visible } = this;
        const { yKey: itemId, yName, title, legendItemName, showInLegend } = this.properties;
        var _ref, _ref1;
        return [
            {
                legendType: "category",
                id: seriesId,
                itemId,
                legendItemName,
                seriesId,
                enabled: visible && legendManager.getItemEnabled({
                    seriesId,
                    itemId
                }),
                label: {
                    text: (_ref1 = (_ref = legendItemName !== null && legendItemName !== void 0 ? legendItemName : title) !== null && _ref !== void 0 ? _ref : yName) !== null && _ref1 !== void 0 ? _ref1 : itemId
                },
                symbol: this.legendItemSymbol(),
                hideInLegend: !showInLegend
            }
        ];
    }
    updatePaths(opts) {
        this.updateLinePaths(opts.paths, opts.contextData);
    }
    updateLinePaths(paths, contextData) {
        const spans = contextData.strokeData.spans;
        const [lineNode] = paths;
        lineNode.path.clear();
        plotLinePathStroke(lineNode, spans);
        lineNode.markDirty("LineSeries");
    }
    animateEmptyUpdateReady(animationData) {
        const { datumSelection, labelSelection, annotationSelections, contextData, paths } = animationData;
        const { animationManager } = this.ctx;
        this.updateLinePaths(paths, contextData);
        pathSwipeInAnimation(this, animationManager, ...paths);
        resetMotion([
            datumSelection
        ], resetMarkerPositionFn);
        markerSwipeScaleInAnimation(this, animationManager, datumSelection);
        seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
        seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
    }
    animateReadyResize(animationData) {
        const { contextData, paths } = animationData;
        this.updateLinePaths(paths, contextData);
        super.animateReadyResize(animationData);
    }
    animateWaitingUpdateReady(animationData) {
        var _this_processedData_reduced_diff, _this_processedData_reduced, _this_processedData;
        const { animationManager } = this.ctx;
        const { datumSelection, labelSelection: labelSelections, annotationSelections, contextData, paths, previousContextData } = animationData;
        const [path] = paths;
        if (contextData.visible === false && (previousContextData === null || previousContextData === void 0 ? void 0 : previousContextData.visible) === false) return;
        this.resetDatumAnimation(animationData);
        this.resetLabelAnimation(animationData);
        const update = ()=>{
            this.resetPathAnimation(animationData);
            this.updateLinePaths(paths, contextData);
        };
        const skip = ()=>{
            animationManager.skipCurrentBatch();
            update();
        };
        if (contextData == null || previousContextData == null) {
            update();
            markerFadeInAnimation(this, animationManager, "added", datumSelection);
            pathFadeInAnimation(this, "path_properties", animationManager, "add", path);
            seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
            seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
            return;
        }
        if (contextData.crossFiltering !== previousContextData.crossFiltering) {
            skip();
            return;
        }
        const fns = prepareLinePathAnimation(contextData, previousContextData, (_this_processedData = this.processedData) === null || _this_processedData === void 0 ? void 0 : (_this_processedData_reduced = _this_processedData.reduced) === null || _this_processedData_reduced === void 0 ? void 0 : (_this_processedData_reduced_diff = _this_processedData_reduced.diff) === null || _this_processedData_reduced_diff === void 0 ? void 0 : _this_processedData_reduced_diff[this.id]);
        if (fns === void 0) {
            skip();
            return;
        } else if (fns.status === "no-op") {
            return;
        }
        fromToMotion(this.id, "path_properties", animationManager, [
            path
        ], fns.stroke.pathProperties);
        if (fns.status === "added") {
            this.updateLinePaths(paths, contextData);
        } else if (fns.status === "removed") {
            this.updateLinePaths(paths, previousContextData);
        } else {
            pathMotion(this.id, "path_update", animationManager, [
                path
            ], fns.stroke.path);
        }
        if (fns.hasMotion) {
            markerFadeInAnimation(this, animationManager, void 0, datumSelection);
            seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
            seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
        }
    }
    isLabelEnabled() {
        return this.properties.label.enabled;
    }
    getBandScalePadding() {
        return {
            inner: 1,
            outer: 0.1
        };
    }
    nodeFactory() {
        return new Marker();
    }
    getFormattedMarkerStyle(datum) {
        const { xKey, yKey } = this.properties;
        const { xValue, yValue } = datum;
        const xDomain = this.getSeriesDomain("x" /* X */ );
        const yDomain = this.getSeriesDomain("y" /* Y */ );
        return this.getMarkerStyle(this.properties.marker, datum, datumStylerProperties(xValue, yValue, xKey, yKey, xDomain, yDomain), true);
    }
    computeFocusBounds(opts) {
        return computeMarkerFocusBounds(this, opts);
    }
    hasItemStylers() {
        return this.properties.marker.itemStyler != null || this.properties.label.itemStyler != null;
    }
    constructor(moduleCtx){
        super({
            moduleCtx,
            propertyKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
            propertyNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
            categoryKey: "xValue",
            pickModes: [
                2 /* AXIS_ALIGNED */ ,
                1 /* NEAREST_NODE */ ,
                0 /* EXACT_SHAPE_MATCH */ 
            ],
            datumSelectionGarbageCollection: false,
            animationResetFns: {
                path: buildResetPathFn({
                    getVisible: ()=>this.visible,
                    getOpacity: ()=>this.getOpacity()
                }),
                label: resetLabelFn,
                datum: (node, datum)=>({
                        ...resetMarkerFn(node),
                        ...resetMarkerPositionFn(node, datum)
                    })
            },
            clipFocusBox: false
        });
        this.properties = new LineSeriesProperties();
        this.dataAggregationFilters = void 0;
    }
};
LineSeries.className = "LineSeries";
LineSeries.type = "line";
// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts
var LineSeriesModule = {
    type: "series",
    optionsKey: "series[]",
    packageType: "community",
    chartTypes: [
        "cartesian"
    ],
    identifier: "line",
    moduleFactory: (ctx)=>new LineSeries(ctx),
    stackable: true,
    defaultAxes: [
        {
            type: "number" /* NUMBER */ ,
            position: "left" /* LEFT */ 
        },
        {
            type: "category" /* CATEGORY */ ,
            position: "bottom" /* BOTTOM */ 
        }
    ],
    themeTemplate: {
        series: {
            stroke: SAFE_STROKE_FILL_OPERATION,
            strokeWidth: 2,
            strokeOpacity: 1,
            lineDash: [
                0
            ],
            lineDashOffset: 0,
            interpolation: {
                type: "linear"
            },
            marker: {
                shape: "circle",
                size: 7,
                strokeWidth: {
                    $isUserOption: [
                        "./stroke",
                        1,
                        0
                    ]
                },
                fill: {
                    $palette: "fill"
                },
                stroke: {
                    $palette: "stroke"
                },
                // @ts-expect-error undocumented option
                fillGradientDefaults: FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
                fillPatternDefaults: FILL_PATTERN_DEFAULTS,
                fillImageDefaults: FILL_IMAGE_DEFAULTS
            },
            label: {
                ...LABEL_BOXING_DEFAULTS,
                enabled: false,
                fontSize: {
                    $ref: "fontSize"
                },
                fontFamily: {
                    $ref: "fontFamily"
                },
                fontWeight: {
                    $ref: "fontWeight"
                },
                color: {
                    $ref: "textColor"
                }
            },
            errorBar: {
                cap: {
                    lengthRatio: 1
                }
            },
            tooltip: {
                range: {
                    $path: [
                        "/tooltip/range",
                        "nearest"
                    ]
                },
                position: {
                    anchorTo: {
                        $path: [
                            "/tooltip/position/anchorTo",
                            "node"
                        ]
                    }
                }
            },
            highlight: multiSeriesHighlightStyle()
        }
    }
};
var NewLineSeriesModule = {
    type: "series",
    name: "line",
    chartType: "cartesian",
    options: lineSeriesOptionsDef,
    create: (ctx)=>new LineSeries(ctx)
};
// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts
var ScatterSeries = class extends BubbleSeries {
};
ScatterSeries.className = "ScatterSeries";
ScatterSeries.type = "scatter";
// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts
var ScatterSeriesModule = {
    type: "series",
    optionsKey: "series[]",
    packageType: "community",
    chartTypes: [
        "cartesian"
    ],
    identifier: "scatter",
    moduleFactory: (ctx)=>new ScatterSeries(ctx),
    defaultAxes: [
        {
            type: "number" /* NUMBER */ ,
            position: "bottom" /* BOTTOM */ 
        },
        {
            type: "number" /* NUMBER */ ,
            position: "left" /* LEFT */ 
        }
    ],
    themeTemplate: {
        series: {
            shape: "circle",
            size: 7,
            fill: {
                $palette: "fill"
            },
            stroke: {
                $palette: "stroke"
            },
            // @ts-expect-error undocumented option
            fillGradientDefaults: FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
            fillPatternDefaults: FILL_PATTERN_DEFAULTS,
            fillImageDefaults: FILL_IMAGE_DEFAULTS,
            fillOpacity: 0.8,
            maxRenderedItems: 1e4,
            label: {
                ...LABEL_BOXING_DEFAULTS,
                enabled: false,
                fontSize: {
                    $ref: "fontSize"
                },
                fontFamily: {
                    $ref: "fontFamily"
                },
                fontWeight: {
                    $ref: "fontWeight"
                },
                color: {
                    $ref: "textColor"
                }
            },
            errorBar: {
                cap: {
                    lengthRatio: 1
                }
            },
            tooltip: {
                range: {
                    $path: [
                        "/tooltip/range",
                        "nearest"
                    ]
                },
                position: {
                    anchorTo: {
                        $path: [
                            "/tooltip/position/anchorTo",
                            "node"
                        ]
                    }
                }
            },
            highlight: multiSeriesHighlightStyle()
        }
    }
};
var NewScatterSeriesModule = {
    type: "series",
    name: "scatter",
    chartType: "cartesian",
    options: scatterSeriesOptionsDef,
    create: (ctx)=>new ScatterSeries(ctx)
};
;
// packages/ag-charts-community/src/scene/sectorBox.ts
var SectorBox = class _SectorBox {
    clone() {
        const { startAngle, endAngle, innerRadius, outerRadius } = this;
        return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);
    }
    equals(other) {
        return this.startAngle === other.startAngle && this.endAngle === other.endAngle && this.innerRadius === other.innerRadius && this.outerRadius === other.outerRadius;
    }
    [interpolate](other, d) {
        return new _SectorBox(this.startAngle * (1 - d) + other.startAngle * d, this.endAngle * (1 - d) + other.endAngle * d, this.innerRadius * (1 - d) + other.innerRadius * d, this.outerRadius * (1 - d) + other.outerRadius * d);
    }
    constructor(startAngle, endAngle, innerRadius, outerRadius){
        this.startAngle = startAngle;
        this.endAngle = endAngle;
        this.innerRadius = innerRadius;
        this.outerRadius = outerRadius;
    }
};
// packages/ag-charts-community/src/scene/util/sector.ts
function sectorBox(param) {
    let { startAngle, endAngle, innerRadius, outerRadius } = param;
    let x0 = Infinity;
    let y0 = Infinity;
    let x1 = -Infinity;
    let y1 = -Infinity;
    const addPoint = (x, y)=>{
        x0 = Math.min(x, x0);
        y0 = Math.min(y, y0);
        x1 = Math.max(x, x1);
        y1 = Math.max(y, y1);
    };
    addPoint(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));
    addPoint(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));
    addPoint(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));
    addPoint(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));
    if (isBetweenAngles(0, startAngle, endAngle)) {
        addPoint(outerRadius, 0);
    }
    if (isBetweenAngles(Math.PI * 0.5, startAngle, endAngle)) {
        addPoint(0, outerRadius);
    }
    if (isBetweenAngles(Math.PI, startAngle, endAngle)) {
        addPoint(-outerRadius, 0);
    }
    if (isBetweenAngles(Math.PI * 1.5, startAngle, endAngle)) {
        addPoint(0, -outerRadius);
    }
    return new BBox(x0, y0, x1 - x0, y1 - y0);
}
function isPointInSector(x, y, sector) {
    const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    const { innerRadius, outerRadius } = sector;
    if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {
        return false;
    }
    const startAngle = normalizeAngle180(sector.startAngle);
    const endAngle = normalizeAngle180(sector.endAngle);
    const angle2 = Math.atan2(y, x);
    return startAngle < endAngle ? angle2 <= endAngle && angle2 >= startAngle : angle2 <= endAngle && angle2 >= -Math.PI || angle2 >= startAngle && angle2 <= Math.PI;
}
function arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {
    if (isNaN(cx) || isNaN(cy)) {
        return 0;
    }
    if (counterClockwise) {
        [endAngle, startAngle] = [
            startAngle,
            endAngle
        ];
    }
    const k = (y2 - y1) / (x2 - x1);
    const y0 = y1 - k * x1;
    const a = Math.pow(k, 2) + 1;
    const b = 2 * (k * (y0 - cy) - cx);
    const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);
    const d = Math.pow(b, 2) - 4 * a * c;
    if (d < 0) {
        return 0;
    }
    const i1x = (-b + Math.sqrt(d)) / 2 / a;
    const i2x = (-b - Math.sqrt(d)) / 2 / a;
    let intersections = 0;
    [
        i1x,
        i2x
    ].forEach((x)=>{
        const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);
        if (!isXInsideLine) {
            return;
        }
        const y = k * x + y0;
        const adjacent = x - cx;
        const opposite = y - cy;
        const angle2 = Math.atan2(opposite, adjacent);
        if (isBetweenAngles(angle2, startAngle, endAngle)) {
            intersections++;
        }
    });
    return intersections;
}
function lineCollidesSector(line, sector) {
    const { startAngle, endAngle, innerRadius, outerRadius } = sector;
    const outerStart = {
        x: outerRadius * Math.cos(startAngle),
        y: outerRadius * Math.sin(startAngle)
    };
    const outerEnd = {
        x: outerRadius * Math.cos(endAngle),
        y: outerRadius * Math.sin(endAngle)
    };
    const innerStart = innerRadius === 0 ? {
        x: 0,
        y: 0
    } : {
        x: innerRadius * Math.cos(startAngle),
        y: innerRadius * Math.sin(startAngle)
    };
    const innerEnd = innerRadius === 0 ? {
        x: 0,
        y: 0
    } : {
        x: innerRadius * Math.cos(endAngle),
        y: innerRadius * Math.sin(endAngle)
    };
    return segmentIntersection(line.start.x, line.start.y, line.end.x, line.end.y, outerStart.x, outerStart.y, innerStart.x, innerStart.y) || segmentIntersection(line.start.x, line.start.y, line.end.x, line.end.y, outerEnd.x, outerEnd.y, innerEnd.x, innerEnd.y) || arcIntersections(0, 0, outerRadius, startAngle, endAngle, true, line.start.x, line.start.y, line.end.x, line.end.y);
}
function boxCollidesSector(box, sector) {
    const topLeft = {
        x: box.x,
        y: box.y
    };
    const topRight = {
        x: box.x + box.width,
        y: box.y
    };
    const bottomLeft = {
        x: box.x,
        y: box.y + box.height
    };
    const bottomRight = {
        x: box.x + box.width,
        y: box.y + box.height
    };
    return lineCollidesSector({
        start: topLeft,
        end: topRight
    }, sector) || lineCollidesSector({
        start: bottomLeft,
        end: bottomRight
    }, sector);
}
function radiiScalingFactor(r, sweep, a, b) {
    if (a === 0 && b === 0) return 0;
    const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;
    if (fs1 < 0) return 1;
    let start2 = 0;
    let end2 = 1;
    for(let i = 0; i < 8; i += 1){
        const s = (start2 + end2) / 2;
        const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;
        if (fs < 0) {
            start2 = s;
        } else {
            end2 = s;
        }
    }
    return start2;
}
var delta2 = 1e-6;
function clockwiseAngle(angle2, relativeToStartAngle) {
    if (angleBetween(angle2, relativeToStartAngle) < delta2) {
        return relativeToStartAngle;
    } else {
        return normalizeAngle360(angle2 - relativeToStartAngle) + relativeToStartAngle;
    }
}
function clockwiseAngles(startAngle, endAngle) {
    let relativeToStartAngle = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;
    const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);
    startAngle = clockwiseAngle(startAngle, relativeToStartAngle);
    endAngle = startAngle + sweepAngle;
    return {
        startAngle,
        endAngle
    };
}
function arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {
    const sinA = Math.sin(clipAngle);
    const cosA = Math.cos(clipAngle);
    const c = cx ** 2 + cy ** 2 - r ** 2;
    let p0x;
    let p0y;
    let p1x;
    let p1y;
    if (cosA > 0.5) {
        const tanA = sinA / cosA;
        const a = 1 + tanA ** 2;
        const b = -2 * (cx + cy * tanA);
        const d = b ** 2 - 4 * a * c;
        if (d < 0) return;
        const x0 = (-b + Math.sqrt(d)) / (2 * a);
        const x1 = (-b - Math.sqrt(d)) / (2 * a);
        p0x = x0;
        p0y = x0 * tanA;
        p1x = x1;
        p1y = x1 * tanA;
    } else {
        const cotA = cosA / sinA;
        const a = 1 + cotA ** 2;
        const b = -2 * (cy + cx * cotA);
        const d = b ** 2 - 4 * a * c;
        if (d < 0) return;
        const y0 = (-b + Math.sqrt(d)) / (2 * a);
        const y1 = (-b - Math.sqrt(d)) / (2 * a);
        p0x = y0 * cotA;
        p0y = y0;
        p1x = y1 * cotA;
        p1y = y1;
    }
    const normalisedX = cosA;
    const normalisedY = sinA;
    const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;
    const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;
    const a0 = p0DotNormalized > 0 ? clockwiseAngle(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;
    const a1 = p1DotNormalized > 0 ? clockwiseAngle(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;
    if (a0 >= startAngle && a0 <= endAngle) {
        return a0;
    } else if (a1 >= startAngle && a1 <= endAngle) {
        return a1;
    }
}
function arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {
    const d = Math.hypot(cx, cy);
    const d1 = (d ** 2 - r ** 2 + circleR ** 2) / (2 * d);
    const d2 = d - d1;
    const theta = Math.atan2(cy, cx);
    const deltaTheta = Math.acos(-d2 / r);
    const a0 = clockwiseAngle(theta + deltaTheta, startAngle);
    const a1 = clockwiseAngle(theta - deltaTheta, startAngle);
    if (a0 >= startAngle && a0 <= endAngle) {
        return a0;
    } else if (a1 >= startAngle && a1 <= endAngle) {
        return a1;
    }
}
// packages/ag-charts-community/src/scene/shape/sector.ts
var Arc = class {
    isValid() {
        return Number.isFinite(this.a0) && Number.isFinite(this.a1);
    }
    pointAt(a) {
        return {
            x: this.cx + this.r * Math.cos(a),
            y: this.cy + this.r * Math.sin(a)
        };
    }
    clipStart(a) {
        if (a == null || !this.isValid() || a < this.a0) return;
        this.a0 = a;
        if (Number.isNaN(a) || this.a0 >= this.a1) {
            this.a0 = NaN;
            this.a1 = NaN;
        }
    }
    clipEnd(a) {
        if (a == null || !this.isValid() || a > this.a1) return;
        this.a1 = a;
        if (Number.isNaN(a) || this.a0 >= this.a1) {
            this.a0 = NaN;
            this.a1 = NaN;
        }
    }
    constructor(cx, cy, r, a0, a1){
        this.cx = cx;
        this.cy = cy;
        this.r = r;
        this.a0 = a0;
        this.a1 = a1;
        if (this.a0 >= this.a1) {
            this.a0 = NaN;
            this.a1 = NaN;
        }
    }
};
var Sector = class extends Path {
    set inset(value) {
        this.concentricEdgeInset = value;
        this.radialEdgeInset = value;
    }
    set cornerRadius(value) {
        this.startOuterCornerRadius = value;
        this.endOuterCornerRadius = value;
        this.startInnerCornerRadius = value;
        this.endInnerCornerRadius = value;
    }
    computeBBox() {
        return sectorBox(this).translate(this.centerX, this.centerY);
    }
    normalizedRadii() {
        const { concentricEdgeInset } = this;
        let { innerRadius, outerRadius } = this;
        innerRadius = innerRadius > 0 ? innerRadius + concentricEdgeInset : 0;
        outerRadius = Math.max(outerRadius - concentricEdgeInset, 0);
        return {
            innerRadius,
            outerRadius
        };
    }
    normalizedClipSector() {
        const { clipSector } = this;
        if (clipSector == null) return;
        const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
        const { innerRadius, outerRadius } = this.normalizedRadii();
        const clipAngles = clockwiseAngles(clipSector.startAngle, clipSector.endAngle, startAngle);
        return new SectorBox(Math.max(startAngle, clipAngles.startAngle), Math.min(endAngle, clipAngles.endAngle), Math.max(innerRadius, clipSector.innerRadius), Math.min(outerRadius, clipSector.outerRadius));
    }
    getAngleOffset(radius) {
        return radius > 0 ? this.radialEdgeInset / radius : 0;
    }
    arc(r, angleSweep, a0, a1, outerArc, innerArc, start2, inner) {
        if (r <= 0) return;
        const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
        const { innerRadius, outerRadius } = this.normalizedRadii();
        const clipSector = this.normalizedClipSector();
        if (inner && innerRadius <= 0) return;
        const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);
        const angle2 = start2 ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;
        const radius = inner ? innerRadius + r : outerRadius - r;
        const cx = radius * Math.cos(angle2);
        const cy = radius * Math.sin(angle2);
        if (clipSector != null) {
            const delta3 = 1e-6;
            if (!start2 && !(angle2 >= startAngle - delta3 && angle2 <= clipSector.endAngle - delta3)) return;
            if (start2 && !(angle2 >= clipSector.startAngle + delta3 && angle2 <= endAngle - delta3)) return;
            if (inner && radius < clipSector.innerRadius - delta3) return;
            if (!inner && radius > clipSector.outerRadius + delta3) return;
        }
        const arc = new Arc(cx, cy, r, a0, a1);
        if (clipSector != null) {
            if (inner) {
                arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));
                arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));
            } else {
                arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));
                arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));
            }
            let circleClipStart;
            let circleClipEnd;
            if (start2) {
                circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);
                circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);
            } else {
                circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);
                circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);
            }
            arc.clipStart(circleClipStart);
            arc.clipEnd(circleClipEnd);
            if (circleClipStart != null) {
                const { x: x2, y: y2 } = arc.pointAt(circleClipStart);
                const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);
                if (start2) {
                    innerArc === null || innerArc === void 0 ? void 0 : innerArc.clipStart(theta2);
                } else {
                    outerArc.clipEnd(theta2);
                }
            }
            if (circleClipEnd != null) {
                const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);
                const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);
                if (start2) {
                    outerArc.clipStart(theta2);
                } else {
                    innerArc === null || innerArc === void 0 ? void 0 : innerArc.clipEnd(theta2);
                }
            }
        }
        if (clipSector != null) {
            const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);
            if (!isPointInSector(x2, y2, clipSector)) return;
        }
        const { x, y } = arc.pointAt(start2 === inner ? arc.a0 : arc.a1);
        const theta = clockwiseAngle(Math.atan2(y, x), startAngle);
        const radialArc = inner ? innerArc : outerArc;
        if (start2) {
            radialArc === null || radialArc === void 0 ? void 0 : radialArc.clipStart(theta);
        } else {
            radialArc === null || radialArc === void 0 ? void 0 : radialArc.clipEnd(theta);
        }
        return arc;
    }
    updatePath() {
        const delta3 = 1e-6;
        const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;
        let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;
        const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
        const { innerRadius, outerRadius } = this.normalizedRadii();
        const clipSector = this.normalizedClipSector();
        const sweepAngle = endAngle - startAngle;
        const fullPie = sweepAngle >= 2 * Math.PI - delta3;
        path.clear();
        var _clipSector_startAngle, _clipSector_endAngle;
        if (innerRadius === 0 && outerRadius === 0 || innerRadius > outerRadius) {
            return;
        } else if (((_clipSector_startAngle = clipSector === null || clipSector === void 0 ? void 0 : clipSector.startAngle) !== null && _clipSector_startAngle !== void 0 ? _clipSector_startAngle : startAngle) === ((_clipSector_endAngle = clipSector === null || clipSector === void 0 ? void 0 : clipSector.endAngle) !== null && _clipSector_endAngle !== void 0 ? _clipSector_endAngle : endAngle)) {
            return;
        } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {
            path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));
            path.arc(centerX, centerY, outerRadius, startAngle, endAngle);
            if (innerRadius > concentricEdgeInset) {
                path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));
                path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
            }
            path.closePath();
            return;
        } else if (this.clipSector == null && Math.abs(innerRadius - outerRadius) < 1e-6) {
            path.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);
            path.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);
            path.closePath();
            return;
        }
        const innerAngleOffset = this.getAngleOffset(innerRadius);
        const outerAngleOffset = this.getAngleOffset(outerRadius);
        const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;
        if (outerAngleExceeded) return;
        var _clipSector_innerRadius;
        const hasInnerSweep = ((_clipSector_innerRadius = clipSector === null || clipSector === void 0 ? void 0 : clipSector.innerRadius) !== null && _clipSector_innerRadius !== void 0 ? _clipSector_innerRadius : innerRadius) > concentricEdgeInset;
        const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;
        const radialLength = outerRadius - innerRadius;
        const maxRadialLength = Math.max(startOuterCornerRadius, startInnerCornerRadius, endOuterCornerRadius, endInnerCornerRadius);
        const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;
        startOuterCornerRadius *= initialScalingFactor;
        endOuterCornerRadius *= initialScalingFactor;
        startInnerCornerRadius *= initialScalingFactor;
        endInnerCornerRadius *= initialScalingFactor;
        const outerScalingFactor = radiiScalingFactor(outerRadius, sweepAngle - 2 * outerAngleOffset, -startOuterCornerRadius, -endOuterCornerRadius);
        startOuterCornerRadius *= outerScalingFactor;
        endOuterCornerRadius *= outerScalingFactor;
        if (!innerAngleExceeded && hasInnerSweep) {
            const innerScalingFactor = radiiScalingFactor(innerRadius, sweepAngle - 2 * innerAngleOffset, startInnerCornerRadius, endInnerCornerRadius);
            startInnerCornerRadius *= innerScalingFactor;
            endInnerCornerRadius *= innerScalingFactor;
        } else {
            startInnerCornerRadius = 0;
            endInnerCornerRadius = 0;
        }
        const maxCombinedRadialLength = Math.max(startOuterCornerRadius + startInnerCornerRadius, endOuterCornerRadius + endInnerCornerRadius);
        const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;
        startOuterCornerRadius *= edgesScalingFactor;
        endOuterCornerRadius *= edgesScalingFactor;
        startInnerCornerRadius *= edgesScalingFactor;
        endInnerCornerRadius *= edgesScalingFactor;
        let startOuterCornerRadiusAngleSweep = 0;
        let endOuterCornerRadiusAngleSweep = 0;
        const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);
        const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);
        if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta3) {
            startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);
        } else {
            startOuterCornerRadiusAngleSweep = sweepAngle / 2;
            const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);
            startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);
        }
        if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta3) {
            endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);
        } else {
            endOuterCornerRadiusAngleSweep = sweepAngle / 2;
            const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);
            endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);
        }
        const startInnerCornerRadiusAngleSweep = Math.asin(startInnerCornerRadius / (innerRadius + startInnerCornerRadius));
        const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));
        var _clipSector_outerRadius;
        const outerArcRadius = (_clipSector_outerRadius = clipSector === null || clipSector === void 0 ? void 0 : clipSector.outerRadius) !== null && _clipSector_outerRadius !== void 0 ? _clipSector_outerRadius : outerRadius;
        const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);
        const outerArc = new Arc(0, 0, outerArcRadius, startAngle + outerArcRadiusOffset, endAngle - outerArcRadiusOffset);
        var _clipSector_innerRadius1;
        const innerArcRadius = (_clipSector_innerRadius1 = clipSector === null || clipSector === void 0 ? void 0 : clipSector.innerRadius) !== null && _clipSector_innerRadius1 !== void 0 ? _clipSector_innerRadius1 : innerRadius;
        const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);
        const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;
        if (clipSector != null) {
            outerArc.clipStart(clipSector.startAngle);
            outerArc.clipEnd(clipSector.endAngle);
            innerArc === null || innerArc === void 0 ? void 0 : innerArc.clipStart(clipSector.startAngle);
            innerArc === null || innerArc === void 0 ? void 0 : innerArc.clipEnd(clipSector.endAngle);
        }
        const startOuterArc = this.arc(startOuterCornerRadius, startOuterCornerRadiusAngleSweep, startAngle - Math.PI * 0.5, startAngle + startOuterCornerRadiusAngleSweep, outerArc, innerArc, true, false);
        const endOuterArc = this.arc(endOuterCornerRadius, endOuterCornerRadiusAngleSweep, endAngle - endOuterCornerRadiusAngleSweep, endAngle + Math.PI * 0.5, outerArc, innerArc, false, false);
        const endInnerArc = this.arc(endInnerCornerRadius, endInnerCornerRadiusAngleSweep, endAngle + Math.PI * 0.5, endAngle + Math.PI - endInnerCornerRadiusAngleSweep, outerArc, innerArc, false, true);
        const startInnerArc = this.arc(startInnerCornerRadius, startInnerCornerRadiusAngleSweep, startAngle + Math.PI + startInnerCornerRadiusAngleSweep, startAngle + Math.PI * 1.5, outerArc, innerArc, true, true);
        if (innerAngleExceeded) {
            const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;
            let r;
            if (x > 0 && x < outerRadius) {
                r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);
            } else {
                r = radialEdgeInset;
            }
            r = Math.max(r, innerRadius);
            const midAngle = startAngle + sweepAngle * 0.5;
            path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));
        } else if ((startInnerArc === null || startInnerArc === void 0 ? void 0 : startInnerArc.isValid()) === true || (innerArc === null || innerArc === void 0 ? void 0 : innerArc.isValid()) === true) {} else {
            const midAngle = startAngle + sweepAngle / 2;
            const cx = innerRadius * Math.cos(midAngle);
            const cy = innerRadius * Math.sin(midAngle);
            path.moveTo(centerX + cx, centerY + cy);
        }
        if ((startOuterArc === null || startOuterArc === void 0 ? void 0 : startOuterArc.isValid()) === true) {
            const { cx, cy, r, a0, a1 } = startOuterArc;
            path.arc(centerX + cx, centerY + cy, r, a0, a1);
        }
        if (outerArc.isValid()) {
            const { r, a0, a1 } = outerArc;
            path.arc(centerX, centerY, r, a0, a1);
        }
        if ((endOuterArc === null || endOuterArc === void 0 ? void 0 : endOuterArc.isValid()) === true) {
            const { cx, cy, r, a0, a1 } = endOuterArc;
            path.arc(centerX + cx, centerY + cy, r, a0, a1);
        }
        if (!innerAngleExceeded) {
            if ((endInnerArc === null || endInnerArc === void 0 ? void 0 : endInnerArc.isValid()) === true) {
                const { cx, cy, r, a0, a1 } = endInnerArc;
                path.arc(centerX + cx, centerY + cy, r, a0, a1);
            }
            if ((innerArc === null || innerArc === void 0 ? void 0 : innerArc.isValid()) === true) {
                const { r, a0, a1 } = innerArc;
                path.arc(centerX, centerY, r, a1, a0, true);
            }
            if ((startInnerArc === null || startInnerArc === void 0 ? void 0 : startInnerArc.isValid()) === true) {
                const { cx, cy, r, a0, a1 } = startInnerArc;
                path.arc(centerX + cx, centerY + cy, r, a0, a1);
            }
        }
        path.closePath();
    }
    isPointInPath(x, y) {
        var _this_clipSector;
        const { startAngle, endAngle, innerRadius, outerRadius } = (_this_clipSector = this.clipSector) !== null && _this_clipSector !== void 0 ? _this_clipSector : this;
        return isPointInSector(x - this.centerX, y - this.centerY, {
            startAngle,
            endAngle,
            innerRadius: Math.min(innerRadius, outerRadius),
            outerRadius: Math.max(innerRadius, outerRadius)
        });
    }
    constructor(){
        super(...arguments);
        this.centerX = 0;
        this.centerY = 0;
        this.innerRadius = 10;
        this.outerRadius = 20;
        this.startAngle = 0;
        this.endAngle = Math.PI * 2;
        this.clipSector = void 0;
        this.concentricEdgeInset = 0;
        this.radialEdgeInset = 0;
        this.startOuterCornerRadius = 0;
        this.endOuterCornerRadius = 0;
        this.startInnerCornerRadius = 0;
        this.endInnerCornerRadius = 0;
    }
};
Sector.className = "Sector";
__decorateClass([
    SceneChangeDetection()
], Sector.prototype, "centerX", 2);
__decorateClass([
    SceneChangeDetection()
], Sector.prototype, "centerY", 2);
__decorateClass([
    SceneChangeDetection()
], Sector.prototype, "innerRadius", 2);
__decorateClass([
    SceneChangeDetection()
], Sector.prototype, "outerRadius", 2);
__decorateClass([
    SceneChangeDetection()
], Sector.prototype, "startAngle", 2);
__decorateClass([
    SceneChangeDetection()
], Sector.prototype, "endAngle", 2);
__decorateClass([
    SceneObjectChangeDetection({
        equals: (lhs, rhs)=>lhs.equals(rhs)
    })
], Sector.prototype, "clipSector", 2);
__decorateClass([
    SceneChangeDetection()
], Sector.prototype, "concentricEdgeInset", 2);
__decorateClass([
    SceneChangeDetection()
], Sector.prototype, "radialEdgeInset", 2);
__decorateClass([
    SceneChangeDetection()
], Sector.prototype, "startOuterCornerRadius", 2);
__decorateClass([
    SceneChangeDetection()
], Sector.prototype, "endOuterCornerRadius", 2);
__decorateClass([
    SceneChangeDetection()
], Sector.prototype, "startInnerCornerRadius", 2);
__decorateClass([
    SceneChangeDetection()
], Sector.prototype, "endInnerCornerRadius", 2);
// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts
var DonutTitle = class extends Caption {
    constructor(){
        super(...arguments);
        this.showInLegend = false;
    }
};
__decorateClass([
    Property
], DonutTitle.prototype, "showInLegend", 2);
var DonutInnerLabel = class extends Label {
    set(properties, _reset) {
        return super.set(properties);
    }
    constructor(){
        super(...arguments);
        this.spacing = 2;
    }
};
__decorateClass([
    Property
], DonutInnerLabel.prototype, "text", 2);
__decorateClass([
    Property
], DonutInnerLabel.prototype, "spacing", 2);
var DonutInnerCircle = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.fill = "transparent";
        this.fillOpacity = 1;
    }
};
__decorateClass([
    Property
], DonutInnerCircle.prototype, "fill", 2);
__decorateClass([
    Property
], DonutInnerCircle.prototype, "fillOpacity", 2);
var DonutSeriesCalloutLabel = class extends Label {
    constructor(){
        super(...arguments);
        this.offset = 3;
        this.minAngle = 0;
        this.minSpacing = 4;
        this.maxCollisionOffset = 50;
        this.avoidCollisions = true;
    }
};
__decorateClass([
    Property
], DonutSeriesCalloutLabel.prototype, "offset", 2);
__decorateClass([
    Property
], DonutSeriesCalloutLabel.prototype, "minAngle", 2);
__decorateClass([
    Property
], DonutSeriesCalloutLabel.prototype, "minSpacing", 2);
__decorateClass([
    Property
], DonutSeriesCalloutLabel.prototype, "maxCollisionOffset", 2);
__decorateClass([
    Property
], DonutSeriesCalloutLabel.prototype, "avoidCollisions", 2);
var DonutSeriesSectorLabel = class extends Label {
    constructor(){
        super(...arguments);
        this.positionOffset = 0;
        this.positionRatio = 0.5;
    }
};
__decorateClass([
    Property
], DonutSeriesSectorLabel.prototype, "positionOffset", 2);
__decorateClass([
    Property
], DonutSeriesSectorLabel.prototype, "positionRatio", 2);
var DonutSeriesCalloutLine = class extends BaseProperties {
    constructor(){
        super(...arguments);
        this.length = 10;
        this.strokeWidth = 1;
    }
};
__decorateClass([
    Property
], DonutSeriesCalloutLine.prototype, "colors", 2);
__decorateClass([
    Property
], DonutSeriesCalloutLine.prototype, "length", 2);
__decorateClass([
    Property
], DonutSeriesCalloutLine.prototype, "strokeWidth", 2);
var DonutSeriesProperties = class extends SeriesProperties {
    constructor(){
        super(...arguments);
        this.defaultColorRange = [];
        this.defaultPatternFills = [];
        this.fills = Object.values(DEFAULT_FILLS);
        this.strokes = Object.values(DEFAULT_STROKES);
        this.fillOpacity = 1;
        this.strokeOpacity = 1;
        this.lineDash = [
            0
        ];
        this.lineDashOffset = 0;
        this.cornerRadius = 0;
        this.rotation = 0;
        this.outerRadiusOffset = 0;
        this.outerRadiusRatio = 1;
        this.strokeWidth = 1;
        this.sectorSpacing = 0;
        this.hideZeroValueSectorsInLegend = false;
        this.innerLabels = new PropertiesArray(DonutInnerLabel);
        this.title = new DonutTitle();
        this.innerCircle = new DonutInnerCircle();
        this.shadow = new DropShadow();
        this.calloutLabel = new DonutSeriesCalloutLabel();
        this.sectorLabel = new DonutSeriesSectorLabel();
        this.calloutLine = new DonutSeriesCalloutLine();
        this.tooltip = makeSeriesTooltip();
    }
};
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "angleKey", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "angleName", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "angleFilterKey", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "radiusKey", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "radiusName", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "radiusMin", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "radiusMax", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "calloutLabelKey", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "calloutLabelName", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "sectorLabelKey", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "sectorLabelName", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "legendItemKey", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "defaultColorRange", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "defaultPatternFills", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "fills", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "strokes", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "rotation", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "outerRadiusOffset", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "outerRadiusRatio", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "innerRadiusOffset", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "innerRadiusRatio", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "hideZeroValueSectorsInLegend", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "innerLabels", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "title", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "innerCircle", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "shadow", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "calloutLabel", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "sectorLabel", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "calloutLine", 2);
__decorateClass([
    Property
], DonutSeriesProperties.prototype, "tooltip", 2);
// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts
function preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {
    const scale2 = [
        scaleFn.convert(0),
        scaleFn.convert(1)
    ];
    const oldScale = [
        oldScaleFn.convert(0),
        oldScaleFn.convert(1)
    ];
    const rotation = Math.PI / -2 + toRadians(rotationDegrees);
    const phase = initialLoad ? "initial" : "update";
    const scaleToNewRadius = (param)=>{
        let { radius } = param;
        return {
            innerRadius: scale2[0],
            outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius
        };
    };
    const scaleToOldRadius = (param)=>{
        let { radius } = param;
        return {
            innerRadius: oldScale[0],
            outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius
        };
    };
    const fromFn = (sect, datum, status, param)=>{
        let { prevFromProps } = param;
        let { startAngle, endAngle, innerRadius, outerRadius } = sect;
        let { fill, stroke: stroke2 } = datum.sectorFormat;
        if (status === "updated" && sect.previousDatum == null) {
            status = "added";
        }
        if (status === "unknown" || status === "added" && !prevFromProps) {
            startAngle = rotation;
            endAngle = rotation;
            innerRadius = datum.innerRadius;
            outerRadius = datum.outerRadius;
        } else if (status === "added" && prevFromProps) {
            var _prevFromProps_endAngle;
            startAngle = (_prevFromProps_endAngle = prevFromProps.endAngle) !== null && _prevFromProps_endAngle !== void 0 ? _prevFromProps_endAngle : rotation;
            var _prevFromProps_endAngle1;
            endAngle = (_prevFromProps_endAngle1 = prevFromProps.endAngle) !== null && _prevFromProps_endAngle1 !== void 0 ? _prevFromProps_endAngle1 : rotation;
            var _prevFromProps_innerRadius;
            innerRadius = (_prevFromProps_innerRadius = prevFromProps.innerRadius) !== null && _prevFromProps_innerRadius !== void 0 ? _prevFromProps_innerRadius : datum.innerRadius;
            var _prevFromProps_outerRadius;
            outerRadius = (_prevFromProps_outerRadius = prevFromProps.outerRadius) !== null && _prevFromProps_outerRadius !== void 0 ? _prevFromProps_outerRadius : datum.outerRadius;
        }
        if (status === "added" && !initialLoad) {
            const radii = scaleToOldRadius(datum);
            innerRadius = radii.innerRadius;
            outerRadius = radii.outerRadius;
        }
        if (status === "updated") {
            var _sect_fill;
            fill = (_sect_fill = sect.fill) !== null && _sect_fill !== void 0 ? _sect_fill : fill;
            var _ref;
            stroke2 = (_ref = typeof sect.stroke === "string" ? sect.stroke : void 0) !== null && _ref !== void 0 ? _ref : stroke2;
        }
        return {
            startAngle,
            endAngle,
            innerRadius,
            outerRadius,
            fill,
            stroke: stroke2,
            phase
        };
    };
    const toFn = (_sect, datum, status, param)=>{
        let { prevLive } = param;
        let { startAngle, endAngle, innerRadius, outerRadius } = datum;
        const { stroke: stroke2, fill } = datum.sectorFormat;
        if (status === "removed" && prevLive) {
            var _prevLive_datum, _prevLive_datum1;
            startAngle = (_prevLive_datum = prevLive.datum) === null || _prevLive_datum === void 0 ? void 0 : _prevLive_datum.endAngle;
            endAngle = (_prevLive_datum1 = prevLive.datum) === null || _prevLive_datum1 === void 0 ? void 0 : _prevLive_datum1.endAngle;
        } else if (status === "removed" && !prevLive) {
            startAngle = rotation;
            endAngle = rotation;
        }
        if (status === "removed") {
            const radii = scaleToNewRadius(datum);
            innerRadius = radii.innerRadius;
            outerRadius = radii.outerRadius;
        }
        return {
            startAngle,
            endAngle,
            outerRadius,
            innerRadius,
            stroke: stroke2,
            fill
        };
    };
    const innerCircleFromFn = (node, _)=>{
        var _node_previousDatum;
        var _node_previousDatum_radius, _ref;
        return {
            size: (_ref = (_node_previousDatum_radius = (_node_previousDatum = node.previousDatum) === null || _node_previousDatum === void 0 ? void 0 : _node_previousDatum.radius) !== null && _node_previousDatum_radius !== void 0 ? _node_previousDatum_radius : node.size) !== null && _ref !== void 0 ? _ref : 0,
            phase
        };
    };
    const innerCircleToFn = (_, datum)=>{
        var _datum_radius;
        return {
            size: (_datum_radius = datum.radius) !== null && _datum_radius !== void 0 ? _datum_radius : 0
        };
    };
    return {
        nodes: {
            toFn,
            fromFn
        },
        innerCircle: {
            fromFn: innerCircleFromFn,
            toFn: innerCircleToFn
        }
    };
}
function resetPieSelectionsFn(_node, datum) {
    return {
        startAngle: datum.startAngle,
        endAngle: datum.endAngle,
        innerRadius: datum.innerRadius,
        outerRadius: datum.outerRadius,
        stroke: datum.sectorFormat.stroke
    };
}
function pickByMatchingAngle(series, point) {
    const dy = point.y - series.centerY;
    const dx = point.x - series.centerX;
    const angle2 = Math.atan2(dy, dx);
    const sectors = series.getItemNodes();
    for (const sector of sectors){
        if (sector.datum.missing === true) continue;
        if (isBetweenAngles(angle2, sector.startAngle, sector.endAngle)) {
            const radius = Math.sqrt(dx * dx + dy * dy);
            let distance2 = 0;
            if (radius < sector.innerRadius) {
                distance2 = sector.innerRadius - radius;
            } else if (radius > sector.outerRadius) {
                distance2 = radius - sector.outerRadius;
            }
            return {
                datum: sector.datum,
                distance: distance2
            };
        }
    }
    return void 0;
}
// packages/ag-charts-community/src/chart/series/polar/polarZIndexMap.ts
var PolarZIndexMap = /* @__PURE__ */ ((PolarZIndexMap2)=>{
    PolarZIndexMap2[PolarZIndexMap2["BACKGROUND"] = 0] = "BACKGROUND";
    PolarZIndexMap2[PolarZIndexMap2["FOREGROUND"] = 1] = "FOREGROUND";
    PolarZIndexMap2[PolarZIndexMap2["HIGHLIGHT"] = 2] = "HIGHLIGHT";
    PolarZIndexMap2[PolarZIndexMap2["LABEL"] = 3] = "LABEL";
    return PolarZIndexMap2;
})(PolarZIndexMap || {});
// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts
var DEFAULT_POLAR_DIRECTION_KEYS = {
    ["angle" /* Angle */ ]: [
        "angleKey"
    ],
    ["radius" /* Radius */ ]: [
        "radiusKey"
    ]
};
var DEFAULT_POLAR_DIRECTION_NAMES = {
    ["angle" /* Angle */ ]: [
        "angleName"
    ],
    ["radius" /* Radius */ ]: [
        "radiusName"
    ]
};
var PolarSeries = class extends DataModelSeries {
    getItemNodes() {
        return [
            ...this.itemGroup.children()
        ];
    }
    getNodeData() {
        return this.nodeData;
    }
    setZIndex(zIndex) {
        super.setZIndex(zIndex);
        this.contentGroup.zIndex = [
            zIndex,
            1 /* FOREGROUND */ 
        ];
        this.highlightGroup.zIndex = [
            zIndex,
            2 /* HIGHLIGHT */ 
        ];
        this.labelGroup.zIndex = [
            zIndex,
            3 /* LABEL */ 
        ];
    }
    resetAnimation(phase) {
        if (phase === "initial") {
            this.animationState.transition("reset");
        } else if (phase === "ready") {
            this.animationState.transition("skip");
        }
    }
    labelFactory() {
        const text = new Text();
        text.pointerEvents = 1 /* None */ ;
        return text;
    }
    addChartEventListeners() {
        this.cleanup.register(this.ctx.eventsHub.on("legend:item-click", (event)=>this.onLegendItemClick(event)), this.ctx.eventsHub.on("legend:item-double-click", (event)=>this.onLegendItemDoubleClick(event)));
    }
    getInnerRadius() {
        return 0;
    }
    computeLabelsBBox(_options, _seriesRect) {
        return null;
    }
    getShapeFillBBox() {
        const outerRadius = this.radius;
        return {
            series: new BBox(-outerRadius, -outerRadius, outerRadius * 2, outerRadius * 2),
            axis: new BBox(-outerRadius, -outerRadius, outerRadius * 2, outerRadius * 2)
        };
    }
    resetAllAnimation() {
        var _this_animationResetFns;
        const { item, label } = (_this_animationResetFns = this.animationResetFns) !== null && _this_animationResetFns !== void 0 ? _this_animationResetFns : {};
        this.ctx.animationManager.stopByAnimationGroupId(this.id);
        if (item) {
            resetMotion([
                this.itemSelection,
                this.highlightSelection
            ], item);
        }
        if (label) {
            resetMotion([
                this.labelSelection
            ], label);
        }
        this.itemSelection.cleanup();
        this.labelSelection.cleanup();
        this.highlightSelection.cleanup();
    }
    animateEmptyUpdateReady(_data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation();
    }
    animateWaitingUpdateReady(_data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation();
    }
    animateReadyHighlight(_data) {
        var _this_animationResetFns;
        const { item } = (_this_animationResetFns = this.animationResetFns) !== null && _this_animationResetFns !== void 0 ? _this_animationResetFns : {};
        if (item) {
            resetMotion([
                this.highlightSelection
            ], item);
        }
    }
    animateReadyHighlightMarkers(_data) {}
    animateReadyResize(_data) {
        this.resetAllAnimation();
    }
    animateClearingUpdateEmpty(_data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation();
    }
    computeFocusBounds(opts) {
        var _this_getNodeData;
        const datum = (_this_getNodeData = this.getNodeData()) === null || _this_getNodeData === void 0 ? void 0 : _this_getNodeData[opts.datumIndex];
        if (datum !== void 0) {
            return this.itemSelection.select((node)=>node instanceof Path && node.datum === datum)[0];
        }
        return void 0;
    }
    getSeriesRange(_direction, _visibleRange) {
        return [
            NaN,
            NaN
        ];
    }
    isSeriesHighlighted(highlightedDatum, legendItemValues) {
        const { series, legendItemName: activeLegendItemName, itemId } = highlightedDatum !== null && highlightedDatum !== void 0 ? highlightedDatum : {};
        const legendItemName = legendItemValues === null || legendItemValues === void 0 ? void 0 : legendItemValues[itemId];
        return series === this || legendItemName != null && legendItemName === activeLegendItemName;
    }
    constructor({ categoryKey, pickModes = [
        1 /* NEAREST_NODE */ ,
        0 /* EXACT_SHAPE_MATCH */ 
    ], canHaveAxes = false, animationResetFns, ...opts }){
        super({
            ...opts,
            categoryKey,
            pickModes,
            canHaveAxes
        });
        this.directions = [
            "angle" /* Angle */ ,
            "radius" /* Radius */ 
        ];
        this.itemGroup = this.contentGroup.appendChild(new Group());
        this.nodeData = [];
        this.itemSelection = Selection.select(this.itemGroup, ()=>this.nodeFactory(), false);
        this.labelSelection = Selection.select(this.labelGroup, ()=>this.labelFactory(), false);
        this.highlightSelection = Selection.select(this.highlightGroup, ()=>this.nodeFactory());
        /**
     * The center of the polar series (for example, the center of a pie).
     * If the polar chart has multiple series, all of them will have their
     * center set to the same value as a result of the polar chart layout.
     * The center coordinates are not supposed to be set by the user.
     */ this.centerX = 0;
        this.centerY = 0;
        /**
     * The maximum radius the series can use.
     * This value is set automatically as a result of the polar chart layout
     * and is not supposed to be set by the user.
     */ this.radius = 0;
        this.animationResetFns = animationResetFns;
        this.animationState = new StateMachine("empty", {
            empty: {
                update: {
                    target: "ready",
                    action: (data)=>this.animateEmptyUpdateReady(data)
                },
                reset: "empty",
                skip: "ready"
            },
            ready: {
                updateData: "waiting",
                clear: "clearing",
                highlight: (data)=>this.animateReadyHighlight(data),
                highlightMarkers: (data)=>this.animateReadyHighlightMarkers(data),
                resize: (data)=>this.animateReadyResize(data),
                reset: "empty",
                skip: "ready"
            },
            waiting: {
                update: {
                    target: "ready",
                    action: (data)=>this.animateWaitingUpdateReady(data)
                },
                reset: "empty",
                skip: "ready"
            },
            clearing: {
                update: {
                    target: "empty",
                    action: (data)=>this.animateClearingUpdateEmpty(data)
                },
                reset: "empty",
                skip: "ready"
            }
        }, ()=>this.checkProcessedDataAnimatable());
    }
};
// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts
var PieDonutSeriesNodeEvent = class extends SeriesNodeEvent {
    constructor(type, nativeEvent, datum, series){
        super(type, nativeEvent, datum, series);
        this.angleKey = series.properties.angleKey;
        this.radiusKey = series.properties.radiusKey;
        this.calloutLabelKey = series.properties.calloutLabelKey;
        this.sectorLabelKey = series.properties.sectorLabelKey;
    }
};
var DonutSeries = class extends PolarSeries {
    get calloutNodeData() {
        var _this_phantomNodeData;
        return (_this_phantomNodeData = this.phantomNodeData) !== null && _this_phantomNodeData !== void 0 ? _this_phantomNodeData : this.nodeData;
    }
    attachSeries(seriesContentNode, seriesNode, annotationNode) {
        super.attachSeries(seriesContentNode, seriesNode, annotationNode);
        seriesContentNode === null || seriesContentNode === void 0 ? void 0 : seriesContentNode.appendChild(this.backgroundGroup);
    }
    detachSeries(seriesContentNode, seriesNode, annotationNode) {
        super.detachSeries(seriesContentNode, seriesNode, annotationNode);
        seriesContentNode === null || seriesContentNode === void 0 ? void 0 : seriesContentNode.removeChild(this.backgroundGroup);
    }
    setZIndex(zIndex) {
        super.setZIndex(zIndex);
        this.backgroundGroup.zIndex = [
            0 /* BACKGROUND */ ,
            zIndex
        ];
    }
    nodeFactory() {
        const sector = new Sector();
        sector.miterLimit = 1e9;
        return sector;
    }
    getSeriesDomain(direction) {
        if (direction === "angle" /* Angle */ ) {
            return this.angleScale.domain;
        } else {
            return this.radiusScale.domain;
        }
    }
    async processData(dataController) {
        var _this_processedData_reduced_animationValidation, _this_processedData_reduced, _this_processedData, _this_processedData_defs, _this_processedData1;
        if (this.data == null) return;
        const { visible, id: seriesId, ctx: { legendManager } } = this;
        const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
        const processor = ()=>(value, index)=>{
                if (visible && legendManager.getItemEnabled({
                    seriesId,
                    itemId: index
                })) {
                    return value;
                }
                return 0;
            };
        const animationEnabled = !this.ctx.animationManager.isSkipped();
        const extraKeyProps = [];
        const extraProps = [];
        if (legendItemKey) {
            extraKeyProps.push(keyProperty(legendItemKey, "category", {
                id: "legendItemKey"
            }));
        } else if (calloutLabelKey) {
            extraKeyProps.push(keyProperty(calloutLabelKey, "category", {
                id: "calloutLabelKey"
            }));
        } else if (sectorLabelKey) {
            extraKeyProps.push(keyProperty(sectorLabelKey, "category", {
                id: "sectorLabelKey"
            }));
        }
        const radiusScaleType = this.radiusScale.type;
        const angleScaleType = this.angleScale.type;
        if (radiusKey) {
            var _this_properties_radiusMin, _this_properties_radiusMax, _this_properties_radiusMin1;
            extraProps.push(rangedValueProperty(radiusKey, {
                id: "radiusValue",
                min: (_this_properties_radiusMin = this.properties.radiusMin) !== null && _this_properties_radiusMin !== void 0 ? _this_properties_radiusMin : 0,
                max: this.properties.radiusMax,
                missingValue: (_this_properties_radiusMax = this.properties.radiusMax) !== null && _this_properties_radiusMax !== void 0 ? _this_properties_radiusMax : 1,
                processor
            }), valueProperty(radiusKey, radiusScaleType, {
                id: "radiusRaw",
                processor
            }), // Raw value pass-through.
            normalisePropertyTo("radiusValue", [
                0,
                1
            ], 1, (_this_properties_radiusMin1 = this.properties.radiusMin) !== null && _this_properties_radiusMin1 !== void 0 ? _this_properties_radiusMin1 : 0, this.properties.radiusMax));
        }
        if (calloutLabelKey) {
            extraProps.push(valueProperty(calloutLabelKey, "category", {
                id: "calloutLabelValue"
            }));
        }
        if (sectorLabelKey) {
            extraProps.push(valueProperty(sectorLabelKey, "category", {
                id: "sectorLabelValue"
            }));
        }
        if (legendItemKey) {
            extraProps.push(valueProperty(legendItemKey, "category", {
                id: "legendItemValue"
            }));
        }
        if (angleFilterKey) {
            extraProps.push(accumulativeValueProperty(angleFilterKey, angleScaleType, {
                id: "angleFilterValue",
                onlyPositive: true,
                invalidValue: 0,
                processor
            }), valueProperty(angleFilterKey, angleScaleType, {
                id: "angleFilterRaw"
            }), normalisePropertyTo("angleFilterValue", [
                0,
                1
            ], 0, 0));
        }
        if (animationEnabled && ((_this_processedData = this.processedData) === null || _this_processedData === void 0 ? void 0 : (_this_processedData_reduced = _this_processedData.reduced) === null || _this_processedData_reduced === void 0 ? void 0 : (_this_processedData_reduced_animationValidation = _this_processedData_reduced.animationValidation) === null || _this_processedData_reduced_animationValidation === void 0 ? void 0 : _this_processedData_reduced_animationValidation.uniqueKeys) && extraKeyProps.length > 0) {
            extraProps.push(diff(this.id, this.processedData));
        }
        extraProps.push(animationValidation());
        await this.requestDataModel(dataController, this.data, {
            props: [
                ...extraKeyProps,
                accumulativeValueProperty(angleKey, angleScaleType, {
                    id: "angleValue",
                    onlyPositive: true,
                    invalidValue: 0,
                    processor
                }),
                valueProperty(angleKey, angleScaleType, {
                    id: "angleRaw"
                }),
                // Raw value pass-through.
                normalisePropertyTo("angleValue", [
                    0,
                    1
                ], 0, 0),
                ...extraProps
            ]
        });
        var _this_processedData_defs_values;
        for (const valueDef of (_this_processedData_defs_values = (_this_processedData1 = this.processedData) === null || _this_processedData1 === void 0 ? void 0 : (_this_processedData_defs = _this_processedData1.defs) === null || _this_processedData_defs === void 0 ? void 0 : _this_processedData_defs.values) !== null && _this_processedData_defs_values !== void 0 ? _this_processedData_defs_values : []){
            const { id, missing, property } = valueDef;
            const missCount = getMissCount(this, missing);
            if (id !== "angleRaw" && missCount > 0) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("no value was found for the key '".concat(String(property), "' on ").concat(missCount, " data element").concat(missCount > 1 ? "s" : ""));
            }
        }
        this.animationState.transition("updateData");
    }
    maybeRefreshNodeData() {
        if (!this.nodeDataRefresh) return;
        var _this_createNodeData;
        const { nodeData = [], phantomNodeData } = (_this_createNodeData = this.createNodeData()) !== null && _this_createNodeData !== void 0 ? _this_createNodeData : {};
        this.nodeData = nodeData;
        this.phantomNodeData = phantomNodeData;
        this.nodeDataRefresh = false;
    }
    getProcessedDataValues(dataModel, processedData) {
        const angleValues = dataModel.resolveColumnById(this, "angleValue", processedData);
        const angleRawValues = dataModel.resolveColumnById(this, "angleRaw", processedData);
        const angleFilterValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, "angleFilterValue", processedData) : void 0;
        const angleFilterRawValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, "angleFilterRaw", processedData) : void 0;
        const radiusValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, "radiusValue", processedData) : void 0;
        const radiusRawValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, "radiusRaw", processedData) : void 0;
        const calloutLabelValues = this.properties.calloutLabelKey ? dataModel.resolveColumnById(this, "calloutLabelValue", processedData) : void 0;
        const sectorLabelValues = this.properties.sectorLabelKey ? dataModel.resolveColumnById(this, "sectorLabelValue", processedData) : void 0;
        const legendItemValues = this.properties.legendItemKey ? dataModel.resolveColumnById(this, "legendItemValue", processedData) : void 0;
        return {
            angleValues,
            angleRawValues,
            angleFilterValues,
            angleFilterRawValues,
            radiusValues,
            radiusRawValues,
            calloutLabelValues,
            sectorLabelValues,
            legendItemValues
        };
    }
    createNodeData() {
        var _processedData_invalidData;
        const { id: seriesId, processedData, dataModel, angleScale, ctx: { legendManager }, visible } = this;
        const { rotation, innerRadiusRatio } = this.properties;
        if (!dataModel || (processedData === null || processedData === void 0 ? void 0 : processedData.type) !== "ungrouped") return;
        const processedDataValues = this.getProcessedDataValues(dataModel, processedData);
        const { angleValues, angleRawValues, angleFilterValues, angleFilterRawValues, radiusValues, radiusRawValues, legendItemValues } = processedDataValues;
        var _angleFilterRawValues_some;
        const useFilterAngles = (_angleFilterRawValues_some = angleFilterRawValues === null || angleFilterRawValues === void 0 ? void 0 : angleFilterRawValues.some((filterRawValue, index)=>{
            return filterRawValue > angleRawValues[index];
        })) !== null && _angleFilterRawValues_some !== void 0 ? _angleFilterRawValues_some : false;
        let currentStart = 0;
        let sum2 = 0;
        const nodes = [];
        const phantomNodes = angleFilterRawValues != null ? [] : void 0;
        var _processedData_dataSources_get;
        const rawData = (_processedData_dataSources_get = processedData.dataSources.get(this.id)) !== null && _processedData_dataSources_get !== void 0 ? _processedData_dataSources_get : [];
        const invalidData = (_processedData_invalidData = processedData.invalidData) === null || _processedData_invalidData === void 0 ? void 0 : _processedData_invalidData.get(this.id);
        rawData.forEach((datum, datumIndex)=>{
            if ((invalidData === null || invalidData === void 0 ? void 0 : invalidData[datumIndex]) === true) return;
            const currentValue = useFilterAngles ? angleFilterValues[datumIndex] : angleValues[datumIndex];
            const crossFilterScale = angleFilterRawValues != null && !useFilterAngles ? Math.sqrt(angleFilterRawValues[datumIndex] / angleRawValues[datumIndex]) : 1;
            const startAngle = angleScale.convert(currentStart) + toRadians(rotation);
            currentStart = currentValue;
            sum2 += currentValue;
            const endAngle = angleScale.convert(currentStart) + toRadians(rotation);
            const span = Math.abs(endAngle - startAngle);
            const midAngle = startAngle + span / 2;
            const angleValue = angleRawValues[datumIndex];
            var _radiusValues_datumIndex;
            const radiusRaw = (_radiusValues_datumIndex = radiusValues === null || radiusValues === void 0 ? void 0 : radiusValues[datumIndex]) !== null && _radiusValues_datumIndex !== void 0 ? _radiusValues_datumIndex : 1;
            const radius = radiusRaw * crossFilterScale;
            const radiusValue = radiusRawValues === null || radiusRawValues === void 0 ? void 0 : radiusRawValues[datumIndex];
            const legendItemValue = legendItemValues === null || legendItemValues === void 0 ? void 0 : legendItemValues[datumIndex];
            const nodeLabels = this.getLabels(datumIndex, datum, midAngle, span, processedDataValues);
            const sectorFormat = this.getSectorFormat(datum, datumIndex, false);
            const node = {
                itemId: datumIndex,
                series: this,
                datum,
                datumIndex,
                angleValue,
                midAngle,
                midCos: Math.cos(midAngle),
                midSin: Math.sin(midAngle),
                startAngle,
                endAngle,
                radius,
                innerRadius: Math.max(this.radiusScale.convert(0), 0),
                outerRadius: Math.max(this.radiusScale.convert(radius), 0),
                sectorFormat,
                radiusValue,
                legendItemValue,
                enabled: visible && legendManager.getItemEnabled({
                    seriesId,
                    itemId: datumIndex
                }),
                focusable: true,
                ...nodeLabels
            };
            nodes.push(node);
            if (phantomNodes != null) {
                phantomNodes.push({
                    ...node,
                    radius: 1,
                    innerRadius: Math.max(this.radiusScale.convert(0), 0),
                    outerRadius: Math.max(this.radiusScale.convert(1), 0),
                    focusable: false
                });
            }
        });
        this.zerosumOuterRing.visible = sum2 === 0;
        this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;
        return {
            itemId: seriesId,
            nodeData: nodes,
            labelData: nodes,
            phantomNodeData: phantomNodes
        };
    }
    getLabelContent(datumIndex, datum, values) {
        var _values_calloutLabelValues, _values_sectorLabelValues, _values_legendItemValues;
        const { id: seriesId, ctx, properties } = this;
        const { formatManager } = ctx;
        const { calloutLabel, sectorLabel, calloutLabelKey, sectorLabelKey, legendItemKey } = properties;
        const calloutLabelValue = (_values_calloutLabelValues = values.calloutLabelValues) === null || _values_calloutLabelValues === void 0 ? void 0 : _values_calloutLabelValues[datumIndex];
        const sectorLabelValue = (_values_sectorLabelValues = values.sectorLabelValues) === null || _values_sectorLabelValues === void 0 ? void 0 : _values_sectorLabelValues[datumIndex];
        const legendItemValue = (_values_legendItemValues = values.legendItemValues) === null || _values_legendItemValues === void 0 ? void 0 : _values_legendItemValues[datumIndex];
        const labelFormatterParams = {
            datum,
            angleKey: this.properties.angleKey,
            angleName: this.properties.angleName,
            radiusKey: this.properties.radiusKey,
            radiusName: this.properties.radiusName,
            calloutLabelKey: this.properties.calloutLabelKey,
            calloutLabelName: this.properties.calloutLabelName,
            sectorLabelKey: this.properties.sectorLabelKey,
            sectorLabelName: this.properties.sectorLabelName,
            legendItemKey: this.properties.legendItemKey
        };
        const result = {
            callout: void 0,
            sector: void 0,
            legendItem: void 0
        };
        if (calloutLabelKey) {
            result.callout = this.getLabelText(calloutLabelValue, datum, calloutLabelKey, "calloutLabel", [], calloutLabel, {
                ...labelFormatterParams,
                value: calloutLabelValue
            });
        }
        if (sectorLabelKey) {
            result.sector = this.getLabelText(sectorLabelValue, datum, sectorLabelKey, "sectorLabel", [], sectorLabel, {
                ...labelFormatterParams,
                value: sectorLabelValue
            });
        }
        if (legendItemKey != null && legendItemValue != null) {
            var _formatManager_format;
            result.legendItem = (_formatManager_format = formatManager.format(this.callWithContext.bind(this), {
                type: "category",
                value: legendItemValue,
                datum,
                seriesId,
                legendItemName: void 0,
                key: legendItemKey,
                source: "legend-label",
                property: "legendItem",
                domain: [],
                boundSeries: this.getFormatterContext("legendItem")
            })) !== null && _formatManager_format !== void 0 ? _formatManager_format : legendItemValue;
        }
        return result;
    }
    getLabels(datumIndex, datum, midAngle, span, values) {
        const { properties } = this;
        const { calloutLabel, sectorLabel, legendItemKey } = properties;
        const formats = this.getLabelContent(datumIndex, datum, values);
        const result = {};
        if (calloutLabel.enabled && formats.callout && span >= toRadians(calloutLabel.minAngle)) {
            result.calloutLabel = {
                ...this.getTextAlignment(midAngle),
                text: formats.callout,
                hidden: false,
                collisionTextAlign: void 0,
                collisionOffsetY: 0,
                box: void 0
            };
        }
        if (sectorLabel.enabled && formats.sector) {
            result.sectorLabel = {
                text: formats.sector
            };
        }
        if (legendItemKey && formats.legendItem) {
            result.legendItem = {
                key: legendItemKey,
                text: formats.legendItem
            };
        }
        return result;
    }
    getTextAlignment(midAngle) {
        const quadrantTextOpts = [
            {
                textAlign: "center",
                textBaseline: "bottom"
            },
            {
                textAlign: "left",
                textBaseline: "middle"
            },
            {
                textAlign: "center",
                textBaseline: "top"
            },
            {
                textAlign: "right",
                textBaseline: "middle"
            }
        ];
        const midAngle180 = normalizeAngle180(midAngle);
        const quadrantStart = -0.75 * Math.PI;
        const quadrantOffset = midAngle180 - quadrantStart;
        const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));
        const quadrantIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["modulus"])(quadrant, quadrantTextOpts.length);
        return quadrantTextOpts[quadrantIndex];
    }
    getNodeFill(fill, defaultColorRange, defaultPatternFill) {
        return getShapeFill(fill, {
            type: "gradient",
            bounds: "series",
            colorStops: defaultColorRange.map((color11)=>({
                    color: color11
                })),
            gradient: "radial",
            rotation: 0,
            reverse: true
        }, {
            type: "pattern",
            pattern: "forward-slanted-lines",
            fill: defaultPatternFill,
            fillOpacity: 1,
            backgroundFill: "none",
            backgroundFillOpacity: 1,
            stroke: defaultPatternFill,
            strokeOpacity: 1,
            strokeWidth: 4,
            rotation: 0
        }, {
            type: "image",
            backgroundFill: defaultPatternFill,
            backgroundFillOpacity: 1,
            fit: "contain",
            repeat: "no-repeat",
            rotation: 0
        });
    }
    getFillParams(fill, innerRadius, outerRadius) {
        if (!isGradientFill(fill) || fill.bounds === "item") return;
        return {
            centerX: 0,
            centerY: 0,
            innerRadius,
            outerRadius
        };
    }
    getSectorFormat(datum, datumIndex, isHighlight, nodeDatum, legendItemValues, activeHighlight) {
        const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, defaultColorRange, defaultPatternFills, itemStyler } = this.properties;
        const defaultStroke = strokes[datumIndex % strokes.length];
        const defaultFill = fills[datumIndex % fills.length];
        const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius, opacity } = mergeDefaults(this.getHighlightStyle(isHighlight, nodeDatum === null || nodeDatum === void 0 ? void 0 : nodeDatum.datumIndex, legendItemValues), {
            fill: defaultFill,
            stroke: defaultStroke
        }, this.properties);
        const defaultColors = defaultColorRange[datumIndex % defaultColorRange.length];
        const defaultPatternFill = defaultPatternFills[datumIndex % defaultPatternFills.length];
        const sectorFill = fill !== null && fill !== void 0 ? fill : "black";
        let format;
        if (itemStyler) {
            format = this.cachedDatumCallback(this.getDatumId(datumIndex) + (isHighlight ? "-highlight" : "-hide"), ()=>{
                var _this_ctx_highlightManager;
                return this.callWithContext(itemStyler, {
                    datum,
                    angleKey,
                    radiusKey,
                    calloutLabelKey,
                    sectorLabelKey,
                    legendItemKey,
                    fill: this.getNodeFill(sectorFill, defaultColors, defaultPatternFill),
                    fillOpacity,
                    stroke: stroke2,
                    strokeWidth,
                    strokeOpacity,
                    lineDash,
                    lineDashOffset,
                    cornerRadius,
                    highlighted: isHighlight,
                    highlightState: this.getHighlightStateString(activeHighlight !== null && activeHighlight !== void 0 ? activeHighlight : (_this_ctx_highlightManager = this.ctx.highlightManager) === null || _this_ctx_highlightManager === void 0 ? void 0 : _this_ctx_highlightManager.getActiveHighlight(), isHighlight, datumIndex),
                    seriesId: this.id
                });
            });
        }
        var _format_fill, _format_fillOpacity, _format_stroke, _format_strokeWidth, _format_strokeOpacity, _format_lineDash, _format_lineDashOffset, _format_cornerRadius;
        return {
            fill: this.getNodeFill((_format_fill = format === null || format === void 0 ? void 0 : format.fill) !== null && _format_fill !== void 0 ? _format_fill : sectorFill, defaultColors, defaultPatternFill),
            fillOpacity: (_format_fillOpacity = format === null || format === void 0 ? void 0 : format.fillOpacity) !== null && _format_fillOpacity !== void 0 ? _format_fillOpacity : fillOpacity,
            stroke: (_format_stroke = format === null || format === void 0 ? void 0 : format.stroke) !== null && _format_stroke !== void 0 ? _format_stroke : stroke2,
            strokeWidth: (_format_strokeWidth = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _format_strokeWidth !== void 0 ? _format_strokeWidth : strokeWidth,
            strokeOpacity: (_format_strokeOpacity = format === null || format === void 0 ? void 0 : format.strokeOpacity) !== null && _format_strokeOpacity !== void 0 ? _format_strokeOpacity : strokeOpacity,
            lineDash: (_format_lineDash = format === null || format === void 0 ? void 0 : format.lineDash) !== null && _format_lineDash !== void 0 ? _format_lineDash : lineDash,
            lineDashOffset: (_format_lineDashOffset = format === null || format === void 0 ? void 0 : format.lineDashOffset) !== null && _format_lineDashOffset !== void 0 ? _format_lineDashOffset : lineDashOffset,
            cornerRadius: (_format_cornerRadius = format === null || format === void 0 ? void 0 : format.cornerRadius) !== null && _format_cornerRadius !== void 0 ? _format_cornerRadius : cornerRadius,
            opacity
        };
    }
    getInnerRadius() {
        const { radius } = this;
        const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;
        const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;
        if (innerRadius === radius || innerRadius < 0) {
            return 0;
        }
        return innerRadius;
    }
    getOuterRadius() {
        const { outerRadiusRatio, outerRadiusOffset } = this.properties;
        return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);
    }
    updateRadiusScale(resize) {
        var _this_phantomNodeData;
        const newRange = [
            this.getInnerRadius(),
            this.getOuterRadius()
        ];
        this.radiusScale.range = newRange;
        if (resize) {
            this.previousRadiusScale.range = newRange;
        }
        const setRadii = (d)=>({
                ...d,
                innerRadius: Math.max(this.radiusScale.convert(0), 0),
                outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)
            });
        this.nodeData = this.nodeData.map(setRadii);
        this.phantomNodeData = (_this_phantomNodeData = this.phantomNodeData) === null || _this_phantomNodeData === void 0 ? void 0 : _this_phantomNodeData.map(setRadii);
    }
    getTitleTranslationY() {
        var _this_properties_title;
        const outerRadius = Math.max(0, this.radiusScale.range[1]);
        if (outerRadius === 0) {
            return NaN;
        }
        var _this_properties_title_spacing;
        const spacing = (_this_properties_title_spacing = (_this_properties_title = this.properties.title) === null || _this_properties_title === void 0 ? void 0 : _this_properties_title.spacing) !== null && _this_properties_title_spacing !== void 0 ? _this_properties_title_spacing : 0;
        const titleOffset = 2 + spacing;
        const dy = Math.max(0, -outerRadius);
        return -outerRadius - titleOffset - dy;
    }
    update(param) {
        let { seriesRect } = param;
        const { title } = this.properties;
        const newNodeDataDependencies = {
            seriesRectWidth: seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.width,
            seriesRectHeight: seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.height
        };
        const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
        if (resize) {
            this._nodeDataDependencies = newNodeDataDependencies;
        }
        this.maybeRefreshNodeData();
        this.updateTitleNodes();
        this.updateRadiusScale(resize);
        this.contentGroup.translationX = this.centerX;
        this.contentGroup.translationY = this.centerY;
        this.highlightGroup.translationX = this.centerX;
        this.highlightGroup.translationY = this.centerY;
        this.backgroundGroup.translationX = this.centerX;
        this.backgroundGroup.translationY = this.centerY;
        if (this.labelGroup) {
            this.labelGroup.translationX = this.centerX;
            this.labelGroup.translationY = this.centerY;
        }
        if (title) {
            const dy = this.getTitleTranslationY();
            title.node.y = isFinite(dy) ? dy : 0;
            const titleBox = title.node.getBBox(false);
            title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox);
        }
        for (const circle of [
            this.zerosumInnerRing,
            this.zerosumOuterRing
        ]){
            circle.fillOpacity = 0;
            circle.stroke = this.properties.calloutLabel.color;
            circle.strokeWidth = 1;
            circle.strokeOpacity = 1;
        }
        this.updateNodeMidPoint();
        this.updateSelections();
        this.updateNodes(seriesRect);
    }
    updateTitleNodes() {
        const { oldTitle } = this;
        const { title } = this.properties;
        if (oldTitle !== title) {
            if (oldTitle) {
                var _this_labelGroup;
                (_this_labelGroup = this.labelGroup) === null || _this_labelGroup === void 0 ? void 0 : _this_labelGroup.removeChild(oldTitle.node);
            }
            if (title) {
                var _this_labelGroup1;
                title.node.textBaseline = "bottom";
                (_this_labelGroup1 = this.labelGroup) === null || _this_labelGroup1 === void 0 ? void 0 : _this_labelGroup1.appendChild(title.node);
            }
            this.oldTitle = title;
        }
    }
    updateNodeMidPoint() {
        var _this_phantomNodeData;
        const setMidPoint = (d)=>{
            const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;
            d.midPoint = {
                x: d.midCos * Math.max(0, radius),
                y: d.midSin * Math.max(0, radius)
            };
        };
        this.nodeData.forEach(setMidPoint);
        (_this_phantomNodeData = this.phantomNodeData) === null || _this_phantomNodeData === void 0 ? void 0 : _this_phantomNodeData.forEach(setMidPoint);
    }
    updateSelections() {
        this.updateGroupSelection();
        this.updateInnerCircleSelection();
    }
    updateGroupSelection() {
        const { itemSelection, highlightSelection, phantomSelection, calloutLabelSelection, labelSelection, innerLabelsSelection } = this;
        const highlightedNodeData = this.nodeData.map((datum)=>({
                ...datum,
                // Allow mutable sectorFormat, so formatted sector styles can be updated and varied
                // between normal and highlighted cases.
                sectorFormat: {
                    ...datum.sectorFormat
                }
            }));
        const update = (selection, nodeData)=>{
            selection.update(nodeData, void 0, (datum)=>this.getDatumId(datum.datumIndex));
            if (this.ctx.animationManager.isSkipped()) {
                selection.cleanup();
            }
        };
        update(itemSelection, this.nodeData);
        update(highlightSelection, highlightedNodeData);
        var _this_phantomNodeData;
        update(phantomSelection, (_this_phantomNodeData = this.phantomNodeData) !== null && _this_phantomNodeData !== void 0 ? _this_phantomNodeData : []);
        calloutLabelSelection.update(this.calloutNodeData, (group)=>{
            const line = new Line();
            line.tag = 0 /* Callout */ ;
            line.pointerEvents = 1 /* None */ ;
            group.appendChild(line);
            const text = new Text();
            text.tag = 1 /* Label */ ;
            text.pointerEvents = 1 /* None */ ;
            group.appendChild(text);
        });
        labelSelection.update(this.nodeData);
        innerLabelsSelection.update(this.properties.innerLabels, (node)=>{
            node.pointerEvents = 1 /* None */ ;
        });
    }
    updateInnerCircleSelection() {
        const { innerCircle } = this.properties;
        let radius = 0;
        const innerRadius = this.getInnerRadius();
        if (innerRadius > 0) {
            const circleRadius = Math.min(innerRadius, this.getOuterRadius());
            const antiAliasingPadding = 1;
            radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);
        }
        const datums = innerCircle ? [
            {
                radius
            }
        ] : [];
        this.innerCircleSelection.update(datums);
    }
    updateNodes(seriesRect) {
        const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();
        const { visible, dataModel, processedData } = this;
        this.backgroundGroup.visible = visible;
        this.contentGroup.visible = visible;
        if (!dataModel || !processedData) return;
        const { legendItemValues } = this.getProcessedDataValues(dataModel, processedData);
        const seriesHighlighted = this.isSeriesHighlighted(highlightedDatum, legendItemValues);
        this.highlightGroup.visible = visible && seriesHighlighted;
        this.labelGroup.visible = visible;
        this.innerCircleSelection.each((node, param)=>{
            let { radius } = param;
            var _this_properties_innerCircle, _this_properties_innerCircle1;
            node.setProperties({
                fill: this.getNodeFill((_this_properties_innerCircle = this.properties.innerCircle) === null || _this_properties_innerCircle === void 0 ? void 0 : _this_properties_innerCircle.fill, [
                    "black"
                ], "black"),
                opacity: (_this_properties_innerCircle1 = this.properties.innerCircle) === null || _this_properties_innerCircle1 === void 0 ? void 0 : _this_properties_innerCircle1.fillOpacity,
                size: radius
            });
        });
        const innerRadius = this.radiusScale.range[0];
        const outerRadius = this.radiusScale.range[1];
        const fillBBox = this.getShapeFillBBox();
        const animationDisabled = this.ctx.animationManager.isSkipped();
        const updateSectorFn = (sector, datum, _index, isDatumHighlighted)=>{
            const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted, datum, legendItemValues, highlightedDatum);
            datum.sectorFormat.fill = format.fill;
            datum.sectorFormat.stroke = format.stroke;
            if (animationDisabled) {
                sector.startAngle = datum.startAngle;
                sector.endAngle = datum.endAngle;
                sector.innerRadius = datum.innerRadius;
                sector.outerRadius = datum.outerRadius;
            }
            if (isDatumHighlighted || animationDisabled) {
                sector.fill = format.fill;
                sector.stroke = format.stroke;
            }
            const fillParams = this.getFillParams(format.fill, innerRadius, outerRadius);
            applyShapeStyle(sector, format, fillBBox, fillParams);
            sector.cornerRadius = format.cornerRadius;
            sector.fillShadow = this.properties.shadow;
            const inset = Math.max((this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2, 0);
            sector.inset = inset;
            sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? "miter" : "round";
        };
        this.itemSelection.each((node, datum, index)=>updateSectorFn(node, datum, index, false));
        this.highlightSelection.each((node, datum, index)=>{
            updateSectorFn(node, datum, index, true);
            node.visible = datum.itemId === (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.itemId);
        });
        this.phantomSelection.each((node, datum, index)=>updateSectorFn(node, datum, index, false));
        this.updateCalloutLineNodes();
        this.updateCalloutLabelNodes(seriesRect);
        this.updateSectorLabelNodes();
        this.updateInnerLabelNodes();
        this.updateZerosumRings();
        this.animationState.transition("update");
    }
    updateCalloutLineNodes() {
        const { calloutLine: { length: calloutLength, strokeWidth, colors }, strokes } = this.properties;
        const calloutStrokeWidth = strokeWidth;
        const calloutColors = isStringFillArray(colors) ? colors !== null && colors !== void 0 ? colors : this.properties.strokes : strokes;
        const { offset } = this.properties.calloutLabel;
        this.calloutLabelSelection.selectByTag(0 /* Callout */ ).forEach((line)=>{
            const datum = line.closestDatum();
            const { calloutLabel: label, outerRadius, datumIndex } = datum;
            if ((label === null || label === void 0 ? void 0 : label.text) && !label.hidden && outerRadius !== 0) {
                line.visible = true;
                line.strokeWidth = calloutStrokeWidth;
                line.stroke = calloutColors[datumIndex % calloutColors.length];
                var _this_getHighlightStyle_opacity;
                line.strokeOpacity = (_this_getHighlightStyle_opacity = this.getHighlightStyle(false, datum.datumIndex).opacity) !== null && _this_getHighlightStyle_opacity !== void 0 ? _this_getHighlightStyle_opacity : 1;
                line.fill = void 0;
                const x1 = datum.midCos * outerRadius;
                const y1 = datum.midSin * outerRadius;
                let x2 = datum.midCos * (outerRadius + calloutLength);
                let y2 = datum.midSin * (outerRadius + calloutLength);
                var _label_collisionTextAlign;
                const isMoved = (_label_collisionTextAlign = label.collisionTextAlign) !== null && _label_collisionTextAlign !== void 0 ? _label_collisionTextAlign : label.collisionOffsetY !== 0;
                if (isMoved && label.box != null) {
                    const box = label.box;
                    let cx = x2;
                    let cy = y2;
                    if (x2 < box.x) {
                        cx = box.x;
                    } else if (x2 > box.x + box.width) {
                        cx = box.x + box.width;
                    }
                    if (y2 < box.y) {
                        cy = box.y;
                    } else if (y2 > box.y + box.height) {
                        cy = box.y + box.height;
                    }
                    const dx = cx - x2;
                    const dy = cy - y2;
                    const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
                    const paddedLength = length2 - offset;
                    if (paddedLength > 0) {
                        x2 = x2 + dx * paddedLength / length2;
                        y2 = y2 + dy * paddedLength / length2;
                    }
                }
                line.x1 = x1;
                line.y1 = y1;
                line.x2 = x2;
                line.y2 = y2;
            } else {
                line.visible = false;
            }
        });
    }
    getLabelOverflow(text, box, seriesRect) {
        const seriesLeft = -this.centerX;
        const seriesRight = seriesLeft + seriesRect.width;
        const seriesTop = -this.centerY;
        const seriesBottom = seriesTop + seriesRect.height;
        const errPx = 1;
        let visibleTextPart = 1;
        if (box.x + errPx < seriesLeft) {
            visibleTextPart = (box.x + box.width - seriesLeft) / box.width;
        } else if (box.x + box.width - errPx > seriesRight) {
            visibleTextPart = (seriesRight - box.x) / box.width;
        }
        const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;
        const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;
        const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);
        return {
            textLength,
            hasVerticalOverflow,
            hasSurroundingSeriesOverflow
        };
    }
    bboxIntersectsSurroundingSeries(box) {
        const { surroundingRadius } = this;
        if (surroundingRadius == null) {
            return false;
        }
        const corners = [
            {
                x: box.x,
                y: box.y
            },
            {
                x: box.x + box.width,
                y: box.y
            },
            {
                x: box.x + box.width,
                y: box.y + box.height
            },
            {
                x: box.x,
                y: box.y + box.height
            }
        ];
        const sur2 = surroundingRadius ** 2;
        return corners.some((corner)=>corner.x ** 2 + corner.y ** 2 > sur2);
    }
    computeCalloutLabelCollisionOffsets() {
        const { radiusScale } = this;
        const { calloutLabel, calloutLine } = this.properties;
        const { offset, minSpacing } = calloutLabel;
        const innerRadius = radiusScale.convert(0);
        const shouldSkip = (datum)=>{
            const label = datum.calloutLabel;
            return !label || datum.outerRadius === 0;
        };
        const fullData = this.calloutNodeData;
        const data = fullData.filter((t)=>!shouldSkip(t));
        data.forEach((datum)=>{
            const label = datum.calloutLabel;
            if (label == null) return;
            label.hidden = false;
            label.collisionTextAlign = void 0;
            label.collisionOffsetY = 0;
        });
        if (data.length <= 1) {
            return;
        }
        const leftLabels = data.filter((d)=>d.midCos < 0).sort((a, b)=>a.midSin - b.midSin);
        const rightLabels = data.filter((d)=>d.midCos >= 0).sort((a, b)=>a.midSin - b.midSin);
        const topLabels = data.filter((d)=>{
            var _d_calloutLabel;
            return d.midSin < 0 && ((_d_calloutLabel = d.calloutLabel) === null || _d_calloutLabel === void 0 ? void 0 : _d_calloutLabel.textAlign) === "center";
        }).sort((a, b)=>a.midCos - b.midCos);
        const bottomLabels = data.filter((d)=>{
            var _d_calloutLabel;
            return d.midSin >= 0 && ((_d_calloutLabel = d.calloutLabel) === null || _d_calloutLabel === void 0 ? void 0 : _d_calloutLabel.textAlign) === "center";
        }).sort((a, b)=>a.midCos - b.midCos);
        const params = {
            angleKey: this.properties.angleKey
        };
        const getTextBBox = (datum)=>{
            const label = datum.calloutLabel;
            if (label == null) return BBox.zero.clone();
            const style = getLabelStyles(this, datum, params, calloutLabel);
            const padding2 = expandLabelPadding(style);
            const labelRadius = datum.outerRadius + calloutLine.length + offset;
            const x = datum.midCos * labelRadius;
            const y = datum.midSin * labelRadius + label.collisionOffsetY;
            var _label_collisionTextAlign;
            const textAlign = (_label_collisionTextAlign = label.collisionTextAlign) !== null && _label_collisionTextAlign !== void 0 ? _label_collisionTextAlign : label.textAlign;
            const textBaseline = label.textBaseline;
            return Text.computeBBox(label.text, x, y, {
                font: this.properties.calloutLabel,
                textAlign,
                textBaseline
            }, false).grow(padding2);
        };
        const avoidNeighbourYCollision = (label, next, direction)=>{
            const box = getTextBBox(label).grow(minSpacing / 2);
            const other = getTextBBox(next).grow(minSpacing / 2);
            const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === "to-top" ? box.y < other.y + other.height : box.y + box.height > other.y);
            if (collidesOrBehind) {
                next.calloutLabel.collisionOffsetY = direction === "to-top" ? box.y - other.y - other.height : box.y + box.height - other.y;
            }
        };
        const avoidYCollisions = (labels)=>{
            const midLabel = labels.slice().sort((a, b)=>Math.abs(a.midSin) - Math.abs(b.midSin))[0];
            const midIndex = labels.indexOf(midLabel);
            for(let i = midIndex - 1; i >= 0; i--){
                const prev = labels[i + 1];
                const next = labels[i];
                avoidNeighbourYCollision(prev, next, "to-top");
            }
            for(let i = midIndex + 1; i < labels.length; i++){
                const prev = labels[i - 1];
                const next = labels[i];
                avoidNeighbourYCollision(prev, next, "to-bottom");
            }
        };
        const avoidXCollisions = (labels)=>{
            const labelsCollideLabelsByY = data.some((datum)=>datum.calloutLabel.collisionOffsetY !== 0);
            const boxes = labels.map((label)=>getTextBBox(label));
            const paddedBoxes = boxes.map((box)=>box.clone().grow(minSpacing / 2));
            let labelsCollideLabelsByX = false;
            for(let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++){
                const box = paddedBoxes[i];
                for(let j = i + 1; j < labels.length; j++){
                    const other = paddedBoxes[j];
                    if (box.collidesBBox(other)) {
                        labelsCollideLabelsByX = true;
                        break;
                    }
                }
            }
            const sectors = fullData.map((datum)=>{
                const { startAngle, endAngle, outerRadius } = datum;
                return {
                    startAngle,
                    endAngle,
                    innerRadius,
                    outerRadius
                };
            });
            const labelsCollideSectors = boxes.some((box)=>{
                return sectors.some((sector)=>boxCollidesSector(box, sector));
            });
            if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {
                return;
            }
            labels.filter((d)=>d.calloutLabel.textAlign === "center").forEach((d)=>{
                const label = d.calloutLabel;
                if (d.midCos < 0) {
                    label.collisionTextAlign = "right";
                } else if (d.midCos > 0) {
                    label.collisionTextAlign = "left";
                } else {
                    label.collisionTextAlign = "center";
                }
            });
        };
        avoidYCollisions(leftLabels);
        avoidYCollisions(rightLabels);
        avoidXCollisions(topLabels);
        avoidXCollisions(bottomLabels);
    }
    updateCalloutLabelNodes(seriesRect) {
        const { radiusScale } = this;
        const { calloutLabel, calloutLine } = this.properties;
        const tempTextNode = new Text();
        this.calloutLabelSelection.selectByTag(1 /* Label */ ).forEach((text)=>{
            var _this_ctx_highlightManager;
            const datum = text.closestDatum();
            const label = datum.calloutLabel;
            const radius = radiusScale.convert(datum.radius);
            const outerRadius = Math.max(0, radius);
            if (!(label === null || label === void 0 ? void 0 : label.text) || outerRadius === 0 || label.hidden) {
                text.visible = false;
                return;
            }
            const activeHighlight = (_this_ctx_highlightManager = this.ctx.highlightManager) === null || _this_ctx_highlightManager === void 0 ? void 0 : _this_ctx_highlightManager.getActiveHighlight();
            const isHighlight = false;
            const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datum.datumIndex);
            const style = getLabelStyles(this, datum, this.properties, calloutLabel, isHighlight, highlightState);
            const labelRadius = outerRadius + calloutLine.length + calloutLabel.offset;
            const x = datum.midCos * labelRadius;
            const y = datum.midSin * labelRadius + label.collisionOffsetY;
            var _label_collisionTextAlign;
            const align2 = {
                textAlign: (_label_collisionTextAlign = label.collisionTextAlign) !== null && _label_collisionTextAlign !== void 0 ? _label_collisionTextAlign : label.textAlign,
                textBaseline: label.textBaseline
            };
            tempTextNode.text = label.text;
            tempTextNode.x = x;
            tempTextNode.y = y;
            tempTextNode.setFont(style);
            tempTextNode.setAlign(align2);
            tempTextNode.setBoxing(style);
            const box = tempTextNode.getBBox(false);
            let displayText = label.text;
            let visible = true;
            if (calloutLabel.avoidCollisions) {
                const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);
                displayText = label.text.length === textLength ? label.text : "".concat(label.text.substring(0, textLength), "");
                visible = !hasVerticalOverflow;
            }
            text.text = displayText;
            text.x = x;
            text.y = y;
            text.setFont(style);
            text.setAlign(align2);
            text.setBoxing(style);
            text.fill = style.color;
            var _this_getHighlightStyle_opacity;
            text.fillOpacity = (_this_getHighlightStyle_opacity = this.getHighlightStyle(false, datum.datumIndex).opacity) !== null && _this_getHighlightStyle_opacity !== void 0 ? _this_getHighlightStyle_opacity : 1;
            text.visible = visible;
        });
    }
    computeLabelsBBox(options, seriesRect) {
        const { calloutLabel, calloutLine } = this.properties;
        const calloutLength = calloutLine.length;
        const { offset, maxCollisionOffset, minSpacing } = calloutLabel;
        if (!calloutLabel.avoidCollisions) {
            return null;
        }
        this.maybeRefreshNodeData();
        this.updateRadiusScale(false);
        this.computeCalloutLabelCollisionOffsets();
        const textBoxes = [];
        const text = new Text();
        let titleBox;
        const { title } = this.properties;
        if ((title === null || title === void 0 ? void 0 : title.text) && title.enabled) {
            const dy = this.getTitleTranslationY();
            if (isFinite(dy)) {
                text.text = title.text;
                text.x = 0;
                text.y = dy;
                text.setFont(title);
                text.setAlign({
                    textBaseline: "bottom",
                    textAlign: "center"
                });
                titleBox = text.getBBox(false);
                textBoxes.push(titleBox);
            }
        }
        const params = {
            angleKey: this.properties.angleKey
        };
        this.calloutNodeData.forEach((datum)=>{
            const label = datum.calloutLabel;
            if (!label || datum.outerRadius === 0) {
                return null;
            }
            const style = getLabelStyles(this, datum, params, calloutLabel);
            const labelRadius = datum.outerRadius + calloutLength + offset;
            const x = datum.midCos * labelRadius;
            const y = datum.midSin * labelRadius + label.collisionOffsetY;
            text.text = label.text;
            text.x = x;
            text.y = y;
            text.setFont(style);
            var _label_collisionTextAlign;
            text.setAlign({
                textAlign: (_label_collisionTextAlign = label.collisionTextAlign) !== null && _label_collisionTextAlign !== void 0 ? _label_collisionTextAlign : label.textAlign,
                textBaseline: label.textBaseline
            });
            text.setBoxing(style);
            const box = text.getBBox(false);
            label.box = box;
            if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {
                label.hidden = true;
                return;
            }
            if (titleBox) {
                const seriesTop = -this.centerY;
                const titleCleanArea = new BBox(titleBox.x - minSpacing, seriesTop, titleBox.width + 2 * minSpacing, titleBox.y + titleBox.height + minSpacing - seriesTop);
                if (box.collidesBBox(titleCleanArea)) {
                    label.hidden = true;
                    return;
                }
            }
            if (options.hideWhenNecessary) {
                const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(label.text, box, seriesRect);
                const isTooShort = label.text.length > 2 && textLength < 2;
                if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {
                    label.hidden = true;
                    return;
                }
            }
            label.hidden = false;
            textBoxes.push(box);
        });
        if (textBoxes.length === 0) {
            return null;
        }
        return BBox.merge(textBoxes);
    }
    updateSectorLabelNodes() {
        var // is donut?
        _this_ctx_legendManager_getData;
        const { properties } = this;
        const { positionOffset, positionRatio } = this.properties.sectorLabel;
        const innerRadius = this.radiusScale.convert(0);
        const shouldPutTextInCenter = innerRadius <= 0 && ((_this_ctx_legendManager_getData = this.ctx.legendManager.getData(this.id)) === null || _this_ctx_legendManager_getData === void 0 ? void 0 : _this_ctx_legendManager_getData.filter((d)=>d.enabled).length) === 1;
        const align2 = {
            textAlign: "center",
            textBaseline: "middle"
        };
        const updateSectorLabel = (text, datum)=>{
            const { outerRadius, startAngle, endAngle } = datum;
            let isTextVisible = false;
            if (datum.sectorLabel && outerRadius !== 0) {
                var _this_ctx_highlightManager;
                const activeHighlight = (_this_ctx_highlightManager = this.ctx.highlightManager) === null || _this_ctx_highlightManager === void 0 ? void 0 : _this_ctx_highlightManager.getActiveHighlight();
                const isHighlight = false;
                const highlightState = this.getHighlightStateString(activeHighlight, isHighlight, datum.datumIndex);
                const style = getLabelStyles(this, datum, properties, properties.sectorLabel, isHighlight, highlightState);
                const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;
                text.fill = style.color;
                var _this_getHighlightStyle_opacity;
                text.fillOpacity = (_this_getHighlightStyle_opacity = this.getHighlightStyle(false, datum.datumIndex).opacity) !== null && _this_getHighlightStyle_opacity !== void 0 ? _this_getHighlightStyle_opacity : 1;
                text.text = datum.sectorLabel.text;
                if (shouldPutTextInCenter) {
                    text.x = 0;
                    text.y = 0;
                } else {
                    text.x = datum.midCos * labelRadius;
                    text.y = datum.midSin * labelRadius;
                }
                text.setFont(style);
                text.setAlign(align2);
                text.setBoxing(style);
                const bbox = text.getBBox(false);
                const corners = [
                    [
                        bbox.x,
                        bbox.y
                    ],
                    [
                        bbox.x + bbox.width,
                        bbox.y
                    ],
                    [
                        bbox.x + bbox.width,
                        bbox.y + bbox.height
                    ],
                    [
                        bbox.x,
                        bbox.y + bbox.height
                    ]
                ];
                const sectorBounds = {
                    startAngle,
                    endAngle,
                    innerRadius,
                    outerRadius
                };
                if (corners.every((param)=>{
                    let [x, y] = param;
                    return isPointInSector(x, y, sectorBounds);
                })) {
                    isTextVisible = true;
                }
            }
            text.visible = isTextVisible;
        };
        this.labelSelection.each(updateSectorLabel);
    }
    updateInnerLabelNodes() {
        const textBBoxes = [];
        const margins = [];
        this.innerLabelsSelection.each((text, datum)=>{
            const { fontStyle, fontWeight, fontSize, fontFamily, color: color11 } = datum;
            text.fontStyle = fontStyle;
            text.fontWeight = fontWeight;
            text.fontSize = fontSize;
            text.fontFamily = fontFamily;
            text.text = datum.text;
            text.x = 0;
            text.y = 0;
            text.fill = color11;
            text.textAlign = "center";
            text.textBaseline = "alphabetic";
            textBBoxes.push(text.getBBox());
            margins.push(datum.spacing);
        });
        const getMarginTop = (index)=>index === 0 ? 0 : margins[index];
        const getMarginBottom = (index)=>index === margins.length - 1 ? 0 : margins[index];
        const totalWidth = textBBoxes.reduce((max, bbox)=>max < bbox.width ? bbox.width : max, 0);
        const totalHeight = textBBoxes.reduce((sum2, bbox, i)=>sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i), 0);
        const innerRadius = this.getInnerRadius();
        const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));
        const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());
        const textBottoms = [];
        for(let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++){
            const bbox = textBBoxes[i];
            const bottom = bbox.height + prev + getMarginTop(i);
            textBottoms.push(bottom);
            prev = bottom + getMarginBottom(i);
        }
        this.innerLabelsSelection.each((text, _datum, index)=>{
            text.visible = labelsVisible;
            if (Array.isArray(text.text)) {
                text.y = textBottoms[index] - textBBoxes[index].height;
            } else {
                text.y = textBottoms[index];
            }
        });
    }
    updateZerosumRings() {
        this.zerosumOuterRing.size = this.getOuterRadius() * 2;
        this.zerosumInnerRing.size = this.getInnerRadius() * 2;
    }
    pickNodeClosestDatum(point) {
        return pickByMatchingAngle(this, point);
    }
    getTooltipContent(datumIndex) {
        var _processedData_dataSources_get;
        const { id: seriesId, dataModel, processedData, properties, ctx: { formatManager } } = this;
        const { legendItemKey, calloutLabelKey, calloutLabelName, sectorLabelKey, sectorLabelName, angleKey, angleName, radiusKey, radiusName, tooltip } = properties;
        const title = this.properties.title.node.getPlainText();
        if (!dataModel || !processedData) return;
        const datum = (_processedData_dataSources_get = processedData.dataSources.get(this.id)) === null || _processedData_dataSources_get === void 0 ? void 0 : _processedData_dataSources_get[datumIndex];
        const processedDataValues = this.getProcessedDataValues(dataModel, processedData);
        const { angleRawValues } = processedDataValues;
        const angleRawValue = angleRawValues[datumIndex];
        const labelValues = this.getLabelContent(datumIndex, datum, processedDataValues);
        var _labelValues_legendItem, _ref, _ref1;
        const label = (_ref1 = (_ref = (_labelValues_legendItem = labelValues.legendItem) !== null && _labelValues_legendItem !== void 0 ? _labelValues_legendItem : labelValues.callout) !== null && _ref !== void 0 ? _ref : labelValues.sector) !== null && _ref1 !== void 0 ? _ref1 : angleName;
        const domain = dataModel.getDomain(this, "angleRaw", "value", processedData);
        var _formatManager_format;
        const angleContent = (_formatManager_format = formatManager.format(this.callWithContext.bind(this), {
            type: "number",
            value: angleRawValue,
            datum,
            seriesId,
            legendItemName: void 0,
            key: angleKey,
            source: "tooltip",
            property: "angle",
            domain,
            boundSeries: this.getFormatterContext("angle"),
            fractionDigits: void 0
        })) !== null && _formatManager_format !== void 0 ? _formatManager_format : formatValue(angleRawValue, 3);
        return this.formatTooltipWithContext(tooltip, {
            title,
            symbol: this.legendItemSymbol(datumIndex),
            data: [
                {
                    label,
                    fallbackLabel: angleKey,
                    value: angleContent
                }
            ]
        }, {
            seriesId,
            datum,
            title: angleName,
            legendItemKey,
            calloutLabelKey,
            calloutLabelName,
            sectorLabelKey,
            sectorLabelName,
            angleKey,
            angleName,
            radiusKey,
            radiusName,
            ...this.getSectorFormat(datum, datumIndex, false)
        });
    }
    legendItemSymbol(datumIndex) {
        var _this_processedData_dataSources_get, _this_processedData;
        const datum = (_this_processedData = this.processedData) === null || _this_processedData === void 0 ? void 0 : (_this_processedData_dataSources_get = _this_processedData.dataSources.get(this.id)) === null || _this_processedData_dataSources_get === void 0 ? void 0 : _this_processedData_dataSources_get[datumIndex];
        const sectorFormat = this.getSectorFormat(datum, datumIndex, false);
        const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this.properties;
        let { fill } = sectorFormat;
        const { stroke: stroke2 } = sectorFormat;
        if (isGradientFill(fill)) {
            fill = {
                ...fill,
                gradient: "linear",
                rotation: 0,
                reverse: false
            };
        }
        return {
            marker: {
                fill,
                stroke: stroke2,
                fillOpacity,
                strokeOpacity,
                strokeWidth,
                lineDash,
                lineDashOffset
            }
        };
    }
    getLegendData(legendType) {
        var _this_properties_title, _processedData_invalidData;
        const { visible, processedData, dataModel, id: seriesId, ctx: { legendManager } } = this;
        if (!dataModel || !processedData || legendType !== "category") {
            return [];
        }
        const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey, showInLegend } = this.properties;
        if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {
            return [];
        }
        const processedDataValues = this.getProcessedDataValues(dataModel, processedData);
        const { angleRawValues } = processedDataValues;
        const titleText = ((_this_properties_title = this.properties.title) === null || _this_properties_title === void 0 ? void 0 : _this_properties_title.showInLegend) && this.properties.title.text;
        const legendData = [];
        const hideZeros = this.properties.hideZeroValueSectorsInLegend;
        const rawData = processedData.dataSources.get(this.id);
        const invalidData = (_processedData_invalidData = processedData.invalidData) === null || _processedData_invalidData === void 0 ? void 0 : _processedData_invalidData.get(this.id);
        for(let datumIndex = 0; datumIndex < processedData.input.count; datumIndex++){
            const datum = rawData === null || rawData === void 0 ? void 0 : rawData[datumIndex];
            const angleRawValue = angleRawValues[datumIndex];
            if ((invalidData === null || invalidData === void 0 ? void 0 : invalidData[datumIndex]) === true || hideZeros && angleRawValue === 0) {
                continue;
            }
            const labelParts = [];
            if (titleText) {
                labelParts.push(titleText);
            }
            const labels = this.getLabelContent(datumIndex, datum, processedDataValues);
            if (legendItemKey && labels.legendItem !== void 0) {
                labelParts.push(labels.legendItem);
            } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.callout !== void 0) {
                labelParts.push(labels.callout);
            } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sector !== void 0) {
                labelParts.push(labels.sector);
            }
            if (labelParts.length === 0) continue;
            legendData.push({
                legendType: "category",
                id: seriesId,
                datum,
                itemId: datumIndex,
                seriesId,
                hideToggleOtherSeries: true,
                enabled: visible && legendManager.getItemEnabled({
                    seriesId,
                    itemId: datumIndex
                }),
                label: {
                    text: labelParts.join(" - ")
                },
                symbol: this.legendItemSymbol(datumIndex),
                legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0,
                hideInLegend: !showInLegend
            });
        }
        return legendData;
    }
    // Used for grid
    setLegendState(enabledItems) {
        const { id: seriesId, ctx: { legendManager, updateService } } = this;
        enabledItems.forEach((enabled, itemId)=>legendManager.toggleItem(enabled, seriesId, itemId));
        legendManager.update();
        updateService.update(5 /* SERIES_UPDATE */ );
    }
    animateEmptyUpdateReady(_data) {
        const { animationManager } = this.ctx;
        const fns = preparePieSeriesAnimationFunctions(true, this.properties.rotation, this.radiusScale, this.previousRadiusScale);
        fromToMotion(this.id, "nodes", animationManager, [
            this.itemSelection,
            this.highlightSelection,
            this.phantomSelection
        ], fns.nodes, (_, datum)=>this.getDatumId(datum.datumIndex));
        fromToMotion(this.id, "innerCircle", animationManager, [
            this.innerCircleSelection
        ], fns.innerCircle);
        seriesLabelFadeInAnimation(this, "callout", animationManager, this.calloutLabelSelection);
        seriesLabelFadeInAnimation(this, "sector", animationManager, this.labelSelection);
        seriesLabelFadeInAnimation(this, "inner", animationManager, this.innerLabelsSelection);
        this.previousRadiusScale.range = this.radiusScale.range;
    }
    animateWaitingUpdateReady() {
        var _processedData_reduced_diff, _processedData_reduced, _processedData_reduced_animationValidation, _processedData_reduced1;
        const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;
        const { animationManager } = this.ctx;
        const dataDiff = processedData === null || processedData === void 0 ? void 0 : (_processedData_reduced = processedData.reduced) === null || _processedData_reduced === void 0 ? void 0 : (_processedData_reduced_diff = _processedData_reduced.diff) === null || _processedData_reduced_diff === void 0 ? void 0 : _processedData_reduced_diff[this.id];
        this.ctx.animationManager.stopByAnimationGroupId(this.id);
        var _dataDiff_moved_size;
        const supportedDiff = ((_dataDiff_moved_size = dataDiff === null || dataDiff === void 0 ? void 0 : dataDiff.moved.size) !== null && _dataDiff_moved_size !== void 0 ? _dataDiff_moved_size : 0) === 0;
        var _processedData_defs_keys_length;
        const hasKeys = ((_processedData_defs_keys_length = processedData === null || processedData === void 0 ? void 0 : processedData.defs.keys.length) !== null && _processedData_defs_keys_length !== void 0 ? _processedData_defs_keys_length : 0) > 0;
        var _processedData_reduced_animationValidation_uniqueKeys;
        const hasUniqueKeys = (_processedData_reduced_animationValidation_uniqueKeys = processedData === null || processedData === void 0 ? void 0 : (_processedData_reduced1 = processedData.reduced) === null || _processedData_reduced1 === void 0 ? void 0 : (_processedData_reduced_animationValidation = _processedData_reduced1.animationValidation) === null || _processedData_reduced_animationValidation === void 0 ? void 0 : _processedData_reduced_animationValidation.uniqueKeys) !== null && _processedData_reduced_animationValidation_uniqueKeys !== void 0 ? _processedData_reduced_animationValidation_uniqueKeys : true;
        if (!supportedDiff || !hasKeys || !hasUniqueKeys) {
            this.ctx.animationManager.skipCurrentBatch();
        }
        const noVisibleData = !this.nodeData.some((n)=>n.enabled);
        const fns = preparePieSeriesAnimationFunctions(false, this.properties.rotation, radiusScale, previousRadiusScale);
        fromToMotion(this.id, "nodes", animationManager, [
            itemSelection,
            highlightSelection,
            phantomSelection
        ], fns.nodes, (_, datum)=>this.getDatumId(datum.datumIndex), dataDiff);
        fromToMotion(this.id, "innerCircle", animationManager, [
            this.innerCircleSelection
        ], fns.innerCircle);
        seriesLabelFadeInAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
        seriesLabelFadeInAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
        if (this.noVisibleData !== noVisibleData) {
            this.noVisibleData = noVisibleData;
            seriesLabelFadeInAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
        }
        this.previousRadiusScale.range = this.radiusScale.range;
    }
    animateClearingUpdateEmpty() {
        const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;
        const { animationManager } = this.ctx;
        const fns = preparePieSeriesAnimationFunctions(false, this.properties.rotation, radiusScale, previousRadiusScale);
        fromToMotion(this.id, "nodes", animationManager, [
            itemSelection,
            highlightSelection,
            phantomSelection
        ], fns.nodes, (_, datum)=>this.getDatumId(datum.datumIndex));
        fromToMotion(this.id, "innerCircle", animationManager, [
            this.innerCircleSelection
        ], fns.innerCircle);
        seriesLabelFadeOutAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
        seriesLabelFadeOutAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
        seriesLabelFadeOutAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
        this.previousRadiusScale.range = this.radiusScale.range;
    }
    getDatumId(datumIndex) {
        return "".concat(datumIndex);
    }
    hasItemStylers() {
        const { itemStyler, calloutLabel, sectorLabel } = this.properties;
        var _ref;
        return ((_ref = itemStyler !== null && itemStyler !== void 0 ? itemStyler : calloutLabel.itemStyler) !== null && _ref !== void 0 ? _ref : sectorLabel.itemStyler) != null;
    }
    constructor(moduleCtx){
        super({
            moduleCtx,
            categoryKey: void 0,
            propertyKeys: {
                ...DEFAULT_POLAR_DIRECTION_KEYS,
                sectorLabel: [
                    "sectorLabelKey"
                ],
                calloutLabel: [
                    "calloutLabelKey"
                ]
            },
            propertyNames: {
                ...DEFAULT_POLAR_DIRECTION_NAMES,
                sectorLabel: [
                    "sectorLabelName"
                ],
                calloutLabel: [
                    "calloutLabelName"
                ]
            },
            pickModes: [
                1 /* NEAREST_NODE */ ,
                0 /* EXACT_SHAPE_MATCH */ 
            ],
            animationResetFns: {
                item: resetPieSelectionsFn,
                label: resetLabelFn
            }
        });
        this.properties = new DonutSeriesProperties();
        this.phantomNodeData = void 0;
        this.backgroundGroup = new TranslatableGroup({
            name: "".concat(this.id, "-background"),
            zIndex: 0 /* BACKGROUND */ 
        });
        this.noVisibleData = false;
        this.previousRadiusScale = new LinearScale();
        this.radiusScale = new LinearScale();
        this.phantomGroup = this.backgroundGroup.appendChild(new Group({
            name: "phantom"
        }));
        this.phantomSelection = Selection.select(this.phantomGroup, ()=>this.nodeFactory(), false);
        this.calloutLabelGroup = this.contentGroup.appendChild(new Group({
            name: "pieCalloutLabels"
        }));
        this.calloutLabelSelection = new Selection(this.calloutLabelGroup, Group);
        // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.
        this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({
            name: "".concat(this.id, "-zerosumRings")
        }));
        this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Marker({
            shape: "circle"
        }));
        this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Marker({
            shape: "circle"
        }));
        this.innerLabelsGroup = this.contentGroup.appendChild(new Group({
            name: "innerLabels"
        }));
        this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({
            name: "".concat(this.id, "-innerCircle")
        }));
        this.innerLabelsSelection = Selection.select(this.innerLabelsGroup, Text);
        this.innerCircleSelection = Selection.select(this.innerCircleGroup, ()=>new Marker({
                shape: "circle"
            }));
        this.surroundingRadius = void 0;
        this.NodeEvent = PieDonutSeriesNodeEvent;
        this.angleScale = new LinearScale();
        this.angleScale.domain = [
            0,
            1
        ];
        this.angleScale.range = [
            -Math.PI,
            Math.PI
        ].map((angle2)=>angle2 + Math.PI / 2);
        this.phantomGroup.opacity = 0.2;
        this.innerLabelsGroup.pointerEvents = 1 /* None */ ;
    }
};
DonutSeries.className = "DonutSeries";
DonutSeries.type = "donut";
// packages/ag-charts-community/src/chart/series/polar/donutTheme.ts
var donutTheme = {
    series: {
        title: {
            enabled: true,
            fontWeight: {
                $ref: "fontWeight"
            },
            fontSize: {
                $rem: FONT_SIZE_RATIO.LARGE
            },
            fontFamily: {
                $ref: "fontFamily"
            },
            color: {
                $ref: "subtleTextColor"
            },
            spacing: 5
        },
        calloutLabel: {
            ...LABEL_BOXING_DEFAULTS,
            enabled: true,
            fontSize: {
                $ref: "fontSize"
            },
            fontFamily: {
                $ref: "fontFamily"
            },
            fontWeight: {
                $ref: "fontWeight"
            },
            color: {
                $ref: "textColor"
            },
            offset: 3,
            minAngle: 1e-3
        },
        sectorLabel: {
            ...LABEL_BOXING_DEFAULTS,
            enabled: true,
            fontWeight: {
                $ref: "fontWeight"
            },
            fontSize: {
                $ref: "fontSize"
            },
            fontFamily: {
                $ref: "fontFamily"
            },
            color: {
                $ref: "chartBackgroundColor"
            },
            positionOffset: 0,
            positionRatio: 0.5
        },
        calloutLine: {
            length: 10,
            strokeWidth: 2,
            colors: {
                $map: [
                    {
                        $if: [
                            {
                                $or: [
                                    {
                                        $isGradient: {
                                            $value: "$1"
                                        }
                                    },
                                    {
                                        $isPattern: {
                                            $value: "$1"
                                        }
                                    },
                                    {
                                        $isImage: {
                                            $value: "$1"
                                        }
                                    }
                                ]
                            },
                            {
                                $path: [
                                    "../../strokes/$index",
                                    {
                                        $ref: "foregroundColor"
                                    }
                                ]
                            },
                            {
                                $value: "$1"
                            }
                        ]
                    },
                    {
                        $if: [
                            {
                                $eq: [
                                    {
                                        $path: "../strokeWidth"
                                    },
                                    0
                                ]
                            },
                            {
                                $path: "../fills"
                            },
                            {
                                $path: "../strokes"
                            }
                        ]
                    }
                ]
            }
        },
        fills: {
            $palette: "fills"
        },
        strokes: {
            $palette: "strokes"
        },
        // @ts-expect-error undocumented option
        defaultColorRange: {
            $palette: "gradients"
        },
        defaultPatternFills: SAFE_FILLS_OPERATION,
        fillOpacity: 1,
        strokeOpacity: 1,
        strokeWidth: {
            $isUserOption: [
                "./strokes/0",
                2,
                0
            ]
        },
        lineDash: [
            0
        ],
        lineDashOffset: 0,
        rotation: 0,
        sectorSpacing: 1,
        innerRadiusRatio: {
            $if: [
                {
                    $eq: [
                        {
                            $path: [
                                "./innerRadiusOffset",
                                void 0
                            ]
                        },
                        void 0
                    ]
                },
                0.7,
                void 0
            ]
        },
        shadow: {
            enabled: false,
            color: DEFAULT_SHADOW_COLOUR,
            xOffset: 3,
            yOffset: 3,
            blur: 5
        },
        innerLabels: {
            $apply: {
                ...LABEL_BOXING_DEFAULTS,
                fontSize: {
                    $ref: "fontSize"
                },
                fontFamily: {
                    $ref: "fontFamily"
                },
                fontWeight: {
                    $ref: "fontWeight"
                },
                color: {
                    $ref: "textColor"
                },
                spacing: 2
            }
        },
        highlight: singleSeriesHighlightStyle()
    },
    legend: {
        enabled: true
    }
};
// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts
var DonutSeriesModule = {
    type: "series",
    optionsKey: "series[]",
    packageType: "community",
    chartTypes: [
        "polar"
    ],
    identifier: "donut",
    moduleFactory: (ctx)=>new DonutSeries(ctx),
    themeTemplate: donutTheme
};
var NewDonutSeriesModule = {
    type: "series",
    name: "donut",
    chartType: "polar",
    options: donutSeriesOptionsDef,
    create: (ctx)=>new DonutSeries(ctx)
};
// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts
var PieSeries = class extends DonutSeries {
};
PieSeries.className = "PieSeries";
PieSeries.type = "pie";
// packages/ag-charts-community/src/chart/series/polar/pieTheme.ts
var pieTheme = {
    series: {
        title: {
            enabled: true,
            fontWeight: {
                $ref: "fontWeight"
            },
            fontSize: {
                $rem: FONT_SIZE_RATIO.LARGE
            },
            fontFamily: {
                $ref: "fontFamily"
            },
            color: {
                $ref: "subtleTextColor"
            },
            spacing: 5
        },
        calloutLabel: {
            ...LABEL_BOXING_DEFAULTS,
            enabled: true,
            fontSize: {
                $ref: "fontSize"
            },
            fontFamily: {
                $ref: "fontFamily"
            },
            fontWeight: {
                $ref: "fontWeight"
            },
            color: {
                $ref: "textColor"
            },
            offset: 3,
            minAngle: 1e-3
        },
        sectorLabel: {
            ...LABEL_BOXING_DEFAULTS,
            enabled: true,
            fontWeight: {
                $ref: "fontWeight"
            },
            fontSize: {
                $ref: "fontSize"
            },
            fontFamily: {
                $ref: "fontFamily"
            },
            color: {
                $ref: "chartBackgroundColor"
            },
            positionOffset: 0,
            positionRatio: 0.5
        },
        calloutLine: {
            length: 10,
            strokeWidth: 2,
            colors: {
                $map: [
                    {
                        $if: [
                            {
                                $or: [
                                    {
                                        $isGradient: {
                                            $value: "$1"
                                        }
                                    },
                                    {
                                        $isPattern: {
                                            $value: "$1"
                                        }
                                    },
                                    {
                                        $isImage: {
                                            $value: "$1"
                                        }
                                    }
                                ]
                            },
                            {
                                $path: [
                                    "../../strokes/$index",
                                    {
                                        $ref: "foregroundColor"
                                    }
                                ]
                            },
                            {
                                $value: "$1"
                            }
                        ]
                    },
                    {
                        $if: [
                            {
                                $eq: [
                                    {
                                        $path: "../strokeWidth"
                                    },
                                    0
                                ]
                            },
                            {
                                $path: "../fills"
                            },
                            {
                                $path: "../strokes"
                            }
                        ]
                    }
                ]
            }
        },
        fills: {
            $palette: "fills"
        },
        strokes: {
            $palette: "strokes"
        },
        // @ts-expect-error undocumented option
        defaultColorRange: {
            $palette: "gradients"
        },
        defaultPatternFills: SAFE_FILLS_OPERATION,
        fillOpacity: 1,
        strokeOpacity: 1,
        strokeWidth: {
            $isUserOption: [
                "./strokes/0",
                2,
                0
            ]
        },
        lineDash: [
            0
        ],
        lineDashOffset: 0,
        rotation: 0,
        sectorSpacing: 1,
        shadow: {
            enabled: false,
            color: DEFAULT_SHADOW_COLOUR,
            xOffset: 3,
            yOffset: 3,
            blur: 5
        },
        highlight: multiSeriesHighlightStyle()
    },
    legend: {
        enabled: true
    }
};
// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts
var PieSeriesModule = {
    type: "series",
    optionsKey: "series[]",
    packageType: "community",
    chartTypes: [
        "polar"
    ],
    identifier: "pie",
    moduleFactory: (ctx)=>new PieSeries(ctx),
    themeTemplate: pieTheme
};
var NewPieSeriesModule = {
    type: "series",
    name: "pie",
    chartType: "polar",
    options: pieSeriesOptionsDef,
    create: (ctx)=>new PieSeries(ctx)
};
// packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts
function registerInbuiltModules() {
    moduleRegistry.register(BackgroundModule, SeriesAreaModule, CommunityLegendModule, LocaleModule, AreaSeriesModule, BarSeriesModule, BubbleSeriesModule, LineSeriesModule, ScatterSeriesModule, DonutSeriesModule, PieSeriesModule, HistogramSeriesModule);
    for (const AxisConstructor of [
        NumberAxis,
        CategoryAxis,
        TimeAxis,
        GroupedCategoryAxis,
        LogAxis,
        UnitTimeAxis
    ]){
        axisRegistry.register(AxisConstructor.type, {
            moduleFactory: (ctx)=>new AxisConstructor(ctx)
        });
    }
}
;
function setupModules() {
    for (const m of moduleRegistry.modules){
        if (m.packageType === "enterprise" && !verifyIfModuleExpected(m)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].errorOnce("Unexpected enterprise module registered: " + m.identifier);
        }
        if (m.type === "root" && m.themeTemplate) {
            for (const chartType of m.chartTypes){
                chartDefaults.set(chartType, m.themeTemplate);
            }
        }
        if (m.type === "series") {
            if (m.chartTypes.length > 1) {
                throw new Error("AG Charts - Module definition error: ".concat(m.identifier));
            }
            seriesRegistry.register(m.identifier, m);
        }
        if (m.type === "series-option" && m.themeTemplate) {
            for (const seriesType of m.seriesTypes){
                seriesRegistry.setThemeTemplate(seriesType, m.themeTemplate);
            }
        }
        if (m.type === "axis-option" && m.themeTemplate) {
            for (const axisType of m.axisTypes){
                const axisTypeTheme = axisRegistry.getThemeTemplate(axisType);
                const theme = mergeDefaults(m.themeTemplate, axisTypeTheme);
                axisRegistry.setThemeTemplate(axisType, theme);
            }
        }
        if (m.type === "axis") {
            axisRegistry.register(m.identifier, m);
        }
        if (m.type === "legend") {
            legendRegistry.register(m.identifier, m);
        }
    }
    if (moduleRegistry.hasEnterpriseModules()) {
        const expectedButUnused = getUnusedExpectedModules();
        if (expectedButUnused.length > 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].errorOnce("Enterprise modules expected but not registered: ", expectedButUnused);
        }
    }
}
;
// packages/ag-charts-community/src/api/preset/presetUtils.ts
var IGNORED_PROP = Symbol("IGNORED_PROP");
function pickProps(opts, values) {
    const out = {};
    for (const key of Object.keys(values)){
        const value = values[key];
        if (value !== IGNORED_PROP && Object.hasOwn(opts, key)) {
            out[key] = value;
        }
    }
    return out;
}
// packages/ag-charts-community/src/api/preset/gauge.ts
function tooltipOptions(opts) {
    const { enabled, mode, showArrow, range: range3, position, pagination, delay, wrapping, interaction, renderer, ...rest } = opts;
    const seriesTooltipOptions = pickProps(opts, {
        enabled,
        showArrow,
        range: range3,
        position,
        interaction,
        renderer,
        ...rest
    });
    const chartTooltipOptions = pickProps(opts, {
        enabled: IGNORED_PROP,
        showArrow: IGNORED_PROP,
        range: IGNORED_PROP,
        position: IGNORED_PROP,
        mode,
        pagination,
        delay,
        wrapping,
        ...rest
    });
    return {
        chartTooltipOptions,
        seriesTooltipOptions
    };
}
function radialGaugeOptions(opts) {
    const { animation, background, container, contextMenu, context, footnote, height: height2, listeners, locale, minHeight, minWidth, overrideDevicePixelRatio, padding: padding2, subtitle, theme, title, width: width2, type, cursor, nodeClickRange, tooltip = {}, value, scale: scale2 = {}, startAngle, endAngle, // eslint-disable-next-line sonarjs/deprecation
    highlightStyle, highlight: highlight5, segmentation, bar, needle, targets, outerRadius, innerRadius, outerRadiusRatio, innerRadiusRatio, cornerRadius, cornerMode, label, secondaryLabel, spacing, ...rest } = opts;
    const { chartTooltipOptions, seriesTooltipOptions } = tooltipOptions(tooltip);
    const chartOpts = pickProps(opts, {
        animation,
        background,
        container,
        contextMenu,
        context,
        footnote,
        height: height2,
        listeners,
        locale,
        minHeight,
        minWidth,
        overrideDevicePixelRatio,
        padding: padding2,
        subtitle,
        theme,
        title,
        tooltip: chartTooltipOptions,
        width: width2
    });
    const seriesOpts = pickProps(opts, {
        needle: needle != null ? {
            enabled: true,
            ...needle
        } : IGNORED_PROP,
        startAngle,
        endAngle,
        scale: scale2,
        type,
        cursor,
        context,
        nodeClickRange,
        tooltip: seriesTooltipOptions,
        value,
        highlightStyle,
        highlight: highlight5,
        segmentation,
        bar,
        targets,
        outerRadius,
        innerRadius,
        outerRadiusRatio,
        innerRadiusRatio,
        cornerRadius,
        cornerMode,
        label,
        secondaryLabel,
        spacing,
        ...rest
    });
    return {
        ...chartOpts,
        series: [
            seriesOpts
        ]
    };
}
function linearGaugeOptions(opts) {
    const { animation, background, container, contextMenu, context, footnote, height: height2, listeners, locale, minHeight, minWidth, overrideDevicePixelRatio, padding: padding2, subtitle, theme, title, width: width2, type, cursor, nodeClickRange, tooltip = {}, value, scale: scale2 = {}, direction = "vertical", thickness, // eslint-disable-next-line sonarjs/deprecation
    highlightStyle, highlight: highlight5, segmentation, bar, targets, cornerRadius, cornerMode, label, ...rest } = opts;
    const { chartTooltipOptions, seriesTooltipOptions } = tooltipOptions(tooltip);
    const chartOpts = pickProps(opts, {
        animation,
        background,
        container,
        contextMenu,
        context,
        footnote,
        height: height2,
        listeners,
        locale,
        minHeight,
        minWidth,
        overrideDevicePixelRatio,
        padding: padding2,
        subtitle,
        theme,
        title,
        tooltip: chartTooltipOptions,
        width: width2
    });
    const seriesOpts = pickProps(opts, {
        scale: scale2,
        type,
        cursor,
        context,
        nodeClickRange,
        tooltip: seriesTooltipOptions,
        value,
        direction,
        thickness,
        highlightStyle,
        highlight: highlight5,
        segmentation,
        bar,
        targets,
        cornerRadius,
        cornerMode,
        label,
        ...rest
    });
    return {
        ...chartOpts,
        series: [
            seriesOpts
        ]
    };
}
function applyThemeDefaults(opts, presetTheme) {
    if (presetTheme == null) return opts;
    const { targets: targetsTheme, ...gaugeTheme } = presetTheme;
    opts = mergeDefaults(opts, gaugeTheme);
    if (opts.targets != null && targetsTheme != null) {
        opts.targets = mergeArrayDefaults(opts.targets, targetsTheme);
    }
    return opts;
}
function gauge(opts, presetTheme) {
    switch(opts.type){
        case "radial-gauge":
            return radialGaugeOptions(applyThemeDefaults(opts, presetTheme));
        case "linear-gauge":
            return linearGaugeOptions(applyThemeDefaults(opts, presetTheme));
        default:
            return {};
    }
}
;
// packages/ag-charts-community/src/api/preset/priceVolumePresetTheme.ts
var stroke = {
    stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
};
var handle = {
    fill: DEFAULT_ANNOTATION_HANDLE_FILL
};
var axisLabel = {
    color: "white",
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
};
var lineText = {
    color: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
};
var font = {
    color: DEFAULT_TEXT_ANNOTATION_COLOR,
    fontSize: {
        $rem: FONT_SIZE_RATIO.LARGE
    },
    fontFamily: {
        $ref: "fontFamily"
    }
};
var measurerStatistics = {
    ...font,
    fontSize: {
        $ref: "fontSize"
    },
    color: DEFAULT_ANNOTATION_STATISTICS_COLOR,
    fill: DEFAULT_ANNOTATION_STATISTICS_FILL,
    stroke: DEFAULT_ANNOTATION_STATISTICS_STROKE,
    strokeWidth: 1,
    divider: {
        stroke: DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,
        strokeWidth: 1,
        strokeOpacity: 0.5
    }
};
var measurer = {
    ...stroke,
    background: {
        fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
        fillOpacity: 0.2
    },
    handle: {
        ...handle
    },
    text: {
        ...lineText
    },
    statistics: {
        ...measurerStatistics
    }
};
var annotationsTheme = {
    // Lines
    line: {
        ...stroke,
        handle: {
            ...handle
        },
        text: {
            ...lineText
        }
    },
    "horizontal-line": {
        ...stroke,
        handle: {
            ...handle
        },
        axisLabel: {
            ...axisLabel
        },
        text: {
            ...lineText
        }
    },
    "vertical-line": {
        ...stroke,
        handle: {
            ...handle
        },
        axisLabel: {
            ...axisLabel
        },
        text: {
            ...lineText
        }
    },
    // Channels
    "disjoint-channel": {
        ...stroke,
        background: {
            fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
            fillOpacity: 0.2
        },
        handle: {
            ...handle
        },
        text: {
            ...lineText
        }
    },
    "parallel-channel": {
        ...stroke,
        background: {
            fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
            fillOpacity: 0.2
        },
        handle: {
            ...handle
        },
        text: {
            ...lineText
        }
    },
    // Fibonnaccis
    "fibonacci-retracement": {
        ...stroke,
        strokes: DEFAULT_FIBONACCI_STROKES,
        rangeStroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
        handle: {
            ...handle
        },
        text: {
            ...lineText,
            position: "center"
        },
        label: {
            ...font,
            color: void 0,
            fontSize: {
                $rem: FONT_SIZE_RATIO.SMALLER
            }
        }
    },
    "fibonacci-retracement-trend-based": {
        ...stroke,
        strokes: DEFAULT_FIBONACCI_STROKES,
        rangeStroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
        handle: {
            ...handle
        },
        text: {
            ...lineText,
            position: "center"
        },
        label: {
            ...font,
            color: void 0,
            fontSize: {
                $rem: FONT_SIZE_RATIO.SMALLER
            }
        }
    },
    // Texts
    callout: {
        ...stroke,
        ...font,
        color: {
            $ref: "textColor"
        },
        handle: {
            ...handle
        },
        fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
        fillOpacity: 0.2
    },
    comment: {
        ...font,
        color: "white",
        fontWeight: 700,
        handle: {
            ...handle
        },
        fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
    },
    note: {
        ...font,
        color: DEFAULT_TEXTBOX_COLOR,
        fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
        stroke: {
            $ref: "chartBackgroundColor"
        },
        strokeWidth: 1,
        strokeOpacity: 1,
        handle: {
            ...handle
        },
        background: {
            fill: DEFAULT_TEXTBOX_FILL,
            stroke: DEFAULT_TEXTBOX_STROKE,
            strokeWidth: 1
        }
    },
    text: {
        ...font,
        handle: {
            ...handle
        }
    },
    // Shapes
    arrow: {
        ...stroke,
        handle: {
            ...handle
        },
        text: {
            ...lineText
        }
    },
    "arrow-up": {
        fill: {
            $palette: "up.fill"
        },
        handle: {
            ...handle,
            stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
        }
    },
    "arrow-down": {
        fill: {
            $palette: "down.fill"
        },
        handle: {
            ...handle,
            stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
        }
    },
    // Measurers
    "date-range": {
        ...measurer
    },
    "price-range": {
        ...measurer
    },
    "date-price-range": {
        ...measurer
    },
    "quick-date-price-range": {
        up: {
            ...stroke,
            fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
            fillOpacity: 0.2,
            handle: {
                ...handle
            },
            statistics: {
                ...measurerStatistics,
                color: "#fff",
                fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
                strokeWidth: 0,
                divider: {
                    stroke: "#fff",
                    strokeWidth: 1,
                    strokeOpacity: 0.5
                }
            }
        },
        down: {
            ...stroke,
            stroke: DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,
            fill: DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
            fillOpacity: 0.2,
            handle: {
                ...handle,
                stroke: DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE
            },
            statistics: {
                ...measurerStatistics,
                color: "#fff",
                fill: DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
                strokeWidth: 0,
                divider: {
                    stroke: "#fff",
                    strokeWidth: 1,
                    strokeOpacity: 0.5
                }
            }
        }
    },
    axesButtons: {
        enabled: true
    }
};
// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts
var chartTypes3 = [
    "ohlc",
    "line",
    "step-line",
    "hlc",
    "high-low",
    "candlestick",
    "hollow-candlestick"
];
var toolbarButtons = [
    {
        icon: "trend-line-drawing",
        tooltip: "toolbarAnnotationsLineAnnotations",
        value: "line-menu"
    },
    {
        icon: "fibonacci-retracement-drawing",
        tooltip: "toolbarAnnotationsFibonacciAnnotations",
        value: "fibonacci-menu"
    },
    {
        icon: "text-annotation",
        tooltip: "toolbarAnnotationsTextAnnotations",
        value: "text-menu"
    },
    {
        icon: "arrow-drawing",
        tooltip: "toolbarAnnotationsShapeAnnotations",
        value: "shape-menu"
    },
    {
        icon: "measurer-drawing",
        tooltip: "toolbarAnnotationsMeasurerAnnotations",
        value: "measurer-menu"
    },
    {
        icon: "delete",
        tooltip: "toolbarAnnotationsClearAll",
        value: "clear"
    }
];
function priceVolume(opts, _presetTheme, getTheme) {
    const { dateKey = "date", highKey = "high", openKey = "open", lowKey = "low", closeKey = "close", volumeKey = "volume", chartType = "candlestick", navigator = false, volume = true, rangeButtons = true, statusBar = true, toolbar = true, zoom = true, sync = false, theme, data, formatter: formatter2, ...unusedOpts } = opts;
    const priceSeries = createPriceSeries(chartType, dateKey, highKey, lowKey, openKey, closeKey);
    const volumeSeries = createVolumeSeries(getTheme, openKey, closeKey, volume, volumeKey);
    const miniChart = volume ? {
        miniChart: {
            enabled: navigator,
            series: [
                {
                    type: "line",
                    xKey: dateKey,
                    yKey: volumeKey,
                    stroke: SAFE_STROKE_FILL_OPERATION,
                    marker: {
                        enabled: false
                    }
                }
            ]
        },
        height: 40,
        minHandle: {
            height: 46
        },
        maxHandle: {
            height: 46
        }
    } : null;
    const navigatorOpts = {
        navigator: {
            enabled: navigator,
            ...miniChart
        }
    };
    const annotationOpts = {
        annotations: {
            enabled: toolbar,
            optionsToolbar: {
                enabled: toolbar
            },
            // @ts-expect-error undocumented option
            snap: true,
            toolbar: {
                enabled: toolbar,
                buttons: toolbarButtons,
                padding: 0
            },
            data,
            xKey: dateKey,
            volumeKey: volume ? volumeKey : void 0
        }
    };
    const statusBarOpts = statusBar ? {
        statusBar: {
            enabled: true,
            data,
            highKey,
            openKey,
            lowKey,
            closeKey,
            volumeKey: volume ? volumeKey : void 0
        }
    } : null;
    const zoomOpts = {
        zoom: {
            enabled: zoom,
            autoScaling: {
                enabled: true
            },
            // @ts-expect-error undocumented option
            enableIndependentAxes: true
        }
    };
    const toolbarOpts = {
        ranges: {
            enabled: rangeButtons
        }
    };
    const syncGroup = sync ? {
        sync: {
            enabled: sync,
            nodeInteraction: true,
            zoom: true
        }
    } : null;
    const volumeAxis = volume ? [
        {
            type: "number",
            position: "left",
            keys: [
                volumeKey
            ],
            label: {
                enabled: false
            },
            crosshair: {
                enabled: false
            },
            gridLine: {
                enabled: false
            },
            nice: false,
            // @ts-expect-error undocumented option
            layoutConstraints: {
                stacked: false,
                width: 20,
                unit: "percent",
                align: "end"
            }
        }
    ] : [];
    return {
        theme: {
            baseTheme: typeof theme === "string" ? theme : "ag-financial",
            ...mergeDefaults(typeof theme === "object" ? theme : null, {
                overrides: {
                    common: {
                        title: {
                            padding: 4
                        },
                        padding: {
                            top: 6,
                            right: 8,
                            bottom: 6
                        },
                        chartToolbar: {
                            enabled: toolbar
                        },
                        annotations: {
                            ...annotationsTheme
                        },
                        axes: {
                            number: {
                                interval: {
                                    maxSpacing: 45
                                },
                                label: {
                                    format: ".2f"
                                }
                            }
                        }
                    },
                    bar: {
                        series: {
                            fillOpacity: 0.5
                        }
                    },
                    line: {
                        series: {
                            marker: {
                                enabled: false
                            },
                            ...inlineSwitch(chartType, {
                                hlc: {
                                    stroke: {
                                        $palette: "altNeutral.stroke"
                                    },
                                    strokeWidth: 2
                                },
                                line: {
                                    stroke: {
                                        $palette: "neutral.stroke"
                                    }
                                },
                                "step-line": {
                                    stroke: {
                                        $palette: "neutral.stroke"
                                    },
                                    interpolation: {
                                        type: "step"
                                    }
                                }
                            })
                        }
                    },
                    candlestick: {
                        series: {
                            ...inlineSwitch(chartType, {
                                "hollow-candlestick": {
                                    item: {
                                        up: {
                                            fill: "transparent"
                                        }
                                    }
                                }
                            })
                        }
                    },
                    "range-area": {
                        series: {
                            fillOpacity: 0.3,
                            strokeWidth: 2
                        }
                    }
                }
            })
        },
        animation: {
            enabled: false
        },
        legend: {
            enabled: false
        },
        series: [
            ...volumeSeries,
            ...priceSeries
        ],
        axes: [
            {
                type: "number",
                position: "right",
                keys: [
                    openKey,
                    closeKey,
                    highKey,
                    lowKey
                ],
                crosshair: {
                    enabled: true,
                    snap: false
                },
                // @ts-expect-error undocumented option
                layoutConstraints: {
                    stacked: false,
                    width: 100,
                    unit: "percent",
                    align: "start"
                }
            },
            ...volumeAxis,
            {
                type: "ordinal-time",
                position: "bottom",
                line: {
                    enabled: false
                },
                label: {
                    enabled: true
                },
                crosshair: {
                    enabled: true
                }
            }
        ],
        tooltip: {
            enabled: false
        },
        data,
        formatter: formatter2,
        ...annotationOpts,
        ...navigatorOpts,
        ...statusBarOpts,
        ...zoomOpts,
        ...toolbarOpts,
        ...syncGroup,
        ...unusedOpts
    };
}
function createVolumeSeries(getTheme, openKey, closeKey, volume, volumeKey) {
    if (!volume) return [];
    return [
        {
            type: "bar",
            xKey: "date",
            yKey: volumeKey,
            tooltip: {
                enabled: false
            },
            itemStyler (param) {
                let { datum } = param;
                const { up, down } = getTheme().palette;
                return {
                    fill: datum[openKey] < datum[closeKey] ? up === null || up === void 0 ? void 0 : up.fill : down === null || down === void 0 ? void 0 : down.fill
                };
            },
            // @ts-expect-error undocumented option
            focusPriority: 1,
            highlight: {
                enabled: false
            }
        }
    ];
}
var RANGE_AREA_TYPE = "range-area";
function createPriceSeries(chartType, xKey, highKey, lowKey, openKey, closeKey) {
    const keys = {
        xKey,
        openKey,
        closeKey,
        highKey,
        lowKey
    };
    const singleKeys = {
        xKey,
        yKey: closeKey
    };
    const common = {
        pickOutsideVisibleMinorAxis: true
    };
    switch(chartType !== null && chartType !== void 0 ? chartType : "candlestick"){
        case "ohlc":
            return createPriceSeriesOHLC(common, keys);
        case "line":
        case "step-line":
            return createPriceSeriesLine(common, singleKeys);
        case "hlc":
            return createPriceSeriesHLC(common, singleKeys, keys);
        case "high-low":
            return createPriceSeriesHighLow(common, keys);
        case "candlestick":
        case "hollow-candlestick":
            return createPriceSeriesCandlestick(common, keys);
        default:
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("unknown chart type: ".concat(chartType, "; expected one of: ").concat(chartTypes3.join(", ")));
            return createPriceSeriesCandlestick(common, keys);
    }
}
function createPriceSeriesOHLC(common, keys) {
    return [
        {
            type: "ohlc",
            // @ts-expect-error undocumented option
            focusPriority: 0,
            ...common,
            ...keys
        }
    ];
}
function createPriceSeriesLine(common, singleKeys) {
    return [
        {
            type: "line",
            // @ts-expect-error undocumented option
            focusPriority: 0,
            ...common,
            ...singleKeys
        }
    ];
}
function createPriceSeriesHLC(common, singleKeys, param) {
    let { xKey, highKey, closeKey, lowKey } = param;
    return [
        {
            type: RANGE_AREA_TYPE,
            // @ts-expect-error undocumented option
            focusPriority: 0,
            ...common,
            xKey,
            yHighKey: highKey,
            yLowKey: closeKey,
            fill: PALETTE_UP_FILL,
            stroke: PALETTE_UP_STROKE
        },
        {
            type: RANGE_AREA_TYPE,
            // @ts-expect-error undocumented option
            focusPriority: 0,
            ...common,
            xKey,
            yHighKey: closeKey,
            yLowKey: lowKey,
            fill: PALETTE_DOWN_FILL,
            stroke: PALETTE_DOWN_STROKE
        },
        {
            type: "line",
            ...common,
            ...singleKeys
        }
    ];
}
function createPriceSeriesHighLow(common, param) {
    let { xKey, highKey, lowKey } = param;
    return [
        {
            type: "range-bar",
            ...common,
            xKey,
            yHighKey: highKey,
            yLowKey: lowKey,
            fill: PALETTE_NEUTRAL_FILL,
            stroke: PALETTE_NEUTRAL_STROKE,
            tooltip: {
                range: "nearest"
            },
            // @ts-expect-error undocumented option
            focusPriority: 0
        }
    ];
}
function createPriceSeriesCandlestick(common, keys) {
    return [
        {
            type: "candlestick",
            // @ts-expect-error undocumented option
            focusPriority: 0,
            ...common,
            ...keys
        }
    ];
}
function inlineSwitch(caseName, switchCases) {
    var _switchCases_caseName;
    return (_switchCases_caseName = switchCases[caseName]) !== null && _switchCases_caseName !== void 0 ? _switchCases_caseName : switchCases.default;
}
// packages/ag-charts-community/src/api/preset/sparkline.ts
var commonAxisProperties = {
    title: {
        enabled: false
    },
    label: {
        enabled: false
    },
    line: {
        enabled: false
    },
    gridLine: {
        enabled: false
    },
    crosshair: {
        enabled: false,
        stroke: DEFAULT_SPARKLINE_CROSSHAIR_STROKE,
        lineDash: [
            0
        ],
        label: {
            enabled: false
        }
    }
};
var numericAxisProperties = {
    ...commonAxisProperties,
    nice: false
};
var chartTooltipDefaults = {
    mode: "compact",
    position: {
        anchorTo: "node",
        placement: [
            "right",
            "left"
        ]
    },
    showArrow: false
};
var barGridLineDefaults = {
    style: [
        {
            stroke: {
                $ref: "gridLineColor"
            }
        }
    ],
    width: 2
};
var barAxisDefaults = {
    number: {
        gridLine: barGridLineDefaults
    },
    time: {
        gridLine: barGridLineDefaults
    },
    category: {
        gridLine: barGridLineDefaults
    }
};
var SPARKLINE_THEME = {
    overrides: {
        common: {
            animation: {
                enabled: false
            },
            contextMenu: {
                enabled: false
            },
            keyboard: {
                enabled: false
            },
            background: {
                visible: false
            },
            navigator: {
                enabled: false
            },
            padding: {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            },
            axes: {
                number: {
                    ...numericAxisProperties,
                    interval: {
                        values: [
                            0
                        ]
                    }
                },
                log: {
                    ...numericAxisProperties
                },
                time: {
                    ...numericAxisProperties
                },
                category: {
                    ...commonAxisProperties
                }
            }
        },
        bar: {
            series: {
                crisp: false,
                label: {
                    placement: "inside-end",
                    padding: 4
                },
                // @ts-expect-error undocumented option
                sparklineMode: true
            },
            tooltip: {
                ...chartTooltipDefaults,
                position: {
                    ...chartTooltipDefaults.position,
                    anchorTo: "pointer"
                },
                range: "nearest"
            },
            axes: barAxisDefaults
        },
        line: {
            seriesArea: {
                padding: {
                    top: 2,
                    right: 2,
                    bottom: 2,
                    left: 2
                }
            },
            series: {
                // @ts-expect-error undocumented option
                sparklineMode: true,
                strokeWidth: 1,
                marker: {
                    enabled: false,
                    size: 3
                }
            },
            tooltip: chartTooltipDefaults
        },
        area: {
            seriesArea: {
                padding: {
                    top: 1,
                    right: 0,
                    bottom: 1,
                    left: 0
                }
            },
            series: {
                strokeWidth: 1,
                fillOpacity: 0.4
            },
            tooltip: chartTooltipDefaults
        }
    }
};
var setInitialBaseTheme = simpleMemorize(createInitialBaseTheme);
function createInitialBaseTheme(baseTheme, initialBaseTheme) {
    if (typeof baseTheme === "string") {
        return {
            ...initialBaseTheme,
            baseTheme
        };
    }
    if (baseTheme != null) {
        return {
            ...baseTheme,
            // @ts-expect-error internal implementation
            baseTheme: setInitialBaseTheme(baseTheme.baseTheme, initialBaseTheme)
        };
    }
    return initialBaseTheme;
}
function sparklineDataPreset(data) {
    if (Array.isArray(data) && data.length !== 0) {
        const firstItem = data.find((v)=>v != null);
        if (typeof firstItem === "number") {
            const mappedData = data.map((y, x)=>({
                    x,
                    y
                }));
            return {
                data: mappedData,
                series: [
                    {
                        xKey: "x",
                        yKey: "y"
                    }
                ],
                datumKey: "y"
            };
        } else if (Array.isArray(firstItem)) {
            const mappedData = data.map((datum)=>({
                    x: datum === null || datum === void 0 ? void 0 : datum[0],
                    y: datum === null || datum === void 0 ? void 0 : datum[1],
                    datum
                }));
            return {
                data: mappedData,
                series: [
                    {
                        xKey: "x",
                        yKey: "y"
                    }
                ],
                datumKey: "datum"
            };
        }
    } else if ((data === null || data === void 0 ? void 0 : data.length) === 0) {
        return {
            data,
            series: [
                {
                    xKey: "x",
                    yKey: "y"
                }
            ],
            datumKey: "y"
        };
    }
    return {
        data
    };
}
function axisPreset(opts) {
    switch(opts === null || opts === void 0 ? void 0 : opts.type){
        case "number":
            {
                const { type, min, max, reverse } = opts;
                return pickProps(opts, {
                    type,
                    reverse,
                    min,
                    max
                });
            }
        case "time":
            {
                const { type, min, max, reverse } = opts;
                return pickProps(opts, {
                    type,
                    reverse,
                    min,
                    max
                });
            }
        case "category":
        default:
            {
                const { paddingInner, paddingOuter, reverse } = opts !== null && opts !== void 0 ? opts : {};
                return pickProps({
                    ...opts,
                    type: "category"
                }, {
                    type: "category",
                    reverse,
                    paddingInner,
                    paddingOuter
                });
            }
    }
}
function gridLinePreset(opts, defaultEnabled, sparkOpts) {
    const gridLineOpts = {};
    if ((opts === null || opts === void 0 ? void 0 : opts.stroke) != null) {
        gridLineOpts.style = [
            {
                stroke: opts === null || opts === void 0 ? void 0 : opts.stroke
            }
        ];
        var _gridLineOpts_enabled;
        (_gridLineOpts_enabled = gridLineOpts.enabled) !== null && _gridLineOpts_enabled !== void 0 ? _gridLineOpts_enabled : gridLineOpts.enabled = true;
    }
    if ((opts === null || opts === void 0 ? void 0 : opts.strokeWidth) != null) {
        gridLineOpts.width = opts === null || opts === void 0 ? void 0 : opts.strokeWidth;
        var _gridLineOpts_enabled1;
        (_gridLineOpts_enabled1 = gridLineOpts.enabled) !== null && _gridLineOpts_enabled1 !== void 0 ? _gridLineOpts_enabled1 : gridLineOpts.enabled = true;
    }
    if (sparkOpts.type === "bar" && sparkOpts.direction !== "horizontal") {
        var _gridLineOpts_enabled2;
        (_gridLineOpts_enabled2 = gridLineOpts.enabled) !== null && _gridLineOpts_enabled2 !== void 0 ? _gridLineOpts_enabled2 : gridLineOpts.enabled = true;
    }
    if ((opts === null || opts === void 0 ? void 0 : opts.visible) != null) {
        gridLineOpts.enabled = opts.visible;
    }
    var _gridLineOpts_enabled3;
    (_gridLineOpts_enabled3 = gridLineOpts.enabled) !== null && _gridLineOpts_enabled3 !== void 0 ? _gridLineOpts_enabled3 : gridLineOpts.enabled = defaultEnabled;
    return gridLineOpts;
}
var tooltipRendererFn = simpleMemorize((context, tooltip, datumKey)=>{
    return (params)=>{
        var _tooltip_renderer;
        const xValue = params.datum[params.xKey];
        const yValue = params.datum[params.yKey];
        const datum = datumKey != null ? params.datum[datumKey] : params.datum;
        const userContent = tooltip === null || tooltip === void 0 ? void 0 : (_tooltip_renderer = tooltip.renderer) === null || _tooltip_renderer === void 0 ? void 0 : _tooltip_renderer.call(tooltip, {
            context,
            datum,
            xValue,
            yValue
        });
        if (typeof userContent === "string") return userContent;
        var _userContent_content;
        const content = (_userContent_content = userContent === null || userContent === void 0 ? void 0 : userContent.content) !== null && _userContent_content !== void 0 ? _userContent_content : yValue.toFixed(2);
        return (userContent === null || userContent === void 0 ? void 0 : userContent.title) ? {
            heading: void 0,
            title: void 0,
            data: [
                {
                    label: userContent.title,
                    value: content
                }
            ]
        } : {
            heading: void 0,
            title: content,
            data: []
        };
    };
});
function sparkline(opts) {
    const { background, container, height: height2, listeners, locale, minHeight, minWidth, overrideDevicePixelRatio, padding: padding2, width: width2, theme: baseTheme, data: baseData, crosshair, axis, min, max, tooltip, context, styleNonce, ...optsRest } = opts;
    const chartOpts = pickProps(opts, {
        background,
        container,
        height: height2,
        listeners,
        locale,
        minHeight,
        minWidth,
        overrideDevicePixelRatio,
        padding: padding2,
        width: width2,
        styleNonce,
        tooltip: IGNORED_PROP,
        context: IGNORED_PROP,
        data: IGNORED_PROP,
        crosshair: IGNORED_PROP,
        axis: IGNORED_PROP,
        min: IGNORED_PROP,
        max: IGNORED_PROP,
        theme: IGNORED_PROP
    });
    const { data, series: [seriesOverrides] = [], datumKey } = sparklineDataPreset(baseData);
    const seriesOptions = optsRest;
    if (seriesOverrides != null) Object.assign(seriesOptions, seriesOverrides);
    seriesOptions.tooltip = {
        ...tooltip,
        renderer: tooltipRendererFn(context, tooltip, datumKey)
    };
    chartOpts.theme = setInitialBaseTheme(baseTheme, SPARKLINE_THEME);
    chartOpts.data = data;
    chartOpts.series = [
        seriesOptions
    ];
    const swapAxes = seriesOptions.type !== "bar" || seriesOptions.direction !== "horizontal";
    const [xAxisPosition, yAxisPosition] = swapAxes ? [
        "bottom",
        "left"
    ] : [
        "left",
        "bottom"
    ];
    const xAxis = {
        ...axisPreset(axis),
        position: xAxisPosition,
        ...pickProps(opts, {
            crosshair
        })
    };
    const yAxis = {
        type: "number",
        gridLine: gridLinePreset(axis, false, opts),
        position: yAxisPosition,
        ...pickProps(opts, {
            min,
            max
        })
    };
    chartOpts.axes = swapAxes ? [
        yAxis,
        xAxis
    ] : [
        xAxis,
        yAxis
    ];
    return chartOpts;
}
// packages/ag-charts-community/src/api/preset/presetModules.ts
var priceVolumeOptionsDef = {
    chartType: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("candlestick", "hollow-candlestick", "ohlc", "line", "step-line", "hlc", "high-low"),
    dateKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    openKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    highKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    lowKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    closeKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    volumeKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    navigator: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    volume: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    rangeButtons: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    statusBar: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    toolbar: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    zoom: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    sync: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    // Valid pass-through options
    theme: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    container: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    height: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    minWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    minHeight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    listeners: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    initialState: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    title: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["array"],
    formatter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]
};
var commonGaugeOptions = {
    // Valid pass-through options
    theme: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    container: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    animation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    background: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    contextMenu: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    context: ()=>true,
    listeners: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    locale: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    height: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    minWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    minHeight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    title: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    subtitle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    footnote: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    tooltip: {
        ...tooltipOptionsDefs,
        ...commonChartOptionsDefs.tooltip
    }
};
commonGaugeOptions.overrideDevicePixelRatio = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]);
var commonSparklineOmit = [
    "showInLegend",
    "showInMiniChart",
    "grouped",
    "stacked",
    "stackGroup",
    "tooltip",
    "listeners",
    "errorBar",
    "xKey",
    "yKey",
    "type"
];
var commonSparklineAxisOptionsDef = {
    visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    reverse: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
    stroke: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["color"],
    strokeWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["positiveNumber"]
};
var commonSparklineOptionsDef = {
    context: ()=>true,
    tooltip: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    theme: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    background: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    container: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    width: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    height: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    minWidth: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    minHeight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    padding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    listeners: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    locale: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    styleNonce: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    axis: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeUnion"])({
        number: {
            ...commonSparklineAxisOptionsDef,
            min: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lessThan"])("max")),
            max: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["greaterThan"])("min"))
        },
        category: {
            ...commonSparklineAxisOptionsDef,
            paddingInner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"],
            paddingOuter: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ratio"]
        },
        time: {
            ...commonSparklineAxisOptionsDef,
            min: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["date"]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lessThan"])("max")),
            max: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["date"]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["greaterThan"])("min"))
        }
    }, "axis options", "category"),
    min: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lessThan"])("max")),
    max: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["and"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["greaterThan"])("min")),
    crosshair: {
        enabled: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        snap: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["strokeOptionsDef"],
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lineDashOptionsDef"]
    },
    xKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
    yKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]
};
var PriceVolumePresetModule = {
    type: "preset",
    name: "price-volume",
    enterprise: true,
    options: priceVolumeOptionsDef,
    create: priceVolume
};
var GaugePresetModule = {
    type: "preset",
    name: "gauge-preset",
    enterprise: true,
    options: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeUnion"])({
        "linear-gauge": {
            ...without(linearGaugeSeriesOptionsDef, [
                "type"
            ]),
            ...commonGaugeOptions
        },
        "radial-gauge": {
            ...without(radialGaugeSeriesOptionsDef, [
                "type"
            ]),
            ...commonGaugeOptions
        }
    }, "gauge options"),
    create: gauge
};
var SparklinePresetModule = {
    type: "preset",
    name: "sparkline",
    options: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeUnion"])({
        area: {
            ...commonSparklineOptionsDef,
            ...without(areaSeriesOptionsDef, commonSparklineOmit)
        },
        bar: {
            ...commonSparklineOptionsDef,
            ...without(barSeriesOptionsDef, commonSparklineOmit)
        },
        line: {
            ...commonSparklineOptionsDef,
            ...without(lineSeriesOptionsDef, commonSparklineOmit)
        }
    }, "sparkline options"),
    create: sparkline,
    processData: sparklineDataPreset
};
;
;
var directions = [
    "top",
    "right",
    "bottom",
    "left"
];
var _CartesianChart = class _CartesianChart extends Chart {
    onAxisChange(newValue, oldValue) {
        super.onAxisChange(newValue, oldValue);
        this.syncAxisChanges(newValue, oldValue);
        if (this.ctx != null) {
            this.ctx.zoomManager.updateAxes(newValue);
        }
    }
    destroySeries(series) {
        super.destroySeries(series);
        this.lastLayoutWidth = NaN;
        this.lastLayoutHeight = NaN;
    }
    getChartType() {
        return "cartesian";
    }
    setRootClipRects(clipRect) {
        const { seriesRoot, annotationRoot } = this;
        seriesRoot.setClipRect(clipRect);
        annotationRoot.setClipRect(clipRect);
    }
    async processData() {
        await super.processData();
        if (this.syncStatus === "init") {
            this.syncStatus = "domains-calculated";
        }
        this.ctx.updateService.dispatchProcessData({
            series: {
                shouldFlipXY: this.shouldFlipXY()
            }
        });
    }
    async processDomains() {
        await super.processDomains();
        for (const axis of this.axes){
            const syncedDomain = await this.getSyncedDomain(axis);
            if (syncedDomain != null) {
                axis.setDomains(syncedDomain);
            }
        }
    }
    performLayout(ctx) {
        const { seriesRoot, annotationRoot } = this;
        const { clipSeries, seriesRect, visible } = this.updateAxes(ctx.layoutBox);
        this.seriesRoot.visible = visible;
        this.seriesRect = seriesRect;
        this.animationRect = ctx.layoutBox;
        const { x, y } = seriesRect;
        if (ctx.width !== this.lastLayoutWidth || ctx.height !== this.lastLayoutHeight) {
            for (const group of [
                seriesRoot,
                annotationRoot
            ]){
                group.translationX = Math.floor(x);
                group.translationY = Math.floor(y);
            }
        } else {
            const { translationX, translationY } = seriesRoot;
            staticFromToMotion(this.id, "seriesRect", this.ctx.animationManager, [
                seriesRoot,
                annotationRoot
            ], {
                translationX,
                translationY
            }, {
                translationX: Math.floor(x),
                translationY: Math.floor(y)
            }, {
                phase: "update"
            });
        }
        this.lastLayoutWidth = ctx.width;
        this.lastLayoutHeight = ctx.height;
        const seriesArea = this.modulesManager.getModule("seriesArea");
        const seriesPaddedRect = seriesRect.clone().grow(seriesArea.getPadding());
        const clipRect = seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;
        const { lastUpdateClipRect } = this;
        this.lastUpdateClipRect = clipRect;
        if (this.ctx.animationManager.isActive() && lastUpdateClipRect != null) {
            this.ctx.animationManager.animate({
                id: this.id,
                groupId: "clip-rect",
                phase: "update",
                from: lastUpdateClipRect,
                to: seriesPaddedRect,
                onUpdate: (interpolatedClipRect)=>this.setRootClipRects(interpolatedClipRect),
                onComplete: ()=>this.setRootClipRects(clipRect)
            });
        } else {
            this.setRootClipRects(clipRect);
        }
        this.ctx.layoutManager.emitLayoutComplete(ctx, {
            axes: this.axes.map((axis)=>axis.getLayoutState()),
            series: {
                visible,
                rect: seriesRect,
                paddedRect: seriesPaddedRect
            },
            clipSeries
        });
    }
    updateAxes(layoutBox) {
        const { clipSeries, seriesRect, overflows } = this.resolveAxesLayout(layoutBox);
        for (const axis of this.axes){
            axis.update();
            axis.setCrossLinesVisible(!overflows);
            this.clipAxis(axis, seriesRect, layoutBox);
        }
        return {
            clipSeries,
            seriesRect,
            visible: !overflows
        };
    }
    // Iteratively try to resolve axis widths - since X axis width affects Y axis range,
    // and vice-versa, we need to iteratively try and find a fit for the axes and their
    // ticks/labels.
    resolveAxesLayout(layoutBox) {
        let newState;
        let prevState;
        let iterations = 0;
        const maxIterations = 10;
        do {
            prevState = newState !== null && newState !== void 0 ? newState : this.getDefaultState();
            newState = this.updateAxesPass(new Map(prevState.axisAreaWidths), layoutBox.clone());
            if (iterations++ > maxIterations) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warn("Max iterations reached. Unable to stabilize axes layout.");
                break;
            }
        }while (!this.isLayoutStable(newState, prevState))
        this.lastAreaWidths = newState.axisAreaWidths;
        return newState;
    }
    updateAxesPass(axisAreaWidths, axisAreaBound) {
        const axisWidths = /* @__PURE__ */ new Map();
        const primaryTickCounts = {};
        let overflows = false;
        let clipSeries = false;
        for (const dir of directions){
            const padding2 = this.modulesManager.getModule("seriesArea").getPadding()[dir];
            const axis = this.axes.findLast((a)=>a.position === dir);
            if (axis) {
                axis.seriesAreaPadding = padding2;
            } else {
                axisAreaBound.shrink(padding2, dir);
            }
        }
        var _axisAreaWidths_get, _axisAreaWidths_get1;
        const totalWidth = ((_axisAreaWidths_get = axisAreaWidths.get("left")) !== null && _axisAreaWidths_get !== void 0 ? _axisAreaWidths_get : 0) + ((_axisAreaWidths_get1 = axisAreaWidths.get("right")) !== null && _axisAreaWidths_get1 !== void 0 ? _axisAreaWidths_get1 : 0);
        var _axisAreaWidths_get2, _axisAreaWidths_get3;
        const totalHeight = ((_axisAreaWidths_get2 = axisAreaWidths.get("top")) !== null && _axisAreaWidths_get2 !== void 0 ? _axisAreaWidths_get2 : 0) + ((_axisAreaWidths_get3 = axisAreaWidths.get("bottom")) !== null && _axisAreaWidths_get3 !== void 0 ? _axisAreaWidths_get3 : 0);
        const crossLinePadding = this.buildCrossLinePadding(axisAreaWidths);
        const crossLineHPadding = crossLinePadding.left + crossLinePadding.right;
        const crossLineVPadding = crossLinePadding.top + crossLinePadding.bottom;
        if (axisAreaBound.width <= totalWidth + crossLineHPadding || axisAreaBound.height <= totalHeight + crossLineVPadding) {
            overflows = true;
        } else {
            axisAreaBound.shrink(crossLinePadding);
        }
        const { scene } = this.ctx;
        const seriesRect = axisAreaBound.clone().shrink(Object.fromEntries(axisAreaWidths));
        for (const axis of this.axes){
            const { position = "left", direction } = axis;
            const isVertical = direction === "y" /* Y */ ;
            let axisWidth;
            this.sizeAxis(axis, seriesRect, position);
            if (axis.thickness == null) {
                const availableSize = getSize(isVertical, scene);
                var _axis_maxThicknessRatio;
                axisWidth = availableSize * ((_axis_maxThicknessRatio = axis.maxThicknessRatio) !== null && _axis_maxThicknessRatio !== void 0 ? _axis_maxThicknessRatio : 1);
            } else {
                axisWidth = axis.thickness;
            }
            const { primaryTickCount, bbox } = axis.calculateLayout(axis.nice ? primaryTickCounts[direction] : void 0, {
                sizeLimit: axisWidth,
                padding: this.padding
            });
            var _primaryTickCounts_direction;
            (_primaryTickCounts_direction = primaryTickCounts[direction]) !== null && _primaryTickCounts_direction !== void 0 ? _primaryTickCounts_direction : primaryTickCounts[direction] = primaryTickCount;
            clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);
            if (axis.thickness == null) {
                var _getSize;
                axisWidth = Math.min((_getSize = getSize(isVertical, bbox)) !== null && _getSize !== void 0 ? _getSize : 0, axisWidth);
            }
            axisWidths.set(axis.id, Math.ceil(axisWidth));
        }
        const axisGroups = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["groupBy"])(this.axes, (axis)=>{
            var _axis_position;
            return (_axis_position = axis.position) !== null && _axis_position !== void 0 ? _axis_position : "left";
        });
        const newAxisAreaWidths = /* @__PURE__ */ new Map();
        const axisOffsets = /* @__PURE__ */ new Map();
        for (const [position, axes] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entries"])(axisGroups)){
            let currentOffset = getSize(position !== "left" && position !== "right", scene) % scene.pixelRatio;
            let totalAxisWidth = 0;
            for (const axis of axes !== null && axes !== void 0 ? axes : []){
                axisOffsets.set(axis.id, currentOffset);
                var _axisWidths_get;
                const axisThickness = (_axisWidths_get = axisWidths.get(axis.id)) !== null && _axisWidths_get !== void 0 ? _axisWidths_get : 0;
                totalAxisWidth = Math.max(totalAxisWidth, currentOffset + axisThickness);
                if (axis.layoutConstraints.stacked) {
                    currentOffset += axisThickness + _CartesianChart.AxesPadding;
                }
            }
            newAxisAreaWidths.set(position, Math.ceil(totalAxisWidth));
        }
        for (const [position, axes] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entries"])(axisGroups)){
            this.positionAxes({
                axes: axes !== null && axes !== void 0 ? axes : [],
                position,
                axisWidths,
                axisOffsets,
                axisAreaWidths: newAxisAreaWidths,
                axisBound: axisAreaBound,
                seriesRect
            });
        }
        return {
            clipSeries,
            seriesRect,
            axisAreaWidths: newAxisAreaWidths,
            overflows
        };
    }
    buildCrossLinePadding(axisAreaSize) {
        const crossLinePadding = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        };
        this.axes.forEach((axis)=>{
            var _axis_crossLines;
            const { position, label } = axis;
            (_axis_crossLines = axis.crossLines) === null || _axis_crossLines === void 0 ? void 0 : _axis_crossLines.forEach((crossLine)=>{
                var _crossLine_calculatePadding;
                var _a;
                if (crossLine instanceof CartesianCrossLine) {
                    crossLine.position = position !== null && position !== void 0 ? position : "top";
                    var _parallel;
                    (_parallel = (_a = crossLine.label).parallel) !== null && _parallel !== void 0 ? _parallel : _a.parallel = label.parallel;
                }
                (_crossLine_calculatePadding = crossLine.calculatePadding) === null || _crossLine_calculatePadding === void 0 ? void 0 : _crossLine_calculatePadding.call(crossLine, crossLinePadding);
            });
        });
        for (const [side, padding2 = 0] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entries"])(crossLinePadding)){
            var _axisAreaSize_get;
            crossLinePadding[side] = Math.max(padding2 - ((_axisAreaSize_get = axisAreaSize.get(side)) !== null && _axisAreaSize_get !== void 0 ? _axisAreaSize_get : 0), 0);
        }
        return crossLinePadding;
    }
    clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {
        const bound = dimension === "x" ? seriesRect.x : seriesRect.y;
        const size = dimension === "x" ? seriesRect.width : seriesRect.height;
        return direction === 1 ? Math.min(value, bound + size) : Math.max(value, bound);
    }
    async getSyncedDomain(axis) {
        const syncModule = this.modulesManager.getModule("sync");
        if (!(syncModule === null || syncModule === void 0 ? void 0 : syncModule.enabled)) return;
        return await syncModule.getSyncedDomain(axis);
    }
    syncAxisChanges(newValue, oldValue) {
        const syncModule = this.modulesManager.getModule("sync");
        if (!(syncModule === null || syncModule === void 0 ? void 0 : syncModule.enabled)) return;
        const removed = new Set(oldValue !== null && oldValue !== void 0 ? oldValue : []);
        for (const axis of newValue){
            removed.delete(axis);
        }
        for (const removedAxis of removed){
            syncModule.removeAxis(removedAxis);
        }
    }
    sizeAxis(axis, seriesRect, position) {
        const isNumberAxis = axis instanceof NumberAxis;
        const isLeftRight = position === "left" || position === "right";
        const { width: width2, height: height2 } = seriesRect;
        const maxEnd = isLeftRight ? height2 : width2;
        let start2 = 0;
        let end2 = maxEnd;
        let { min, max } = this.ctx.zoomManager.getAxisZoom(axis.id);
        const { width: axisWidth, unit, align: align2 } = axis.layoutConstraints;
        if (unit === "px") {
            end2 = start2 + axisWidth;
        } else {
            end2 = end2 * axisWidth / 100;
        }
        if (align2 === "end") {
            start2 = maxEnd - (end2 - start2);
            end2 = maxEnd;
        }
        if (isLeftRight) {
            if (isNumberAxis) {
                [start2, end2] = [
                    end2,
                    start2
                ];
            } else {
                [min, max] = [
                    1 - max,
                    1 - min
                ];
            }
        }
        axis.range = [
            start2,
            end2
        ];
        axis.visibleRange = [
            min,
            max
        ];
        axis.gridLength = isLeftRight ? width2 : height2;
    }
    positionAxes(opts) {
        const { axes, axisBound, axisWidths, axisOffsets, axisAreaWidths, seriesRect, position } = opts;
        var _axisAreaWidths_get;
        const axisAreaWidth = (_axisAreaWidths_get = axisAreaWidths.get(position)) !== null && _axisAreaWidths_get !== void 0 ? _axisAreaWidths_get : 0;
        let mainDimension = "x";
        let minorDimension = "y";
        let direction = 1;
        if (position === "top" || position === "bottom") {
            mainDimension = "y";
            minorDimension = "x";
        }
        let axisBoundMainOffset = axisBound[mainDimension];
        if (position === "right" || position === "bottom") {
            direction = -1;
            axisBoundMainOffset += mainDimension === "x" ? axisBound.width : axisBound.height;
        }
        for (const axis of axes){
            var _axisAreaWidths_get1;
            const minorOffset = (_axisAreaWidths_get1 = axisAreaWidths.get(minorDimension === "x" ? "left" : "top")) !== null && _axisAreaWidths_get1 !== void 0 ? _axisAreaWidths_get1 : 0;
            var _axisWidths_get;
            const axisThickness = (_axisWidths_get = axisWidths.get(axis.id)) !== null && _axisWidths_get !== void 0 ? _axisWidths_get : 0;
            var _axisOffsets_get;
            const axisOffset = (_axisOffsets_get = axisOffsets.get(axis.id)) !== null && _axisOffsets_get !== void 0 ? _axisOffsets_get : 0;
            axis.gridPadding = axisAreaWidth - axisOffset - axisThickness;
            axis.translation[minorDimension] = axisBound[minorDimension] + minorOffset;
            axis.translation[mainDimension] = this.clampToOutsideSeriesRect(seriesRect, axisBoundMainOffset + direction * (axisOffset + axisThickness), mainDimension, direction);
        }
    }
    shouldFlipXY() {
        return this.series.every((series)=>series instanceof CartesianSeries && series.shouldFlipXY());
    }
    getDefaultState() {
        const axisAreaWidths = /* @__PURE__ */ new Map();
        if (this.lastAreaWidths) {
            for (const { position = "left" } of this.axes){
                const areaWidth = this.lastAreaWidths.get(position);
                if (areaWidth != null) {
                    axisAreaWidths.set(position, areaWidth);
                }
            }
        }
        return {
            axisAreaWidths,
            clipSeries: false,
            overflows: false
        };
    }
    isLayoutStable(newState, prevState) {
        if (prevState.overflows !== newState.overflows || prevState.clipSeries !== newState.clipSeries) {
            return false;
        }
        for (const key of newState.axisAreaWidths.keys()){
            if (!prevState.axisAreaWidths.has(key)) {
                return false;
            }
        }
        for (const [p, w] of prevState.axisAreaWidths.entries()){
            const otherW = newState.axisAreaWidths.get(p);
            if ((w != null || otherW != null) && w !== otherW) {
                return false;
            }
        }
        return true;
    }
    clipAxis(axis, seriesRect, layoutBBox) {
        var _axis_gridLine, _axis_line;
        var _axis_gridLine_width;
        const gridLinePadding = Math.ceil((_axis_gridLine_width = (_axis_gridLine = axis.gridLine) === null || _axis_gridLine === void 0 ? void 0 : _axis_gridLine.width) !== null && _axis_gridLine_width !== void 0 ? _axis_gridLine_width : 0);
        var _axis_line_width;
        const axisLinePadding = Math.ceil((_axis_line_width = (_axis_line = axis.line) === null || _axis_line === void 0 ? void 0 : _axis_line.width) !== null && _axis_line_width !== void 0 ? _axis_line_width : 0);
        let { width: width2, height: height2 } = seriesRect;
        width2 += axis.direction === "x" /* X */  ? gridLinePadding : axisLinePadding;
        height2 += axis.direction === "y" /* Y */  ? gridLinePadding : axisLinePadding;
        axis.clipGrid(seriesRect.x, seriesRect.y, width2, height2);
        switch(axis.position){
            case "left":
            case "right":
                axis.clipTickLines(layoutBBox.x, seriesRect.y - gridLinePadding, layoutBBox.width + gridLinePadding, seriesRect.height + gridLinePadding * 2);
                break;
            case "top":
            case "bottom":
                axis.clipTickLines(seriesRect.x - gridLinePadding, layoutBBox.y, seriesRect.width + gridLinePadding * 2, layoutBBox.height + gridLinePadding);
                break;
        }
    }
    constructor(options, resources){
        super(options, resources);
        // TODO should come from theme
        /** Integrated Charts feature state - not used in Standalone Charts. */ this.paired = true;
        this.lastUpdateClipRect = void 0;
        this.lastLayoutWidth = NaN;
        this.lastLayoutHeight = NaN;
    }
};
_CartesianChart.className = "CartesianChart";
_CartesianChart.type = "cartesian";
_CartesianChart.AxesPadding = 15;
var CartesianChart = _CartesianChart;
function getSize(isVertical, bounds) {
    return isVertical ? bounds === null || bounds === void 0 ? void 0 : bounds.width : bounds === null || bounds === void 0 ? void 0 : bounds.height;
}
;
var commonChartOptions = {
    mode: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undocumented"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"])("integrated", "standalone")),
    container: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlElement"],
    context: ()=>true,
    theme: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    series: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["array"],
    annotations: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    navigator: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
    initialState: {
        chartType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
        annotations: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"],
        legend: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayOfDefs"])({
            visible: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["boolean"],
            seriesId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
            itemId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"],
            legendItemName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string"]
        }, "legend state array"),
        zoom: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defined"]
    }
};
var cartesianChartOptionsDefs = {
    ...commonChartOptionsDefs,
    ...commonChartOptions,
    axes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayLength"])(2),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["array"]
};
var polarChartOptionsDefs = {
    ...commonChartOptionsDefs,
    ...commonChartOptions,
    axes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arrayLength"])(2),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["array"]
};
var topologyChartOptionsDefs = {
    ...commonChartOptionsDefs,
    ...commonChartOptions,
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["array"],
    topology: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geoJson"]
};
var standaloneChartOptionsDefs = {
    ...commonChartOptionsDefs,
    ...commonChartOptions,
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["array"]
};
// packages/ag-charts-community/src/chart/cartesianChartModule.ts
var histogramAxisTypes = /* @__PURE__ */ new Set([
    "number",
    "log",
    "time"
]);
var validHistogramAxis = (axis)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObject"])(axis) && !histogramAxisTypes.has(axis.type);
var CartesianChartModule = {
    type: "chart",
    name: "cartesian",
    options: cartesianChartOptionsDefs,
    detect: isAgCartesianChartOptions,
    create (options, resources) {
        return new CartesianChart(options, resources);
    },
    validate (options, optionsDefs6, path) {
        var _options_series_, _options_series;
        const additionalErrors = [];
        if ((options === null || options === void 0 ? void 0 : (_options_series = options.series) === null || _options_series === void 0 ? void 0 : (_options_series_ = _options_series[0]) === null || _options_series_ === void 0 ? void 0 : _options_series_.type) === "histogram") {
            var _options_axes;
            if (options === null || options === void 0 ? void 0 : (_options_axes = options.axes) === null || _options_axes === void 0 ? void 0 : _options_axes.some(validHistogramAxis)) {
                additionalErrors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ValidationError"]("invalid", "only continuous axis types when histogram series is used", options.axes, path, "axes"));
                options = without(options, [
                    "axes"
                ]);
            }
        }
        const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"])(options, optionsDefs6, path);
        result.invalid.push(...additionalErrors);
        return result;
    }
};
// packages/ag-charts-community/src/chart/enterpriseChartModules.ts
var placeholderCreate = ()=>{
    throw new Error("Enterprise module placeholder cannot be initialised");
};
var StandaloneChartModule = {
    type: "chart",
    name: "standalone",
    placeholder: true,
    options: {},
    detect: isAgStandaloneChartOptions,
    create: placeholderCreate
};
var TopologyChartModule = {
    type: "chart",
    name: "topology",
    placeholder: true,
    options: {},
    detect: isAgTopologyChartOptions,
    create: placeholderCreate
};
;
;
// packages/ag-charts-community/src/chart/axis/polarAxis.ts
var PolarAxis = class extends Axis {
    layoutCrossLines() {
        const sideFlag = this.label.getSideFlag();
        const crosslinesVisible = this.hasDefinedDomain() || this.hasVisibleSeries();
        const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();
        this.crossLines.forEach((crossLine)=>{
            var _crossLine_calculateLayout;
            crossLine.sideFlag = -sideFlag;
            crossLine.direction = rotation === -Math.PI / 2 ? "angle" /* Angle */  : "radius" /* Radius */ ;
            crossLine.parallelFlipRotation = parallelFlipRotation;
            crossLine.regularFlipRotation = regularFlipRotation;
            (_crossLine_calculateLayout = crossLine.calculateLayout) === null || _crossLine_calculateLayout === void 0 ? void 0 : _crossLine_calculateLayout.call(crossLine, crosslinesVisible, this.reverse);
        });
    }
    updatePosition() {
        super.updatePosition();
        const translationX = Math.floor(this.translation.x);
        const translationY = Math.floor(this.translation.y);
        this.tickLineGroup.translationX = translationX;
        this.tickLineGroup.translationY = translationY;
        this.tickLabelGroup.translationX = translationX;
        this.tickLabelGroup.translationY = translationY;
        this.crossLineRangeGroup.translationX = translationX;
        this.crossLineRangeGroup.translationY = translationY;
        this.crossLineLineGroup.translationX = translationX;
        this.crossLineLineGroup.translationY = translationY;
        this.crossLineLabelGroup.translationX = translationX;
        this.crossLineLabelGroup.translationY = translationY;
        this.tickLabelGroupSelection.each(resetAxisLabelSelectionFn());
    }
    computeLabelsBBox(_options, _seriesRect) {
        return null;
    }
    computeRange() {}
    getAxisLinePoints() {
        return void 0;
    }
    constructor(){
        super(...arguments);
        this.shape = "polygon";
        this.innerRadiusRatio = 0;
        this.defaultTickMinSpacing = 20;
    }
};
__decorateClass([
    Property
], PolarAxis.prototype, "shape", 2);
__decorateClass([
    Property
], PolarAxis.prototype, "innerRadiusRatio", 2);
// packages/ag-charts-community/src/chart/polarChart.ts
var PolarChart = class extends Chart {
    getChartType() {
        return "polar";
    }
    async performLayout(ctx) {
        const { layoutBox } = ctx;
        const seriesRect = layoutBox.clone().shrink(this.modulesManager.getModule("seriesArea").getPadding());
        this.seriesRect = seriesRect;
        this.animationRect = seriesRect;
        this.seriesRoot.translationX = seriesRect.x;
        this.seriesRoot.translationY = seriesRect.y;
        await this.computeCircle(seriesRect);
        this.axes.forEach((axis)=>axis.update());
        this.ctx.layoutManager.emitLayoutComplete(ctx, {
            series: {
                visible: true,
                rect: seriesRect,
                paddedRect: layoutBox
            }
        });
    }
    updateAxes(seriesBox, cx, cy, radius) {
        var _angleScale_ticks_ticks, _angleScale_ticks;
        const angleAxis = this.axes.find((axis)=>axis.direction === "angle" /* Angle */ );
        const radiusAxis = this.axes.find((axis)=>axis.direction === "radius" /* Radius */ );
        if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis)) return;
        const angleScale = angleAxis.scale;
        const innerRadiusRatio = radiusAxis.innerRadiusRatio;
        angleAxis.innerRadiusRatio = innerRadiusRatio;
        angleAxis.computeRange();
        angleAxis.gridLength = radius;
        radiusAxis.gridAngles = (_angleScale_ticks = angleScale.ticks({
            nice: angleAxis.nice,
            interval: void 0,
            tickCount: void 0,
            minTickCount: 0,
            maxTickCount: Infinity
        })) === null || _angleScale_ticks === void 0 ? void 0 : (_angleScale_ticks_ticks = _angleScale_ticks.ticks) === null || _angleScale_ticks_ticks === void 0 ? void 0 : _angleScale_ticks_ticks.map((value)=>angleScale.convert(value));
        radiusAxis.gridRange = angleAxis.range;
        radiusAxis.range = [
            radius,
            radius * innerRadiusRatio
        ];
        [
            angleAxis,
            radiusAxis
        ].forEach((axis)=>{
            axis.translation.x = seriesBox.x + cx;
            axis.translation.y = seriesBox.y + cy;
            axis.calculateLayout();
        });
    }
    async computeCircle(seriesBox) {
        var _this = this;
        const polarSeries = this.series.filter(isPolarSeries);
        const polarAxes = this.axes.filter(isPolarAxis);
        const setSeriesCircle = (cx, cy, r)=>{
            this.updateAxes(seriesBox, cx, cy, r);
            polarSeries.forEach((series)=>{
                series.centerX = cx;
                series.centerY = cy;
                series.radius = r;
            });
            const pieSeries = polarSeries.filter((s)=>s.type === "donut" || s.type === "pie");
            if (pieSeries.length > 1) {
                const innerRadii = pieSeries.map((series)=>{
                    const innerRadius = series.getInnerRadius();
                    return {
                        series,
                        innerRadius
                    };
                }).sort((a, b)=>a.innerRadius - b.innerRadius);
                innerRadii.at(-1).series.surroundingRadius = void 0;
                for(let i = 0; i < innerRadii.length - 1; i++){
                    innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;
                }
            }
        };
        const centerX = seriesBox.width / 2;
        const centerY = seriesBox.height / 2;
        const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);
        let radius = initialRadius;
        setSeriesCircle(centerX, centerY, radius);
        const shake = async function() {
            let { hideWhenNecessary = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            const labelBoxes = [];
            for (const series of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["iterate"])(polarAxes, polarSeries)){
                const box = await series.computeLabelsBBox({
                    hideWhenNecessary
                }, seriesBox);
                if (box) {
                    labelBoxes.push(box);
                }
            }
            if (labelBoxes.length === 0) {
                setSeriesCircle(centerX, centerY, initialRadius);
                return;
            }
            const labelBox = BBox.merge(labelBoxes);
            const refined = _this.refineCircle(labelBox, radius, seriesBox);
            setSeriesCircle(refined.centerX, refined.centerY, refined.radius);
            radius = refined.radius;
        };
        await shake();
        await shake();
        await shake();
        await shake({
            hideWhenNecessary: true
        });
        await shake({
            hideWhenNecessary: true
        });
        for (const series of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["iterate"])(polarAxes, polarSeries)){
            await series.computeLabelsBBox({
                hideWhenNecessary: true
            }, seriesBox);
        }
        return {
            radius,
            centerX,
            centerY
        };
    }
    refineCircle(labelsBox, radius, seriesBox) {
        const minCircleRatio = 0.5;
        const circleLeft = -radius;
        const circleTop = -radius;
        const circleRight = radius;
        const circleBottom = radius;
        let padLeft = Math.max(0, circleLeft - labelsBox.x);
        let padTop = Math.max(0, circleTop - labelsBox.y);
        let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);
        let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);
        padLeft = padRight = Math.max(padLeft, padRight);
        padTop = padBottom = Math.max(padTop, padBottom);
        const availCircleWidth = seriesBox.width - padLeft - padRight;
        const availCircleHeight = seriesBox.height - padTop - padBottom;
        let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;
        const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;
        const minVerticalRadius = minCircleRatio * seriesBox.height / 2;
        const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);
        if (newRadius < minRadius) {
            newRadius = minRadius;
            const horizontalPadding = padLeft + padRight;
            const verticalPadding = padTop + padBottom;
            if (2 * newRadius + verticalPadding > seriesBox.height) {
                const padHeight = seriesBox.height - 2 * newRadius;
                if (Math.min(padTop, padBottom) * 2 > padHeight) {
                    padTop = padHeight / 2;
                    padBottom = padHeight / 2;
                } else if (padTop > padBottom) {
                    padTop = padHeight - padBottom;
                } else {
                    padBottom = padHeight - padTop;
                }
            }
            if (2 * newRadius + horizontalPadding > seriesBox.width) {
                const padWidth = seriesBox.width - 2 * newRadius;
                if (Math.min(padLeft, padRight) * 2 > padWidth) {
                    padLeft = padWidth / 2;
                    padRight = padWidth / 2;
                } else if (padLeft > padRight) {
                    padLeft = padWidth - padRight;
                } else {
                    padRight = padWidth - padLeft;
                }
            }
        }
        const newWidth = padLeft + 2 * newRadius + padRight;
        const newHeight = padTop + 2 * newRadius + padBottom;
        return {
            centerX: (seriesBox.width - newWidth) / 2 + padLeft + newRadius,
            centerY: (seriesBox.height - newHeight) / 2 + padTop + newRadius,
            radius: newRadius
        };
    }
    constructor(options, resources){
        super(options, resources);
        this.padding = new Padding(40);
        this.ctx.axisManager.axisGroup.zIndex = 8 /* AXIS_FOREGROUND */ ;
    }
};
PolarChart.className = "PolarChart";
PolarChart.type = "polar";
function isPolarSeries(series) {
    return series instanceof PolarSeries;
}
function isPolarAxis(axis) {
    return axis instanceof PolarAxis;
}
// packages/ag-charts-community/src/chart/polarChartModule.ts
var PolarChartModule = {
    type: "chart",
    name: "polar",
    options: polarChartOptionsDefs,
    detect: isAgPolarChartOptions,
    create (options, resources) {
        return new PolarChart(options, resources);
    },
    validate (options, optionsDefs6, path) {
        var _options_series_, _options_series;
        const additionalErrors = [];
        const baseType = options === null || options === void 0 ? void 0 : (_options_series = options.series) === null || _options_series === void 0 ? void 0 : (_options_series_ = _options_series[0]) === null || _options_series_ === void 0 ? void 0 : _options_series_.type;
        if (baseType === "pie" || baseType === "donut") {
            if (options === null || options === void 0 ? void 0 : options.axes) {
                additionalErrors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnknownError"]([], options.axes, path, "axes"));
                options = without(options, [
                    "axes"
                ]);
            }
        }
        const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"])(options, optionsDefs6, path);
        result.invalid.push(...additionalErrors);
        return result;
    }
};
;
var AllCartesianCommunityModules = [
    CartesianChartModule,
    NumberAxisModule,
    LogAxisModule,
    TimeAxisModule,
    CategoryAxisModule,
    GroupedCategoryAxisModule,
    UnitTimeAxisModule,
    NewAreaSeriesModule,
    NewBarSeriesModule,
    NewBubbleSeriesModule,
    NewHistogramSeriesModule,
    NewLineSeriesModule,
    NewScatterSeriesModule
];
var AllPolarCommunityModules = [
    PolarChartModule,
    NewDonutSeriesModule,
    NewPieSeriesModule
];
var AllCommunityModules = [
    ...AllCartesianCommunityModules,
    ...AllPolarCommunityModules,
    // Enterprise placeholders
    StandaloneChartModule,
    TopologyChartModule,
    // Presets
    PriceVolumePresetModule,
    GaugePresetModule,
    SparklinePresetModule
];
// packages/ag-charts-community/src/util/pool.ts
var CLEANUP_TIMEOUT_MS = 1e3;
var _Pool = class _Pool {
    static getPool(name, buildItem, releaseItem, destroyItem, maxPoolSize) {
        if (!this.pools.has(name)) {
            this.pools.set(name, new _Pool(name, buildItem, releaseItem, destroyItem, maxPoolSize));
        }
        return this.pools.get(name);
    }
    isFull() {
        return this.freePool.length + this.busyPool.size >= this.maxPoolSize;
    }
    hasFree() {
        return this.freePool.length > 0;
    }
    obtain(params) {
        if (!this.hasFree() && this.isFull()) {
            throw new Error("AG Charts - pool exhausted");
        }
        let nextFree = this.freePool.pop();
        if (nextFree == null) {
            nextFree = this.buildItem(params);
            _Pool.debug(()=>[
                    "Pool[name=".concat(this.name, "]: Created instance (").concat(this.freePool.length, " / ").concat(this.busyPool.size + 1, " / ").concat(this.maxPoolSize, ")"),
                    nextFree
                ]);
        } else {
            _Pool.debug(()=>[
                    "Pool[name=".concat(this.name, "]: Re-used instance (").concat(this.freePool.length, " / ").concat(this.busyPool.size + 1, " / ").concat(this.maxPoolSize, ")"),
                    nextFree
                ]);
        }
        this.busyPool.add(nextFree);
        return {
            item: nextFree,
            release: ()=>this.release(nextFree)
        };
    }
    obtainFree() {
        const nextFree = this.freePool.pop();
        if (nextFree == null) {
            throw new Error("AG Charts - pool has no free instances");
        }
        _Pool.debug(()=>[
                "Pool[name=".concat(this.name, "]: Re-used instance (").concat(this.freePool.length, " / ").concat(this.busyPool.size + 1, " / ").concat(this.maxPoolSize, ")"),
                nextFree
            ]);
        this.busyPool.add(nextFree);
        return {
            item: nextFree,
            release: ()=>this.release(nextFree)
        };
    }
    release(item) {
        if (!this.busyPool.has(item)) {
            throw new Error("AG Charts - cannot free item from pool which is not tracked as busy.");
        }
        _Pool.debug(()=>[
                "Pool[name=".concat(this.name, "]: Releasing instance (").concat(this.freePool.length, " / ").concat(this.busyPool.size, " / ").concat(this.maxPoolSize, ")"),
                item
            ]);
        this.releaseItem(item);
        this.busyPool.delete(item);
        this.freePool.push(item);
        _Pool.debug(()=>[
                "Pool[name=".concat(this.name, "]: Returned instance to free pool (").concat(this.freePool.length, " / ").concat(this.busyPool.size, " / ").concat(this.maxPoolSize, ")"),
                item
            ]);
        const now = Date.now();
        const earliestClean = now + this.cleanupTimeMs * 0.5;
        var _this_cleanPoolDue;
        if (this.cleanPoolTimer && ((_this_cleanPoolDue = this.cleanPoolDue) !== null && _this_cleanPoolDue !== void 0 ? _this_cleanPoolDue : Infinity) < earliestClean) {
            clearTimeout(this.cleanPoolTimer);
            this.cleanPoolTimer = void 0;
        }
        if (!this.cleanPoolTimer) {
            this.cleanPoolDue = now + this.cleanupTimeMs;
            this.cleanPoolTimer = setTimeout(this.cleanPool.bind(this), this.cleanupTimeMs);
        }
    }
    cleanPool() {
        const itemsToFree = this.freePool.splice(0);
        for (const item of itemsToFree){
            this.destroyItem(item);
        }
        _Pool.debug(()=>[
                "Pool[name=".concat(this.name, "]: Cleaned pool of ").concat(itemsToFree.length, " items (").concat(this.freePool.length, " / ").concat(this.busyPool.size, " / ").concat(this.maxPoolSize, ")")
            ]);
    }
    destroy() {
        this.cleanPool();
        for (const item of this.busyPool.values()){
            this.destroyItem(item);
        }
        this.busyPool.clear();
    }
    constructor(name, buildItem, releaseItem, destroyItem, maxPoolSize, cleanupTimeMs = CLEANUP_TIMEOUT_MS){
        this.name = name;
        this.buildItem = buildItem;
        this.releaseItem = releaseItem;
        this.destroyItem = destroyItem;
        this.maxPoolSize = maxPoolSize;
        this.cleanupTimeMs = cleanupTimeMs;
        this.freePool = [];
        this.busyPool = /* @__PURE__ */ new Set();
    }
};
_Pool.pools = /* @__PURE__ */ new Map();
_Pool.debug = Debug.create(true, "pool");
var Pool = _Pool;
// packages/ag-charts-community/src/api/agCharts.ts
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].registerMany(AllCommunityModules, VERSION);
var debug3 = Debug.create(true, "opts");
var AgCharts = class {
    static licenseCheck(options) {
        var _enterpriseModule_licenseManager, _this_licenseManager;
        if (this.licenseChecked) return;
        this.licenseManager = (_enterpriseModule_licenseManager = enterpriseModule.licenseManager) === null || _enterpriseModule_licenseManager === void 0 ? void 0 : _enterpriseModule_licenseManager.call(enterpriseModule, options);
        (_this_licenseManager = this.licenseManager) === null || _this_licenseManager === void 0 ? void 0 : _this_licenseManager.validateLicense();
        this.licenseChecked = true;
    }
    static getLicenseDetails(licenseKey) {
        var _enterpriseModule_licenseManager;
        return (_enterpriseModule_licenseManager = enterpriseModule.licenseManager) === null || _enterpriseModule_licenseManager === void 0 ? void 0 : _enterpriseModule_licenseManager.call(enterpriseModule, {}).getLicenseDetails(licenseKey);
    }
    /**
   * Returns the `AgChartInstance` for a DOM node, if there is one.
   */ static getInstance(element2) {
        return AgChartsInternal.getInstance(element2);
    }
    /**
   * Create a new `AgChartInstance` based upon the given configuration options.
   */ static create(userOptions, optionsMetadata) {
        const apiStartTime = Debug.check("scene:stats", "scene:stats:verbose") ? performance.now() : void 0;
        return debug3.group("AgCharts.create()", ()=>{
            var _this_licenseManager;
            var _Debug_inDevelopmentMode;
            userOptions = (_Debug_inDevelopmentMode = Debug.inDevelopmentMode(()=>deepFreeze(deepClone(userOptions)))) !== null && _Debug_inDevelopmentMode !== void 0 ? _Debug_inDevelopmentMode : userOptions;
            this.licenseCheck(userOptions);
            const chart = AgChartsInternal.createOrUpdate({
                userOptions,
                licenseManager: this.licenseManager,
                optionsMetadata,
                apiStartTime
            });
            if (((_this_licenseManager = this.licenseManager) === null || _this_licenseManager === void 0 ? void 0 : _this_licenseManager.isDisplayWatermark()) && this.licenseManager) {
                var _enterpriseModule_injectWatermark;
                (_enterpriseModule_injectWatermark = enterpriseModule.injectWatermark) === null || _enterpriseModule_injectWatermark === void 0 ? void 0 : _enterpriseModule_injectWatermark.call(enterpriseModule, chart.chart.ctx.domManager, this.licenseManager.getWatermarkMessage());
            }
            return chart;
        });
    }
    static createFinancialChart(options) {
        return debug3.group("AgCharts.createFinancialChart()", ()=>{
            return this.create(options, {
                presetType: "price-volume"
            });
        });
    }
    static createGauge(options) {
        return debug3.group("AgCharts.createGauge()", ()=>{
            return this.create(options, {
                presetType: "gauge-preset"
            });
        });
    }
    static __createSparkline(options) {
        return debug3.group("AgCharts.__createSparkline()", ()=>{
            const { pool, ...normalOptions } = options;
            return this.create(normalOptions, {
                presetType: "sparkline",
                pool: pool !== null && pool !== void 0 ? pool : true,
                domMode: "minimal",
                withDragInterpretation: false
            });
        });
    }
};
AgCharts.licenseChecked = false;
var _AgChartsInternal = class _AgChartsInternal {
    static getInstance(element2) {
        const chart = Chart.getInstance(element2);
        return chart ? AgChartInstanceProxy.chartInstances.get(chart) : void 0;
    }
    static initialiseModules() {
        if (_AgChartsInternal.initialised) return;
        registerInbuiltModules();
        setupModules();
        _AgChartsInternal.initialised = true;
    }
    static createOrUpdate(opts) {
        var _proxy_chart, _proxy_chart1, _proxy_chart2;
        let { proxy } = opts;
        var _proxy_chart_chartOptions_processedOverrides, _proxy_chart_chartOptions_specialOverrides, _proxy_chart_chartOptions_optionMetadata;
        const { userOptions, licenseManager, processedOverrides = (_proxy_chart_chartOptions_processedOverrides = proxy === null || proxy === void 0 ? void 0 : (_proxy_chart = proxy.chart) === null || _proxy_chart === void 0 ? void 0 : _proxy_chart.chartOptions.processedOverrides) !== null && _proxy_chart_chartOptions_processedOverrides !== void 0 ? _proxy_chart_chartOptions_processedOverrides : {}, specialOverrides = (_proxy_chart_chartOptions_specialOverrides = proxy === null || proxy === void 0 ? void 0 : (_proxy_chart1 = proxy.chart) === null || _proxy_chart1 === void 0 ? void 0 : _proxy_chart1.chartOptions.specialOverrides) !== null && _proxy_chart_chartOptions_specialOverrides !== void 0 ? _proxy_chart_chartOptions_specialOverrides : {}, optionsMetadata = (_proxy_chart_chartOptions_optionMetadata = proxy === null || proxy === void 0 ? void 0 : (_proxy_chart2 = proxy.chart) === null || _proxy_chart2 === void 0 ? void 0 : _proxy_chart2.chartOptions.optionMetadata) !== null && _proxy_chart_chartOptions_optionMetadata !== void 0 ? _proxy_chart_chartOptions_optionMetadata : {}, deltaOptions, data, stripSymbols = false, apiStartTime } = opts;
        const styles = enterpriseModule.styles != null ? [
            [
                "ag-charts-enterprise",
                enterpriseModule.styles
            ]
        ] : [];
        _AgChartsInternal.initialiseModules();
        debug3(()=>[
                ">>> AgCharts.createOrUpdate() user options",
                deepClone(userOptions)
            ]);
        const { presetType } = optionsMetadata;
        let mutableOptions = userOptions;
        if (AgCharts.optionsMutationFn && mutableOptions) {
            mutableOptions = AgCharts.optionsMutationFn(deepClone(mutableOptions, ChartOptions.OPTIONS_CLONE_OPTS_FAST), presetType);
            debug3(()=>[
                    ">>> AgCharts.createOrUpdate() MUTATED user options",
                    deepClone(mutableOptions)
                ]);
        }
        const pool = this.getPool(optionsMetadata);
        let create = false;
        let poolResult;
        let chart = proxy === null || proxy === void 0 ? void 0 : proxy.chart;
        if (chart == null && (pool === null || pool === void 0 ? void 0 : pool.hasFree())) {
            poolResult = pool.obtainFree();
            chart = poolResult.item;
        }
        const { document: document2, window: userWindow, styleContainer, ...options } = mutableOptions !== null && mutableOptions !== void 0 ? mutableOptions : {};
        const baseOptions = chart === null || chart === void 0 ? void 0 : chart.getChartOptions();
        const chartOptions = new ChartOptions(baseOptions, options, processedOverrides, {
            ...specialOverrides,
            document: document2,
            window: userWindow,
            styleContainer
        }, optionsMetadata, deltaOptions, stripSymbols, apiStartTime);
        if (chart == null || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].detectChartDefinition(chartOptions.processedOptions) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].detectChartDefinition(chart.chartOptions.processedOptions)) {
            var _this_getPool;
            poolResult === null || poolResult === void 0 ? void 0 : poolResult.release();
            poolResult = (_this_getPool = this.getPool(chartOptions.optionMetadata)) === null || _this_getPool === void 0 ? void 0 : _this_getPool.obtain(chartOptions);
            if (poolResult) {
                chart = poolResult.item;
            } else {
                create = true;
                chart = _AgChartsInternal.createChartInstance(chartOptions, chart);
            }
        }
        styles.forEach((param)=>{
            let [id, css] = param;
            chart.ctx.domManager.addStyles(id, css);
        });
        chart.ctx.fontManager.updateFonts(chartOptions.googleFonts);
        if (data != null) {
            chart.ctx.dataService.restoreData(data);
        }
        if (proxy == null) {
            proxy = new AgChartInstanceProxy(chart, _AgChartsInternal.callbackApi, licenseManager);
            proxy.releaseChart = poolResult === null || poolResult === void 0 ? void 0 : poolResult.release;
        } else if (poolResult || create) {
            var _proxy_releaseChart;
            (_proxy_releaseChart = proxy.releaseChart) === null || _proxy_releaseChart === void 0 ? void 0 : _proxy_releaseChart.call(proxy);
            proxy.chart = chart;
            proxy.releaseChart = poolResult === null || poolResult === void 0 ? void 0 : poolResult.release;
        }
        if (debug3.check() && typeof window !== "undefined") {
            var _window_agChartInstances;
            (_window_agChartInstances = window.agChartInstances) !== null && _window_agChartInstances !== void 0 ? _window_agChartInstances : window.agChartInstances = {};
            window.agChartInstances[chart.id] = chart;
        }
        chart.queuedUserOptions.push(chartOptions.userOptions);
        chart.queuedChartOptions.push(chartOptions);
        chart.requestFactoryUpdate((chartRef)=>{
            debug3.group(">>>> Chart.applyOptions()", ()=>{
                chartRef.applyOptions(chartOptions);
                const queueIdx = chartRef.queuedUserOptions.indexOf(chartOptions.userOptions) + 1;
                chartRef.queuedUserOptions.splice(0, queueIdx);
                chartRef.queuedChartOptions.splice(0, queueIdx);
            });
        });
        return proxy;
    }
    static markRemovedProperties(node, _) {
        let modified = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        if (typeof node !== "object") return modified;
        for (const key of Object.keys(node)){
            const value = node[key];
            if (typeof value === "undefined") {
                Object.assign(node, {
                    [key]: Symbol("UNSET")
                });
                modified || (modified = true);
            }
        }
        return modified;
    }
    static updateUserDelta(proxy, deltaOptions, apiStartTime) {
        deltaOptions = deepClone(deltaOptions, ChartOptions.OPTIONS_CLONE_OPTS_FAST);
        const stripSymbols = jsonWalk(deltaOptions, _AgChartsInternal.markRemovedProperties, /* @__PURE__ */ new Set([
            "data"
        ]), void 0, void 0, false);
        debug3(()=>[
                ">>> AgCharts.updateUserDelta() user delta",
                deepClone(deltaOptions)
            ]);
        _AgChartsInternal.createOrUpdate({
            proxy,
            deltaOptions,
            stripSymbols,
            apiStartTime
        });
    }
    static createChartInstance(options, oldChart) {
        const transferableResource = oldChart === null || oldChart === void 0 ? void 0 : oldChart.destroy({
            keepTransferableResources: true
        });
        const chartDef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"].detectChartDefinition(options.processedOptions);
        return chartDef.create(options, transferableResource);
    }
    static getPool(optionMetadata) {
        if (optionMetadata.pool !== true) return;
        var _optionMetadata_presetType;
        return Pool.getPool((_optionMetadata_presetType = optionMetadata.presetType) !== null && _optionMetadata_presetType !== void 0 ? _optionMetadata_presetType : "default", this.createChartInstance, this.detachAndClear, this.destroy, Infinity);
    }
};
_AgChartsInternal.caretaker = new MementoCaretaker(VERSION);
_AgChartsInternal.initialised = false;
_AgChartsInternal.callbackApi = {
    caretaker: _AgChartsInternal.caretaker,
    create (userOptions, processedOverrides, specialOverrides, optionsMetadata, data) {
        return _AgChartsInternal.createOrUpdate({
            userOptions,
            processedOverrides,
            specialOverrides,
            optionsMetadata,
            data
        });
    },
    update (opts, chart, specialOverrides, apiStartTime) {
        return _AgChartsInternal.createOrUpdate({
            userOptions: opts,
            proxy: chart,
            specialOverrides,
            apiStartTime
        });
    },
    updateUserDelta (chart, deltaOptions, apiStartTime) {
        return _AgChartsInternal.updateUserDelta(chart, deltaOptions, apiStartTime);
    }
};
_AgChartsInternal.detachAndClear = (chart)=>chart.detachAndClear();
_AgChartsInternal.destroy = (chart)=>chart.destroy();
var AgChartsInternal = _AgChartsInternal;
// packages/ag-charts-community/src/integrated-charts-scene.ts
var integrated_charts_scene_exports = {};
__export(integrated_charts_scene_exports, {
    Arc: ()=>Arc2,
    BBox: ()=>BBox,
    Caption: ()=>Caption,
    CategoryScale: ()=>CategoryScale,
    Group: ()=>Group,
    Line: ()=>Line,
    LinearScale: ()=>LinearScale,
    Marker: ()=>Marker,
    Path: ()=>Path,
    RadialColumnShape: ()=>RadialColumnShape,
    Rect: ()=>Rect,
    Scene: ()=>Scene,
    Sector: ()=>Sector,
    Shape: ()=>Shape,
    TranslatableGroup: ()=>TranslatableGroup,
    getRadialColumnWidth: ()=>getRadialColumnWidth,
    toRadians: ()=>toRadians
});
;
var Arc2 = class extends Path {
    get fullPie() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberEqual"])(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));
    }
    updatePath() {
        const path = this.path;
        path.clear();
        path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);
        if (this.type === 1 /* Chord */ ) {
            path.closePath();
        } else if (this.type === 2 /* Round */  && !this.fullPie) {
            path.lineTo(this.centerX, this.centerY);
            path.closePath();
        }
    }
    computeBBox() {
        return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);
    }
    isPointInPath(x, y) {
        const bbox = this.getBBox();
        return this.type !== 0 /* Open */  && bbox.containsPoint(x, y) && this.path.isPointInPath(x, y);
    }
    constructor(){
        super(...arguments);
        this.centerX = 0;
        this.centerY = 0;
        this.radius = 10;
        this.startAngle = 0;
        this.endAngle = Math.PI * 2;
        this.counterClockwise = false;
        this.type = 0 /* Open */ ;
    }
};
Arc2.className = "Arc";
__decorateClass([
    SceneChangeDetection()
], Arc2.prototype, "centerX", 2);
__decorateClass([
    SceneChangeDetection()
], Arc2.prototype, "centerY", 2);
__decorateClass([
    SceneChangeDetection()
], Arc2.prototype, "radius", 2);
__decorateClass([
    SceneChangeDetection()
], Arc2.prototype, "startAngle", 2);
__decorateClass([
    SceneChangeDetection()
], Arc2.prototype, "endAngle", 2);
__decorateClass([
    SceneChangeDetection()
], Arc2.prototype, "counterClockwise", 2);
__decorateClass([
    SceneChangeDetection()
], Arc2.prototype, "type", 2);
;
function rotatePoint(x, y, rotation) {
    const radius = Math.sqrt(x ** 2 + y ** 2);
    const angle2 = Math.atan2(y, x);
    const rotated = angle2 + rotation;
    return {
        x: Math.cos(rotated) * radius,
        y: Math.sin(rotated) * radius
    };
}
var RadialColumnShape = class extends Path {
    set cornerRadius(_value) {}
    computeBBox() {
        const { innerRadius, outerRadius, columnWidth } = this;
        const rotation = this.getRotation();
        const left = -columnWidth / 2;
        const right = columnWidth / 2;
        const top = -outerRadius;
        const bottom = -innerRadius;
        let x0 = Infinity;
        let y0 = Infinity;
        let x1 = -Infinity;
        let y1 = -Infinity;
        for(let i = 0; i < 4; i += 1){
            const { x, y } = rotatePoint(i % 2 === 0 ? left : right, i < 2 ? top : bottom, rotation);
            x0 = Math.min(x, x0);
            y0 = Math.min(y, y0);
            x1 = Math.max(x, x1);
            y1 = Math.max(y, y1);
        }
        return new BBox(x0, y0, x1 - x0, y1 - y0);
    }
    getRotation() {
        const { startAngle, endAngle } = this;
        const midAngle = angleBetween(startAngle, endAngle);
        return normalizeAngle360(startAngle + midAngle / 2 + Math.PI / 2);
    }
    updatePath() {
        const { isBeveled } = this;
        if (isBeveled) {
            this.updateBeveledPath();
        } else {
            this.updateRectangularPath();
        }
        this.checkPathDirty();
    }
    updateRectangularPath() {
        const { columnWidth, innerRadius, outerRadius, path } = this;
        const left = -columnWidth / 2;
        const right = columnWidth / 2;
        const top = -outerRadius;
        const bottom = -innerRadius;
        const rotation = this.getRotation();
        const points = [
            [
                left,
                bottom
            ],
            [
                left,
                top
            ],
            [
                right,
                top
            ],
            [
                right,
                bottom
            ]
        ].map((param)=>{
            let [x, y] = param;
            return rotatePoint(x, y, rotation);
        });
        path.clear(true);
        path.moveTo(points[0].x, points[0].y);
        path.lineTo(points[1].x, points[1].y);
        path.lineTo(points[2].x, points[2].y);
        path.lineTo(points[3].x, points[3].y);
        path.closePath();
    }
    updateBeveledPath() {
        const { columnWidth, path, outerRadius, innerRadius, axisInnerRadius, axisOuterRadius, isRadiusAxisReversed } = this;
        const isStackBottom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberEqual"])(innerRadius, axisInnerRadius);
        const sideRotation = Math.asin(columnWidth / 2 / innerRadius);
        const pointRotation = this.getRotation();
        const rotate2 = (x, y)=>rotatePoint(x, y, pointRotation);
        const getTriangleHypotenuse = (leg, otherLeg)=>Math.sqrt(leg ** 2 + otherLeg ** 2);
        const getTriangleLeg = (hypotenuse, otherLeg)=>{
            if (otherLeg > hypotenuse) {
                return 0;
            }
            return Math.sqrt(hypotenuse ** 2 - otherLeg ** 2);
        };
        const compare = (value, otherValue, lessThan6)=>lessThan6 ? value < otherValue : value > otherValue;
        const shouldConnectBottomCircle = isStackBottom && !isNaN(sideRotation) && sideRotation < Math.PI / 6;
        let left = -columnWidth / 2;
        let right = columnWidth / 2;
        const top = -outerRadius;
        const bottom = -innerRadius * (shouldConnectBottomCircle ? Math.cos(sideRotation) : 1);
        const hasBottomIntersection = compare(axisOuterRadius, getTriangleHypotenuse(innerRadius, columnWidth / 2), !isRadiusAxisReversed);
        if (hasBottomIntersection) {
            const bottomIntersectionX = getTriangleLeg(axisOuterRadius, innerRadius);
            left = -bottomIntersectionX;
            right = bottomIntersectionX;
        }
        path.clear(true);
        const bottomLeftPt = rotate2(left, bottom);
        path.moveTo(bottomLeftPt.x, bottomLeftPt.y);
        const isEmpty = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberEqual"])(innerRadius, outerRadius);
        const hasSideIntersection = compare(axisOuterRadius, getTriangleHypotenuse(outerRadius, columnWidth / 2), !isRadiusAxisReversed);
        if (isEmpty && shouldConnectBottomCircle) {
            path.arc(0, 0, innerRadius, normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation, normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation, false);
        } else if (hasSideIntersection) {
            const sideIntersectionY = -getTriangleLeg(axisOuterRadius, columnWidth / 2);
            const topIntersectionX = getTriangleLeg(axisOuterRadius, outerRadius);
            if (!hasBottomIntersection) {
                const topLeftPt = rotate2(left, sideIntersectionY);
                path.lineTo(topLeftPt.x, topLeftPt.y);
            }
            path.arc(0, 0, axisOuterRadius, Math.atan2(sideIntersectionY, left) + pointRotation, Math.atan2(top, -topIntersectionX) + pointRotation, false);
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumberEqual"])(topIntersectionX, 0)) {
                const topRightBevelPt = rotate2(topIntersectionX, top);
                path.lineTo(topRightBevelPt.x, topRightBevelPt.y);
            }
            path.arc(0, 0, axisOuterRadius, Math.atan2(top, topIntersectionX) + pointRotation, Math.atan2(sideIntersectionY, right) + pointRotation, false);
        } else {
            const topLeftPt = rotate2(left, top);
            const topRightPt = rotate2(right, top);
            path.lineTo(topLeftPt.x, topLeftPt.y);
            path.lineTo(topRightPt.x, topRightPt.y);
        }
        const bottomRightPt = rotate2(right, bottom);
        path.lineTo(bottomRightPt.x, bottomRightPt.y);
        if (shouldConnectBottomCircle) {
            path.arc(0, 0, innerRadius, normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation, normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation, true);
        } else {
            const rotatedBottomLeftPt = rotate2(left, bottom);
            path.lineTo(rotatedBottomLeftPt.x, rotatedBottomLeftPt.y);
        }
        path.closePath();
    }
    constructor(){
        super(...arguments);
        this.isBeveled = true;
        this.columnWidth = 0;
        this.startAngle = 0;
        this.endAngle = 0;
        this.outerRadius = 0;
        this.innerRadius = 0;
        this.axisInnerRadius = 0;
        this.axisOuterRadius = 0;
        this.isRadiusAxisReversed = false;
    }
};
RadialColumnShape.className = "RadialColumnShape";
__decorateClass([
    SceneChangeDetection()
], RadialColumnShape.prototype, "isBeveled", 2);
__decorateClass([
    SceneChangeDetection()
], RadialColumnShape.prototype, "columnWidth", 2);
__decorateClass([
    SceneChangeDetection()
], RadialColumnShape.prototype, "startAngle", 2);
__decorateClass([
    SceneChangeDetection()
], RadialColumnShape.prototype, "endAngle", 2);
__decorateClass([
    SceneChangeDetection()
], RadialColumnShape.prototype, "outerRadius", 2);
__decorateClass([
    SceneChangeDetection()
], RadialColumnShape.prototype, "innerRadius", 2);
__decorateClass([
    SceneChangeDetection()
], RadialColumnShape.prototype, "axisInnerRadius", 2);
__decorateClass([
    SceneChangeDetection()
], RadialColumnShape.prototype, "axisOuterRadius", 2);
__decorateClass([
    SceneChangeDetection()
], RadialColumnShape.prototype, "isRadiusAxisReversed", 2);
function getRadialColumnWidth(startAngle, endAngle, axisOuterRadius, columnWidthRatio, maxColumnWidthRatio) {
    const rotation = angleBetween(startAngle, endAngle);
    const pad2 = rotation * (1 - columnWidthRatio) / 2;
    startAngle += pad2;
    endAngle -= pad2;
    if (rotation < 1e-3) {
        return 2 * axisOuterRadius * maxColumnWidthRatio;
    }
    if (rotation >= 2 * Math.PI) {
        const midAngle = startAngle + rotation / 2;
        startAngle = midAngle - Math.PI;
        endAngle = midAngle + Math.PI;
    }
    const startX = axisOuterRadius * Math.cos(startAngle);
    const startY = axisOuterRadius * Math.sin(startAngle);
    const endX = axisOuterRadius * Math.cos(endAngle);
    const endY = axisOuterRadius * Math.sin(endAngle);
    const colWidth = Math.floor(Math.sqrt((startX - endX) ** 2 + (startY - endY) ** 2));
    const maxWidth = 2 * axisOuterRadius * maxColumnWidthRatio;
    return Math.max(1, Math.min(maxWidth, colWidth));
}
// packages/ag-charts-community/src/integrated-charts-theme.ts
var integrated_charts_theme_exports = {};
__export(integrated_charts_theme_exports, {
    ChartTheme: ()=>ChartTheme,
    DEFAULT_ANNOTATION_HANDLE_FILL: ()=>DEFAULT_ANNOTATION_HANDLE_FILL,
    DEFAULT_ANNOTATION_STATISTICS_COLOR: ()=>DEFAULT_ANNOTATION_STATISTICS_COLOR,
    DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE: ()=>DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,
    DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL: ()=>DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
    DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE: ()=>DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,
    DEFAULT_ANNOTATION_STATISTICS_FILL: ()=>DEFAULT_ANNOTATION_STATISTICS_FILL,
    DEFAULT_ANNOTATION_STATISTICS_STROKE: ()=>DEFAULT_ANNOTATION_STATISTICS_STROKE,
    DEFAULT_CAPTION_ALIGNMENT: ()=>DEFAULT_CAPTION_ALIGNMENT,
    DEFAULT_CAPTION_LAYOUT_STYLE: ()=>DEFAULT_CAPTION_LAYOUT_STYLE,
    DEFAULT_FIBONACCI_STROKES: ()=>DEFAULT_FIBONACCI_STROKES,
    DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL: ()=>DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
    DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR: ()=>DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
    DEFAULT_GRIDLINE_ENABLED: ()=>DEFAULT_GRIDLINE_ENABLED,
    DEFAULT_POLAR_SERIES_STROKE: ()=>DEFAULT_POLAR_SERIES_STROKE,
    DEFAULT_SEPARATION_LINES_COLOUR: ()=>DEFAULT_SEPARATION_LINES_COLOUR,
    DEFAULT_SHADOW_COLOUR: ()=>DEFAULT_SHADOW_COLOUR,
    DEFAULT_SPARKLINE_CROSSHAIR_STROKE: ()=>DEFAULT_SPARKLINE_CROSSHAIR_STROKE,
    DEFAULT_TEXTBOX_COLOR: ()=>DEFAULT_TEXTBOX_COLOR,
    DEFAULT_TEXTBOX_FILL: ()=>DEFAULT_TEXTBOX_FILL,
    DEFAULT_TEXTBOX_STROKE: ()=>DEFAULT_TEXTBOX_STROKE,
    DEFAULT_TEXT_ANNOTATION_COLOR: ()=>DEFAULT_TEXT_ANNOTATION_COLOR,
    DEFAULT_TOOLBAR_POSITION: ()=>DEFAULT_TOOLBAR_POSITION,
    IS_DARK_THEME: ()=>IS_DARK_THEME,
    PALETTE_ALT_DOWN_FILL: ()=>PALETTE_ALT_DOWN_FILL,
    PALETTE_ALT_DOWN_STROKE: ()=>PALETTE_ALT_DOWN_STROKE,
    PALETTE_ALT_NEUTRAL_FILL: ()=>PALETTE_ALT_NEUTRAL_FILL,
    PALETTE_ALT_NEUTRAL_STROKE: ()=>PALETTE_ALT_NEUTRAL_STROKE,
    PALETTE_ALT_UP_FILL: ()=>PALETTE_ALT_UP_FILL,
    PALETTE_ALT_UP_STROKE: ()=>PALETTE_ALT_UP_STROKE,
    PALETTE_DOWN_FILL: ()=>PALETTE_DOWN_FILL,
    PALETTE_DOWN_STROKE: ()=>PALETTE_DOWN_STROKE,
    PALETTE_NEUTRAL_FILL: ()=>PALETTE_NEUTRAL_FILL,
    PALETTE_NEUTRAL_STROKE: ()=>PALETTE_NEUTRAL_STROKE,
    PALETTE_UP_FILL: ()=>PALETTE_UP_FILL,
    PALETTE_UP_STROKE: ()=>PALETTE_UP_STROKE,
    getChartTheme: ()=>getChartTheme,
    resolveOperation: ()=>resolveOperation,
    themeNames: ()=>themeNames,
    themeSymbols: ()=>symbols_exports,
    themes: ()=>themes
});
var themeNames = Object.keys(themes);
function resolveOperation(operation) {
    const params = ChartTheme.getDefaultPublicParameters();
    const palette = ChartTheme.getDefaultColors();
    const graph = new OptionsGraph({
        line: {
            operation
        }
    }, {
        series: [
            {
                type: "line"
            }
        ]
    }, params, palette);
    const resolved = graph.resolve();
    return resolved.operation;
}
// packages/ag-charts-community/src/integrated-charts-util.ts
var integrated_charts_util_exports = {};
__export(integrated_charts_util_exports, {
    Color: ()=>Color,
    interpolateColor: ()=>interpolateColor
});
;
function createTimeInterval(unit, step, epoch, utc) {
    return {
        unit,
        step,
        epoch,
        utc,
        every (count) {
            var _this_step;
            return createTimeInterval(this.unit, ((_this_step = this.step) !== null && _this_step !== void 0 ? _this_step : 1) * count, this.epoch, this.utc);
        }
    };
}
var cachedInstances = {};
function getTimeInterval(unit) {
    let step = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, epoch = arguments.length > 2 ? arguments[2] : void 0, utc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce("time import is deprecated, use object notation instead");
    var _epoch_getTime;
    const key = "".concat(unit, ":").concat(step, ":").concat((_epoch_getTime = epoch === null || epoch === void 0 ? void 0 : epoch.getTime()) !== null && _epoch_getTime !== void 0 ? _epoch_getTime : 0, ":").concat(utc);
    let instance = cachedInstances[key];
    if (instance == null) {
        instance = createTimeInterval(unit, step, epoch, utc);
        cachedInstances[key] = instance;
    }
    return instance;
}
var time2 = {
    get millisecond () {
        return getTimeInterval("millisecond");
    },
    get second () {
        return getTimeInterval("second");
    },
    get minute () {
        return getTimeInterval("minute");
    },
    get hour () {
        return getTimeInterval("hour");
    },
    get day () {
        return getTimeInterval("day");
    },
    get monday () {
        return getTimeInterval("day", 7, new Date(1970, 0, 5));
    },
    get tuesday () {
        return getTimeInterval("day", 7, new Date(1970, 0, 6));
    },
    get wednesday () {
        return getTimeInterval("day", 7, new Date(1970, 0, 7));
    },
    get thursday () {
        return getTimeInterval("day", 7, new Date(1970, 0, 1));
    },
    get friday () {
        return getTimeInterval("day", 7, new Date(1970, 0, 2));
    },
    get saturday () {
        return getTimeInterval("day", 7, new Date(1970, 0, 3));
    },
    get sunday () {
        return getTimeInterval("day", 7, new Date(1970, 0, 4));
    },
    get month () {
        return getTimeInterval("month");
    },
    get year () {
        return getTimeInterval("year");
    },
    get utcMillisecond () {
        return getTimeInterval("millisecond", 1, void 0, true);
    },
    get utcSecond () {
        return getTimeInterval("second", 1, void 0, true);
    },
    get utcMinute () {
        return getTimeInterval("minute", 1, void 0, true);
    },
    get utcHour () {
        return getTimeInterval("hour", 1, void 0, true);
    },
    get utcDay () {
        return getTimeInterval("day", 1, void 0, true);
    },
    get utcMonth () {
        return getTimeInterval("month", 1, void 0, true);
    },
    get utcYear () {
        return getTimeInterval("year", 1, void 0, true);
    }
};
// packages/ag-charts-community/src/module-support.ts
var module_support_exports = {};
__export(module_support_exports, {
    AGGREGATION_INDEX_X_MAX: ()=>AGGREGATION_INDEX_X_MAX,
    AGGREGATION_INDEX_X_MIN: ()=>AGGREGATION_INDEX_X_MIN,
    AGGREGATION_INDEX_Y_MAX: ()=>AGGREGATION_INDEX_Y_MAX,
    AGGREGATION_INDEX_Y_MIN: ()=>AGGREGATION_INDEX_Y_MIN,
    AGGREGATION_SPAN: ()=>AGGREGATION_SPAN,
    AbstractBarSeries: ()=>AbstractBarSeries,
    AbstractBarSeriesProperties: ()=>AbstractBarSeriesProperties,
    ActionOnSet: ()=>ActionOnSet,
    AnchoredPopover: ()=>AnchoredPopover,
    Animation: ()=>Animation,
    AnimationManager: ()=>AnimationManager,
    Arc: ()=>Arc2,
    Axis: ()=>Axis,
    AxisGroupZIndexMap: ()=>AxisGroupZIndexMap,
    AxisInterval: ()=>AxisInterval,
    AxisLabel: ()=>AxisLabel,
    AxisTick: ()=>AxisTick,
    AxisTickGenerator: ()=>AxisTickGenerator,
    BASE_FONT_SIZE: ()=>BASE_FONT_SIZE,
    BBox: ()=>BBox,
    Background: ()=>Background,
    BackgroundModule: ()=>BackgroundModule,
    BandScale: ()=>BandScale,
    BarSeries: ()=>BarSeries,
    BarSeriesModule: ()=>BarSeriesModule,
    BaseModuleInstance: ()=>BaseModuleInstance,
    BaseProperties: ()=>BaseProperties,
    BaseToolbar: ()=>BaseToolbar,
    Border: ()=>Border,
    ButtonWidget: ()=>ButtonWidget,
    CachedTextMeasurer: ()=>CachedTextMeasurer,
    CachedTextMeasurerPool: ()=>CachedTextMeasurerPool,
    CallbackCache: ()=>CallbackCache,
    Caption: ()=>Caption,
    CartesianAxis: ()=>CartesianAxis,
    CartesianSeries: ()=>CartesianSeries,
    CartesianSeriesNodeEvent: ()=>CartesianSeriesNodeEvent,
    CartesianSeriesProperties: ()=>CartesianSeriesProperties,
    CategoryAxis: ()=>CategoryAxis,
    CategoryScale: ()=>CategoryScale,
    ChangeDetectableProperties: ()=>ChangeDetectableProperties,
    Chart: ()=>Chart,
    ChartAxisDirection: ()=>ChartAxisDirection,
    ChartOptions: ()=>ChartOptions,
    ChartUpdateType: ()=>ChartUpdateType,
    CollapseMode: ()=>CollapseMode,
    Color: ()=>Color,
    ColorScale: ()=>ColorScale,
    ConicGradient: ()=>ConicGradient,
    ContextMenuBuiltins: ()=>ContextMenuBuiltins,
    ContextMenuRegistry: ()=>ContextMenuRegistry,
    ContinuousScale: ()=>ContinuousScale,
    DEFAULT_CARTESIAN_DIRECTION_KEYS: ()=>DEFAULT_CARTESIAN_DIRECTION_KEYS,
    DEFAULT_CARTESIAN_DIRECTION_NAMES: ()=>DEFAULT_CARTESIAN_DIRECTION_NAMES,
    DEFAULT_POLAR_DIRECTION_KEYS: ()=>DEFAULT_POLAR_DIRECTION_KEYS,
    DEFAULT_POLAR_DIRECTION_NAMES: ()=>DEFAULT_POLAR_DIRECTION_NAMES,
    DEFAULT_TOOLTIP_CLASS: ()=>DEFAULT_TOOLTIP_CLASS,
    DEFAULT_TOOLTIP_DARK_CLASS: ()=>DEFAULT_TOOLTIP_DARK_CLASS,
    DIRECTION_SWAP_AXES: ()=>DIRECTION_SWAP_AXES,
    DOMManager: ()=>DOMManager,
    DataController: ()=>DataController,
    DataModel: ()=>DataModel,
    DataModelSeries: ()=>DataModelSeries,
    DataService: ()=>DataService,
    Debug: ()=>Debug,
    Deprecated: ()=>Deprecated,
    DeprecatedAndRenamedTo: ()=>DeprecatedAndRenamedTo,
    DiscreteTimeAxis: ()=>DiscreteTimeAxis,
    DiscreteTimeScale: ()=>DiscreteTimeScale,
    DragInterpreter: ()=>DragInterpreter,
    DraggablePopover: ()=>DraggablePopover,
    DropShadow: ()=>DropShadow,
    ExtendedPath2D: ()=>ExtendedPath2D,
    FILL_GRADIENT_CONIC_DEFAULTS: ()=>FILL_GRADIENT_CONIC_DEFAULTS,
    FILL_GRADIENT_LINEAR_DEFAULTS: ()=>FILL_GRADIENT_LINEAR_DEFAULTS,
    FILL_GRADIENT_LINEAR_HIERARCHY_DEFAULTS: ()=>FILL_GRADIENT_LINEAR_HIERARCHY_DEFAULTS,
    FILL_GRADIENT_LINEAR_SHADED_DEFAULTS: ()=>FILL_GRADIENT_LINEAR_SHADED_DEFAULTS,
    FILL_GRADIENT_RADIAL_DEFAULTS: ()=>FILL_GRADIENT_RADIAL_DEFAULTS,
    FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS: ()=>FILL_GRADIENT_RADIAL_REVERSED_DEFAULTS,
    FILL_GRADIENT_RADIAL_REVERSED_SERIES_DEFAULTS: ()=>FILL_GRADIENT_RADIAL_REVERSED_SERIES_DEFAULTS,
    FILL_GRADIENT_RADIAL_SERIES_DEFAULTS: ()=>FILL_GRADIENT_RADIAL_SERIES_DEFAULTS,
    FILL_IMAGE_DEFAULTS: ()=>FILL_IMAGE_DEFAULTS,
    FILL_PATTERN_DEFAULTS: ()=>FILL_PATTERN_DEFAULTS,
    FILL_PATTERN_HIERARCHY_DEFAULTS: ()=>FILL_PATTERN_HIERARCHY_DEFAULTS,
    FONT_SIZE: ()=>FONT_SIZE,
    FONT_SIZE_RATIO: ()=>FONT_SIZE_RATIO,
    FillGradientDefaults: ()=>FillGradientDefaults,
    FillImageDefaults: ()=>FillImageDefaults,
    FillPatternDefaults: ()=>FillPatternDefaults,
    FloatingToolbar: ()=>FloatingToolbar,
    FormatManager: ()=>FormatManager,
    Gradient: ()=>Gradient,
    Group: ()=>Group,
    GroupedCategoryAxis: ()=>GroupedCategoryAxis,
    HdpiCanvas: ()=>HdpiCanvas,
    HierarchyNode: ()=>HierarchyNode,
    HierarchySeries: ()=>HierarchySeries,
    HierarchySeriesProperties: ()=>HierarchySeriesProperties,
    HighlightManager: ()=>HighlightManager,
    HighlightProperties: ()=>HighlightProperties,
    HighlightState: ()=>HighlightState,
    HighlightStyle: ()=>HighlightStyle,
    Image: ()=>Image3,
    InteractionManager: ()=>InteractionManager,
    InteractionState: ()=>InteractionState,
    InterpolationProperties: ()=>InterpolationProperties,
    Invalidating: ()=>Invalidating,
    LABEL_BOXING_DEFAULTS: ()=>LABEL_BOXING_DEFAULTS,
    LARGEST_KEY_INTERVAL: ()=>LARGEST_KEY_INTERVAL,
    LEGEND_CONTAINER_THEME: ()=>LEGEND_CONTAINER_THEME,
    Label: ()=>Label,
    LayoutElement: ()=>LayoutElement,
    LayoutManager: ()=>LayoutManager,
    LegendMarkerLabel: ()=>LegendMarkerLabel,
    Line: ()=>Line,
    LineSeries: ()=>LineSeries,
    LineSeriesModule: ()=>LineSeriesModule,
    LinearGradient: ()=>LinearGradient,
    LinearScale: ()=>LinearScale,
    LogScale: ()=>LogScale,
    LonLatBBox: ()=>LonLatBBox,
    Marker: ()=>Marker,
    Menu: ()=>Menu,
    MenuItemWidget: ()=>MenuItemWidget,
    MenuWidget: ()=>MenuWidget,
    MercatorScale: ()=>MercatorScale,
    ModuleRegistry: ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModuleRegistry"],
    Motion: ()=>easing_exports,
    NODE_UPDATE_STATE_TO_PHASE_MAPPING: ()=>NODE_UPDATE_STATE_TO_PHASE_MAPPING,
    NativeWidget: ()=>NativeWidget,
    NewAreaSeriesModule: ()=>NewAreaSeriesModule,
    NewBarSeriesModule: ()=>NewBarSeriesModule,
    NewBubbleSeriesModule: ()=>NewBubbleSeriesModule,
    NewHistogramSeriesModule: ()=>NewHistogramSeriesModule,
    NewLineSeriesModule: ()=>NewLineSeriesModule,
    NewScatterSeriesModule: ()=>NewScatterSeriesModule,
    NiceMode: ()=>NiceMode,
    Node: ()=>Node2,
    NumberAxis: ()=>NumberAxis,
    ObserveChanges: ()=>ObserveChanges,
    OrdinalTimeScale: ()=>OrdinalTimeScale,
    PHASE_METADATA: ()=>PHASE_METADATA,
    PHASE_ORDER: ()=>PHASE_ORDER,
    PREV_NEXT_KEYS: ()=>PREV_NEXT_KEYS,
    Padding: ()=>Padding,
    ParallelStateMachine: ()=>ParallelStateMachine,
    Path: ()=>Path,
    PointerEvents: ()=>PointerEvents,
    PolarAxis: ()=>PolarAxis,
    PolarSeries: ()=>PolarSeries,
    PolarZIndexMap: ()=>PolarZIndexMap,
    Popover: ()=>Popover,
    PropertiesArray: ()=>PropertiesArray,
    Property: ()=>Property,
    ProxyInteractionService: ()=>ProxyInteractionService,
    ProxyOnWrite: ()=>ProxyOnWrite,
    ProxyProperty: ()=>ProxyProperty,
    ProxyPropertyOnWrite: ()=>ProxyPropertyOnWrite,
    QUICK_TRANSITION: ()=>QUICK_TRANSITION,
    QuadtreeNearest: ()=>QuadtreeNearest,
    RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD: ()=>RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD,
    RadialColumnShape: ()=>RadialColumnShape,
    Range: ()=>Range,
    Rect: ()=>Rect,
    RepeatType: ()=>RepeatType,
    Rotatable: ()=>Rotatable,
    RotatableGroup: ()=>RotatableGroup,
    RotatableText: ()=>RotatableText,
    SAFE_FILLS_OPERATION: ()=>SAFE_FILLS_OPERATION,
    SAFE_FILL_OPERATION: ()=>SAFE_FILL_OPERATION,
    SAFE_RANGE2_OPERATION: ()=>SAFE_RANGE2_OPERATION,
    SAFE_STROKE_FILL_OPERATION: ()=>SAFE_STROKE_FILL_OPERATION,
    SKIP_JS_BUILTINS: ()=>SKIP_JS_BUILTINS,
    SMALLEST_KEY_INTERVAL: ()=>SMALLEST_KEY_INTERVAL,
    SORT_DOMAIN_GROUPS: ()=>SORT_DOMAIN_GROUPS,
    Scalable: ()=>Scalable,
    ScalableGroup: ()=>ScalableGroup,
    ScaleAlignment: ()=>ScaleAlignment,
    Scene: ()=>Scene,
    SceneArrayChangeDetection: ()=>SceneArrayChangeDetection,
    SceneChangeDetection: ()=>SceneChangeDetection,
    SceneObjectChangeDetection: ()=>SceneObjectChangeDetection,
    SceneRefChangeDetection: ()=>SceneRefChangeDetection,
    Sector: ()=>Sector,
    SectorBox: ()=>SectorBox,
    Selection: ()=>Selection,
    Series: ()=>Series,
    SeriesContentZIndexMap: ()=>SeriesContentZIndexMap,
    SeriesGroupingChangedEvent: ()=>SeriesGroupingChangedEvent,
    SeriesItemHighlightStyle: ()=>SeriesItemHighlightStyle,
    SeriesMarker: ()=>SeriesMarker,
    SeriesNodeEvent: ()=>SeriesNodeEvent,
    SeriesNodePickMode: ()=>SeriesNodePickMode,
    SeriesProperties: ()=>SeriesProperties,
    SeriesTooltip: ()=>SeriesTooltip,
    SeriesZIndexMap: ()=>SeriesZIndexMap,
    Shape: ()=>Shape,
    SimpleTextMeasurer: ()=>SimpleTextMeasurer,
    SliderWidget: ()=>SliderWidget,
    StateMachine: ()=>StateMachine,
    StateMachineProperty: ()=>StateMachineProperty,
    StopProperties: ()=>StopProperties,
    SvgPath: ()=>SvgPath,
    TRIPLE_EQ: ()=>TRIPLE_EQ,
    Text: ()=>Text,
    TextUtils: ()=>TextUtils,
    TextWrapper: ()=>TextWrapper,
    ThemeConstants: ()=>constants_exports,
    ThemeSymbols: ()=>symbols_exports,
    TimeAxisParentLevel: ()=>TimeAxisParentLevel,
    TimeScale: ()=>TimeScale,
    Toolbar: ()=>Toolbar,
    ToolbarButtonProperties: ()=>ToolbarButtonProperties,
    ToolbarButtonWidget: ()=>ToolbarButtonWidget,
    ToolbarWidget: ()=>ToolbarWidget,
    Tooltip: ()=>Tooltip,
    TooltipManager: ()=>TooltipManager,
    TooltipPosition: ()=>TooltipPosition,
    Transformable: ()=>Transformable,
    TransformableGroup: ()=>TransformableGroup,
    TransformableText: ()=>TransformableText,
    Translatable: ()=>Translatable,
    TranslatableGroup: ()=>TranslatableGroup,
    TranslatableSvgPath: ()=>TranslatableSvgPath,
    UnitTimeScale: ()=>UnitTimeScale,
    UpdateService: ()=>UpdateService,
    Vec2: ()=>Vec2,
    Vec4: ()=>Vec4,
    WIDGET_HTML_EVENTS: ()=>WIDGET_HTML_EVENTS,
    Widget: ()=>Widget,
    WidgetEventUtil: ()=>WidgetEventUtil,
    ZIndexMap: ()=>ZIndexMap,
    ZoomManager: ()=>ZoomManager,
    accumulateGroup: ()=>accumulateGroup,
    accumulateStack: ()=>accumulateStack,
    accumulatedValue: ()=>accumulatedValue,
    accumulativeValueProperty: ()=>accumulativeValueProperty,
    addEscapeEventListener: ()=>addEscapeEventListener,
    addHitTestersToQuadtree: ()=>addHitTestersToQuadtree,
    addMouseCloseListener: ()=>addMouseCloseListener,
    addOverrideFocusVisibleEventListener: ()=>addOverrideFocusVisibleEventListener,
    addTouchCloseListener: ()=>addTouchCloseListener,
    adjustLabelPlacement: ()=>adjustLabelPlacement,
    aggregationDomain: ()=>aggregationDomain,
    aggregationIndexForXRatio: ()=>aggregationIndexForXRatio,
    aggregationRangeFittingPoints: ()=>aggregationRangeFittingPoints,
    aggregationXRatioForDatumIndex: ()=>aggregationXRatioForDatumIndex,
    aggregationXRatioForXValue: ()=>aggregationXRatioForXValue,
    angleBetween: ()=>angleBetween,
    angleCategoryAxisOptionsDefs: ()=>angleCategoryAxisOptionsDefs,
    angleNumberAxisOptionsDefs: ()=>angleNumberAxisOptionsDefs,
    angularPadding: ()=>angularPadding,
    animationValidation: ()=>animationValidation,
    annotationCalloutStylesDefs: ()=>annotationCalloutStylesDefs,
    annotationChannelStyleDefs: ()=>annotationChannelStyleDefs,
    annotationChannelTextDefs: ()=>annotationChannelTextDefs,
    annotationCommentStylesDefs: ()=>annotationCommentStylesDefs,
    annotationCrossLineStyleDefs: ()=>annotationCrossLineStyleDefs,
    annotationDisjointChannelStyleDefs: ()=>annotationDisjointChannelStyleDefs,
    annotationFibonacciStylesDefs: ()=>annotationFibonacciStylesDefs,
    annotationLineStyleDefs: ()=>annotationLineStyleDefs,
    annotationLineTextDefs: ()=>annotationLineTextDefs,
    annotationMeasurerStylesDefs: ()=>annotationMeasurerStylesDefs,
    annotationNoteStylesDefs: ()=>annotationNoteStylesDefs,
    annotationOptionsDef: ()=>annotationOptionsDef,
    annotationParallelChannelStyleDefs: ()=>annotationParallelChannelStyleDefs,
    annotationQuickMeasurerStylesDefs: ()=>annotationQuickMeasurerStylesDefs,
    annotationShapeStylesDefs: ()=>annotationShapeStylesDefs,
    annotationTextStylesDef: ()=>annotationTextStylesDef,
    applyShapeFillBBox: ()=>applyShapeFillBBox,
    applyShapeStyle: ()=>applyShapeStyle,
    areScalingEqual: ()=>areScalingEqual,
    area: ()=>area,
    autoSizedLabelOptionsDefs: ()=>autoSizedLabelOptionsDefs,
    bezier2DDistance: ()=>bezier2DDistance,
    bezier2DExtrema: ()=>bezier2DExtrema,
    boxPlotHighlightStyleOptionsDef: ()=>boxPlotHighlightStyleOptionsDef,
    boxPlotSeriesThemeableOptionsDef: ()=>boxPlotSeriesThemeableOptionsDef,
    boxPlotStyleOptionsDef: ()=>boxPlotStyleOptionsDef,
    buildDateFormatter: ()=>buildDateFormatter,
    buildResetPathFn: ()=>buildResetPathFn,
    calculateDataDiff: ()=>calculateDataDiff,
    calculateLabelTranslation: ()=>calculateLabelTranslation,
    calculatePlacement: ()=>calculatePlacement,
    callWithContext: ()=>callWithContext,
    candlestickSeriesThemeableOptionsDef: ()=>candlestickSeriesThemeableOptionsDef,
    cartesianAxisBandHighlightOptions: ()=>cartesianAxisBandHighlightOptions,
    cartesianAxisCrosshairOptions: ()=>cartesianAxisCrosshairOptions,
    cartesianAxisLabelOptionsDefs: ()=>cartesianAxisLabelOptionsDefs,
    cartesianAxisOptionsDefs: ()=>cartesianAxisOptionsDefs,
    cartesianChartOptionsDefs: ()=>cartesianChartOptionsDefs,
    cartesianCrossLineOptionsDefs: ()=>cartesianCrossLineOptionsDefs,
    cartesianNumericAxisLabel: ()=>cartesianNumericAxisLabel,
    cartesianTimeAxisLabel: ()=>cartesianTimeAxisLabel,
    cartesianTimeAxisParentLevel: ()=>cartesianTimeAxisParentLevel,
    checkCrisp: ()=>checkCrisp,
    chordSeriesThemeableOptionsDef: ()=>chordSeriesThemeableOptionsDef,
    clampArray: ()=>clampArray,
    clippedRoundRect: ()=>clippedRoundRect,
    collapsedStartingBarPosition: ()=>collapsedStartingBarPosition,
    commonAxisIntervalOptionsDefs: ()=>commonAxisIntervalOptionsDefs,
    commonAxisLabelOptionsDefs: ()=>commonAxisLabelOptionsDefs,
    commonAxisOptionsDefs: ()=>commonAxisOptionsDefs,
    commonChartOptionsDefs: ()=>commonChartOptionsDefs,
    commonCrossLineLabelOptionsDefs: ()=>commonCrossLineLabelOptionsDefs,
    commonCrossLineOptionsDefs: ()=>commonCrossLineOptionsDefs,
    commonSeriesOptionsDefs: ()=>commonSeriesOptionsDefs,
    commonSeriesThemeableOptionsDefs: ()=>commonSeriesThemeableOptionsDefs,
    compactAggregationIndices: ()=>compactAggregationIndices,
    compareDates: ()=>compareDates,
    computeBarFocusBounds: ()=>computeBarFocusBounds,
    computeMarkerFocusBounds: ()=>computeMarkerFocusBounds,
    coneFunnelSeriesThemeableOptionsDef: ()=>coneFunnelSeriesThemeableOptionsDef,
    continuousAxisOptions: ()=>continuousAxisOptions,
    countExpandingSearch: ()=>countExpandingSearch,
    createAggregationIndices: ()=>createAggregationIndices,
    createButton: ()=>createButton,
    createCheckbox: ()=>createCheckbox,
    createDatumId: ()=>createDatumId,
    createDeprecationWarning: ()=>createDeprecationWarning,
    createIcon: ()=>createIcon,
    createIdsGenerator: ()=>createIdsGenerator,
    createSelect: ()=>createSelect,
    createTextArea: ()=>createTextArea,
    dateToNumber: ()=>dateToNumber,
    dateTruncationForDomain: ()=>dateTruncationForDomain,
    datesSortOrder: ()=>datesSortOrder,
    datumKeys: ()=>datumKeys,
    datumStylerProperties: ()=>datumStylerProperties,
    deconstructSelectionsOrNodes: ()=>deconstructSelectionsOrNodes,
    deepClone: ()=>deepClone,
    deepFreeze: ()=>deepFreeze,
    diff: ()=>diff,
    discreteTimeAxisIntervalOptionsDefs: ()=>discreteTimeAxisIntervalOptionsDefs,
    drawCorner: ()=>drawCorner,
    drawMarkerUnitPolygon: ()=>drawMarkerUnitPolygon,
    durationDay: ()=>durationDay,
    durationHour: ()=>durationHour,
    durationMinute: ()=>durationMinute,
    durationMonth: ()=>durationMonth,
    durationSecond: ()=>durationSecond,
    durationWeek: ()=>durationWeek,
    durationYear: ()=>durationYear,
    easing: ()=>easing_exports,
    enterpriseModule: ()=>enterpriseModule,
    errorBarOptionsDefs: ()=>errorBarOptionsDefs,
    errorBarThemeableOptionsDefs: ()=>errorBarThemeableOptionsDefs,
    estimateTickCount: ()=>estimateTickCount,
    evaluateBezier: ()=>evaluateBezier,
    expandLegendPosition: ()=>expandLegendPosition,
    extent: ()=>extent,
    extractDecoratedProperties: ()=>extractDecoratedProperties,
    fillsOptionsDef: ()=>fillsOptionsDef,
    findMinMax: ()=>findMinMax,
    findQuadtreeMatch: ()=>findQuadtreeMatch,
    findRangeExtent: ()=>findRangeExtent,
    fixNumericExtent: ()=>fixNumericExtent,
    focusCursorAtEnd: ()=>focusCursorAtEnd,
    formatNumber: ()=>formatNumber,
    formatObjectValidator: ()=>formatObjectValidator,
    formatPercent: ()=>formatPercent,
    formatValue: ()=>formatValue,
    fromToMotion: ()=>fromToMotion,
    funnelSeriesThemeableOptionsDef: ()=>funnelSeriesThemeableOptionsDef,
    getAngleRatioRadians: ()=>getAngleRatioRadians,
    getColorStops: ()=>getColorStops,
    getCrossLineValue: ()=>getCrossLineValue,
    getDateTicksForInterval: ()=>getDateTicksForInterval,
    getDatumRefPoint: ()=>getDatumRefPoint,
    getElementBBox: ()=>getElementBBox,
    getIconClassNames: ()=>getIconClassNames,
    getLabelStyles: ()=>getLabelStyles,
    getLastFocus: ()=>getLastFocus,
    getMissCount: ()=>getMissCount,
    getPath: ()=>getPath,
    getPathComponents: ()=>getPathComponents,
    getRadialColumnWidth: ()=>getRadialColumnWidth,
    getSequentialColors: ()=>getSequentialColors,
    getShapeFill: ()=>getShapeFill,
    getShapeStyle: ()=>getShapeStyle,
    groupAccumulativeValueProperty: ()=>groupAccumulativeValueProperty,
    groupAverage: ()=>groupAverage,
    groupCount: ()=>groupCount,
    groupStackValueProperty: ()=>groupStackValueProperty,
    groupSum: ()=>groupSum,
    hasNoModifiers: ()=>hasNoModifiers,
    heatmapSeriesThemeableOptionsDef: ()=>heatmapSeriesThemeableOptionsDef,
    initMenuKeyNav: ()=>initMenuKeyNav,
    initRovingTabIndex: ()=>initRovingTabIndex,
    interpolatePoints: ()=>interpolatePoints,
    interpolationOptionsDefs: ()=>interpolationOptionsDefs,
    intervalCeil: ()=>intervalCeil,
    intervalEpoch: ()=>intervalEpoch,
    intervalExtent: ()=>intervalExtent,
    intervalFloor: ()=>intervalFloor,
    intervalHierarchy: ()=>intervalHierarchy,
    intervalMilliseconds: ()=>intervalMilliseconds,
    intervalNext: ()=>intervalNext,
    intervalPrevious: ()=>intervalPrevious,
    intervalRange: ()=>intervalRange,
    intervalRangeCount: ()=>intervalRangeCount,
    intervalRangeStartIndex: ()=>intervalRangeStartIndex,
    intervalStep: ()=>intervalStep,
    intervalUnit: ()=>intervalUnit,
    isAgStandaloneChartOptions: ()=>isAgStandaloneChartOptions,
    isAgTopologyChartOptions: ()=>isAgTopologyChartOptions,
    isBetweenAngles: ()=>isBetweenAngles,
    isButtonClickEvent: ()=>isButtonClickEvent,
    isChartAxisDirection: ()=>isChartAxisDirection,
    isContinuous: ()=>isContinuous,
    isDecoratedObject: ()=>isDecoratedObject,
    isDenseInterval: ()=>isDenseInterval,
    isGradientFill: ()=>isGradientFill,
    isGradientOrPatternFill: ()=>isGradientOrPatternFill,
    isImageFill: ()=>isImageFill,
    isInputPending: ()=>isInputPending,
    isObjectWithProperty: ()=>isObjectWithProperty,
    isObjectWithStringProperty: ()=>isObjectWithStringProperty,
    isPatternFill: ()=>isPatternFill,
    isProperties: ()=>isProperties,
    isScaleValid: ()=>isScaleValid,
    jsonApply: ()=>jsonApply,
    jsonDiff: ()=>jsonDiff,
    jsonPropertyCompare: ()=>jsonPropertyCompare,
    jsonWalk: ()=>jsonWalk,
    keyProperty: ()=>keyProperty,
    legendSymbolSvg: ()=>legendSymbolSvg,
    lineDistanceSquared: ()=>lineDistanceSquared,
    linearGaugeSeriesOptionsDef: ()=>linearGaugeSeriesOptionsDef,
    linearGaugeSeriesThemeableOptionsDef: ()=>linearGaugeSeriesThemeableOptionsDef,
    linearGaugeTargetOptionsDef: ()=>linearGaugeTargetOptionsDef,
    listDecoratedProperties: ()=>listDecoratedProperties,
    lowestGranularityForInterval: ()=>lowestGranularityForInterval,
    lowestGranularityUnitForTicks: ()=>lowestGranularityUnitForTicks,
    lowestGranularityUnitForValue: ()=>lowestGranularityUnitForValue,
    makeAccessibleClickListener: ()=>makeAccessibleClickListener,
    makeSeriesTooltip: ()=>makeSeriesTooltip,
    mapLineBackgroundSeriesThemeableOptionsDef: ()=>mapLineBackgroundSeriesThemeableOptionsDef,
    mapLineSeriesThemeableOptionsDef: ()=>mapLineSeriesThemeableOptionsDef,
    mapMarkerSeriesThemeableOptionsDef: ()=>mapMarkerSeriesThemeableOptionsDef,
    mapShapeBackgroundSeriesThemeableOptionsDef: ()=>mapShapeBackgroundSeriesThemeableOptionsDef,
    mapShapeSeriesThemeableOptionsDef: ()=>mapShapeSeriesThemeableOptionsDef,
    mapValues: ()=>mapValues,
    markerFadeInAnimation: ()=>markerFadeInAnimation,
    markerOptionsDefs: ()=>markerOptionsDefs,
    markerScaleInAnimation: ()=>markerScaleInAnimation,
    markerSwipeScaleInAnimation: ()=>markerSwipeScaleInAnimation,
    memo: ()=>memo,
    merge: ()=>merge,
    mergeArrayDefaults: ()=>mergeArrayDefaults,
    mergeDefaults: ()=>mergeDefaults,
    midpointStartingBarPosition: ()=>midpointStartingBarPosition,
    minimumTimeAxisDatumGranularity: ()=>minimumTimeAxisDatumGranularity,
    moduleRegistry: ()=>moduleRegistry,
    motion: ()=>motion,
    multiSeriesHighlightStyle: ()=>multiSeriesHighlightStyle,
    nearestSquared: ()=>nearestSquared,
    nearestSquaredInContainer: ()=>nearestSquaredInContainer,
    nextPowerOf2: ()=>nextPowerOf2,
    nightingaleSeriesThemeableOptionsDef: ()=>nightingaleSeriesThemeableOptionsDef,
    normaliseGroupTo: ()=>normaliseGroupTo,
    normalisePropertyTo: ()=>normalisePropertyTo,
    normalisedExtentWithMetadata: ()=>normalisedExtentWithMetadata,
    normalizeAngle180: ()=>normalizeAngle180,
    normalizeAngle360: ()=>normalizeAngle360,
    normalizeAngle360FromDegrees: ()=>normalizeAngle360FromDegrees,
    normalizeAngle360Inclusive: ()=>normalizeAngle360Inclusive,
    normalizeContinuousDomains: ()=>normalizeContinuousDomains,
    numberFormatValidator: ()=>numberFormatValidator,
    objectsEqual: ()=>objectsEqual,
    objectsEqualWith: ()=>objectsEqualWith,
    ohlcSeriesThemeableOptionsDef: ()=>ohlcSeriesThemeableOptionsDef,
    ordinalTimeAxisOptionsDefs: ()=>ordinalTimeAxisOptionsDefs,
    pairUpSpans: ()=>pairUpSpans,
    partialAssign: ()=>partialAssign,
    pathFadeInAnimation: ()=>pathFadeInAnimation,
    pathMotion: ()=>pathMotion,
    pathSwipeInAnimation: ()=>pathSwipeInAnimation,
    pick: ()=>pick,
    pickByMatchingAngle: ()=>pickByMatchingAngle,
    plotAreaPathFill: ()=>plotAreaPathFill,
    plotInterpolatedAreaSeriesFillSpans: ()=>plotInterpolatedAreaSeriesFillSpans,
    plotInterpolatedLinePathStroke: ()=>plotInterpolatedLinePathStroke,
    plotLinePathStroke: ()=>plotLinePathStroke,
    pointsEq: ()=>pointsEq,
    polarChartOptionsDefs: ()=>polarChartOptionsDefs,
    prepareAreaFillAnimationFns: ()=>prepareAreaFillAnimationFns,
    prepareAreaPathAnimation: ()=>prepareAreaPathAnimation,
    prepareAxisAnimationContext: ()=>prepareAxisAnimationContext,
    prepareAxisAnimationFunctions: ()=>prepareAxisAnimationFunctions,
    prepareBarAnimationFunctions: ()=>prepareBarAnimationFunctions,
    prepareLinePathAnimation: ()=>prepareLinePathAnimation,
    prepareLinePathPropertyAnimation: ()=>prepareLinePathPropertyAnimation,
    prepareLinePathStrokeAnimationFns: ()=>prepareLinePathStrokeAnimationFns,
    preparePieSeriesAnimationFunctions: ()=>preparePieSeriesAnimationFunctions,
    previousPowerOf2: ()=>previousPowerOf2,
    processedDataIsAnimatable: ()=>processedDataIsAnimatable,
    pyramidSeriesThemeableOptionsDef: ()=>pyramidSeriesThemeableOptionsDef,
    radarAreaSeriesThemeableOptionsDef: ()=>radarAreaSeriesThemeableOptionsDef,
    radarLineSeriesThemeableOptionsDef: ()=>radarLineSeriesThemeableOptionsDef,
    radialBarSeriesThemeableOptionsDef: ()=>radialBarSeriesThemeableOptionsDef,
    radialColumnSeriesThemeableOptionsDef: ()=>radialColumnSeriesThemeableOptionsDef,
    radialGaugeSeriesOptionsDef: ()=>radialGaugeSeriesOptionsDef,
    radialGaugeSeriesThemeableOptionsDef: ()=>radialGaugeSeriesThemeableOptionsDef,
    radialGaugeTargetOptionsDef: ()=>radialGaugeTargetOptionsDef,
    radiusCategoryAxisOptionsDefs: ()=>radiusCategoryAxisOptionsDefs,
    radiusNumberAxisOptionsDefs: ()=>radiusNumberAxisOptionsDefs,
    range: ()=>range,
    rangeAreaSeriesThemeableOptionsDef: ()=>rangeAreaSeriesThemeableOptionsDef,
    rangeBarSeriesThemeableOptionsDef: ()=>rangeBarSeriesThemeableOptionsDef,
    rangeValidator: ()=>rangeValidator2,
    rangedValueProperty: ()=>rangedValueProperty,
    resetAxisFillSelectionFn: ()=>resetAxisFillSelectionFn,
    resetAxisGroupFn: ()=>resetAxisGroupFn,
    resetAxisLabelSelectionFn: ()=>resetAxisLabelSelectionFn,
    resetAxisLineSelectionFn: ()=>resetAxisLineSelectionFn,
    resetBarSelectionsFn: ()=>resetBarSelectionsFn,
    resetLabelFn: ()=>resetLabelFn,
    resetMarkerFn: ()=>resetMarkerFn,
    resetMarkerPositionFn: ()=>resetMarkerPositionFn,
    resetMotion: ()=>resetMotion,
    resetPieSelectionsFn: ()=>resetPieSelectionsFn,
    rowCountProperty: ()=>rowCountProperty,
    sankeySeriesThemeableOptionsDef: ()=>sankeySeriesThemeableOptionsDef,
    scale: ()=>scale,
    sectorBox: ()=>sectorBox,
    seriesLabelFadeInAnimation: ()=>seriesLabelFadeInAnimation,
    seriesLabelFadeOutAnimation: ()=>seriesLabelFadeOutAnimation,
    seriesLabelOptionsDefs: ()=>seriesLabelOptionsDefs,
    setElementBBox: ()=>setElementBBox,
    setPath: ()=>setPath,
    shadowOptionsDefs: ()=>shadowOptionsDefs,
    shallowClone: ()=>shallowClone,
    simpleMemorize: ()=>simpleMemorize,
    simpleMemorize2: ()=>simpleMemorize2,
    singleSeriesHighlightStyle: ()=>singleSeriesHighlightStyle,
    solveBezier: ()=>solveBezier,
    sortAndUniqueDates: ()=>sortAndUniqueDates,
    splitBezier2D: ()=>splitBezier2D,
    standaloneChartOptionsDefs: ()=>standaloneChartOptionsDefs,
    staticFromToMotion: ()=>staticFromToMotion,
    stopPageScrolling: ()=>stopPageScrolling,
    sum: ()=>sum,
    sumValues: ()=>sumValues,
    sunburstSeriesThemeableOptionsDef: ()=>sunburstSeriesThemeableOptionsDef,
    textOrSegments: ()=>textOrSegments,
    tickFormat: ()=>tickFormat,
    timeInterval: ()=>timeInterval2,
    timeIntervalUnit: ()=>timeIntervalUnit,
    toDegrees: ()=>toDegrees,
    toRadians: ()=>toRadians,
    toolbarButtonOptionsDefs: ()=>toolbarButtonOptionsDefs,
    tooltipContentAriaLabel: ()=>tooltipContentAriaLabel,
    tooltipHtml: ()=>tooltipHtml,
    tooltipOptionsDefs: ()=>tooltipOptionsDefs,
    topologyChartOptionsDefs: ()=>topologyChartOptionsDefs,
    trailingAccumulatedValue: ()=>trailingAccumulatedValue,
    trailingAccumulatedValueProperty: ()=>trailingAccumulatedValueProperty,
    treemapSeriesThemeableOptionsDef: ()=>treemapSeriesThemeableOptionsDef,
    updateClipPath: ()=>updateClipPath,
    updateLabelNode: ()=>updateLabelNode,
    validateCrossLineValue: ()=>validateCrossLineValue,
    valueProperty: ()=>valueProperty,
    visibleRangeIndices: ()=>visibleRangeIndices,
    waterfallSeriesThemeableOptionsDef: ()=>waterfallSeriesThemeableOptionsDef,
    without: ()=>without
});
;
;
function createDeprecationWarning() {
    return (key, message)=>{
        const msg = [
            "Property [".concat(key, "] is deprecated."),
            message
        ].filter(Boolean).join(" ");
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].warnOnce(msg);
    };
}
function Deprecated(message, opts) {
    const warnDeprecated = createDeprecationWarning();
    const def = opts === null || opts === void 0 ? void 0 : opts.default;
    return addTransformToInstanceProperty((_, key, value)=>{
        if (value !== def) {
            warnDeprecated(key.toString(), message);
        }
        return value;
    });
}
function DeprecatedAndRenamedTo(newPropName, mapValue) {
    const warnDeprecated = createDeprecationWarning();
    return addTransformToInstanceProperty((target, key, value)=>{
        if (value !== target[newPropName]) {
            warnDeprecated(key.toString(), "Use [".concat(newPropName, "] instead."));
            setPath(target, newPropName, mapValue ? mapValue(value) : value);
        }
        return BREAK_TRANSFORM_CHAIN;
    }, (target, key)=>{
        warnDeprecated(key.toString(), "Use [".concat(newPropName, "] instead."));
        return getPath(target, newPropName);
    });
}
;
var Vec2 = {
    add,
    angle,
    apply,
    equal,
    distance,
    distanceSquared,
    from: from2,
    gradient,
    intercept,
    intersectAtX,
    intersectAtY,
    length,
    lengthSquared,
    multiply,
    normalized,
    origin: origin2,
    required: required16,
    rotate,
    round: round2,
    sub
};
function add(a, b) {
    if (typeof b === "number") {
        return {
            x: a.x + b,
            y: a.y + b
        };
    }
    return {
        x: a.x + b.x,
        y: a.y + b.y
    };
}
function sub(a, b) {
    if (typeof b === "number") {
        return {
            x: a.x - b,
            y: a.y - b
        };
    }
    return {
        x: a.x - b.x,
        y: a.y - b.y
    };
}
function multiply(a, b) {
    if (typeof b === "number") {
        return {
            x: a.x * b,
            y: a.y * b
        };
    }
    return {
        x: a.x * b.x,
        y: a.y * b.y
    };
}
function length(a) {
    return Math.sqrt(a.x * a.x + a.y * a.y);
}
function lengthSquared(a) {
    return a.x * a.x + a.y * a.y;
}
function distance(a, b) {
    const d = sub(a, b);
    return Math.sqrt(d.x * d.x + d.y * d.y);
}
function distanceSquared(a, b) {
    const d = sub(a, b);
    return d.x * d.x + d.y * d.y;
}
function normalized(a) {
    const l = length(a);
    return {
        x: a.x / l,
        y: a.y / l
    };
}
function angle(a, b) {
    if (b == null) return Math.atan2(a.y, a.x);
    return Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x);
}
function rotate(a, theta) {
    let b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : origin2();
    const l = length(a);
    return {
        x: b.x + l * Math.cos(theta),
        y: b.y + l * Math.sin(theta)
    };
}
function gradient(a, b, reflection) {
    const dx = b.x - a.x;
    const dy = reflection == null ? b.y - a.y : reflection - b.y - (reflection - a.y);
    return dy / dx;
}
function intercept(a, gradient2, reflection) {
    const y = reflection == null ? a.y : reflection - a.y;
    return y - gradient2 * a.x;
}
function intersectAtY(gradient2, coefficient) {
    let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, reflection = arguments.length > 3 ? arguments[3] : void 0;
    return {
        x: gradient2 === Infinity ? Infinity : (y - coefficient) / gradient2,
        y: reflection == null ? y : reflection - y
    };
}
function intersectAtX(gradient2, coefficient) {
    let x = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, reflection = arguments.length > 3 ? arguments[3] : void 0;
    const y = gradient2 === Infinity ? Infinity : gradient2 * x + coefficient;
    return {
        x,
        y: reflection == null ? y : reflection - y
    };
}
function round2(a) {
    let decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    return {
        x: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["roundTo"])(a.x, decimals),
        y: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["roundTo"])(a.y, decimals)
    };
}
function equal(a, b) {
    return a.x === b.x && a.y === b.y;
}
function from2(a, b) {
    if (typeof a === "number") {
        return {
            x: a,
            y: b
        };
    }
    if ("currentX" in a) {
        return {
            x: a.currentX,
            y: a.currentY
        };
    }
    if ("offsetWidth" in a) {
        return {
            x: a.offsetWidth,
            y: a.offsetHeight
        };
    }
    if ("width" in a) {
        return [
            {
                x: a.x,
                y: a.y
            },
            {
                x: a.x + a.width,
                y: a.y + a.height
            }
        ];
    }
    if ("x1" in a) {
        return [
            {
                x: a.x1,
                y: a.y1
            },
            {
                x: a.x2,
                y: a.y2
            }
        ];
    }
    throw new Error("Values can not be converted into a vector: [".concat(JSON.stringify(a), "] [").concat(b, "]"));
}
function apply(a, b) {
    a.x = b.x;
    a.y = b.y;
    return a;
}
function required16(a) {
    var _a_x, _a_y;
    return {
        x: (_a_x = a === null || a === void 0 ? void 0 : a.x) !== null && _a_x !== void 0 ? _a_x : 0,
        y: (_a_y = a === null || a === void 0 ? void 0 : a.y) !== null && _a_y !== void 0 ? _a_y : 0
    };
}
function origin2() {
    return {
        x: 0,
        y: 0
    };
}
;
var _HierarchyNode = class _HierarchyNode {
    get hasChildren() {
        return this.children.length > 0;
    }
    walk(callback8) {
        let order = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _HierarchyNode.Walk.PreOrder;
        if (order === _HierarchyNode.Walk.PreOrder) {
            callback8(this);
        }
        this.children.forEach((child)=>{
            child.walk(callback8, order);
        });
        if (order === _HierarchyNode.Walk.PostOrder) {
            callback8(this);
        }
    }
    *[Symbol.iterator]() {
        yield this;
        for (const child of this.children){
            yield* child;
        }
    }
    constructor(series, datumIndex, datum, sizeValue, colorValue, sumSize, depth, parent, children){
        this.series = series;
        this.datumIndex = datumIndex;
        this.datum = datum;
        this.sizeValue = sizeValue;
        this.colorValue = colorValue;
        this.sumSize = sumSize;
        this.depth = depth;
        this.parent = parent;
        this.children = children;
        this.midPoint = {
            x: 0,
            y: 0
        };
    }
};
_HierarchyNode.Walk = {
    PreOrder: 0,
    PostOrder: 1
};
var HierarchyNode = _HierarchyNode;
var HierarchySeries = class extends Series {
    resetAnimation(phase) {
        if (phase === "initial") {
            this.animationState.transition("reset");
        } else if (phase === "ready") {
            this.animationState.transition("skip");
        }
    }
    processData() {
        const { NodeClass } = this;
        const { childrenKey, sizeKey, colorKey, colorRange } = this.properties;
        let maxDepth = 0;
        let minColor = Infinity;
        let maxColor = -Infinity;
        const createNode = (datum, indexPath, parent)=>{
            const depth = parent.depth != null ? parent.depth + 1 : 0;
            const children = childrenKey != null ? datum[childrenKey] : void 0;
            const isLeaf = children == null || children.length === 0;
            let sizeValue = sizeKey != null ? datum[sizeKey] : void 0;
            if (Number.isFinite(sizeValue)) {
                sizeValue = Math.max(sizeValue, 0);
            } else {
                sizeValue = isLeaf ? 1 : 0;
            }
            const sumSize = sizeValue;
            maxDepth = Math.max(maxDepth, depth);
            const colorValue = colorKey != null ? datum[colorKey] : void 0;
            if (typeof colorValue === "number") {
                minColor = Math.min(minColor, colorValue);
                maxColor = Math.max(maxColor, colorValue);
            }
            return appendChildren(new NodeClass(this, indexPath, datum, sizeValue, colorValue, sumSize, depth, parent, []), children);
        };
        const appendChildren = (node, data)=>{
            const { datumIndex } = node;
            data === null || data === void 0 ? void 0 : data.forEach((datum, childIndex)=>{
                const child = createNode(datum, datumIndex.concat(childIndex), node);
                node.children.push(child);
                node.sumSize += child.sumSize;
            });
            return node;
        };
        const rootNode = appendChildren(new NodeClass(this, [], void 0, 0, void 0, 0, void 0, void 0, []), this.data);
        const colorDomain = [
            minColor,
            maxColor
        ];
        this.colorScale.domain = minColor < maxColor ? [
            minColor,
            maxColor
        ] : [
            0,
            1
        ];
        this.colorScale.range = colorRange !== null && colorRange !== void 0 ? colorRange : [
            "black"
        ];
        this.colorScale.update();
        this.rootNode = rootNode;
        this.maxDepth = maxDepth;
        this.colorDomain = colorDomain;
    }
    update(param) {
        let { seriesRect } = param;
        this.updateSelections();
        this.updateNodes();
        const animationData = this.getAnimationData();
        const resize = this.checkResize(seriesRect);
        if (resize) {
            this.animationState.transition("resize", animationData);
        }
        this.animationState.transition("update", animationData);
    }
    resetAllAnimation(_data) {
        this.ctx.animationManager.stopByAnimationGroupId(this.id);
    }
    animateEmptyUpdateReady(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation(data);
    }
    animateWaitingUpdateReady(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation(data);
    }
    animateReadyHighlight(_data) {}
    animateReadyResize(data) {
        this.resetAllAnimation(data);
    }
    animateClearingUpdateEmpty(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation(data);
    }
    getAnimationData() {
        return {};
    }
    isProcessedDataAnimatable() {
        return true;
    }
    checkProcessedDataAnimatable() {
        if (!this.isProcessedDataAnimatable()) {
            this.ctx.animationManager.skipCurrentBatch();
        }
    }
    dataCount() {
        return NaN;
    }
    getSeriesDomain() {
        return [
            NaN,
            NaN
        ];
    }
    getSeriesRange(_direction, _visibleRange) {
        return [
            NaN,
            NaN
        ];
    }
    getLegendData(legendType) {
        const { colorKey, colorRange } = this.properties;
        const { id: seriesId, ctx: { legendManager }, visible } = this;
        return legendType === "gradient" && colorKey != null && colorRange != null ? [
            {
                legendType: "gradient",
                enabled: visible && legendManager.getItemEnabled({
                    seriesId
                }),
                seriesId,
                series: this.getFormatterContext("color"),
                colorRange,
                colorDomain: this.colorDomain
            }
        ] : [];
    }
    getDatumIdFromData(node) {
        return node.datumIndex.join(":");
    }
    getDatumId(node) {
        return this.getDatumIdFromData(node);
    }
    removeMeIndexPathForIndex(index) {
        var _this_datumSelection_at;
        var _this_datumSelection_at_datum_datumIndex;
        return (_this_datumSelection_at_datum_datumIndex = (_this_datumSelection_at = this.datumSelection.at(index + 1)) === null || _this_datumSelection_at === void 0 ? void 0 : _this_datumSelection_at.datum.datumIndex) !== null && _this_datumSelection_at_datum_datumIndex !== void 0 ? _this_datumSelection_at_datum_datumIndex : [];
    }
    removeMeIndexForIndexPath(indexPath) {
        for (const { index, datum } of this.datumSelection){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["arraysEqual"])(datum.datumIndex, indexPath)) {
                return index - 1;
            }
        }
        return 0;
    }
    pickFocus(opts) {
        var _this_rootNode;
        if (!((_this_rootNode = this.rootNode) === null || _this_rootNode === void 0 ? void 0 : _this_rootNode.children.length)) return void 0;
        const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, opts.datumIndex - opts.datumIndexDelta, this.datumSelection.length - 1);
        const { datumIndexDelta: childDelta, otherIndexDelta: depthDelta } = opts;
        let path = this.removeMeIndexPathForIndex(index);
        const currentNode = path.reduce((n, childIndex)=>n.children[childIndex], this.rootNode);
        if (depthDelta > 0 && currentNode.hasChildren) {
            path = [
                ...path,
                0
            ];
        } else if (depthDelta < 0 && path.length > 1) {
            path = path.slice(0, -1);
        } else if (depthDelta === 0 && childDelta !== 0) {
            const maxIndex = currentNode.parent.children.length - 1;
            path = path.slice();
            path[path.length - 1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, path[path.length - 1] + childDelta, maxIndex);
        }
        const nextNode = path.reduce((n, childIndex)=>n.children[childIndex], this.rootNode);
        const bounds = this.computeFocusBounds(this.datumSelection.at(index + 1));
        if (bounds == null) return;
        return {
            datum: nextNode,
            datumIndex: this.removeMeIndexForIndexPath(path),
            otherIndex: nextNode.depth,
            bounds,
            clipFocusBox: true
        };
    }
    getDatumAriaText(datum, description) {
        if (!(datum instanceof this.NodeClass)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].error("datum is not HierarchyNode: ".concat(JSON.stringify(datum)));
            return;
        }
        var _datum_depth;
        return this.ctx.localeManager.t("ariaAnnounceHierarchyDatum", {
            level: ((_datum_depth = datum.depth) !== null && _datum_depth !== void 0 ? _datum_depth : -1) + 1,
            count: datum.children.length,
            description
        });
    }
    getCategoryValue(_datumIndex) {
        return;
    }
    datumIndexForCategoryValue(_categoryValue) {
        return;
    }
    constructor(moduleCtx){
        super({
            moduleCtx,
            pickModes: [
                1 /* NEAREST_NODE */ ,
                0 /* EXACT_SHAPE_MATCH */ 
            ]
        });
        this.colorDomain = [
            0,
            0
        ];
        this.maxDepth = 0;
        this.colorScale = new ColorScale();
        this.animationState = new StateMachine("empty", {
            empty: {
                update: {
                    target: "ready",
                    action: (data)=>this.animateEmptyUpdateReady(data)
                },
                reset: "empty",
                skip: "ready"
            },
            ready: {
                updateData: "waiting",
                clear: "clearing",
                highlight: (data)=>this.animateReadyHighlight(data),
                resize: (data)=>this.animateReadyResize(data),
                reset: "empty",
                skip: "ready"
            },
            waiting: {
                update: {
                    target: "ready",
                    action: (data)=>this.animateWaitingUpdateReady(data)
                },
                reset: "empty",
                skip: "ready"
            },
            clearing: {
                update: {
                    target: "empty",
                    action: (data)=>this.animateClearingUpdateEmpty(data)
                },
                reset: "empty",
                skip: "ready"
            }
        }, ()=>this.checkProcessedDataAnimatable());
    }
};
// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeriesProperties.ts
var HierarchySeriesProperties = class extends SeriesProperties {
    constructor(){
        super(...arguments);
        this.childrenKey = "children";
        this.fills = Object.values(DEFAULT_FILLS);
        this.fillGradientDefaults = new FillGradientDefaults();
        this.fillPatternDefaults = new FillPatternDefaults();
        this.fillImageDefaults = new FillImageDefaults();
        this.strokes = Object.values(DEFAULT_STROKES);
    }
};
__decorateClass([
    Property
], HierarchySeriesProperties.prototype, "childrenKey", 2);
__decorateClass([
    Property
], HierarchySeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
    Property
], HierarchySeriesProperties.prototype, "colorKey", 2);
__decorateClass([
    Property
], HierarchySeriesProperties.prototype, "colorName", 2);
__decorateClass([
    Property
], HierarchySeriesProperties.prototype, "fills", 2);
__decorateClass([
    Property
], HierarchySeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
    Property
], HierarchySeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
    Property
], HierarchySeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
    Property
], HierarchySeriesProperties.prototype, "strokes", 2);
__decorateClass([
    Property
], HierarchySeriesProperties.prototype, "colorRange", 2);
// packages/ag-charts-community/src/chart/series/topology/lonLatBbox.ts
var LonLatBBox = class _LonLatBBox {
    extend(lon0, lat0, lon1, lat1) {
        this.lon0 = Math.min(this.lon0, lon0);
        this.lat0 = Math.min(this.lat0, lat0);
        this.lon1 = Math.max(this.lon1, lon1);
        this.lat1 = Math.max(this.lat1, lat1);
        return this;
    }
    merge(other) {
        return this.extend(other.lon0, other.lat0, other.lon1, other.lat1);
    }
    static extend(into, lon0, lat0, lon1, lat1) {
        return into ? into.extend(lon0, lat0, lon1, lat1) : new _LonLatBBox(lon0, lat0, lon1, lat1);
    }
    constructor(lon0, lat0, lon1, lat1){
        this.lon0 = lon0;
        this.lat0 = lat0;
        this.lon1 = lon1;
        this.lat1 = lat1;
    }
};
// packages/ag-charts-community/src/chart/series/topology/mercatorScale.ts
var radsInDeg = Math.PI / 180;
var lonX = (lon)=>lon * radsInDeg;
var latY = (lat)=>-Math.log(Math.tan(Math.PI * 0.25 + lat * radsInDeg * 0.5));
var xLon = (x)=>x / radsInDeg;
var yLat = (y)=>(Math.atan(Math.exp(-y)) - Math.PI * 0.25) / (radsInDeg * 0.5);
var MercatorScale = class _MercatorScale extends AbstractScale {
    static bounds(domain) {
        const [[lon0, lat0], [lon1, lat1]] = domain;
        const x0 = lonX(lon0);
        const y0 = latY(lat0);
        const x1 = lonX(lon1);
        const y1 = latY(lat1);
        return new BBox(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1 - x0), Math.abs(y1 - y0));
    }
    static fixedScale() {
        return new _MercatorScale([
            [
                xLon(0),
                yLat(0)
            ],
            [
                xLon(1),
                yLat(1)
            ]
        ], [
            [
                0,
                0
            ],
            [
                1,
                1
            ]
        ]);
    }
    toDomain() {
        return;
    }
    normalizeDomains() {
        for(var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++){
            domains[_key] = arguments[_key];
        }
        let x0 = -Infinity;
        let x1 = Infinity;
        let y0 = -Infinity;
        let y1 = Infinity;
        for (const domain of domains){
            for (const [x, y] of domain){
                x0 = Math.min(x, x0);
                x1 = Math.max(x, x1);
                y0 = Math.min(y, y0);
                y1 = Math.max(y, y1);
            }
        }
        return {
            domain: [
                [
                    x0,
                    y0
                ],
                [
                    x1,
                    y1
                ]
            ],
            animatable: true
        };
    }
    convert(param) {
        let [lon, lat] = param;
        const [[x0, y0], [x1, y1]] = this.range;
        const xScale = (x1 - x0) / this.bounds.width;
        const yScale = (y1 - y0) / this.bounds.height;
        return [
            (lonX(lon) - this.bounds.x) * xScale + x0,
            (latY(lat) - this.bounds.y) * yScale + y0
        ];
    }
    invert(param) {
        let [x, y] = param;
        const [[x0, y0], [x1, y1]] = this.range;
        const xScale = (x1 - x0) / this.bounds.width;
        const yScale = (y1 - y0) / this.bounds.height;
        return [
            xLon((x - x0) / xScale + this.bounds.x),
            yLat((y - y0) / yScale + this.bounds.y)
        ];
    }
    constructor(domain, range3){
        super();
        this.domain = domain;
        this.range = range3;
        this.type = "mercator";
        this.defaultTickCount = 0;
        this.bounds = _MercatorScale.bounds(domain);
    }
};
// packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts
var horizontalCrosslineTranslationDirections = {
    top: {
        xTranslationDirection: 0,
        yTranslationDirection: -1
    },
    bottom: {
        xTranslationDirection: 0,
        yTranslationDirection: 1
    },
    left: {
        xTranslationDirection: -1,
        yTranslationDirection: 0
    },
    right: {
        xTranslationDirection: 1,
        yTranslationDirection: 0
    },
    "top-left": {
        xTranslationDirection: 1,
        yTranslationDirection: -1
    },
    "top-right": {
        xTranslationDirection: -1,
        yTranslationDirection: -1
    },
    "bottom-left": {
        xTranslationDirection: 1,
        yTranslationDirection: 1
    },
    "bottom-right": {
        xTranslationDirection: -1,
        yTranslationDirection: 1
    },
    inside: {
        xTranslationDirection: 0,
        yTranslationDirection: 0
    },
    "inside-left": {
        xTranslationDirection: 1,
        yTranslationDirection: 0
    },
    "inside-right": {
        xTranslationDirection: -1,
        yTranslationDirection: 0
    },
    "inside-top": {
        xTranslationDirection: 0,
        yTranslationDirection: 1
    },
    "inside-bottom": {
        xTranslationDirection: 0,
        yTranslationDirection: -1
    },
    "inside-top-left": {
        xTranslationDirection: 1,
        yTranslationDirection: 1
    },
    "inside-bottom-left": {
        xTranslationDirection: 1,
        yTranslationDirection: -1
    },
    "inside-top-right": {
        xTranslationDirection: -1,
        yTranslationDirection: 1
    },
    "inside-bottom-right": {
        xTranslationDirection: -1,
        yTranslationDirection: -1
    }
};
var verticalCrossLineTranslationDirections = {
    top: {
        xTranslationDirection: 1,
        yTranslationDirection: 0
    },
    bottom: {
        xTranslationDirection: -1,
        yTranslationDirection: 0
    },
    left: {
        xTranslationDirection: 0,
        yTranslationDirection: -1
    },
    right: {
        xTranslationDirection: 0,
        yTranslationDirection: 1
    },
    "top-left": {
        xTranslationDirection: -1,
        yTranslationDirection: -1
    },
    "top-right": {
        xTranslationDirection: -1,
        yTranslationDirection: 1
    },
    "bottom-left": {
        xTranslationDirection: 1,
        yTranslationDirection: -1
    },
    "bottom-right": {
        xTranslationDirection: 1,
        yTranslationDirection: 1
    },
    inside: {
        xTranslationDirection: 0,
        yTranslationDirection: 0
    },
    "inside-left": {
        xTranslationDirection: 0,
        yTranslationDirection: 1
    },
    "inside-right": {
        xTranslationDirection: 0,
        yTranslationDirection: -1
    },
    "inside-top": {
        xTranslationDirection: -1,
        yTranslationDirection: 0
    },
    "inside-bottom": {
        xTranslationDirection: 1,
        yTranslationDirection: 0
    },
    "inside-top-left": {
        xTranslationDirection: -1,
        yTranslationDirection: 1
    },
    "inside-bottom-left": {
        xTranslationDirection: 1,
        yTranslationDirection: 1
    },
    "inside-top-right": {
        xTranslationDirection: -1,
        yTranslationDirection: -1
    },
    "inside-bottom-right": {
        xTranslationDirection: 1,
        yTranslationDirection: -1
    }
};
function calculateLabelTranslation(param) {
    let { yDirection, padding: padding2 = 0, position = "top", bbox } = param;
    const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;
    const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];
    const xTranslation = xTranslationDirection * (padding2 + bbox.width / 2);
    const yTranslation = yTranslationDirection * (padding2 + bbox.height / 2);
    return {
        xTranslation,
        yTranslation
    };
}
;
function createButton(options, attrs) {
    const button = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("button", getClassName("ag-charts-input ag-charts-button", attrs));
    if (options.label !== void 0) {
        button.append(options.label);
    } else {
        button.append(createIcon(options.icon));
        button.ariaLabel = options.altText;
    }
    button.addEventListener("click", options.onPress);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttributes"])(button, attrs);
    return button;
}
function createCheckbox(options, attrs) {
    const checkbox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("input", getClassName("ag-charts-input ag-charts-checkbox", attrs));
    checkbox.type = "checkbox";
    checkbox.checked = options.checked;
    checkbox.addEventListener("change", (event)=>options.onChange(checkbox.checked, event));
    checkbox.addEventListener("keydown", (event)=>{
        if (isButtonClickEvent(event)) {
            event.preventDefault();
            checkbox.click();
        }
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttributes"])(checkbox, attrs);
    return checkbox;
}
function createSelect(options, attrs) {
    const select = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("select", getClassName("ag-charts-input ag-charts-select", attrs));
    select.append(...options.options.map((option)=>{
        const optionEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("option");
        optionEl.value = option.value;
        optionEl.textContent = option.label;
        return optionEl;
    }));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(select, "data-preventdefault", false);
    select.value = options.value;
    select.addEventListener("change", (event)=>options.onChange(select.value, event));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttributes"])(select, attrs);
    return select;
}
function createTextArea(options, attrs) {
    const textArea = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("textarea", getClassName("ag-charts-input ag-charts-textarea", attrs));
    textArea.value = options.value;
    textArea.addEventListener("input", (event)=>options.onChange(textArea.value, event));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttributes"])(textArea, attrs);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(textArea, "data-preventdefault", false);
    return textArea;
}
function createIcon(icon) {
    const el = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("span", "ag-charts-icon ag-charts-icon-".concat(icon));
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(el, "aria-hidden", true);
    return el;
}
function getClassName(baseClass, attrs) {
    if (attrs == null) return baseClass;
    return "".concat(baseClass, " ").concat(attrs.class);
}
// packages/ag-charts-community/src/scene/shape/svgPath.ts
var SvgPath = class extends Path {
    get d() {
        return this._d;
    }
    set d(d) {
        if (d === this._d) return;
        this._d = d;
        this.path.clear();
        this.path.appendSvg(d);
        this.checkPathDirty();
    }
    constructor(d = ""){
        super();
        this._d = "";
        this.d = d;
    }
};
var TranslatableSvgPath = class extends Translatable(SvgPath) {
    isPointInPath(x, y) {
        return super.isPointInPath(x - this.translationX, y - this.translationY);
    }
};
// packages/ag-charts-community/src/scene/image.ts
var Image3 = class extends Node2 {
    render(renderCtx) {
        const { ctx } = renderCtx;
        const image = this.sourceImage;
        if (image) {
            ctx.globalAlpha = this.opacity;
            ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);
        }
        super.render(renderCtx);
    }
    constructor(sourceImage){
        super();
        this.sourceImage = sourceImage;
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
        this.opacity = 1;
    }
};
__decorateClass([
    SceneChangeDetection()
], Image3.prototype, "x", 2);
__decorateClass([
    SceneChangeDetection()
], Image3.prototype, "y", 2);
__decorateClass([
    SceneChangeDetection()
], Image3.prototype, "width", 2);
__decorateClass([
    SceneChangeDetection()
], Image3.prototype, "height", 2);
__decorateClass([
    SceneChangeDetection()
], Image3.prototype, "opacity", 2);
// packages/ag-charts-community/src/widget/exports.ts
var exports_exports = {};
__export(exports_exports, {
    ButtonWidget: ()=>ButtonWidget,
    MenuItemWidget: ()=>MenuItemWidget,
    MenuWidget: ()=>MenuWidget,
    NativeWidget: ()=>NativeWidget,
    SliderWidget: ()=>SliderWidget,
    ToolbarWidget: ()=>ToolbarWidget,
    WIDGET_HTML_EVENTS: ()=>WIDGET_HTML_EVENTS,
    Widget: ()=>Widget,
    WidgetEventUtil: ()=>WidgetEventUtil
});
;
;
var MenuItemWidget = class extends AbstractButtonWidget {
    constructor(){
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div"), "menuitem");
    }
};
// packages/ag-charts-community/src/widget/menuWidget.ts
var closeKeys = [
    "Escape",
    "ArrowLeft"
];
var MenuWidget = class _MenuWidget extends RovingTabContainerWidget {
    destructor() {
        this.selfClose("2" /* DESTROY */ );
    }
    addSeparator() {
        const sep = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])().createElement("div");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(sep, "role", "separator");
        this.elem.appendChild(sep);
        return sep;
    }
    onChildAdded(child) {
        super.onChildAdded(child);
        if (!child.hasPopup()) {
            child.addListener("mouseenter", this.closeSubMenu);
        }
    }
    onChildRemoved(child) {
        super.onChildRemoved(child);
        if (!child.hasPopup()) {
            child.removeListener("mouseenter", this.closeSubMenu);
        }
    }
    addSubMenu() {
        const subMenuButton = new MenuItemWidget();
        const subMenuId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementId"])();
        const subMenu = new _MenuWidget(this.orientation);
        const accessibleOpener = (ev)=>{
            if (!subMenuButton.isDisabled()) {
                this.openSubMenu(ev, subMenu);
            }
        };
        const arrowRightOpener = (ev)=>{
            if (hasNoModifiers(ev.sourceEvent) && ev.sourceEvent.code === "ArrowRight") {
                accessibleOpener(ev);
            }
        };
        subMenuButton.setAriaHasPopup("menu");
        subMenuButton.setAriaExpanded(false);
        subMenuButton.setAriaControls(subMenuId);
        subMenuButton.addListener("click", accessibleOpener);
        subMenuButton.addListener("mouseenter", accessibleOpener);
        subMenuButton.addListener("keydown", arrowRightOpener);
        subMenu.addListener("close-widget", ()=>subMenuButton.setAriaExpanded(false));
        subMenu.addListener("open-widget", ()=>subMenuButton.setAriaExpanded(true));
        subMenu.id = subMenuId;
        this.addChild(subMenuButton);
        return {
            subMenuButton,
            subMenu
        };
    }
    openSubMenu(ev, subMenu) {
        var _openScope_openSubMenu;
        const { openScope } = this;
        if (!openScope) return;
        (_openScope_openSubMenu = openScope.openSubMenu) === null || _openScope_openSubMenu === void 0 ? void 0 : _openScope_openSubMenu.selfClose("4" /* SIDLING_OPENED */ );
        subMenu === null || subMenu === void 0 ? void 0 : subMenu.open(ev);
        openScope.openSubMenu = subMenu;
    }
    open(event, opts) {
        var _this_internalListener, _this_children_;
        if (this.openScope != null) return;
        this.openScope = {
            lastFocus: getLastFocus(event.sourceEvent),
            openSubMenu: void 0,
            abort: ()=>this.selfClose("1" /* ABORT */ ),
            close: ()=>this.selfClose("0" /* CLOSE */ ),
            removers: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanupRegistry"]()
        };
        const scope = this.openScope;
        const buttons = this.children.map((value)=>value.getElement());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(scope.lastFocus, "aria-expanded", true);
        scope.removers.register(addMouseCloseListener(this.elem, scope.abort), addTouchCloseListener(this.elem, scope.abort), ...this.children.map((child)=>addEscapeEventListener(child.getElement(), scope.close, closeKeys)), (opts === null || opts === void 0 ? void 0 : opts.overrideFocusVisible) && addOverrideFocusVisibleEventListener(this.elem, buttons, opts.overrideFocusVisible));
        (_this_internalListener = this.internalListener) === null || _this_internalListener === void 0 ? void 0 : _this_internalListener.dispatch("open-widget", this, {
            type: "open-widget"
        });
        (_this_children_ = this.children[0]) === null || _this_children_ === void 0 ? void 0 : _this_children_.focus({
            preventScroll: true
        });
    }
    selfClose(mode) {
        var _this_internalListener;
        if (this.openScope === void 0) return;
        const { lastFocus, removers, openSubMenu } = this.openScope;
        this.openScope = void 0;
        openSubMenu === null || openSubMenu === void 0 ? void 0 : openSubMenu.selfClose("3" /* PARENT_CLOSED */ );
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(lastFocus, "aria-expanded", false);
        if (mode === "0" /* CLOSE */ ) {
            lastFocus === null || lastFocus === void 0 ? void 0 : lastFocus.focus({
                preventScroll: true
            });
        }
        removers.flush();
        (_this_internalListener = this.internalListener) === null || _this_internalListener === void 0 ? void 0 : _this_internalListener.dispatch("close-widget", this, {
            type: "close-widget"
        });
    }
    close() {
        this.selfClose("0" /* CLOSE */ );
    }
    constructor(orientation = "vertical"){
        super(orientation, "menu");
        this.closeSubMenu = (ev)=>this.openSubMenu(ev, void 0);
    }
};
;
;
;
var canvasOverlay = "canvas-overlay";
var Popover = class extends BaseModuleInstance {
    attachTo(popover) {
        if (this.element.parentElement) return;
        popover.element.append(this.element);
    }
    hide(opts) {
        const { lastFocus = this.lastFocus } = opts !== null && opts !== void 0 ? opts : {};
        if (this.element.children.length === 0) return;
        this.hideFns.forEach((fn)=>fn());
        lastFocus === null || lastFocus === void 0 ? void 0 : lastFocus.focus();
        this.lastFocus = void 0;
    }
    removeChildren() {
        this.element.replaceChildren();
    }
    showWithChildren(children, options) {
        if (!this.element.parentElement) {
            throw new Error("Can not show popover that has not been attached to a parent.");
        }
        const popover = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div", "ag-charts-popover");
        if (options.ariaLabel != null) {
            popover.setAttribute("aria-label", options.ariaLabel);
        }
        if (options.class != null) {
            popover.classList.add(options.class);
        }
        popover.replaceChildren(...children);
        this.element.replaceChildren(popover);
        this.hideFns.push(()=>this.removeChildren());
        if (options.onHide) {
            this.hideFns.push(options.onHide);
        }
        if (options.initialFocus && options.sourceEvent) {
            const lastFocus = getLastFocus(options.sourceEvent);
            if (lastFocus !== void 0) {
                this.lastFocus = lastFocus;
                this.initialFocus = options.initialFocus;
            }
        }
        return popover;
    }
    getPopoverElement() {
        return this.element.firstElementChild;
    }
    updatePosition(position) {
        var _this_initialFocus;
        const popover = this.getPopoverElement();
        if (!popover) return;
        popover.style.setProperty("right", "unset");
        popover.style.setProperty("bottom", "unset");
        if (position.x != null) popover.style.setProperty("left", "".concat(Math.floor(position.x), "px"));
        if (position.y != null) popover.style.setProperty("top", "".concat(Math.floor(position.y), "px"));
        (_this_initialFocus = this.initialFocus) === null || _this_initialFocus === void 0 ? void 0 : _this_initialFocus.focus();
        this.initialFocus = void 0;
    }
    constructor(ctx, id, options){
        super();
        this.ctx = ctx;
        this.hideFns = [];
        this.moduleId = "popover-".concat(id);
        if (options === null || options === void 0 ? void 0 : options.detached) {
            this.element = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div");
        } else {
            this.element = ctx.domManager.addChild(canvasOverlay, this.moduleId);
        }
        this.element.setAttribute("role", "presentation");
        this.cleanup.register(()=>ctx.domManager.removeChild(canvasOverlay, this.moduleId));
    }
};
// packages/ag-charts-community/src/components/popover/anchoredPopover.ts
var AnchoredPopover = class extends Popover {
    setAnchor(anchor, fallbackAnchor) {
        this.anchor = anchor;
        this.fallbackAnchor = fallbackAnchor;
        this.updatePosition(anchor);
        this.repositionWithinBounds();
    }
    showWithChildren(children, options) {
        var _options_anchor;
        const anchor = (_options_anchor = options.anchor) !== null && _options_anchor !== void 0 ? _options_anchor : this.anchor;
        var _options_fallbackAnchor;
        const fallbackAnchor = (_options_fallbackAnchor = options.fallbackAnchor) !== null && _options_fallbackAnchor !== void 0 ? _options_fallbackAnchor : this.fallbackAnchor;
        const popover = super.showWithChildren(children, options);
        if (anchor) {
            this.setAnchor(anchor, fallbackAnchor);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])().requestAnimationFrame(()=>{
            this.repositionWithinBounds();
        });
        return popover;
    }
    repositionWithinBounds() {
        const { anchor, ctx, fallbackAnchor } = this;
        const popover = this.getPopoverElement();
        if (!anchor || !popover) return;
        const canvasRect = ctx.domManager.getBoundingClientRect();
        const { offsetWidth: width2, offsetHeight: height2 } = popover;
        let x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, anchor.x, canvasRect.width - width2);
        let y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, anchor.y, canvasRect.height - height2);
        if (x !== anchor.x && (fallbackAnchor === null || fallbackAnchor === void 0 ? void 0 : fallbackAnchor.x) != null) {
            x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, fallbackAnchor.x - width2, canvasRect.width - width2);
        }
        if (y !== anchor.y && (fallbackAnchor === null || fallbackAnchor === void 0 ? void 0 : fallbackAnchor.y) != null) {
            y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, fallbackAnchor.y - height2, canvasRect.height - height2);
        }
        this.updatePosition({
            x,
            y
        });
    }
};
// packages/ag-charts-community/src/components/menu/menu.ts
var Menu = class extends AnchoredPopover {
    show(options) {
        const rows = options.items.map((item)=>this.createRow(options, item));
        const popover = this.showWithChildren(rows, options);
        popover.classList.add("ag-charts-menu");
        popover.setAttribute("role", "menu");
        this.menuCloser = initMenuKeyNav({
            orientation: "vertical",
            menu: popover,
            buttons: rows,
            sourceEvent: options.sourceEvent,
            closeCallback: ()=>this.hide()
        });
        this.hideFns.push(()=>{
            var _this_menuCloser;
            (_this_menuCloser = this.menuCloser) === null || _this_menuCloser === void 0 ? void 0 : _this_menuCloser.finishClosing();
            this.menuCloser = void 0;
        });
    }
    createRow(options, item) {
        const { menuItemRole = "menuitem" } = options;
        const active = item.value === options.value;
        const row = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div", "ag-charts-menu__row");
        row.setAttribute("role", menuItemRole);
        if (menuItemRole === "menuitemradio") {
            row.setAttribute("aria-checked", (options.value === item.value).toString());
        }
        if (typeof item.value === "string") {
            row.dataset.popoverId = item.value;
        }
        row.classList.toggle("ag-charts-menu__row--active", active);
        if (item.icon != null) {
            const icon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("span", "ag-charts-menu__icon ".concat(getIconClassNames(item.icon)));
            row.appendChild(icon);
        }
        const strokeWidthVisible = item.strokeWidth != null;
        if (strokeWidthVisible) {
            row.classList.toggle("ag-charts-menu__row--stroke-width-visible", strokeWidthVisible);
            row.style.setProperty("--strokeWidth", strokeWidthVisible ? "".concat(item.strokeWidth, "px") : null);
        }
        if (item.label != null) {
            const label = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("span", "ag-charts-menu__label");
            label.textContent = this.ctx.localeManager.t(item.label);
            row.appendChild(label);
        }
        if ("altText" in item) {
            row.ariaLabel = this.ctx.localeManager.t(item.altText);
        }
        const select = ()=>{
            var _options_onPress;
            (_options_onPress = options.onPress) === null || _options_onPress === void 0 ? void 0 : _options_onPress.call(options, item);
        };
        const onclick = (e)=>{
            if (isButtonClickEvent(e)) {
                select();
                e.preventDefault();
                e.stopPropagation();
            }
        };
        row.addEventListener("keydown", onclick);
        row.addEventListener("click", onclick);
        row.addEventListener("mousemove", ()=>{
            row.focus({
                preventScroll: true
            });
        });
        return row;
    }
};
// packages/ag-charts-community/src/components/popover/draggablePopover.ts
var DraggablePopover = class extends Popover {
    setDragHandle(dragHandle) {
        dragHandle.addListener("drag-start", (event)=>{
            dragHandle.addClass(this.dragHandleDraggingClass);
            this.onDragStart(event);
        });
        dragHandle.addListener("drag-move", this.onDragMove.bind(this));
        dragHandle.addListener("drag-end", ()=>{
            dragHandle.removeClass(this.dragHandleDraggingClass);
            this.onDragEnd.bind(this);
        });
    }
    onDragStart(event) {
        const popover = this.getPopoverElement();
        if (!popover) return;
        event.sourceEvent.preventDefault();
        this.dragged = true;
        this.dragStartState = {
            client: Vec2.from(event.clientX, event.clientY),
            position: Vec2.from(Number(popover.style.getPropertyValue("left").replace("px", "")), Number(popover.style.getPropertyValue("top").replace("px", "")))
        };
    }
    onDragMove(event) {
        const { dragStartState } = this;
        const popover = this.getPopoverElement();
        if (!dragStartState || !popover) return;
        const offset = Vec2.sub(Vec2.from(event.clientX, event.clientY), dragStartState.client);
        const position = Vec2.add(dragStartState.position, offset);
        const bounds = this.ctx.domManager.getBoundingClientRect();
        const partialPosition = {};
        if (position.x >= 0 && position.x + popover.offsetWidth <= bounds.width) {
            partialPosition.x = position.x;
        }
        if (position.y >= 0 && position.y + popover.offsetHeight <= bounds.height) {
            partialPosition.y = position.y;
        }
        this.updatePosition(partialPosition);
    }
    onDragEnd() {
        this.dragStartState = void 0;
    }
    constructor(){
        super(...arguments);
        this.dragged = false;
    }
};
// packages/ag-charts-community/src/components/toolbar/toolbarButtonProperties.ts
var ToolbarButtonProperties = class extends BaseProperties {
};
__decorateClass([
    Property
], ToolbarButtonProperties.prototype, "icon", 2);
__decorateClass([
    Property
], ToolbarButtonProperties.prototype, "label", 2);
__decorateClass([
    Property
], ToolbarButtonProperties.prototype, "ariaLabel", 2);
__decorateClass([
    Property
], ToolbarButtonProperties.prototype, "tooltip", 2);
;
var ToolbarButtonWidget = class extends ButtonWidget {
    update(options) {
        const { localeManager } = this;
        if (options.tooltip) {
            this.elem.title = localeManager.t(options.tooltip);
        }
        let innerHTML = "";
        if (options.icon != null) {
            innerHTML = '<span class="'.concat(getIconClassNames(options.icon), ' ag-charts-toolbar__icon"></span>');
        }
        if (options.label != null) {
            const label = localeManager.t(options.label);
            innerHTML = "".concat(innerHTML, '<span class="ag-charts-toolbar__label">').concat(label, "</span>");
        }
        this.elem.innerHTML = innerHTML;
    }
    setChecked(checked) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setAttribute"])(this.elem, "aria-checked", checked);
    }
    constructor(localeManager){
        super();
        this.localeManager = localeManager;
    }
};
// packages/ag-charts-community/src/components/toolbar/toolbar.ts
var BUTTON_ACTIVE_CLASS = "ag-charts-toolbar__button--active";
var BaseToolbar = class extends ToolbarWidget {
    setAriaLabelId(ariaLabelId) {
        this.ariaLabelId = ariaLabelId;
        this.updateAriaLabel();
    }
    addToolbarListener(eventType, handler) {
        return this.events.addListener(eventType, handler);
    }
    clearButtons() {
        for (const button of this.buttonWidgets){
            button.destroy();
        }
        this.buttonWidgets.splice(0);
    }
    updateButtons(buttons) {
        const { buttonWidgets } = this;
        for (const [index, button] of buttons.entries()){
            var _this_buttonWidgets_at;
            const buttonWidget = (_this_buttonWidgets_at = this.buttonWidgets.at(index)) !== null && _this_buttonWidgets_at !== void 0 ? _this_buttonWidgets_at : this.createButton(index, button);
            buttonWidget.update(button);
        }
        for(let index = buttons.length; index < buttonWidgets.length; index++){
            const button = this.buttonWidgets.at(index);
            button === null || button === void 0 ? void 0 : button.destroy();
        }
        this.buttonWidgets.splice(buttons.length);
        this.refreshButtonClasses();
    }
    updateButtonByIndex(index, button) {
        var _this_buttonWidgets_at;
        (_this_buttonWidgets_at = this.buttonWidgets.at(index)) === null || _this_buttonWidgets_at === void 0 ? void 0 : _this_buttonWidgets_at.update(button);
    }
    clearActiveButton() {
        for (const button of this.buttonWidgets){
            button.toggleClass(BUTTON_ACTIVE_CLASS, false);
        }
    }
    toggleActiveButtonByIndex(index) {
        if (index === -1) return;
        for (const [buttonIndex, button] of this.buttonWidgets.entries()){
            button.toggleClass(BUTTON_ACTIVE_CLASS, index != null && index === buttonIndex);
        }
    }
    toggleButtonEnabledByIndex(index, enabled) {
        var _this_buttonWidgets_at;
        if (index === -1) return;
        (_this_buttonWidgets_at = this.buttonWidgets.at(index)) === null || _this_buttonWidgets_at === void 0 ? void 0 : _this_buttonWidgets_at.setEnabled(enabled);
    }
    toggleSwitchCheckedByIndex(index, checked) {
        var _this_buttonWidgets_at;
        if (index === -1) return;
        (_this_buttonWidgets_at = this.buttonWidgets.at(index)) === null || _this_buttonWidgets_at === void 0 ? void 0 : _this_buttonWidgets_at.setChecked(checked);
    }
    getButtonBounds() {
        return this.buttonWidgets.map((buttonWidget)=>this.getButtonWidgetBounds(buttonWidget));
    }
    setButtonHiddenByIndex(index, hidden) {
        var _this_buttonWidgets_at;
        (_this_buttonWidgets_at = this.buttonWidgets.at(index)) === null || _this_buttonWidgets_at === void 0 ? void 0 : _this_buttonWidgets_at.setHidden(hidden);
    }
    getButtonWidgetBounds(buttonWidget) {
        const parent = this.getBounds();
        const bounds = buttonWidget.getBounds();
        return new BBox(bounds.x + parent.x, bounds.y + parent.y, bounds.width, bounds.height);
    }
    refreshButtonClasses() {
        const { buttonWidgets, hasPrefix } = this;
        let first2;
        let last;
        let section;
        for (const [index, buttonWidget] of buttonWidgets.entries()){
            var _buttonWidgets_at;
            first2 = !hasPrefix && index === 0 || section != buttonWidget.section;
            last = index === buttonWidgets.length - 1 || buttonWidget.section != ((_buttonWidgets_at = buttonWidgets.at(index + 1)) === null || _buttonWidgets_at === void 0 ? void 0 : _buttonWidgets_at.section);
            buttonWidget.toggleClass("ag-charts-toolbar__button--first", first2);
            buttonWidget.toggleClass("ag-charts-toolbar__button--last", last);
            buttonWidget.toggleClass("ag-charts-toolbar__button--gap", index > 0 && first2);
            section = buttonWidget.section;
        }
    }
    createButton(index, button) {
        const buttonWidget = this.createButtonWidget();
        buttonWidget.addClass("ag-charts-toolbar__button");
        buttonWidget.addListener("click", (event)=>{
            const buttonOptions = {
                index,
                ...button instanceof BaseProperties ? button.toJson() : button
            };
            const buttonBounds = this.getButtonWidgetBounds(buttonWidget);
            this.events.dispatch("button-pressed", {
                event,
                button: buttonOptions,
                buttonBounds
            });
        });
        buttonWidget.addListener("focus", ()=>{
            this.events.dispatch("button-focused", {
                button: {
                    index
                }
            });
        });
        if (button.section) {
            buttonWidget.section = button.section;
        }
        this.buttonWidgets.push(buttonWidget);
        this.addChild(buttonWidget);
        return buttonWidget;
    }
    constructor({ eventsHub, localeManager }, ariaLabelId, orientation){
        super(orientation);
        this.ariaLabelId = ariaLabelId;
        this.horizontalSpacing = 10;
        this.verticalSpacing = 10;
        this.events = new Listeners();
        this.hasPrefix = false;
        this.buttonWidgets = [];
        this.updateAriaLabel = ()=>this.setAriaLabel(this.localeManager.t(this.ariaLabelId));
        this.eventsHub = eventsHub;
        this.localeManager = localeManager;
        this.addClass("ag-charts-toolbar");
        this.toggleClass("ag-charts-toolbar--horizontal", orientation === "horizontal");
        this.toggleClass("ag-charts-toolbar--vertical", orientation === "vertical");
        this.eventsHub.on("locale:change", this.updateAriaLabel);
        this.updateAriaLabel();
    }
};
var Toolbar = class extends BaseToolbar {
    createButtonWidget() {
        return new ToolbarButtonWidget(this.localeManager);
    }
};
;
var FloatingToolbarPopover = class extends DraggablePopover {
    show(children) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.showWithChildren(children, {
            ...options,
            class: "ag-charts-floating-toolbar"
        });
    }
    hide() {
        this.dragged = false;
        super.hide();
    }
    getBounds() {
        const element2 = this.getPopoverElement();
        var _element2_offsetLeft, _element2_offsetTop, _element2_offsetWidth, _element2_offsetHeight;
        return new BBox((_element2_offsetLeft = element2 === null || element2 === void 0 ? void 0 : element2.offsetLeft) !== null && _element2_offsetLeft !== void 0 ? _element2_offsetLeft : 0, (_element2_offsetTop = element2 === null || element2 === void 0 ? void 0 : element2.offsetTop) !== null && _element2_offsetTop !== void 0 ? _element2_offsetTop : 0, (_element2_offsetWidth = element2 === null || element2 === void 0 ? void 0 : element2.offsetWidth) !== null && _element2_offsetWidth !== void 0 ? _element2_offsetWidth : 0, (_element2_offsetHeight = element2 === null || element2 === void 0 ? void 0 : element2.offsetHeight) !== null && _element2_offsetHeight !== void 0 ? _element2_offsetHeight : 0);
    }
    hasBeenDragged() {
        return this.dragged;
    }
    setAnchor(anchor, horizontalSpacing, verticalSpacing) {
        const element2 = this.getPopoverElement();
        if (!element2) return;
        var _anchor_position;
        const position = (_anchor_position = anchor.position) !== null && _anchor_position !== void 0 ? _anchor_position : "above";
        const { offsetWidth: width2, offsetHeight: height2 } = element2;
        let top = anchor.y - height2 - verticalSpacing;
        let left = anchor.x - width2 / 2;
        if (position === "below") {
            top = anchor.y + verticalSpacing;
        } else if (position === "right") {
            top = anchor.y - height2 / 2;
            left = anchor.x + horizontalSpacing;
        } else if (position === "above-left") {
            left = anchor.x;
        }
        this.updatePosition({
            x: left,
            y: top
        });
    }
    ignorePointerEvents() {
        const element2 = this.getPopoverElement();
        if (element2) element2.style.pointerEvents = "none";
    }
    capturePointerEvents() {
        const element2 = this.getPopoverElement();
        if (element2) element2.style.pointerEvents = "unset";
    }
    updatePosition(position) {
        const bounds = this.getBounds();
        const canvasRect = this.ctx.domManager.getBoundingClientRect();
        position.x = Math.floor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, position.x, canvasRect.width - bounds.width));
        position.y = Math.floor((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(0, position.y, canvasRect.height - bounds.height));
        super.updatePosition(position);
        this.onPopoverMoved();
    }
    constructor(ctx, id, onPopoverMoved){
        super(ctx, id);
        this.onPopoverMoved = onPopoverMoved;
        this.dragHandleDraggingClass = "ag-charts-floating-toolbar__drag-handle--dragging";
    }
};
var FloatingToolbar = class extends BaseToolbar {
    destroy() {
        super.destroy();
        this.popover.destroy();
    }
    show() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.popover.show([
            this.dragHandle.getElement(),
            this.getElement()
        ], options);
    }
    hide() {
        this.popover.hide();
    }
    setAnchor(anchor) {
        this.popover.setAnchor(anchor, this.horizontalSpacing, this.verticalSpacing);
    }
    hasBeenDragged() {
        return this.popover.hasBeenDragged();
    }
    ignorePointerEvents() {
        this.popover.ignorePointerEvents();
    }
    capturePointerEvents() {
        this.popover.capturePointerEvents();
    }
    onPopoverMoved() {
        var _this_popoverBounds;
        const popoverBounds = this.popover.getBounds();
        if ((_this_popoverBounds = this.popoverBounds) === null || _this_popoverBounds === void 0 ? void 0 : _this_popoverBounds.equals(popoverBounds)) return;
        this.popoverBounds = popoverBounds.clone();
        const buttonBounds = this.getButtonBounds();
        this.events.dispatch("toolbar-moved", {
            popoverBounds,
            buttonBounds
        });
    }
    getButtonWidgetBounds(buttonWidget) {
        const popoverBounds = this.popover.getBounds();
        const bounds = super.getButtonWidgetBounds(buttonWidget);
        const dragHandleBounds = this.dragHandle.getBounds();
        return new BBox(bounds.x + popoverBounds.x - dragHandleBounds.width, bounds.y + popoverBounds.y, bounds.width, bounds.height);
    }
    constructor(ctx, ariaLabelId, id){
        super(ctx, ariaLabelId, "horizontal");
        this.hasPrefix = true;
        this.popover = new FloatingToolbarPopover(ctx, id, this.onPopoverMoved.bind(this));
        this.dragHandle = new DragHandleWidget(ctx.localeManager.t("toolbarAnnotationsDragHandle"));
        this.popover.setDragHandle(this.dragHandle);
    }
};
var DragHandleWidget = class extends NativeWidget {
    constructor(title){
        super((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("div", "ag-charts-floating-toolbar__drag-handle"));
        const icon = new NativeWidget((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ag$2d$charts$2d$core$2f$dist$2f$package$2f$main$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])("span", "".concat(getIconClassNames("drag-handle"), " ag-charts-toolbar__icon")));
        icon.setAriaHidden(true);
        this.addChild(icon);
        this.elem.title = title;
    }
};
// packages/ag-charts-community/src/module-support.ts
var motion = {
    ...fromToMotion_exports,
    ...resetMotion_exports
};
// packages/ag-charts-community/src/main.ts
var AgChartsCommunityModule = {
    VERSION,
    _Scene: integrated_charts_scene_exports,
    _Theme: integrated_charts_theme_exports,
    _Util: integrated_charts_util_exports,
    create: AgCharts.create.bind(AgCharts),
    createSparkline: AgCharts.__createSparkline.bind(AgCharts),
    setup: registerInbuiltModules,
    isEnterprise: false
};
;
}),
]);

//# sourceMappingURL=node_modules_ag-charts-community_dist_package_main_esm_mjs_f2702e81._.js.map